{"version":3,"mappings":";;AAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfA,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;ACAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,ECAfC,QAAe;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,QAAe;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,ECAfC,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,QAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,ECAfC,QAAe;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,ECAfC,QAAe;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,QAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,UAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC;AAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,QAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,QAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EC+BFC,GAA6C,CACtD,OACI;ACuyCkL;AAAA;AAAA;AC5zC3H;AAAA,EAAS,EAAE,MAAK,CAErD,IAAI;AAAkB;AAAA,EAAS,EAAE,KAAK,OAIxD,CACJ,UAEI;ACwrB8B,CAAI,EAAE,OAAO,EAAE,SAAK;AAAA,CAAI,CAAC,CAC3D,CACJ,MAEO,CAAMC;ACqtB2D,EAAQC,IAIxEC,KACFC,EAAa;ACtmC2B;AAAA;AAoD6B,kBAAmCC,EAAUC,GAAQ,YAAc,EAChIC;ACpXuD,EAAiB,CAClF;AAAmE,EAAqB,CACxF,YAAYC,MACJA,KAAO,gBACP,OAAK,cAAoBA,MAAO;ACiBO,CAAI,GAAK,MAEhDC,EAAQ,QACR,CACAA,IAAQC,CAAqB,KAAK,mBAAmB,OAAS,CAC1D,WAAW,MAAK;AA6Ic,EAAS,QAAwB,EAAI,SAC5D,CACf,KAAIC,CAAU,EACVC,EAEJ,MADS;AAmF6B,EAAS,IAAIC,GAAgBC,CAAI,OACvEC,SAAeC,CAAY,SAAU,CACrC,MAAMJ,IAAa;AC/EmB,GAAQK;AC7JhC,GACNC,OACS,EAGTC;ACvBmB;;ACkBK,CAAI,EAChB;ACN0C,CAAI,CACtE,CACA;ACsDyB,CAAI,CAC7B,CACA,IAAI,UACA,QAAO,CAAK;AA4FO,CAAI,CAC3B,CACA,oBACI,QAAK,OACL,QAAK;AAqMgB,CAAI,CAAC,CAC9B,CACA,YAAYC,EAASC,EAAQC;AC/RuF,CAAI,CACxH,CACJ,CACA,MAAMC,UAAoBC,CAC1BC,QAAsBC;ACyBI,EACVC,EAAQ;ACxFoE,EAAS;AAAA;AAAA,CAAM,EAC5F,IACX,CACA,eAAeC,EAAO,CAClB,iBAAK,IACE,MAEX;AACkB,EAAKC,IAAoCC,EAAMC,CAAM,CAAC;AAAA,EAC7D,IACX,CACA,aAAmBC,EAAOC,OACtB;AA2EG,CAAI,CACf,CACO;AC8GG,CAAI,EACV,IAAIC,UACEC,EAAoBD;AAUrB,CAAI,CACZ,CAIA,MAAME,CAAW,CAChB,QACA,UACA;AAsBkB,CAAI,CAExB,CACG,CACD,CACA,OAAOC,WACM,YAAW,SAAM;AAyCR,CAAI,CAC5B,CAEE,CACA,YAAWA,CAAK,CACf;AAE2B,CAAI,EAAE,MAAM;AAAA,CAAI,EACtCC,EAAM,GACNxB;AAoBkC,CAAI,EACnCyB,GAAcC,WAEV;AAAkC,OAAU,EACpD,QAAQ;AACQ,EAAKA,EAAU,GAAKA,GACtC1B,EAAOA,WAAc;AAAA,EAAKyB,EAAW,GAAKA,GAG1C,MAAME,IAAM;AAgBoB,EAAOC,EAAM,KAAK;AAAA,CAAI,EAC/CC,GAAW;AASc,EAAOD,EAAM,KAAK;AAAA,CAAI,EAC/CC,GAAW,KAAK,MAAKC,CAAO,EAClCC,MAAc,OAAS,CAAC;AAG8C,CAAI,EAC1E,QACD,CACD,WAEC,EAAM,aACN,SACA,OACA;AAqCwB,EAAM,CAAC,EAAE,CAAC,EAAE,QAAQ;AACnB,EAAM,CAAC,EAAE,CAAC,EAC/BC,GAAY,CAAC5B,QAAS,EACtB6B,WACA;AAce,EAClBV,EAAMA,EAAI;AAUiB,EAAM,CAAC,EAAE,CAAC,EAmBpC,MAlBWW;AAsBM,EAAOC,GAAS,MAAMF,MAAM,EAExC,CAeJ,KAbID,QAIK;AAYO,EAAOG,EACxB,CACI,CAACH,IAAa,CAACG,YAClBH,GAAY,KAEbR,GAAOU,aAAU;AAAA,EACjBX,EAAMA,EAAI,UAAUW,IAAQ;AAiG6C,CAAI,EAAI,GAC/EE,GAAO,CACZ,UAAM,GACN,UACA;AAyDkD,EAC/CC,EAAI,CAAC,EAAE;AAubS,EAAiB,EACpC,UAAQ;AAiOa,CAAI,EAC1B,KAAK,YAAYd,MAAK,CAAK,SAC3B;AAsCoC,EAGjCQ,EAAO,KAAKO,CAAK,EAElB,WAGD,CAAIA,EAAQ,MAAK,oBACVf;AAIY,EAAOe,EAAM,IAC9BC,EAAU,MAAQ;AAAA,EAAOD,EAAM,KAC/B,WAAK,OAAY,WAAK;AAgDL,EAAOA,EAAM,IAC9BC;AAAkB,EAAOD,EAAM,IAC/B,OAAK;AA0CY,EAAOA,EAAM,IAC9BC,EAAU,OAAQ;AAAA,EAAOD,EAAM,KAC/B,cAAK,GAAY,MACjB,YAAK,KAAY,KAAK;AAcL,EAAOA,EAAM,IAC9BC,EAAU,MAAQ;AAAA,EAAOD,EAAM,KAC/B,WAAK,OAAY,WACZ;AA+M+B,EACvC,OAAKE;AASF,EARK,kBACOxB,CAAOyB,EAASzB;AAC3B,CAOL,CACA,eAAa,SAEZ,KAAO;AAAA,EADM,KAAK,gBACU;AAAA,CAC7B,CACA,KAAK,CAAE,QAAQ,CACd;AAG+D,CAChE,CACA,GAAGsB,EAAO,CACT,YAAO;AAAA,CACR,CACA,KAAKA,EAAO;AAUqB,EAAQI,EAAO,KAAOC,MAAO;AAAA,CAC9D,CACA,SAASP,MACR,CAAIQ,EAAW,MACXR,OAAW,CACd;AAqBqB,CACvB,CACA,SAAS,CAAE,WAAW,CACrB,MAAO,WACHS,GAAU;AAI8B,CAC7C,CACA,MAAMP,EAAO,CACZ,KAAIQ,CAAS,GAETC;AAgBG;AAAA,EAEJD,EACA;AAAA,EACAJ,EACA;AAAA,CACJ,CACA,SAAS,CAAE,KAAA1C,GAAQ,IAClB,UAAO;AAAA,EAASA,CAAI;AAAA,CACrB,CACA,UAAUsC,IACT;AAKgC,CACjC,CAIA,OAAO,CAAE,UAAU,CAClB,MAAO,WAAW;AAyKN,EAAO,KAAK;AAwaV;AC/2DK,EAElBU,EAAS,KAAQC,GACN,KAEF,WAAU;AAC0B,CAC7C,EACAD,EAAS,GAAK,IACH,WAEK,QAAU,SAAEE,CAAS,MACjC,OAAa,CAAIC,IAAK;AAAuB,CAAI,EAAI;AAAA,CACzD,EACAH,EAAS,eAAc,CAAAhD,MACZA,CAAO;AAAA,EAElBgD,EAAS;AACoC,CAC7C,EACAA,EAAS,WAAQ;AAC+C,EAAOI,EAAK,IAAIC,GAASA,MAAUN,GAAQ,QAAK;AAAiC,CAAI,EAAI;AAAA,CACzJ,EACAC,EAAS,WAAc;AAgBZ,EAEXA,EAAS,IAAM,CAAC,CAAE,UACPhD,EAEXgD,SAAkBC;AAiCuB,CAAI,EAC/BK,EAAW1B,EAAMA,EAAM;AA2LH,CAAI,EACtC,IAAI2B,QAEJ;AAyBiE,CAAI,EAAIC,EAC/DC,EAAkB,CAAC,CAACC,EAAW,MAAM,SAAQ,CAC7CC,UAAkD;AAAO,GAAM,SAAS,WAAe,CAC7F,QAAOC,QAIf,UAA0BC;AC9iBQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECxPlC,IAAIC,QAA0C,KAAUC,MAAyBC,EAAM,CACnF,IAAIC,EAAI;ACsgBW,EACf;AC8KiB;AAAA,oBAED;AAAsG,IAC1H,EAEQC,EAAO;AACM;AAAA,sBAED;AAA2F,IAC/G,EAEQA,EAAO;AAgCM;AAAA,kBAEPC,CAAM;AAA+E;AAC8C,IACjJ,EAEI,MAAMC,EAAmCC,GAAsBH,EAAO,0BAA6B;AAclF,kBACPC,CAAM;AAAA;AACA;AACkF,IACtG,QAEe;AACM,iBACRA,CAAM;AAAA,iBACNA,CAAM;AAAA;AAAA,wBAECD;AAAgC,KACnD,EACOI,OAAa;AAAA;AACF,iBACNH,CAAM;AAAA;AAAA;AAEiC,KACnD,GAEOD,EAAO,oBACPI,EAAQ,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,qBAKJJ,EAAO;AAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO1C,EAEQA,EAAO,6BACPI,EAAQ,OAAK;AAAA;AAAA;AAAA;AAAA;AAIkC;AAAA,IAEvD,EAEI,KAAK;AAAwC,CAAI,CACrD,CACJ,CACO,OAAMC,OACT,iBAAqB,UACrB;ACjgBiD,CAAI,CACrD,CACA;ACxF6C,WAAkBpD,EAAOqD,IAAgB,cAAeC,EAAE;AC0hBhF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzBC,GAAWC,GAAQ;AAAc,EACjCD,GAAWC,GAAQ,WAAW,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA6R7B;AAGc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmDV,MAAMC,EAAuBC,MAAM,YAC/BD,QACU;AAAA;AAAA;AAEiB;AAAA;AAAA;AAAA,mBAIpBA,CAAoB;AAAA;AAAA;AAAA;AAAA,qBAIA;AAAA;AAAA,MAI/B,QAAuCC,EAAM;AAE/B;AAAA,mBAEHC,CAA8B;AAAA;AAAA,MAIzC,QAA4CD,EAAM,+BAC9CE,IACAC;AAAU;AAAA;AAEgC;AAAA,MAI9C,MAAMC,QAA6C;AAErC;AAAA;AAEiC;AAAA,OAKnD,MAAOD,CACX,CCvmCO,MAAME,GAAmB,CAC5B,YAAYC,EAAoBC,EAAkBC,EAAqBC,GACnE,KAAK,mBAAqBH,GAC1B,IAAK,kBAAmBC,CACxB;AC0MkD,EAAO,OAAQ,IAC3DrD,EAAS,UAEXwD;AAkBkB,EACVA,KACAC,CAAsBC,EAAY;ACgDtC,EACD,EAGA,MAGR,UAAqC,CACxC,OAAKnF,EAGIA,gBAAmBoF,CAAiCpF,aAAmBqF,KAFrE,CAGf,CACO,UACH,WAAYC,MACR,QAAK,GAASA,EACd,KAAK,wBAET,iBACI,GAAMC,EAAc,KAAK;ACwWA,CACb,CAGJ,OAAI,CAAK,gBAAe,QAAW,YAAY/E,CAAK,EAEhD,MADmB,EAAK,eAAeM,KAAmB,IACvC,UACT0E;AA6GT,EACTC,IAAmB,QAAY,CAAI,EAAE,EACjC3E,EAAK,OAAM;AAgBN,GAEb,OAAM4E,CAAY,KAAK,mBACjBC,EAAU,KAAK,cAAc7E,EAAM4E,EAAU,MACnD,EAAIE,GAAUD,CACd,aAAgBE,CAAIH,EAAU,QAAQG,GAClCD,EAAU,MAAK,aAAcA,EAASF,IAAY,cAEjD,kBAAyBC,GAElC,+BACUG,CAAQhF,GAAK,KACbiF,EAAcjF,EAAK;AAiSZ,GAEb,UAAgB,GAAK,0BAA0B;AAoJD,EAClD,CACA,YAAYkF,GACR;AA2EoC,CAAM,EAC1C,KAAK,cAAcC,IAAa,CAAC,KAEjC;AASiB,EACLC,EAAS,MAAM,SAAW,UACXA,CAAQ,MAEtB,CACD,SAAcA,CAAS,MACjBC,EAAW,gBAAoB,GAAO,GAAG,MAAQ,CAAC,EAClDC,YAA2B,CAC3BC,uBAAqCP;ACvrCxC,EACX,IAAK,GACD,MAAO;AAAA,EACX,IAAK,IACD;AA2CsC,EAAS,EAAyB,MAExDQ,CAAG,MAGfC,CAAYD,SAAQ,WAAQ,SAAeE,CAAS,CAE5D,CACAC,EAAWC,CAAC,EAAI,SACZ,UACA,KAAYJ,EAAG,YAAc,OAC7B,IAAOK,EACP,kBAAkB,WAAYA,EAAe,gBAAiBA,OAAe,WAC7E,SAAa,KAAK,sBAAsBA,CAAc,GACtD,QACA,QAAUC,CACV,sBACA,eACA,4BAA6B,QAC7B,qBAAsBN,EAAG,sBAAwB,EACjE,IAGmB,KAAKO,GAAoB,iBAAiB,EACrD,IAAIC,EAAoB,IACxB,YAAgBC,CAAQN,QAAW,CAAS,WACxC,MAAMO,EAAWP,GAAY,EAAE,SAAM,cAC/BQ,GAAiBR,CAAWC,OAAO,SAAM;ACjMM,EAAO;AAAA,EAE5DQ,EAAeC,EAAgB,EAExB;AAAA,EAGJ;AAAA,CACX,CACA,OAAOC,EAAY,CACf,mBAAiB,EAAQA,OACV,GAAK;AAEN,IAAW,KAAK,IAAM,GAAK,KAAK,KAAM,GACxCC,OAAQ;AAAA,IAAS,KAAK,IAAM,GAAK,SAAK,EAAQ,IAEtD;AC4M4D,EAAM,GAAO,GAAO,GAAM,EAAI,EAC9FC,EAAwB,QAAO,GAC/B,IAAK,QAAUA,uBACV,EAAoBC;AA8DsC,EAAS;AAAA,EACxE,GAAI,KAAK,QAAQ,YAAaC;AAqQI,EAC5B,EACA,CACV,CACA;AAmQyC,CAAI,EAAI,EAAG,CAG5C,MAAMC,EADe;AAeY,CAAI,EAAI,EAAG,CAE5C,MAAMA,EADe;AAmCa,EAAO,EAAqC,KAC/DJ,EAGnB,IACI,KAAK;AAmF+F,IAIpF,EAAAK,IAAmBC,EAAU;AACyE,GAK1G,CAAAC,EAAgB,GAChB,MACJ,CACA,KAAmB,CACf,MAAMC;ACv3BV,EACRC,EAAgB,EAEXT,IAAQ;AAAA,IACbS,EAAgB,GAEpB,IAAIC,EAAqBC,GAAsB;AAuC+E,EAAO;AAAA,CACzI,CACA,gCACUtD;ACswBoC,CAAI,EAC9C,MAAO,CACH,iCAGA;ACpwBoC,UACtC,KAAK;AAAmC;AACW,IACzD,EACI;AAA6C,CAAI,EACjD,KAAK,MAAK,KAAMd,CAAM,UAE1B;ACgvDiD,CAAI,EACjD,KAAK,KAAK,MAAMA,CAAM,CAC1B,EAEA,gBAAiBqE;ACryDS,EAAS,KAC3B9I,GAAU+I,EACV,UAAWC;ACweoB,CAAI,EAC/BC,SAAmB,GAAG;ACpUhB,CAAI,CAC1B,CCpRO,OAAMC,GAAK,EACd;ACoI0B,CAAI,CAC9B,CACJ,CACA,MAAMC,IAAe,GAAIC;AC5FK,CAAI,CAC1B,CACR,CACA,CACO,MAAMC,MACT,KAAQC,GACJ,WAAoC,EACpC;ACqIkC,EAAK,KAAK,SAAS,GACrD,KAAK,4BACL,EAAK,eAAiB,IACtB;AAgIsG,CAAI,CAAC,IAAI,EAC/G;AAE+B,CAAI,EACnC,KAAK;AAK6B,EAAK;ACnRnB,iBAAqB,CAAC,GAAGjI,EAAM,WAAS,QAAQ,GAAK,IAAI,CAAC;AAAA,iBAAsB,CAAC;AAAmC,CAAK,EAE7I,eAAiB;AAAA,CAAI,CACzB,CAKA,iBACI;AChDwC,EAA4CkI,EAAM,qBAGrFC,CAAqB,CAC9B;AAiUwH,CAAI,EAAE,uBAAiB;AAAA,CAAI,CAAC,EAAvHC,GAAM,uBAE5B,IAAcC;AAmCG,CAAI,CACxB,CACA,mCAC6D;AAKhC,CAAI,CAAC,CAEtC,CACJ,CC3XO,MAAMC,QAAyB,IAAI;AC8JF;AAAA,EAASC,GAElCC,GAAW;AAmUgB,EAAO;AAAA,CAC7C,CACJ,EACAC,GAAsCzF,GAAW;ACvCuB,EAAO0F,EACjEC,SAAkB,EACxB;ACzMW,GAAOC,CAAW,YAE7B,KAAAC;AAAO,GACAA,CACX,CACA,aACI,EAAK,yBAAyB,SAAO,CACrC,QAAK,WAAgB,YAEzB;AC8D+Q;AC/P7N,EAAMC,EAAoB,CAAC,KAAO,IAC5EC;ACgZwD,CAAI,EAAIC,EAAW,QAC/E,EAAE,gBAAc,CACZ,EAAE;AA6BwC,CAAI,EAAG,IAAI,SAI7D;ACjNoE,CAAI,EACtDC,EAA0BC,EAAoB,WAAUC,CAAkB,CAAC;AAe9B,CAAI,EACjDC,EAAyBC;AA4XT,EAAMC,EAAa,CAAC,EAC1CA,QACA;ACxMa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAeb,aACA,OAAQ,MACI,SACR,SAAY,KAAK,EACjB;ACxDsB,EAAM,CACpC;AAa0B,EAAMC,CAAY,EAEhD,GAAI,CAACzE,QAAM;AAGmB,EAAOlG,EAAO;AAMV,EAAOA,EAAO,qBAAqB4K,EAAE,eAAgB,SAAU,EAAGD,IAE3F,EAAIC,EAAE;AAEmB,EAAO5K,EAAO;AAMvB,EAAO6K,EAAkB;AAAA,EAAOC,EACjD,YACW,CAAIC,GAAsCC,EAAOC;AAQlC,EAAOjL,EAAO,uBAAyC4K,SAAE,GAAU,KAErG,CACA,OAAMM;AA0B8D,EAAOlL,EAAO;AAUhB,EAAOA,EAAO;AAItD,EAAOA,EAAO,qBAAqBmL;AAU0B,CAAI,MAElF,CACDC,IACA,MAAMzK,EAASuF;AAkFgB,CAAI,IAAM5F,EAAK,QAAS,OACtC,EAEjB+K,GAEA,MAAMC,EAAgB,IAAIC,EAAMC,EAAS,WAAY;ACnTrB,CAAI,GAAK,EACzC,YAEJ;AC6RiC,EAAS,KAAK;AC7US,EACxDC,EAAgB,EAEXC,GAAWA,KAAQ;AAAqC,IAC7DD,EAAgB,UAER,SAAW;AC3OsD,EAAO;AAAA,GAEhE;ACiPU,CAAI,EAClC,IAAIE,EAAYvK,KAChB,IAAIwK;ACuMI;ACpgBhB;AAAA;AAAA;AAAA;AAAA;ACCA;AAAA;AAAA;AAAA;AAAA;ACAA;AAAA;AAAA;AAAA;AAAA;ACAA;AAAA;AAAA;AAAA;AAAA;ACAA;AAAA;AAAA;AAAA;AAAA,iFAOA,IAAIC,IAAY,OAAO,kBACnBC,CAAmB;AC8GsC,CAAM,EAE/D;AACqB,CAAM,EAE3B,MAAQ7B,MACW;AC9GG,CAAI,EAEnB8B,CACX,CACA,WAASC,CAAyBC,EAAW,CAEzC,YAAc,kBAAS;ACsIgC,KAAoCC,EAAK,UAAuB,CAAC,CAAC,CACrH,CACA,GAAItJ;AAkB6C,KAAmCsJ,EAAK,OAAOC,EAAeC,CAAC,CAAC,CAAC,CAClH,WAEU;ACkDwK,CAAI,EAClL,KAAK;ACdqB,EAAM,EAAI,CAAC,EAC7B,MACJ;AC2bwC,CAAI,EAC5C,EAAE;AAuCyC,CAAI,EAC/C,EAAE,eAAc,EAChB,QAGR,SAAM,EAAO;ACrLgB;AAAA;AAAA;AAAA,QAKb,WAAYC;AA2EC;AAAA;AAAA;AAAA;AAAA,QAMb,WAAYA;ACxkB+E,CAAI,CAAC,CAAC,CACzH,CAAS,EAAE;AAuCuB,CAAI,CAClC,CACA,IAAI;ACuJ4C,CAAI,EAChDC,EAAaC,EAAW,QAAQ,YAAY;AAAA,CAAI,CACpD,CACA,UAAUC,EAAc,CACpB,OAAO,OAAyB;ACyOS;AChWR,EAC7BC,GAAM,WAAW/J;AAA0B,EAC3C+J,GAAM;AAAmG,EACzGA,GAAM;AAA0B,EAChCA,GAAM,YAAe,GAAG;AAA8F,EACtHA,GAAM,iBAAiB/J,EAAK;AAAqC,EACjEgK,EAAgB,IAAIC,GAAc,MAAG;AC8E9B;AAAA;AAAA;AAAA,sBAIO;AAAA,EAElB,CAAC,CAAC,CAAC,EAEH,KAAK,UAAU;ACxKqB,CAAI,EACpCC,IAAe,IAEX,OAAK;AAM6J,CAAI,EAGrK,KAAK;AAIuF,CAAI,EAHjGC,EAAQ,qBAAqBtB,EAAMuB,IAAE;AAAmH,EAAOF,CAAU,EAMjL;ACiF4G,CAAI,EACpG,gBAAiB;AAoD+E,CAAI,CAE5G,SAEIG,KAAqB,kBACrBC,CAAiB9G,IAAM,eAA+B,CAEtD2G,KAAQ,oBAA2BE;AAEqH,EAAOC,CAAc,EACzK;AC9GiI,CAAI,CAAC,EAF3I;ACuN6D,CAAI,CAAC,CAAC,MACvD,GAAKC,CAAc;ACpBiC,CAAI,EAE3E,gBAAsCC,EAAgBC;AC5LD,CAAI,CAAC,EACtD,MAAO,CACH,KAAMC,OAAO,KAAK;AAAA,CAAI,EACtB;AAiBsF,CAAI,CAAC,EAAE,OAAK,KAAK;AAAA,CAAI,EACzGC,EAAeC,GAAkBC,EAAU,QAAK,KAAM;AAAA,CAAI,CAAC,EAAE;AAAU,CAAI,EACjF,KAAK;AAkJuC,CAAI,EAAE,OAAS,EACrDC,MAAS,CAAK,WAAQ,OAAU,UACzB;AClM4B,CAAI,GAAK,EAAEtB,EAAK;AA6FkB;AAAA;AAAA;AAAA,gBAIvEuB,KAAU;AAAA,EACxB,CACM,CAAC,CAAC,EACF,KAAK,UAAU,KAAIC,UAA2B,IAAQ,KAAK,eAAgB,KAAK;AAiBzD,CAAI,GAAKxB,EAAK,MAAM;AA8ElB,CAAI,IACzB5L,EAAOqN,EAAK,OAAK,QAAU,CAAC,GAEhC,UAAK,EAAO,aAAY,EACxB,UAAK,EAAO,aAAa;AClL8B,CAAI,CAAC,CAC5D,CAAC,EAAE;ACbuD,CAAI,CAAC,EAC3D,WAAK;AAA4C,CAAI,CAAC,EACtD,MAAMC,EAAI,MAAK;ACSiC,CAAI,EAAI;AANJ,CAAI,EAAI,SASpE;AAQuC,CAAI,CAC/C,EAEQ,MAAMtI,EAAS,MAAMuI,KAAS;ACnGtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAgBA,IAAIC,GAAG;AAAokT;AAAA;AAEvhS;AAAA,EAEljBV,EAAE,KAAK,EAAE,IAAI,MAAMA,EAAE,WAAQ;AAAA;AAAA,EAE7BA,EAAE;AAiB8oU,CACjpU,EAAE,UAAS;AAAK,CAChB,CAAC,CAAC,CAAC,EAAEW,IAAG,iBAAc,EAAK,CAAC,cAAc,EAAE;AAG2ulE,CACvxlE,CAAC,CAAC,CAAC,EAAE,KAAK,UAAU,KAAK,mBAAe;AAAmqY,EAC1sYC,EAAE,GAAG,KAAKA,EAAE,QAAQA,KAAK,QAAO,KAAG,CAAIA,MAAK,GAAIA;AAAkipD,EACllpD;AAAA,CACD,CAAC,CAAC;AAAg2pI,CACl2pI,CAAC,CAAC,EAAE,MAAK;AAA00B,IACh1B,KAAK,wBAAuB,UAAK;AAA8rwC,EACjuwC,CAAC,CAAC,CAAC,MAAMZ,EAAE,CAAC,OAAK,IAAM,MAAMA,KAAG,QAAU","names":["pointersCode","mathCode","memoryCode","fibonacciCode","factorialCode","primesCode","arraysCode","structsCode","linkedListCode","binaryTreeCode","treeTraversalCode","avlTreeCode","functionPointersCode","macrosCode","enumsCode","unionsCode","EXAMPLES_INFO","ListenerLeakError","serializedHTML","SAFE_FOR_TEMPLATES","arrayForEach","expected","Scanner","offset","config","regex","strings.createRegExp","counter","m","LineFeedCounter","text","searcher","searchStart","character","line","column","element","group","UndoRedoGroup","colorRegistry","ColorRegistry","platform.Registry","Extensions","current","value","appendEscapedMarkdownCodeBlockFence","code","langId","label","title","node","matchIndentInNode","_Tokenizer","src","raw","currentText","currentRaw","top","lines","newToken","newText","tokens","blankLine","indent","rawLine","nextLine","item","cap","token","lastToken","langString","escape$1","body","type","itemBody","checked","header","cell","renderer","_","items","x","rows","cells","lastLine","numCols","mergedRawText","line1EndsInPipe","prefixText","newRawText","marked.lexer","hook","__decorate","decorators","desc","c","styles","suffix","inactiveFocusAndSelectionOutline","asCssValueWithDefault","content","unthemedListStyles","UILabelProvider","OS","formatRule","Codicon","scrollbarShadowColor","style","scrollbarSliderBackgroundColor","scrollbarSliderHoverBackgroundColor","result","scrollbarSliderActiveBackgroundColor","ContextMenuHandler","contextViewService","telemetryService","notificationService","keybindingService","curLineCount","lastLineBreakOffset","curOffset","SingleModelEditStackElement","MultiModelEditStackElement","model","lastElement","previousPos","updateTreeMetadata","newPieces","newNode","tmpNode","k","piece","bufferIndex","val","prev","nextNode","newStart","newLength","newLineFeedCnt","op","validText","bufferEOL","operations","i","validatedRange","eolCount","PieceTreeTextBuffer","hasTouchingRanges","count","rangeEnd","nextRangeStart","totalCRCount","totalEOLCount","defaultEOL","eol","emptyDisposedTextBuffer","Disposable","newEOL","searchData","trimLineNumber","editRange","allowTrimLine","trimRange","newDefaultEOL","trimAutoWhitespace","EDITOR_MODEL_DEFAULTS","location","total","highlight","newStyles","vs","iconRegistry","IconRegistry","UnthemedProductIconTheme","contribution","graph","InstantiationService","Trace","_enableTracing","unsupportedSchemas","detail","mainWindow","StandaloneResourcePropertiesService","lineWithoutLF","lineLength","cssPropName","str","lastLineFeedIndex","lineFeedCnt","dataToCopy","lineTextBeforeSelection","textBeforeSelection","lineFeedOffset1","lineTextAfterSelection","lineFeedOffset2","startIndex","keepPosition","r","increasedIndent","normalIndent","ReplaceCommandWithoutChangingPosition","range","typeText","lineText","indentation","lineNumber","pasteOnNewLine","typeSelection","Range","position","eolPreference","options","firstLine","firstLF","__defProp","__getOwnPropDesc","stack","detectSystemErrorMessage","exception","edit","toErrorMessage","e","foldingArgumentsConstraint","insertText","filterText","updatedRange","md","documentation","MarkdownString","sourceText","builder","s","movingLineNumber","movingLineText","finalSelection","findController","isDisconnectedFromFindController","t","modifiedText","removeIndentation","ghostText","height","fontFamily","InlineEditHintsWidget","data","d","provider","zs","qn","E"],"ignoreList":[20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108],"sources":["../../examples/basics/hello.c?raw","../../examples/basics/pointers.c?raw","../../examples/basics/strings.c?raw","../../examples/basics/math.c?raw","../../examples/basics/memory.c?raw","../../examples/algorithms/fibonacci.c?raw","../../examples/algorithms/factorial.c?raw","../../examples/algorithms/binary-search.c?raw","../../examples/algorithms/primes.c?raw","../../examples/data-structures/arrays.c?raw","../../examples/data-structures/structs.c?raw","../../examples/data-structures/linked-list.c?raw","../../examples/data-structures/binary-tree.c?raw","../../examples/data-structures/tree-traversal.c?raw","../../examples/data-structures/avl-tree.c?raw","../../examples/advanced/function-pointers.c?raw","../../examples/advanced/macros.c?raw","../../examples/advanced/enums.c?raw","../../examples/advanced/unions.c?raw","../../src/examples.ts","../../node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js","../../node_modules/monaco-editor/esm/vs/base/common/errors.js","../../node_modules/monaco-editor/esm/vs/base/common/event.js","../../node_modules/monaco-editor/esm/vs/base/browser/dompurify/dompurify.js","../../node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../../node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js","../../node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js","../../node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js","../../node_modules/monaco-editor/esm/vs/platform/theme/common/colorUtils.js","../../node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js","../../node_modules/monaco-editor/esm/vs/base/common/htmlContent.js","../../node_modules/monaco-editor/esm/vs/base/common/marked/marked.js","../../node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.js","../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextViewService.js","../../node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationModels.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.js","../../node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js","../../node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js","../../node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js","../../node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputController.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js","../../node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js","../../node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js","../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js","../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js","../../node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js","../../node_modules/monaco-editor/esm/vs/editor/browser/editorDom.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js","../../node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeEditOperations.js","../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditor/codeEditorWidget.js","../../node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/components/diffEditorViewZones/inlineDiffDeletedCodeMargin.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js","../../node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js","../../node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js","../../node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/language/typescript/monaco.contribution.js","../../node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js","../../node_modules/monaco-editor/esm/vs/base/common/errorMessage.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/ghostText.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/provideInlineCompletions.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionsController.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineEdit/browser/inlineEditSideBySideWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineEdit/browser/inlineEditController.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineEdits/browser/inlineEditsWidget.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineEdits/browser/inlineEditsModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js","../../node_modules/@xterm/xterm/lib/xterm.mjs"],"sourcesContent":["export default \"#include <stdio.h>\\n\\nint main() {\\n    printf(\\\"Hello, World!\\\\n\\\");\\n    printf(\\\"Welcome to Sea - an in-browser C compiler.\\\\n\\\");\\n    printf(\\\"Uses binji/wasm-clang to compile C to WebAssembly.\\\\n\\\");\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\nvoid swap(int *a, int *b) {\\n    int temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint main() {\\n    printf(\\\"Pointers Demo\\\\n\\\");\\n    printf(\\\"=============\\\\n\\\\n\\\");\\n\\n    int value = 42;\\n    int *ptr = &value;\\n\\n    printf(\\\"1. Basic Pointers:\\\\n\\\");\\n    printf(\\\"   value = %d\\\\n\\\", value);\\n    printf(\\\"   &value (address) = %p\\\\n\\\", (void*)&value);\\n    printf(\\\"   ptr = %p\\\\n\\\", (void*)ptr);\\n    printf(\\\"   *ptr (dereferenced) = %d\\\\n\\\\n\\\", *ptr);\\n\\n    *ptr = 100;\\n    printf(\\\"2. After *ptr = 100:\\\\n\\\");\\n    printf(\\\"   value = %d\\\\n\\\\n\\\", value);\\n\\n    int arr[] = {10, 20, 30, 40, 50};\\n    int *arr_ptr = arr;\\n\\n    printf(\\\"3. Pointer Arithmetic:\\\\n\\\");\\n    printf(\\\"   Array: [10, 20, 30, 40, 50]\\\\n\\\");\\n    for (int i = 0; i < 5; i++) {\\n        printf(\\\"   *(arr_ptr + %d) = %d\\\\n\\\", i, *(arr_ptr + i));\\n    }\\n\\n    int x = 5, y = 10;\\n    printf(\\\"\\\\n4. Swap using pointers:\\\\n\\\");\\n    printf(\\\"   Before: x = %d, y = %d\\\\n\\\", x, y);\\n    swap(&x, &y);\\n    printf(\\\"   After:  x = %d, y = %d\\\\n\\\", x, y);\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"String Operations Demo\\\\n\\\");\\n    printf(\\\"======================\\\\n\\\\n\\\");\\n\\n    char str1[100] = \\\"Hello\\\";\\n    char str2[] = \\\"World\\\";\\n    char str3[100];\\n\\n    printf(\\\"1. strlen():\\\\n\\\");\\n    printf(\\\"   Length of \\\\\\\"%s\\\\\\\": %lu\\\\n\\\\n\\\", str1, strlen(str1));\\n\\n    strcpy(str3, str1);\\n    printf(\\\"2. strcpy():\\\\n\\\");\\n    printf(\\\"   Copied \\\\\\\"%s\\\\\\\" to str3: \\\\\\\"%s\\\\\\\"\\\\n\\\\n\\\", str1, str3);\\n\\n    strcat(str1, \\\" \\\");\\n    strcat(str1, str2);\\n    printf(\\\"3. strcat():\\\\n\\\");\\n    printf(\\\"   Concatenated: \\\\\\\"%s\\\\\\\"\\\\n\\\\n\\\", str1);\\n\\n    printf(\\\"4. strcmp():\\\\n\\\");\\n    printf(\\\"   strcmp(\\\\\\\"abc\\\\\\\", \\\\\\\"abc\\\\\\\") = %d\\\\n\\\", strcmp(\\\"abc\\\", \\\"abc\\\"));\\n    printf(\\\"   strcmp(\\\\\\\"abc\\\\\\\", \\\\\\\"abd\\\\\\\") = %d\\\\n\\\", strcmp(\\\"abc\\\", \\\"abd\\\"));\\n    printf(\\\"   strcmp(\\\\\\\"abd\\\\\\\", \\\\\\\"abc\\\\\\\") = %d\\\\n\\\\n\\\", strcmp(\\\"abd\\\", \\\"abc\\\"));\\n\\n    char *found = strchr(str1, 'o');\\n    printf(\\\"5. strchr():\\\\n\\\");\\n    printf(\\\"   First 'o' in \\\\\\\"%s\\\\\\\": \\\\\\\"%s\\\\\\\"\\\\n\\\\n\\\", str1, found ? found : \\\"not found\\\");\\n\\n    char *substr = strstr(str1, \\\"World\\\");\\n    printf(\\\"6. strstr():\\\\n\\\");\\n    printf(\\\"   \\\\\\\"World\\\\\\\" found at: \\\\\\\"%s\\\\\\\"\\\\n\\\", substr ? substr : \\\"not found\\\");\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    printf(\\\"Math Functions Demo\\\\n\\\");\\n    printf(\\\"===================\\\\n\\\\n\\\");\\n\\n    double x = 2.0;\\n    double y = 3.0;\\n\\n    printf(\\\"1. Power and Roots:\\\\n\\\");\\n    printf(\\\"   pow(%.1f, %.1f) = %.4f\\\\n\\\", x, y, pow(x, y));\\n    printf(\\\"   sqrt(16.0) = %.4f\\\\n\\\", sqrt(16.0));\\n    printf(\\\"   cbrt(27.0) = %.4f\\\\n\\\\n\\\", cbrt(27.0));\\n\\n    double angle = M_PI / 4;\\n    printf(\\\"2. Trigonometric (angle = PI/4 = 45 degrees):\\\\n\\\");\\n    printf(\\\"   sin(PI/4) = %.4f\\\\n\\\", sin(angle));\\n    printf(\\\"   cos(PI/4) = %.4f\\\\n\\\", cos(angle));\\n    printf(\\\"   tan(PI/4) = %.4f\\\\n\\\\n\\\", tan(angle));\\n\\n    printf(\\\"3. Logarithms:\\\\n\\\");\\n    printf(\\\"   log(e) = %.4f (natural log)\\\\n\\\", log(M_E));\\n    printf(\\\"   log10(100) = %.4f\\\\n\\\", log10(100));\\n    printf(\\\"   log2(8) = %.4f\\\\n\\\\n\\\", log2(8));\\n\\n    double val = 3.7;\\n    printf(\\\"4. Rounding (value = %.1f):\\\\n\\\", val);\\n    printf(\\\"   floor(%.1f) = %.1f\\\\n\\\", val, floor(val));\\n    printf(\\\"   ceil(%.1f) = %.1f\\\\n\\\", val, ceil(val));\\n    printf(\\\"   round(%.1f) = %.1f\\\\n\\\\n\\\", val, round(val));\\n\\n    printf(\\\"5. Absolute values:\\\\n\\\");\\n    printf(\\\"   fabs(-5.5) = %.1f\\\\n\\\\n\\\", fabs(-5.5));\\n\\n    printf(\\\"6. Math Constants:\\\\n\\\");\\n    printf(\\\"   PI = %.10f\\\\n\\\", M_PI);\\n    printf(\\\"   E  = %.10f\\\\n\\\", M_E);\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nvoid demonstrate_malloc() {\\n    printf(\\\"1. malloc() - Dynamic Memory Allocation:\\\\n\\\");\\n    int* arr = (int*)malloc(5 * sizeof(int));\\n    if (arr == NULL) {\\n        printf(\\\"   Memory allocation failed!\\\\n\\\");\\n        return;\\n    }\\n    \\n    printf(\\\"   Allocated array of 5 integers\\\\n\\\");\\n    for (int i = 0; i < 5; i++) {\\n        arr[i] = i * 10;\\n        printf(\\\"   arr[%d] = %d\\\\n\\\", i, arr[i]);\\n    }\\n    \\n    free(arr);\\n    printf(\\\"   Memory freed\\\\n\\\\n\\\");\\n}\\n\\nvoid demonstrate_calloc() {\\n    printf(\\\"2. calloc() - Zero-initialized Allocation:\\\\n\\\");\\n    int* arr = (int*)calloc(5, sizeof(int));\\n    if (arr == NULL) {\\n        printf(\\\"   Memory allocation failed!\\\\n\\\");\\n        return;\\n    }\\n    \\n    printf(\\\"   Allocated and zero-initialized array:\\\\n\\\");\\n    for (int i = 0; i < 5; i++) {\\n        printf(\\\"   arr[%d] = %d\\\\n\\\", i, arr[i]);\\n    }\\n    \\n    free(arr);\\n    printf(\\\"   Memory freed\\\\n\\\\n\\\");\\n}\\n\\nvoid demonstrate_realloc() {\\n    printf(\\\"3. realloc() - Resizing Memory:\\\\n\\\");\\n    int* arr = (int*)malloc(3 * sizeof(int));\\n    if (arr == NULL) {\\n        printf(\\\"   Memory allocation failed!\\\\n\\\");\\n        return;\\n    }\\n    \\n    printf(\\\"   Initial array (size 3):\\\\n\\\");\\n    for (int i = 0; i < 3; i++) {\\n        arr[i] = i + 1;\\n        printf(\\\"   arr[%d] = %d\\\\n\\\", i, arr[i]);\\n    }\\n    \\n    arr = (int*)realloc(arr, 6 * sizeof(int));\\n    if (arr == NULL) {\\n        printf(\\\"   Reallocation failed!\\\\n\\\");\\n        return;\\n    }\\n    \\n    printf(\\\"   Resized array (size 6):\\\\n\\\");\\n    for (int i = 3; i < 6; i++) {\\n        arr[i] = i + 1;\\n    }\\n    for (int i = 0; i < 6; i++) {\\n        printf(\\\"   arr[%d] = %d\\\\n\\\", i, arr[i]);\\n    }\\n    \\n    free(arr);\\n    printf(\\\"   Memory freed\\\\n\\\\n\\\");\\n}\\n\\nvoid demonstrate_string_allocation() {\\n    printf(\\\"4. String Memory Management:\\\\n\\\");\\n    char* str1 = (char*)malloc(20 * sizeof(char));\\n    if (str1 == NULL) {\\n        printf(\\\"   Memory allocation failed!\\\\n\\\");\\n        return;\\n    }\\n    \\n    strcpy(str1, \\\"Hello, World!\\\");\\n    printf(\\\"   Allocated string: \\\\\\\"%s\\\\\\\"\\\\n\\\", str1);\\n    printf(\\\"   Length: %lu\\\\n\\\", strlen(str1));\\n    \\n    char* str2 = (char*)calloc(20, sizeof(char));\\n    if (str2 == NULL) {\\n        free(str1);\\n        return;\\n    }\\n    \\n    strcpy(str2, \\\"Dynamic Memory\\\");\\n    printf(\\\"   Another string: \\\\\\\"%s\\\\\\\"\\\\n\\\", str2);\\n    \\n    free(str1);\\n    free(str2);\\n    printf(\\\"   Both strings freed\\\\n\\\");\\n}\\n\\nint main() {\\n    printf(\\\"Memory Management Demo\\\\n\\\");\\n    printf(\\\"======================\\\\n\\\\n\\\");\\n    \\n    demonstrate_malloc();\\n    demonstrate_calloc();\\n    demonstrate_realloc();\\n    demonstrate_string_allocation();\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\n// Recursive Fibonacci\\nlong fib_recursive(int n) {\\n    if (n <= 1) return n;\\n    return fib_recursive(n - 1) + fib_recursive(n - 2);\\n}\\n\\n// Iterative Fibonacci (more efficient)\\nlong fib_iterative(int n) {\\n    if (n <= 1) return n;\\n    long prev = 0, curr = 1;\\n    for (int i = 2; i <= n; i++) {\\n        long next = prev + curr;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return curr;\\n}\\n\\nint main() {\\n    printf(\\\"Fibonacci Sequence\\\\n\\\");\\n    printf(\\\"==================\\\\n\\\\n\\\");\\n\\n    printf(\\\"First 20 Fibonacci numbers (iterative):\\\\n\\\");\\n    for (int i = 0; i < 20; i++) {\\n        printf(\\\"F(%d) = %ld\\\\n\\\", i, fib_iterative(i));\\n    }\\n\\n    printf(\\\"\\\\nRecursive calculation for F(10): %ld\\\\n\\\", fib_recursive(10));\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\n// Recursive factorial\\nunsigned long long factorial_recursive(int n) {\\n    if (n <= 1) return 1;\\n    return n * factorial_recursive(n - 1);\\n}\\n\\n// Iterative factorial\\nunsigned long long factorial_iterative(int n) {\\n    unsigned long long result = 1;\\n    for (int i = 2; i <= n; i++) {\\n        result *= i;\\n    }\\n    return result;\\n}\\n\\nint main() {\\n    printf(\\\"Factorial Calculator\\\\n\\\");\\n    printf(\\\"====================\\\\n\\\\n\\\");\\n\\n    for (int i = 0; i <= 20; i++) {\\n        printf(\\\"%2d! = %llu\\\\n\\\", i, factorial_iterative(i));\\n    }\\n\\n    printf(\\\"\\\\nNote: Values overflow after 20! for 64-bit integers\\\\n\\\");\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\nint binary_search(int arr[], int size, int target) {\\n    int left = 0;\\n    int right = size - 1;\\n    \\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        \\n        if (arr[mid] == target) {\\n            return mid;\\n        }\\n        \\n        if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    \\n    return -1; // Not found\\n}\\n\\nint binary_search_recursive(int arr[], int left, int right, int target) {\\n    if (left > right) {\\n        return -1; // Not found\\n    }\\n    \\n    int mid = left + (right - left) / 2;\\n    \\n    if (arr[mid] == target) {\\n        return mid;\\n    }\\n    \\n    if (arr[mid] < target) {\\n        return binary_search_recursive(arr, mid + 1, right, target);\\n    } else {\\n        return binary_search_recursive(arr, left, mid - 1, target);\\n    }\\n}\\n\\nvoid print_array(int arr[], int size) {\\n    printf(\\\"[\\\");\\n    for (int i = 0; i < size; i++) {\\n        printf(\\\"%d\\\", arr[i]);\\n        if (i < size - 1) printf(\\\", \\\");\\n    }\\n    printf(\\\"]\\\");\\n}\\n\\nint main() {\\n    printf(\\\"Binary Search Demo\\\\n\\\");\\n    printf(\\\"==================\\\\n\\\\n\\\");\\n    \\n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 67, 78, 89, 90};\\n    int size = sizeof(arr) / sizeof(arr[0]);\\n    \\n    printf(\\\"Sorted array: \\\");\\n    print_array(arr, size);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    int targets[] = {23, 5, 90, 100, 12};\\n    int num_targets = sizeof(targets) / sizeof(targets[0]);\\n    \\n    printf(\\\"Iterative Binary Search:\\\\n\\\");\\n    for (int i = 0; i < num_targets; i++) {\\n        int index = binary_search(arr, size, targets[i]);\\n        if (index != -1) {\\n            printf(\\\"  Found %d at index %d\\\\n\\\", targets[i], index);\\n        } else {\\n            printf(\\\"  %d not found\\\\n\\\", targets[i]);\\n        }\\n    }\\n    \\n    printf(\\\"\\\\nRecursive Binary Search:\\\\n\\\");\\n    for (int i = 0; i < num_targets; i++) {\\n        int index = binary_search_recursive(arr, 0, size - 1, targets[i]);\\n        if (index != -1) {\\n            printf(\\\"  Found %d at index %d\\\\n\\\", targets[i], index);\\n        } else {\\n            printf(\\\"  %d not found\\\\n\\\", targets[i]);\\n        }\\n    }\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <math.h>\\n\\nbool is_prime(int n) {\\n    if (n < 2) return false;\\n    if (n == 2) return true;\\n    if (n % 2 == 0) return false;\\n    \\n    int limit = (int)sqrt(n);\\n    for (int i = 3; i <= limit; i += 2) {\\n        if (n % i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid sieve_of_eratosthenes(int n) {\\n    bool* is_prime_arr = (bool*)malloc((n + 1) * sizeof(bool));\\n    \\n    // Initialize all as prime\\n    for (int i = 0; i <= n; i++) {\\n        is_prime_arr[i] = true;\\n    }\\n    \\n    is_prime_arr[0] = false;\\n    is_prime_arr[1] = false;\\n    \\n    // Sieve\\n    for (int i = 2; i * i <= n; i++) {\\n        if (is_prime_arr[i]) {\\n            for (int j = i * i; j <= n; j += i) {\\n                is_prime_arr[j] = false;\\n            }\\n        }\\n    }\\n    \\n    // Print primes\\n    printf(\\\"Primes up to %d: \\\", n);\\n    int count = 0;\\n    for (int i = 2; i <= n; i++) {\\n        if (is_prime_arr[i]) {\\n            printf(\\\"%d \\\", i);\\n            count++;\\n        }\\n    }\\n    printf(\\\"\\\\nTotal: %d primes\\\\n\\\", count);\\n    \\n    free(is_prime_arr);\\n}\\n\\nint main() {\\n    printf(\\\"Prime Numbers Demo\\\\n\\\");\\n    printf(\\\"==================\\\\n\\\\n\\\");\\n    \\n    printf(\\\"1. Checking individual numbers:\\\\n\\\");\\n    int test_numbers[] = {2, 3, 4, 17, 25, 29, 97, 100};\\n    int num_tests = sizeof(test_numbers) / sizeof(test_numbers[0]);\\n    \\n    for (int i = 0; i < num_tests; i++) {\\n        int num = test_numbers[i];\\n        printf(\\\"   %d is %s\\\\n\\\", num, is_prime(num) ? \\\"prime\\\" : \\\"not prime\\\");\\n    }\\n    \\n    printf(\\\"\\\\n2. Sieve of Eratosthenes:\\\\n\\\");\\n    sieve_of_eratosthenes(50);\\n    \\n    printf(\\\"\\\\n3. First 20 primes:\\\\n\\\");\\n    int count = 0;\\n    int num = 2;\\n    while (count < 20) {\\n        if (is_prime(num)) {\\n            printf(\\\"%d \\\", num);\\n            count++;\\n        }\\n        num++;\\n    }\\n    printf(\\\"\\\\n\\\");\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\nvoid print_array(int arr[], int size, const char *label) {\\n    printf(\\\"%s: [\\\", label);\\n    for (int i = 0; i < size; i++) {\\n        printf(\\\"%d\\\", arr[i]);\\n        if (i < size - 1) printf(\\\", \\\");\\n    }\\n    printf(\\\"]\\\\n\\\");\\n}\\n\\nvoid bubble_sort(int arr[], int size) {\\n    for (int i = 0; i < size - 1; i++) {\\n        for (int j = 0; j < size - i - 1; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                int temp = arr[j];\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int numbers[] = {64, 34, 25, 12, 22, 11, 90, 42, 15, 7};\\n    int size = sizeof(numbers) / sizeof(numbers[0]);\\n\\n    printf(\\\"Array Operations Demo\\\\n\\\");\\n    printf(\\\"=====================\\\\n\\\\n\\\");\\n\\n    print_array(numbers, size, \\\"Original\\\");\\n\\n    bubble_sort(numbers, size);\\n\\n    print_array(numbers, size, \\\"Sorted  \\\");\\n\\n    int min = numbers[0], max = numbers[size - 1];\\n    int sum = 0;\\n    for (int i = 0; i < size; i++) {\\n        sum += numbers[i];\\n    }\\n\\n    printf(\\\"\\\\nStatistics:\\\\n\\\");\\n    printf(\\\"  Min: %d\\\\n\\\", min);\\n    printf(\\\"  Max: %d\\\\n\\\", max);\\n    printf(\\\"  Sum: %d\\\\n\\\", sum);\\n    printf(\\\"  Avg: %.2f\\\\n\\\", (float)sum / size);\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <string.h>\\n\\nstruct Person {\\n    char name[50];\\n    int age;\\n    float height;\\n};\\n\\nstruct Point {\\n    int x;\\n    int y;\\n};\\n\\nfloat distance(struct Point p1, struct Point p2) {\\n    int dx = p2.x - p1.x;\\n    int dy = p2.y - p1.y;\\n    return (float)(dx * dx + dy * dy);\\n}\\n\\nvoid print_person(struct Person p) {\\n    printf(\\\"  Name: %s\\\\n\\\", p.name);\\n    printf(\\\"  Age: %d years\\\\n\\\", p.age);\\n    printf(\\\"  Height: %.2f meters\\\\n\\\", p.height);\\n}\\n\\nint main() {\\n    printf(\\\"Structures Demo\\\\n\\\");\\n    printf(\\\"===============\\\\n\\\\n\\\");\\n\\n    struct Person alice;\\n    strcpy(alice.name, \\\"Alice Johnson\\\");\\n    alice.age = 28;\\n    alice.height = 1.65;\\n\\n    struct Person bob = {\\\"Bob Smith\\\", 35, 1.80};\\n\\n    printf(\\\"Person 1:\\\\n\\\");\\n    print_person(alice);\\n    printf(\\\"\\\\nPerson 2:\\\\n\\\");\\n    print_person(bob);\\n\\n    printf(\\\"\\\\nPoints Demo:\\\\n\\\");\\n    struct Point p1 = {0, 0};\\n    struct Point p2 = {3, 4};\\n\\n    printf(\\\"  Point 1: (%d, %d)\\\\n\\\", p1.x, p1.y);\\n    printf(\\\"  Point 2: (%d, %d)\\\\n\\\", p2.x, p2.y);\\n    printf(\\\"  Squared distance: %.2f\\\\n\\\", distance(p1, p2));\\n\\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int data;\\n    struct Node* next;\\n} Node;\\n\\nNode* create_node(int data) {\\n    Node* new_node = (Node*)malloc(sizeof(Node));\\n    if (new_node == NULL) {\\n        printf(\\\"Memory allocation failed!\\\\n\\\");\\n        return NULL;\\n    }\\n    new_node->data = data;\\n    new_node->next = NULL;\\n    return new_node;\\n}\\n\\nvoid insert_at_end(Node** head, int data) {\\n    Node* new_node = create_node(data);\\n    if (*head == NULL) {\\n        *head = new_node;\\n        return;\\n    }\\n    Node* current = *head;\\n    while (current->next != NULL) {\\n        current = current->next;\\n    }\\n    current->next = new_node;\\n}\\n\\nvoid insert_at_beginning(Node** head, int data) {\\n    Node* new_node = create_node(data);\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\n\\nvoid delete_node(Node** head, int data) {\\n    if (*head == NULL) return;\\n    \\n    if ((*head)->data == data) {\\n        Node* temp = *head;\\n        *head = (*head)->next;\\n        free(temp);\\n        return;\\n    }\\n    \\n    Node* current = *head;\\n    while (current->next != NULL && current->next->data != data) {\\n        current = current->next;\\n    }\\n    \\n    if (current->next != NULL) {\\n        Node* temp = current->next;\\n        current->next = current->next->next;\\n        free(temp);\\n    }\\n}\\n\\nvoid print_list(Node* head) {\\n    Node* current = head;\\n    printf(\\\"List: \\\");\\n    while (current != NULL) {\\n        printf(\\\"%d\\\", current->data);\\n        if (current->next != NULL) printf(\\\" -> \\\");\\n        current = current->next;\\n    }\\n    printf(\\\" -> NULL\\\\n\\\");\\n}\\n\\nvoid free_list(Node** head) {\\n    Node* current = *head;\\n    while (current != NULL) {\\n        Node* temp = current;\\n        current = current->next;\\n        free(temp);\\n    }\\n    *head = NULL;\\n}\\n\\nint main() {\\n    printf(\\\"Linked List Demo\\\\n\\\");\\n    printf(\\\"===============\\\\n\\\\n\\\");\\n    \\n    Node* head = NULL;\\n    \\n    printf(\\\"1. Inserting at end: 10, 20, 30\\\\n\\\");\\n    insert_at_end(&head, 10);\\n    insert_at_end(&head, 20);\\n    insert_at_end(&head, 30);\\n    print_list(head);\\n    \\n    printf(\\\"\\\\n2. Inserting at beginning: 5\\\\n\\\");\\n    insert_at_beginning(&head, 5);\\n    print_list(head);\\n    \\n    printf(\\\"\\\\n3. Deleting node with value 20\\\\n\\\");\\n    delete_node(&head, 20);\\n    print_list(head);\\n    \\n    printf(\\\"\\\\n4. Inserting more nodes: 15, 25\\\\n\\\");\\n    insert_at_end(&head, 15);\\n    insert_at_end(&head, 25);\\n    print_list(head);\\n    \\n    free_list(&head);\\n    printf(\\\"\\\\n5. List freed (memory deallocated)\\\\n\\\");\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int data;\\n    struct Node* left;\\n    struct Node* right;\\n} Node;\\n\\nNode* create_node(int data) {\\n    Node* new_node = (Node*)malloc(sizeof(Node));\\n    if (new_node == NULL) {\\n        printf(\\\"Memory allocation failed!\\\\n\\\");\\n        return NULL;\\n    }\\n    new_node->data = data;\\n    new_node->left = NULL;\\n    new_node->right = NULL;\\n    return new_node;\\n}\\n\\nvoid insert(Node** root, int data) {\\n    if (*root == NULL) {\\n        *root = create_node(data);\\n        return;\\n    }\\n    \\n    if (data < (*root)->data) {\\n        insert(&((*root)->left), data);\\n    } else if (data > (*root)->data) {\\n        insert(&((*root)->right), data);\\n    }\\n}\\n\\nvoid inorder_traversal(Node* root) {\\n    if (root == NULL) return;\\n    inorder_traversal(root->left);\\n    printf(\\\"%d \\\", root->data);\\n    inorder_traversal(root->right);\\n}\\n\\nvoid preorder_traversal(Node* root) {\\n    if (root == NULL) return;\\n    printf(\\\"%d \\\", root->data);\\n    preorder_traversal(root->left);\\n    preorder_traversal(root->right);\\n}\\n\\nvoid postorder_traversal(Node* root) {\\n    if (root == NULL) return;\\n    postorder_traversal(root->left);\\n    postorder_traversal(root->right);\\n    printf(\\\"%d \\\", root->data);\\n}\\n\\nint search(Node* root, int data) {\\n    if (root == NULL) return 0;\\n    if (root->data == data) return 1;\\n    if (data < root->data) return search(root->left, data);\\n    return search(root->right, data);\\n}\\n\\nint find_min(Node* root) {\\n    if (root == NULL) return -1;\\n    while (root->left != NULL) {\\n        root = root->left;\\n    }\\n    return root->data;\\n}\\n\\nint find_max(Node* root) {\\n    if (root == NULL) return -1;\\n    while (root->right != NULL) {\\n        root = root->right;\\n    }\\n    return root->data;\\n}\\n\\nint height(Node* root) {\\n    if (root == NULL) return -1;\\n    int left_height = height(root->left);\\n    int right_height = height(root->right);\\n    return (left_height > right_height ? left_height : right_height) + 1;\\n}\\n\\nvoid free_tree(Node* root) {\\n    if (root == NULL) return;\\n    free_tree(root->left);\\n    free_tree(root->right);\\n    free(root);\\n}\\n\\nint main() {\\n    printf(\\\"Binary Search Tree Demo\\\\n\\\");\\n    printf(\\\"======================\\\\n\\\\n\\\");\\n    \\n    Node* root = NULL;\\n    \\n    // Insert values\\n    int values[] = {50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45};\\n    int size = sizeof(values) / sizeof(values[0]);\\n    \\n    printf(\\\"1. Inserting values: \\\");\\n    for (int i = 0; i < size; i++) {\\n        printf(\\\"%d \\\", values[i]);\\n        insert(&root, values[i]);\\n    }\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    printf(\\\"2. Tree Traversals:\\\\n\\\");\\n    printf(\\\"   Inorder (sorted):   \\\");\\n    inorder_traversal(root);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"   Preorder:            \\\");\\n    preorder_traversal(root);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"   Postorder:          \\\");\\n    postorder_traversal(root);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    printf(\\\"3. Tree Properties:\\\\n\\\");\\n    printf(\\\"   Height: %d\\\\n\\\", height(root));\\n    printf(\\\"   Minimum value: %d\\\\n\\\", find_min(root));\\n    printf(\\\"   Maximum value: %d\\\\n\\\", find_max(root));\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"4. Search Operations:\\\\n\\\");\\n    int search_values[] = {40, 55, 70, 100};\\n    for (int i = 0; i < 4; i++) {\\n        int found = search(root, search_values[i]);\\n        printf(\\\"   %d: %s\\\\n\\\", search_values[i], found ? \\\"Found\\\" : \\\"Not found\\\");\\n    }\\n    \\n    free_tree(root);\\n    printf(\\\"\\\\n5. Tree freed (memory deallocated)\\\\n\\\");\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int data;\\n    struct Node* left;\\n    struct Node* right;\\n} Node;\\n\\nNode* create_node(int data) {\\n    Node* node = (Node*)malloc(sizeof(Node));\\n    node->data = data;\\n    node->left = NULL;\\n    node->right = NULL;\\n    return node;\\n}\\n\\n// Inorder: Left -> Root -> Right\\nvoid inorder(Node* root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    printf(\\\"%d \\\", root->data);\\n    inorder(root->right);\\n}\\n\\n// Preorder: Root -> Left -> Right\\nvoid preorder(Node* root) {\\n    if (root == NULL) return;\\n    printf(\\\"%d \\\", root->data);\\n    preorder(root->left);\\n    preorder(root->right);\\n}\\n\\n// Postorder: Left -> Right -> Root\\nvoid postorder(Node* root) {\\n    if (root == NULL) return;\\n    postorder(root->left);\\n    postorder(root->right);\\n    printf(\\\"%d \\\", root->data);\\n}\\n\\n// Level-order (BFS) using recursion\\nint max_level(Node* root) {\\n    if (root == NULL) return 0;\\n    int left = max_level(root->left);\\n    int right = max_level(root->right);\\n    return (left > right ? left : right) + 1;\\n}\\n\\nvoid print_level(Node* root, int level) {\\n    if (root == NULL) return;\\n    if (level == 1) {\\n        printf(\\\"%d \\\", root->data);\\n    } else if (level > 1) {\\n        print_level(root->left, level - 1);\\n        print_level(root->right, level - 1);\\n    }\\n}\\n\\nvoid level_order(Node* root) {\\n    int h = max_level(root);\\n    for (int i = 1; i <= h; i++) {\\n        print_level(root, i);\\n    }\\n}\\n\\nint count_nodes(Node* root) {\\n    if (root == NULL) return 0;\\n    return 1 + count_nodes(root->left) + count_nodes(root->right);\\n}\\n\\nint count_leaves(Node* root) {\\n    if (root == NULL) return 0;\\n    if (root->left == NULL && root->right == NULL) return 1;\\n    return count_leaves(root->left) + count_leaves(root->right);\\n}\\n\\nvoid free_tree(Node* root) {\\n    if (root == NULL) return;\\n    free_tree(root->left);\\n    free_tree(root->right);\\n    free(root);\\n}\\n\\nint main() {\\n    printf(\\\"Tree Traversal Demo\\\\n\\\");\\n    printf(\\\"===================\\\\n\\\\n\\\");\\n    \\n    // Create a sample tree:\\n    //        1\\n    //       / \\\\\\n    //      2   3\\n    //     / \\\\   \\\\\\n    //    4   5   6\\n    //       /\\n    //      7\\n    \\n    Node* root = create_node(1);\\n    root->left = create_node(2);\\n    root->right = create_node(3);\\n    root->left->left = create_node(4);\\n    root->left->right = create_node(5);\\n    root->right->right = create_node(6);\\n    root->left->right->left = create_node(7);\\n    \\n    printf(\\\"Tree Structure:\\\\n\\\");\\n    printf(\\\"        1\\\\n\\\");\\n    printf(\\\"       / \\\\\\\\\\\\n\\\");\\n    printf(\\\"      2   3\\\\n\\\");\\n    printf(\\\"     / \\\\\\\\   \\\\\\\\\\\\n\\\");\\n    printf(\\\"    4   5   6\\\\n\\\");\\n    printf(\\\"       /\\\\n\\\");\\n    printf(\\\"      7\\\\n\\\\n\\\");\\n    \\n    printf(\\\"1. Depth-First Traversals:\\\\n\\\");\\n    printf(\\\"   Inorder:   \\\");\\n    inorder(root);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"   Preorder:  \\\");\\n    preorder(root);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"   Postorder: \\\");\\n    postorder(root);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    printf(\\\"2. Breadth-First Traversal:\\\\n\\\");\\n    printf(\\\"   Level-order: \\\");\\n    level_order(root);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    printf(\\\"3. Tree Statistics:\\\\n\\\");\\n    printf(\\\"   Total nodes: %d\\\\n\\\", count_nodes(root));\\n    printf(\\\"   Leaf nodes: %d\\\\n\\\", count_leaves(root));\\n    printf(\\\"   Tree height: %d\\\\n\\\", max_level(root) - 1);\\n    \\n    free_tree(root);\\n    printf(\\\"\\\\n4. Tree freed\\\\n\\\");\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef struct Node {\\n    int data;\\n    struct Node* left;\\n    struct Node* right;\\n    int height;\\n} Node;\\n\\nint max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\n\\nint get_height(Node* node) {\\n    if (node == NULL) return 0;\\n    return node->height;\\n}\\n\\nint get_balance(Node* node) {\\n    if (node == NULL) return 0;\\n    return get_height(node->left) - get_height(node->right);\\n}\\n\\nNode* create_node(int data) {\\n    Node* node = (Node*)malloc(sizeof(Node));\\n    node->data = data;\\n    node->left = NULL;\\n    node->right = NULL;\\n    node->height = 1;\\n    return node;\\n}\\n\\nNode* right_rotate(Node* y) {\\n    Node* x = y->left;\\n    Node* T2 = x->right;\\n    \\n    x->right = y;\\n    y->left = T2;\\n    \\n    y->height = max(get_height(y->left), get_height(y->right)) + 1;\\n    x->height = max(get_height(x->left), get_height(x->right)) + 1;\\n    \\n    return x;\\n}\\n\\nNode* left_rotate(Node* x) {\\n    Node* y = x->right;\\n    Node* T2 = y->left;\\n    \\n    y->left = x;\\n    x->right = T2;\\n    \\n    x->height = max(get_height(x->left), get_height(x->right)) + 1;\\n    y->height = max(get_height(y->left), get_height(y->right)) + 1;\\n    \\n    return y;\\n}\\n\\nNode* insert(Node* node, int data) {\\n    if (node == NULL) {\\n        return create_node(data);\\n    }\\n    \\n    if (data < node->data) {\\n        node->left = insert(node->left, data);\\n    } else if (data > node->data) {\\n        node->right = insert(node->right, data);\\n    } else {\\n        return node; // Duplicate values not allowed\\n    }\\n    \\n    node->height = 1 + max(get_height(node->left), get_height(node->right));\\n    \\n    int balance = get_balance(node);\\n    \\n    // Left Left Case\\n    if (balance > 1 && data < node->left->data) {\\n        return right_rotate(node);\\n    }\\n    \\n    // Right Right Case\\n    if (balance < -1 && data > node->right->data) {\\n        return left_rotate(node);\\n    }\\n    \\n    // Left Right Case\\n    if (balance > 1 && data > node->left->data) {\\n        node->left = left_rotate(node->left);\\n        return right_rotate(node);\\n    }\\n    \\n    // Right Left Case\\n    if (balance < -1 && data < node->right->data) {\\n        node->right = right_rotate(node->right);\\n        return left_rotate(node);\\n    }\\n    \\n    return node;\\n}\\n\\nvoid inorder(Node* root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    printf(\\\"%d (h:%d, b:%d) \\\", root->data, root->height, get_balance(root));\\n    inorder(root->right);\\n}\\n\\nvoid free_tree(Node* root) {\\n    if (root == NULL) return;\\n    free_tree(root->left);\\n    free_tree(root->right);\\n    free(root);\\n}\\n\\nint main() {\\n    printf(\\\"AVL Tree (Self-Balancing) Demo\\\\n\\\");\\n    printf(\\\"==============================\\\\n\\\\n\\\");\\n    \\n    Node* root = NULL;\\n    \\n    printf(\\\"1. Inserting values (AVL tree auto-balances):\\\\n\\\");\\n    int values[] = {10, 20, 30, 40, 50, 25};\\n    int size = sizeof(values) / sizeof(values[0]);\\n    \\n    for (int i = 0; i < size; i++) {\\n        printf(\\\"   Inserting %d...\\\\n\\\", values[i]);\\n        root = insert(root, values[i]);\\n    }\\n    \\n    printf(\\\"\\\\n2. Inorder traversal (with height and balance factor):\\\\n\\\");\\n    printf(\\\"   \\\");\\n    inorder(root);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    printf(\\\"3. Tree Properties:\\\\n\\\");\\n    printf(\\\"   Root: %d\\\\n\\\", root->data);\\n    printf(\\\"   Root height: %d\\\\n\\\", root->height);\\n    printf(\\\"   Root balance: %d\\\\n\\\", get_balance(root));\\n    printf(\\\"   (Balance should be -1, 0, or 1 for AVL property)\\\\n\\\");\\n    \\n    free_tree(root);\\n    printf(\\\"\\\\n4. Tree freed\\\\n\\\");\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\n// Function pointer type definitions\\ntypedef int (*MathOperation)(int, int);\\ntypedef void (*PrintFunction)(const char*);\\n\\n// Math operations\\nint add(int a, int b) {\\n    return a + b;\\n}\\n\\nint subtract(int a, int b) {\\n    return a - b;\\n}\\n\\nint multiply(int a, int b) {\\n    return a * b;\\n}\\n\\nint divide(int a, int b) {\\n    if (b == 0) {\\n        printf(\\\"Error: Division by zero!\\\\n\\\");\\n        return 0;\\n    }\\n    return a / b;\\n}\\n\\n// Print functions\\nvoid print_normal(const char* msg) {\\n    printf(\\\"%s\\\\n\\\", msg);\\n}\\n\\nvoid print_uppercase(const char* msg) {\\n    int i = 0;\\n    while (msg[i] != '\\\\0') {\\n        if (msg[i] >= 'a' && msg[i] <= 'z') {\\n            printf(\\\"%c\\\", msg[i] - 32);\\n        } else {\\n            printf(\\\"%c\\\", msg[i]);\\n        }\\n        i++;\\n    }\\n    printf(\\\"\\\\n\\\");\\n}\\n\\nvoid print_with_prefix(const char* msg) {\\n    printf(\\\">>> %s\\\\n\\\", msg);\\n}\\n\\n// Calculator using function pointers\\nint calculate(int a, int b, MathOperation op) {\\n    return op(a, b);\\n}\\n\\n// Apply print function\\nvoid apply_print(const char* message, PrintFunction print_func) {\\n    print_func(message);\\n}\\n\\nint main() {\\n    printf(\\\"Function Pointers Demo\\\\n\\\");\\n    printf(\\\"=====================\\\\n\\\\n\\\");\\n    \\n    printf(\\\"1. Math Operations:\\\\n\\\");\\n    int x = 20, y = 4;\\n    \\n    MathOperation operations[] = {add, subtract, multiply, divide};\\n    const char* op_names[] = {\\\"Add\\\", \\\"Subtract\\\", \\\"Multiply\\\", \\\"Divide\\\"};\\n    \\n    for (int i = 0; i < 4; i++) {\\n        int result = calculate(x, y, operations[i]);\\n        printf(\\\"   %s(%d, %d) = %d\\\\n\\\", op_names[i], x, y, result);\\n    }\\n    \\n    printf(\\\"\\\\n2. Print Functions:\\\\n\\\");\\n    const char* message = \\\"Hello from function pointer!\\\";\\n    \\n    PrintFunction printers[] = {print_normal, print_uppercase, print_with_prefix};\\n    const char* printer_names[] = {\\\"Normal\\\", \\\"Uppercase\\\", \\\"With Prefix\\\"};\\n    \\n    for (int i = 0; i < 3; i++) {\\n        printf(\\\"   %s: \\\", printer_names[i]);\\n        apply_print(message, printers[i]);\\n    }\\n    \\n    printf(\\\"\\\\n3. Function Pointer Array:\\\\n\\\");\\n    MathOperation ops[] = {add, multiply};\\n    int values[] = {10, 5, 8, 2};\\n    \\n    for (int i = 0; i < 2; i++) {\\n        int result = ops[i](values[i * 2], values[i * 2 + 1]);\\n        printf(\\\"   Operation %d: %d\\\\n\\\", i + 1, result);\\n    }\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <stdlib.h>\\n#include <math.h>\\n\\n// Simple macros\\n#define PI 3.14159265359\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\n#define SQUARE(x) ((x) * (x))\\n#define ABS(x) ((x) < 0 ? -(x) : (x))\\n\\n// Multi-line macro\\n#define PRINT_SUM(a, b) \\\\\\n    do { \\\\\\n        printf(\\\"Sum of %d and %d = %d\\\\n\\\", a, b, (a) + (b)); \\\\\\n    } while(0)\\n\\n// Conditional compilation\\n#define DEBUG 1\\n\\n// Macro with stringification\\n#define PRINT_VAR(x) printf(#x \\\" = %d\\\\n\\\", x)\\n\\n// Macro with token pasting\\n#define CONCAT(a, b) a##b\\n\\nint main() {\\n    printf(\\\"Preprocessor Macros Demo\\\\n\\\");\\n    printf(\\\"========================\\\\n\\\\n\\\");\\n    \\n    printf(\\\"1. Constant Macros:\\\\n\\\");\\n    printf(\\\"   PI = %.5f\\\\n\\\", PI);\\n    printf(\\\"   PI * 2 = %.5f\\\\n\\\\n\\\", PI * 2);\\n    \\n    printf(\\\"2. Function-like Macros:\\\\n\\\");\\n    int a = 15, b = 25;\\n    printf(\\\"   MAX(%d, %d) = %d\\\\n\\\", a, b, MAX(a, b));\\n    printf(\\\"   MIN(%d, %d) = %d\\\\n\\\", a, b, MIN(a, b));\\n    printf(\\\"   SQUARE(%d) = %d\\\\n\\\", a, SQUARE(a));\\n    printf(\\\"   ABS(-%d) = %d\\\\n\\\\n\\\", a, ABS(-a));\\n    \\n    printf(\\\"3. Multi-line Macro:\\\\n\\\");\\n    PRINT_SUM(10, 20);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"4. Stringification:\\\\n\\\");\\n    int value = 42;\\n    PRINT_VAR(value);\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"5. Conditional Compilation:\\\\n\\\");\\n    #ifdef DEBUG\\n        printf(\\\"   DEBUG mode is ON\\\\n\\\");\\n    #else\\n        printf(\\\"   DEBUG mode is OFF\\\\n\\\");\\n    #endif\\n    \\n    #if DEBUG == 1\\n        printf(\\\"   Debug level: 1\\\\n\\\");\\n    #endif\\n    printf(\\\"\\\\n\\\");\\n    \\n    printf(\\\"6. Token Pasting:\\\\n\\\");\\n    int CONCAT(var, 1) = 100;  // Creates var1\\n    int CONCAT(var, 2) = 200;  // Creates var2\\n    printf(\\\"   var1 = %d\\\\n\\\", CONCAT(var, 1));\\n    printf(\\\"   var2 = %d\\\\n\\\", CONCAT(var, 2));\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n\\n// Basic enum declaration\\nenum Color {\\n    RED,\\n    GREEN,\\n    BLUE\\n};\\n\\n// Enum with explicit values\\nenum Status {\\n    PENDING = 1,\\n    PROCESSING = 5,\\n    COMPLETED = 10,\\n    FAILED = -1\\n};\\n\\n// Enum with typedef (common practice)\\ntypedef enum {\\n    MONDAY,\\n    TUESDAY,\\n    WEDNESDAY,\\n    THURSDAY,\\n    FRIDAY,\\n    SATURDAY,\\n    SUNDAY\\n} Day;\\n\\n// Enum for state machine\\ntypedef enum {\\n    IDLE,\\n    RUNNING,\\n    PAUSED,\\n    STOPPED\\n} State;\\n\\nconst char* get_state_name(State s) {\\n    switch (s) {\\n        case IDLE: return \\\"IDLE\\\";\\n        case RUNNING: return \\\"RUNNING\\\";\\n        case PAUSED: return \\\"PAUSED\\\";\\n        case STOPPED: return \\\"STOPPED\\\";\\n        default: return \\\"UNKNOWN\\\";\\n    }\\n}\\n\\nint main() {\\n    printf(\\\"Enum Examples\\\\n\\\");\\n    printf(\\\"=============\\\\n\\\\n\\\");\\n    \\n    // 1. Basic enum usage\\n    printf(\\\"1. Basic Enum (Color):\\\\n\\\");\\n    enum Color c1 = RED;\\n    enum Color c2 = GREEN;\\n    enum Color c3 = BLUE;\\n    \\n    printf(\\\"   RED = %d\\\\n\\\", c1);\\n    printf(\\\"   GREEN = %d\\\\n\\\", c2);\\n    printf(\\\"   BLUE = %d\\\\n\\\", c3);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 2. Enum with explicit values\\n    printf(\\\"2. Enum with Explicit Values (Status):\\\\n\\\");\\n    enum Status s1 = PENDING;\\n    enum Status s2 = PROCESSING;\\n    enum Status s3 = COMPLETED;\\n    enum Status s4 = FAILED;\\n    \\n    printf(\\\"   PENDING = %d\\\\n\\\", s1);\\n    printf(\\\"   PROCESSING = %d\\\\n\\\", s2);\\n    printf(\\\"   COMPLETED = %d\\\\n\\\", s3);\\n    printf(\\\"   FAILED = %d\\\\n\\\", s4);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 3. Typedef enum usage\\n    printf(\\\"3. Typedef Enum (Day):\\\\n\\\");\\n    Day today = MONDAY;\\n    Day tomorrow = TUESDAY;\\n    \\n    printf(\\\"   Today: %d (MONDAY)\\\\n\\\", today);\\n    printf(\\\"   Tomorrow: %d (TUESDAY)\\\\n\\\", tomorrow);\\n    printf(\\\"   Weekend starts at: %d (SATURDAY)\\\\n\\\", SATURDAY);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 4. Enum in switch statement\\n    printf(\\\"4. Enum in Switch Statement (State Machine):\\\\n\\\");\\n    State current_state = IDLE;\\n    \\n    printf(\\\"   Initial state: %s\\\\n\\\", get_state_name(current_state));\\n    \\n    current_state = RUNNING;\\n    printf(\\\"   After start: %s\\\\n\\\", get_state_name(current_state));\\n    \\n    current_state = PAUSED;\\n    printf(\\\"   After pause: %s\\\\n\\\", get_state_name(current_state));\\n    \\n    current_state = STOPPED;\\n    printf(\\\"   After stop: %s\\\\n\\\", get_state_name(current_state));\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 5. Enum iteration\\n    printf(\\\"5. Enum Values:\\\\n\\\");\\n    printf(\\\"   All days of the week:\\\\n\\\");\\n    for (int i = MONDAY; i <= SUNDAY; i++) {\\n        const char* day_names[] = {\\n            \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\",\\n            \\\"Friday\\\", \\\"Saturday\\\", \\\"Sunday\\\"\\n        };\\n        printf(\\\"     %d: %s\\\\n\\\", i, day_names[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 6. Enum comparison\\n    printf(\\\"6. Enum Comparison:\\\\n\\\");\\n    Day day1 = FRIDAY;\\n    Day day2 = MONDAY;\\n    \\n    if (day1 > day2) {\\n        printf(\\\"   FRIDAY (%d) comes after MONDAY (%d)\\\\n\\\", day1, day2);\\n    }\\n    \\n    if (day1 == FRIDAY) {\\n        printf(\\\"   day1 is indeed FRIDAY\\\\n\\\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\"","export default \"#include <stdio.h>\\n#include <string.h>\\n\\n// Basic union - shares memory space\\nunion Data {\\n    int i;\\n    float f;\\n    char str[20];\\n};\\n\\n// Union with struct (tagged union pattern)\\ntypedef enum {\\n    INT_TYPE,\\n    FLOAT_TYPE,\\n    STRING_TYPE\\n} DataType;\\n\\ntypedef struct {\\n    DataType type;\\n    union {\\n        int int_value;\\n        float float_value;\\n        char string_value[20];\\n    } value;\\n} Variant;\\n\\n// Union for type punning (reading memory as different type)\\nunion IntFloat {\\n    int int_bits;\\n    float float_bits;\\n};\\n\\n// Union for efficient storage of different types\\ntypedef union {\\n    struct {\\n        unsigned char r, g, b, a;\\n    } rgba;\\n    unsigned int color;\\n} Color32;\\n\\nvoid print_variant(Variant* v) {\\n    switch (v->type) {\\n        case INT_TYPE:\\n            printf(\\\"   Integer: %d\\\\n\\\", v->value.int_value);\\n            break;\\n        case FLOAT_TYPE:\\n            printf(\\\"   Float: %.2f\\\\n\\\", v->value.float_value);\\n            break;\\n        case STRING_TYPE:\\n            printf(\\\"   String: %s\\\\n\\\", v->value.string_value);\\n            break;\\n    }\\n}\\n\\nint main() {\\n    printf(\\\"Union Examples\\\\n\\\");\\n    printf(\\\"==============\\\\n\\\\n\\\");\\n    \\n    // 1. Basic union usage\\n    printf(\\\"1. Basic Union (shares memory):\\\\n\\\");\\n    union Data data;\\n    \\n    printf(\\\"   Size of union: %zu bytes\\\\n\\\", sizeof(union Data));\\n    printf(\\\"   (int: %zu, float: %zu, char[20]: %zu)\\\\n\\\\n\\\",\\n           sizeof(int), sizeof(float), sizeof(char[20]));\\n    \\n    data.i = 42;\\n    printf(\\\"   Setting int: %d\\\\n\\\", data.i);\\n    printf(\\\"   Reading as float: %.2f (garbage)\\\\n\\\", data.f);\\n    \\n    data.f = 3.14f;\\n    printf(\\\"   Setting float: %.2f\\\\n\\\", data.f);\\n    printf(\\\"   Reading as int: %d (garbage)\\\\n\\\", data.i);\\n    \\n    strcpy(data.str, \\\"Hello\\\");\\n    printf(\\\"   Setting string: %s\\\\n\\\", data.str);\\n    printf(\\\"   Reading as int: %d (garbage)\\\\n\\\", data.i);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 2. Tagged union pattern\\n    printf(\\\"2. Tagged Union (Variant type):\\\\n\\\");\\n    Variant v1, v2, v3;\\n    \\n    v1.type = INT_TYPE;\\n    v1.value.int_value = 100;\\n    printf(\\\"   Variant 1:\\\");\\n    print_variant(&v1);\\n    \\n    v2.type = FLOAT_TYPE;\\n    v2.value.float_value = 3.14159f;\\n    printf(\\\"   Variant 2:\\\");\\n    print_variant(&v2);\\n    \\n    v3.type = STRING_TYPE;\\n    strcpy(v3.value.string_value, \\\"Union Demo\\\");\\n    printf(\\\"   Variant 3:\\\");\\n    print_variant(&v3);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 3. Type punning (viewing memory as different type)\\n    printf(\\\"3. Type Punning (bit manipulation):\\\\n\\\");\\n    union IntFloat converter;\\n    \\n    converter.float_bits = 3.14159f;\\n    printf(\\\"   Float value: %.5f\\\\n\\\", converter.float_bits);\\n    printf(\\\"   As integer bits: 0x%08X\\\\n\\\", converter.int_bits);\\n    \\n    converter.int_bits = 0x40490FDB; // IEEE 754 representation of ~3.14159\\n    printf(\\\"   Setting bits: 0x%08X\\\\n\\\", converter.int_bits);\\n    printf(\\\"   As float: %.5f\\\\n\\\", converter.float_bits);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 4. Efficient color storage\\n    printf(\\\"4. Efficient Storage (Color32):\\\\n\\\");\\n    Color32 color;\\n    \\n    // Set RGBA components\\n    color.rgba.r = 255;\\n    color.rgba.g = 128;\\n    color.rgba.b = 64;\\n    color.rgba.a = 255;\\n    \\n    printf(\\\"   RGBA: (%d, %d, %d, %d)\\\\n\\\",\\n           color.rgba.r, color.rgba.g, color.rgba.b, color.rgba.a);\\n    printf(\\\"   As 32-bit integer: 0x%08X\\\\n\\\", color.color);\\n    \\n    // Access as integer\\n    color.color = 0xFF8040FF;\\n    printf(\\\"   Setting integer: 0x%08X\\\\n\\\", color.color);\\n    printf(\\\"   RGBA: (%d, %d, %d, %d)\\\\n\\\",\\n           color.rgba.r, color.rgba.g, color.rgba.b, color.rgba.a);\\n    printf(\\\"\\\\n\\\");\\n    \\n    // 5. Memory efficiency comparison\\n    printf(\\\"5. Memory Efficiency:\\\\n\\\");\\n    struct {\\n        int i;\\n        float f;\\n        char str[20];\\n    } separate = {42, 3.14f, \\\"Hello\\\"};\\n    \\n    printf(\\\"   Struct size: %zu bytes (all fields stored)\\\\n\\\", sizeof(separate));\\n    printf(\\\"   Union size: %zu bytes (only largest field)\\\\n\\\", sizeof(union Data));\\n    printf(\\\"   Memory saved: %zu bytes\\\\n\\\",\\n           sizeof(separate) - sizeof(union Data));\\n    \\n    return 0;\\n}\\n\\n\"","// C Code Examples for Sea - Dynamically loaded from examples directory\n\n// Import all example C files as raw text\nimport helloCode from '../examples/basics/hello.c?raw';\nimport pointersCode from '../examples/basics/pointers.c?raw';\nimport stringsCode from '../examples/basics/strings.c?raw';\nimport mathCode from '../examples/basics/math.c?raw';\nimport memoryCode from '../examples/basics/memory.c?raw';\nimport fibonacciCode from '../examples/algorithms/fibonacci.c?raw';\nimport factorialCode from '../examples/algorithms/factorial.c?raw';\nimport binarySearchCode from '../examples/algorithms/binary-search.c?raw';\nimport primesCode from '../examples/algorithms/primes.c?raw';\nimport arraysCode from '../examples/data-structures/arrays.c?raw';\nimport structsCode from '../examples/data-structures/structs.c?raw';\nimport linkedListCode from '../examples/data-structures/linked-list.c?raw';\nimport binaryTreeCode from '../examples/data-structures/binary-tree.c?raw';\nimport treeTraversalCode from '../examples/data-structures/tree-traversal.c?raw';\nimport avlTreeCode from '../examples/data-structures/avl-tree.c?raw';\nimport functionPointersCode from '../examples/advanced/function-pointers.c?raw';\nimport macrosCode from '../examples/advanced/macros.c?raw';\nimport enumsCode from '../examples/advanced/enums.c?raw';\nimport unionsCode from '../examples/advanced/unions.c?raw';\n\nexport interface ExampleInfo {\n    title: string;\n    description: string;\n    code: string;\n    category: string;\n}\n\n// Single source of truth: metadata with code references\nexport const EXAMPLES_INFO: Record<string, ExampleInfo> = {\n    hello: {\n        title: 'Hello World',\n        description: 'Basic printf example',\n        code: helloCode,\n        category: 'basics',\n    },\n    macros: {\n        title: 'Preprocessor Macros',\n        description: 'Macro definitions and usage',\n        code: macrosCode,\n        category: 'basics',\n    },\n    fibonacci: {\n        title: 'Fibonacci',\n        description: 'Recursive function',\n        code: fibonacciCode,\n        category: 'algorithms',\n    },\n    factorial: {\n        title: 'Factorial',\n        description: 'Iterative & recursive',\n        code: factorialCode,\n        category: 'algorithms',\n    },\n    'binary-search': {\n        title: 'Binary Search',\n        description: 'Iterative & recursive search',\n        code: binarySearchCode,\n        category: 'algorithms',\n    },\n    primes: {\n        title: 'Prime Numbers',\n        description: 'Sieve of Eratosthenes',\n        code: primesCode,\n        category: 'algorithms',\n    },\n    arrays: {\n        title: 'Arrays & Sorting',\n        description: 'Bubble sort implementation',\n        code: arraysCode,\n        category: 'data-structures',\n    },\n    structs: {\n        title: 'Structures',\n        description: 'Struct definitions and usage',\n        code: structsCode,\n        category: 'data-structures',\n    },\n    'linked-list': {\n        title: 'Linked List',\n        description: 'Dynamic linked list operations',\n        code: linkedListCode,\n        category: 'data-structures',\n    },\n    'binary-tree': {\n        title: 'Binary Search Tree',\n        description: 'BST operations and traversals',\n        code: binaryTreeCode,\n        category: 'data-structures',\n    },\n    'tree-traversal': {\n        title: 'Tree Traversal',\n        description: 'Inorder, preorder, postorder, level-order',\n        code: treeTraversalCode,\n        category: 'data-structures',\n    },\n    'avl-tree': {\n        title: 'AVL Tree',\n        description: 'Self-balancing binary search tree',\n        code: avlTreeCode,\n        category: 'data-structures',\n    },\n    pointers: {\n        title: 'Pointers',\n        description: 'Pointer manipulation',\n        code: pointersCode,\n        category: 'advanced',\n    },\n    strings: {\n        title: 'String Operations',\n        description: 'String library functions',\n        code: stringsCode,\n        category: 'advanced',\n    },\n    math: {\n        title: 'Math Functions',\n        description: 'Using math.h',\n        code: mathCode,\n        category: 'advanced',\n    },\n    memory: {\n        title: 'Memory Management',\n        description: 'malloc, calloc, realloc, free',\n        code: memoryCode,\n        category: 'advanced',\n    },\n    'function-pointers': {\n        title: 'Function Pointers',\n        description: 'Function pointer usage',\n        code: functionPointersCode,\n        category: 'advanced',\n    },\n    enums: {\n        title: 'Enums',\n        description: 'Enumeration types and usage',\n        code: enumsCode,\n        category: 'advanced',\n    },\n    unions: {\n        title: 'Unions',\n        description: 'Union types and memory sharing',\n        code: unionsCode,\n        category: 'advanced',\n    },\n};\n\n// Derive EXAMPLES from EXAMPLES_INFO to avoid duplication\nexport const EXAMPLES: Record<string, string> = Object.fromEntries(\n    Object.entries(EXAMPLES_INFO).map(([key, info]) => [key, info.code])\n);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport * as objects from '../../../base/common/objects.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { USUAL_WORD_SEPARATORS } from '../core/wordHelper.js';\nimport * as nls from '../../../nls.js';\n/**\n * @internal\n * The width of the minimap gutter, in pixels.\n */\nexport const MINIMAP_GUTTER_WIDTH = 8;\n//#endregion\n/**\n * An event describing that the configuration of the editor has changed.\n */\nexport class ConfigurationChangedEvent {\n    /**\n     * @internal\n     */\n    constructor(values) {\n        this._values = values;\n    }\n    hasChanged(id) {\n        return this._values[id];\n    }\n}\n/**\n * @internal\n */\nexport class ComputeOptionsMemory {\n    constructor() {\n        this.stableMinimapLayoutInput = null;\n        this.stableFitMaxMinimapScale = 0;\n        this.stableFitRemainingWidth = 0;\n    }\n}\n/**\n * @internal\n */\nclass BaseEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\nexport class ApplyUpdateResult {\n    constructor(newValue, didChange) {\n        this.newValue = newValue;\n        this.didChange = didChange;\n    }\n}\nfunction applyUpdate(value, update) {\n    if (typeof value !== 'object' || typeof update !== 'object' || !value || !update) {\n        return new ApplyUpdateResult(update, value !== update);\n    }\n    if (Array.isArray(value) || Array.isArray(update)) {\n        const arrayEquals = Array.isArray(value) && Array.isArray(update) && arrays.equals(value, update);\n        return new ApplyUpdateResult(update, !arrayEquals);\n    }\n    let didChange = false;\n    for (const key in update) {\n        if (update.hasOwnProperty(key)) {\n            const result = applyUpdate(value[key], update[key]);\n            if (result.didChange) {\n                value[key] = result.newValue;\n                didChange = true;\n            }\n        }\n    }\n    return new ApplyUpdateResult(value, didChange);\n}\n/**\n * @internal\n */\nclass ComputedEditorOption {\n    constructor(id) {\n        this.schema = undefined;\n        this.id = id;\n        this.name = '_never_';\n        this.defaultValue = undefined;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        return this.defaultValue;\n    }\n}\nclass SimpleEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        return input;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\n/**\n * @internal\n */\nexport function boolean(value, defaultValue) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    if (value === 'false') {\n        // treat the string 'false' as false\n        return false;\n    }\n    return Boolean(value);\n}\nclass EditorBooleanOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'boolean';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return boolean(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function clampedInt(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    let r = parseInt(value, 10);\n    if (isNaN(r)) {\n        return defaultValue;\n    }\n    r = Math.max(minimum, r);\n    r = Math.min(maximum, r);\n    return r | 0;\n}\nclass EditorIntOption extends SimpleEditorOption {\n    static clampedInt(value, defaultValue, minimum, maximum) {\n        return clampedInt(value, defaultValue, minimum, maximum);\n    }\n    constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'integer';\n            schema.default = defaultValue;\n            schema.minimum = minimum;\n            schema.maximum = maximum;\n        }\n        super(id, name, defaultValue, schema);\n        this.minimum = minimum;\n        this.maximum = maximum;\n    }\n    validate(input) {\n        return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);\n    }\n}\n/**\n * @internal\n */\nexport function clampedFloat(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    const r = EditorFloatOption.float(value, defaultValue);\n    return EditorFloatOption.clamp(r, minimum, maximum);\n}\nclass EditorFloatOption extends SimpleEditorOption {\n    static clamp(n, min, max) {\n        if (n < min) {\n            return min;\n        }\n        if (n > max) {\n            return max;\n        }\n        return n;\n    }\n    static float(value, defaultValue) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        const r = parseFloat(value);\n        return (isNaN(r) ? defaultValue : r);\n    }\n    constructor(id, name, defaultValue, validationFn, schema) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'number';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this.validationFn = validationFn;\n    }\n    validate(input) {\n        return this.validationFn(EditorFloatOption.float(input, this.defaultValue));\n    }\n}\nclass EditorStringOption extends SimpleEditorOption {\n    static string(value, defaultValue) {\n        if (typeof value !== 'string') {\n            return defaultValue;\n        }\n        return value;\n    }\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return EditorStringOption.string(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function stringSet(value, defaultValue, allowedValues, renamedValues) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (renamedValues && value in renamedValues) {\n        return renamedValues[value];\n    }\n    if (allowedValues.indexOf(value) === -1) {\n        return defaultValue;\n    }\n    return value;\n}\nclass EditorStringEnumOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, allowedValues, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n    }\n    validate(input) {\n        return stringSet(input, this.defaultValue, this._allowedValues);\n    }\n}\nclass EditorEnumOption extends BaseEditorOption {\n    constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultStringValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n        this._convert = convert;\n    }\n    validate(input) {\n        if (typeof input !== 'string') {\n            return this.defaultValue;\n        }\n        if (this._allowedValues.indexOf(input) === -1) {\n            return this.defaultValue;\n        }\n        return this._convert(input);\n    }\n}\n//#endregion\n//#region autoIndent\nfunction _autoIndentFromString(autoIndent) {\n    switch (autoIndent) {\n        case 'none': return 0 /* EditorAutoIndentStrategy.None */;\n        case 'keep': return 1 /* EditorAutoIndentStrategy.Keep */;\n        case 'brackets': return 2 /* EditorAutoIndentStrategy.Brackets */;\n        case 'advanced': return 3 /* EditorAutoIndentStrategy.Advanced */;\n        case 'full': return 4 /* EditorAutoIndentStrategy.Full */;\n    }\n}\n//#endregion\n//#region accessibilitySupport\nclass EditorAccessibilitySupport extends BaseEditorOption {\n    constructor() {\n        super(2 /* EditorOption.accessibilitySupport */, 'accessibilitySupport', 0 /* AccessibilitySupport.Unknown */, {\n            type: 'string',\n            enum: ['auto', 'on', 'off'],\n            enumDescriptions: [\n                nls.localize('accessibilitySupport.auto', \"Use platform APIs to detect when a Screen Reader is attached.\"),\n                nls.localize('accessibilitySupport.on', \"Optimize for usage with a Screen Reader.\"),\n                nls.localize('accessibilitySupport.off', \"Assume a screen reader is not attached.\"),\n            ],\n            default: 'auto',\n            tags: ['accessibility'],\n            description: nls.localize('accessibilitySupport', \"Controls if the UI should run in a mode where it is optimized for screen readers.\")\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'auto': return 0 /* AccessibilitySupport.Unknown */;\n            case 'off': return 1 /* AccessibilitySupport.Disabled */;\n            case 'on': return 2 /* AccessibilitySupport.Enabled */;\n        }\n        return this.defaultValue;\n    }\n    compute(env, options, value) {\n        if (value === 0 /* AccessibilitySupport.Unknown */) {\n            // The editor reads the `accessibilitySupport` from the environment\n            return env.accessibilitySupport;\n        }\n        return value;\n    }\n}\nclass EditorComments extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertSpace: true,\n            ignoreEmptyLines: true,\n        };\n        super(23 /* EditorOption.comments */, 'comments', defaults, {\n            'editor.comments.insertSpace': {\n                type: 'boolean',\n                default: defaults.insertSpace,\n                description: nls.localize('comments.insertSpace', \"Controls whether a space character is inserted when commenting.\")\n            },\n            'editor.comments.ignoreEmptyLines': {\n                type: 'boolean',\n                default: defaults.ignoreEmptyLines,\n                description: nls.localize('comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),\n            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),\n        };\n    }\n}\nfunction _cursorBlinkingStyleFromString(cursorBlinkingStyle) {\n    switch (cursorBlinkingStyle) {\n        case 'blink': return 1 /* TextEditorCursorBlinkingStyle.Blink */;\n        case 'smooth': return 2 /* TextEditorCursorBlinkingStyle.Smooth */;\n        case 'phase': return 3 /* TextEditorCursorBlinkingStyle.Phase */;\n        case 'expand': return 4 /* TextEditorCursorBlinkingStyle.Expand */;\n        case 'solid': return 5 /* TextEditorCursorBlinkingStyle.Solid */;\n    }\n}\n//#endregion\n//#region cursorStyle\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nfunction _cursorStyleFromString(cursorStyle) {\n    switch (cursorStyle) {\n        case 'line': return TextEditorCursorStyle.Line;\n        case 'block': return TextEditorCursorStyle.Block;\n        case 'underline': return TextEditorCursorStyle.Underline;\n        case 'line-thin': return TextEditorCursorStyle.LineThin;\n        case 'block-outline': return TextEditorCursorStyle.BlockOutline;\n        case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;\n    }\n}\n//#endregion\n//#region editorClassName\nclass EditorClassName extends ComputedEditorOption {\n    constructor() {\n        super(143 /* EditorOption.editorClassName */);\n    }\n    compute(env, options, _) {\n        const classNames = ['monaco-editor'];\n        if (options.get(39 /* EditorOption.extraEditorClassName */)) {\n            classNames.push(options.get(39 /* EditorOption.extraEditorClassName */));\n        }\n        if (env.extraEditorClassName) {\n            classNames.push(env.extraEditorClassName);\n        }\n        if (options.get(74 /* EditorOption.mouseStyle */) === 'default') {\n            classNames.push('mouse-default');\n        }\n        else if (options.get(74 /* EditorOption.mouseStyle */) === 'copy') {\n            classNames.push('mouse-copy');\n        }\n        if (options.get(112 /* EditorOption.showUnused */)) {\n            classNames.push('showUnused');\n        }\n        if (options.get(141 /* EditorOption.showDeprecated */)) {\n            classNames.push('showDeprecated');\n        }\n        return classNames.join(' ');\n    }\n}\n//#endregion\n//#region emptySelectionClipboard\nclass EditorEmptySelectionClipboard extends EditorBooleanOption {\n    constructor() {\n        super(37 /* EditorOption.emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localize('emptySelectionClipboard', \"Controls whether copying without a selection copies the current line.\") });\n    }\n    compute(env, options, value) {\n        return value && env.emptySelectionClipboard;\n    }\n}\nclass EditorFind extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            cursorMoveOnType: true,\n            seedSearchStringFromSelection: 'always',\n            autoFindInSelection: 'never',\n            globalFindClipboard: false,\n            addExtraSpaceOnTop: true,\n            loop: true\n        };\n        super(41 /* EditorOption.find */, 'find', defaults, {\n            'editor.find.cursorMoveOnType': {\n                type: 'boolean',\n                default: defaults.cursorMoveOnType,\n                description: nls.localize('find.cursorMoveOnType', \"Controls whether the cursor should jump to find matches while typing.\")\n            },\n            'editor.find.seedSearchStringFromSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'selection'],\n                default: defaults.seedSearchStringFromSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.seedSearchStringFromSelection.never', 'Never seed search string from the editor selection.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.always', 'Always seed search string from the editor selection, including word at cursor position.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.selection', 'Only seed search string from the editor selection.')\n                ],\n                description: nls.localize('find.seedSearchStringFromSelection', \"Controls whether the search string in the Find Widget is seeded from the editor selection.\")\n            },\n            'editor.find.autoFindInSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'multiline'],\n                default: defaults.autoFindInSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.autoFindInSelection.never', 'Never turn on Find in Selection automatically (default).'),\n                    nls.localize('editor.find.autoFindInSelection.always', 'Always turn on Find in Selection automatically.'),\n                    nls.localize('editor.find.autoFindInSelection.multiline', 'Turn on Find in Selection automatically when multiple lines of content are selected.')\n                ],\n                description: nls.localize('find.autoFindInSelection', \"Controls the condition for turning on Find in Selection automatically.\")\n            },\n            'editor.find.globalFindClipboard': {\n                type: 'boolean',\n                default: defaults.globalFindClipboard,\n                description: nls.localize('find.globalFindClipboard', \"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.\"),\n                included: platform.isMacintosh\n            },\n            'editor.find.addExtraSpaceOnTop': {\n                type: 'boolean',\n                default: defaults.addExtraSpaceOnTop,\n                description: nls.localize('find.addExtraSpaceOnTop', \"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.\")\n            },\n            'editor.find.loop': {\n                type: 'boolean',\n                default: defaults.loop,\n                description: nls.localize('find.loop', \"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),\n            seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === 'boolean'\n                ? (_input.seedSearchStringFromSelection ? 'always' : 'never')\n                : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ['never', 'always', 'selection']),\n            autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'\n                ? (_input.autoFindInSelection ? 'always' : 'never')\n                : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),\n            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),\n            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),\n            loop: boolean(input.loop, this.defaultValue.loop),\n        };\n    }\n}\n//#endregion\n//#region fontLigatures\n/**\n * @internal\n */\nexport class EditorFontLigatures extends BaseEditorOption {\n    static { this.OFF = '\"liga\" off, \"calt\" off'; }\n    static { this.ON = '\"liga\" on, \"calt\" on'; }\n    constructor() {\n        super(51 /* EditorOption.fontLigatures */, 'fontLigatures', EditorFontLigatures.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontLigatures', \"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontFeatureSettings', \"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.\")\n                }\n            ],\n            description: nls.localize('fontLigaturesGeneral', \"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false' || input.length === 0) {\n                return EditorFontLigatures.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontLigatures.ON;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontLigatures.ON;\n        }\n        return EditorFontLigatures.OFF;\n    }\n}\n//#endregion\n//#region fontVariations\n/**\n * @internal\n */\nexport class EditorFontVariations extends BaseEditorOption {\n    // Text is laid out using default settings.\n    static { this.OFF = 'normal'; }\n    // Translate `fontWeight` config to the `font-variation-settings` CSS property.\n    static { this.TRANSLATE = 'translate'; }\n    constructor() {\n        super(54 /* EditorOption.fontVariations */, 'fontVariations', EditorFontVariations.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontVariations', \"Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontVariationSettings', \"Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.\")\n                }\n            ],\n            description: nls.localize('fontVariationsGeneral', \"Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                return EditorFontVariations.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontVariations.TRANSLATE;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontVariations.TRANSLATE;\n        }\n        return EditorFontVariations.OFF;\n    }\n    compute(env, options, value) {\n        // The value is computed from the fontWeight if it is true.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontVariationSettings;\n    }\n}\n//#endregion\n//#region fontInfo\nclass EditorFontInfo extends ComputedEditorOption {\n    constructor() {\n        super(50 /* EditorOption.fontInfo */);\n    }\n    compute(env, options, _) {\n        return env.fontInfo;\n    }\n}\n//#endregion\n//#region fontSize\nclass EditorFontSize extends SimpleEditorOption {\n    constructor() {\n        super(52 /* EditorOption.fontSize */, 'fontSize', EDITOR_FONT_DEFAULTS.fontSize, {\n            type: 'number',\n            minimum: 6,\n            maximum: 100,\n            default: EDITOR_FONT_DEFAULTS.fontSize,\n            description: nls.localize('fontSize', \"Controls the font size in pixels.\")\n        });\n    }\n    validate(input) {\n        const r = EditorFloatOption.float(input, this.defaultValue);\n        if (r === 0) {\n            return EDITOR_FONT_DEFAULTS.fontSize;\n        }\n        return EditorFloatOption.clamp(r, 6, 100);\n    }\n    compute(env, options, value) {\n        // The final fontSize respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontSize;\n    }\n}\n//#endregion\n//#region fontWeight\nclass EditorFontWeight extends BaseEditorOption {\n    static { this.SUGGESTION_VALUES = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']; }\n    static { this.MINIMUM_VALUE = 1; }\n    static { this.MAXIMUM_VALUE = 1000; }\n    constructor() {\n        super(53 /* EditorOption.fontWeight */, 'fontWeight', EDITOR_FONT_DEFAULTS.fontWeight, {\n            anyOf: [\n                {\n                    type: 'number',\n                    minimum: EditorFontWeight.MINIMUM_VALUE,\n                    maximum: EditorFontWeight.MAXIMUM_VALUE,\n                    errorMessage: nls.localize('fontWeightErrorMessage', \"Only \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000 are allowed.\")\n                },\n                {\n                    type: 'string',\n                    pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'\n                },\n                {\n                    enum: EditorFontWeight.SUGGESTION_VALUES\n                }\n            ],\n            default: EDITOR_FONT_DEFAULTS.fontWeight,\n            description: nls.localize('fontWeight', \"Controls the font weight. Accepts \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000.\")\n        });\n    }\n    validate(input) {\n        if (input === 'normal' || input === 'bold') {\n            return input;\n        }\n        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));\n    }\n}\nclass EditorGoToLocation extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            multiple: 'peek',\n            multipleDefinitions: 'peek',\n            multipleTypeDefinitions: 'peek',\n            multipleDeclarations: 'peek',\n            multipleImplementations: 'peek',\n            multipleReferences: 'peek',\n            multipleTests: 'peek',\n            alternativeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeTypeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeDeclarationCommand: 'editor.action.goToReferences',\n            alternativeImplementationCommand: '',\n            alternativeReferenceCommand: '',\n            alternativeTestsCommand: '',\n        };\n        const jsonSubset = {\n            type: 'string',\n            enum: ['peek', 'gotoAndPeek', 'goto'],\n            default: defaults.multiple,\n            enumDescriptions: [\n                nls.localize('editor.gotoLocation.multiple.peek', 'Show Peek view of the results (default)'),\n                nls.localize('editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a Peek view'),\n                nls.localize('editor.gotoLocation.multiple.goto', 'Go to the primary result and enable Peek-less navigation to others')\n            ]\n        };\n        const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];\n        super(58 /* EditorOption.gotoLocation */, 'gotoLocation', defaults, {\n            'editor.gotoLocation.multiple': {\n                deprecationMessage: nls.localize('editor.gotoLocation.multiple.deprecated', \"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.\"),\n            },\n            'editor.gotoLocation.multipleDefinitions': {\n                description: nls.localize('editor.editor.gotoLocation.multipleDefinitions', \"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleTypeDefinitions': {\n                description: nls.localize('editor.editor.gotoLocation.multipleTypeDefinitions', \"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleDeclarations': {\n                description: nls.localize('editor.editor.gotoLocation.multipleDeclarations', \"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleImplementations': {\n                description: nls.localize('editor.editor.gotoLocation.multipleImplemenattions', \"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleReferences': {\n                description: nls.localize('editor.editor.gotoLocation.multipleReferences', \"Controls the behavior the 'Go to References'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.alternativeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeTypeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeTypeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeTypeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeDeclarationCommand': {\n                type: 'string',\n                default: defaults.alternativeDeclarationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDeclarationCommand', \"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeImplementationCommand': {\n                type: 'string',\n                default: defaults.alternativeImplementationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeImplementationCommand', \"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeReferenceCommand': {\n                type: 'string',\n                default: defaults.alternativeReferenceCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeReferenceCommand', \"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),\n            multipleDefinitions: input.multipleDefinitions ?? stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTypeDefinitions: input.multipleTypeDefinitions ?? stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleDeclarations: input.multipleDeclarations ?? stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleImplementations: input.multipleImplementations ?? stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleReferences: input.multipleReferences ?? stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTests: input.multipleTests ?? stringSet(input.multipleTests, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),\n            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),\n            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),\n            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),\n            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),\n            alternativeTestsCommand: EditorStringOption.string(input.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand),\n        };\n    }\n}\nclass EditorHover extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            delay: 300,\n            hidingDelay: 300,\n            sticky: true,\n            above: true,\n        };\n        super(60 /* EditorOption.hover */, 'hover', defaults, {\n            'editor.hover.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('hover.enabled', \"Controls whether the hover is shown.\")\n            },\n            'editor.hover.delay': {\n                type: 'number',\n                default: defaults.delay,\n                minimum: 0,\n                maximum: 10000,\n                description: nls.localize('hover.delay', \"Controls the delay in milliseconds after which the hover is shown.\")\n            },\n            'editor.hover.sticky': {\n                type: 'boolean',\n                default: defaults.sticky,\n                description: nls.localize('hover.sticky', \"Controls whether the hover should remain visible when mouse is moved over it.\")\n            },\n            'editor.hover.hidingDelay': {\n                type: 'integer',\n                minimum: 0,\n                default: defaults.hidingDelay,\n                description: nls.localize('hover.hidingDelay', \"Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.\")\n            },\n            'editor.hover.above': {\n                type: 'boolean',\n                default: defaults.above,\n                description: nls.localize('hover.above', \"Prefer showing hovers above the line, if there's space.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),\n            sticky: boolean(input.sticky, this.defaultValue.sticky),\n            hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 600000),\n            above: boolean(input.above, this.defaultValue.above),\n        };\n    }\n}\n/**\n * @internal\n */\nexport class EditorLayoutInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(146 /* EditorOption.layoutInfo */);\n    }\n    compute(env, options, _) {\n        return EditorLayoutInfoComputer.computeLayout(options, {\n            memory: env.memory,\n            outerWidth: env.outerWidth,\n            outerHeight: env.outerHeight,\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            lineHeight: env.fontInfo.lineHeight,\n            viewLineCount: env.viewLineCount,\n            lineNumbersDigitCount: env.lineNumbersDigitCount,\n            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,\n            maxDigitWidth: env.fontInfo.maxDigitWidth,\n            pixelRatio: env.pixelRatio,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount\n        });\n    }\n    static computeContainedMinimapLineCount(input) {\n        const typicalViewportLineCount = input.height / input.lineHeight;\n        const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);\n        let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);\n        if (input.scrollBeyondLastLine) {\n            extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);\n        }\n        const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);\n        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);\n        return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };\n    }\n    static _computeMinimapLayout(input, memory) {\n        const outerWidth = input.outerWidth;\n        const outerHeight = input.outerHeight;\n        const pixelRatio = input.pixelRatio;\n        if (!input.minimap.enabled) {\n            return {\n                renderMinimap: 0 /* RenderMinimap.None */,\n                minimapLeft: 0,\n                minimapWidth: 0,\n                minimapHeightIsEditorHeight: false,\n                minimapIsSampling: false,\n                minimapScale: 1,\n                minimapLineHeight: 1,\n                minimapCanvasInnerWidth: 0,\n                minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),\n                minimapCanvasOuterWidth: 0,\n                minimapCanvasOuterHeight: outerHeight,\n            };\n        }\n        // Can use memory if only the `viewLineCount` and `remainingWidth` have changed\n        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;\n        const couldUseMemory = (stableMinimapLayoutInput\n            // && input.outerWidth === lastMinimapLayoutInput.outerWidth !!! INTENTIONAL OMITTED\n            && input.outerHeight === stableMinimapLayoutInput.outerHeight\n            && input.lineHeight === stableMinimapLayoutInput.lineHeight\n            && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth\n            && input.pixelRatio === stableMinimapLayoutInput.pixelRatio\n            && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine\n            && input.paddingTop === stableMinimapLayoutInput.paddingTop\n            && input.paddingBottom === stableMinimapLayoutInput.paddingBottom\n            && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled\n            && input.minimap.side === stableMinimapLayoutInput.minimap.side\n            && input.minimap.size === stableMinimapLayoutInput.minimap.size\n            && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider\n            && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters\n            && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn\n            && input.minimap.scale === stableMinimapLayoutInput.minimap.scale\n            && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth\n            // && input.viewLineCount === lastMinimapLayoutInput.viewLineCount !!! INTENTIONAL OMITTED\n            // && input.remainingWidth === lastMinimapLayoutInput.remainingWidth !!! INTENTIONAL OMITTED\n            && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);\n        const lineHeight = input.lineHeight;\n        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastLine = input.scrollBeyondLastLine;\n        const minimapRenderCharacters = input.minimap.renderCharacters;\n        let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);\n        const minimapMaxColumn = input.minimap.maxColumn;\n        const minimapSize = input.minimap.size;\n        const minimapSide = input.minimap.side;\n        const verticalScrollbarWidth = input.verticalScrollbarWidth;\n        const viewLineCount = input.viewLineCount;\n        const remainingWidth = input.remainingWidth;\n        const isViewportWrapping = input.isViewportWrapping;\n        const baseCharHeight = minimapRenderCharacters ? 2 : 3;\n        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);\n        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;\n        let minimapHeightIsEditorHeight = false;\n        let minimapIsSampling = false;\n        let minimapLineHeight = baseCharHeight * minimapScale;\n        let minimapCharWidth = minimapScale / pixelRatio;\n        let minimapWidthMultiplier = 1;\n        if (minimapSize === 'fill' || minimapSize === 'fit') {\n            const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n                viewLineCount: viewLineCount,\n                scrollBeyondLastLine: scrollBeyondLastLine,\n                paddingTop: input.paddingTop,\n                paddingBottom: input.paddingBottom,\n                height: outerHeight,\n                lineHeight: lineHeight,\n                pixelRatio: pixelRatio\n            });\n            // ratio is intentionally not part of the layout to avoid the layout changing all the time\n            // when doing sampling\n            const ratio = viewLineCount / minimapLineCount;\n            if (ratio > 1) {\n                minimapHeightIsEditorHeight = true;\n                minimapIsSampling = true;\n                minimapScale = 1;\n                minimapLineHeight = 1;\n                minimapCharWidth = minimapScale / pixelRatio;\n            }\n            else {\n                let fitBecomesFill = false;\n                let maxMinimapScale = minimapScale + 1;\n                if (minimapSize === 'fit') {\n                    const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fit` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        fitBecomesFill = true;\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    else {\n                        fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);\n                    }\n                }\n                if (minimapSize === 'fill' || fitBecomesFill) {\n                    minimapHeightIsEditorHeight = true;\n                    const configuredMinimapScale = minimapScale;\n                    minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fill` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));\n                    if (minimapScale > configuredMinimapScale) {\n                        minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);\n                    }\n                    minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;\n                    minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);\n                    if (isViewportWrapping) {\n                        // remember for next time\n                        memory.stableMinimapLayoutInput = input;\n                        memory.stableFitRemainingWidth = remainingWidth;\n                        memory.stableFitMaxMinimapScale = minimapScale;\n                    }\n                    else {\n                        memory.stableMinimapLayoutInput = null;\n                        memory.stableFitRemainingWidth = 0;\n                    }\n                }\n            }\n        }\n        // Given:\n        // (leaving 2px for the cursor to have space after the last character)\n        // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth\n        // minimapWidth = viewportColumn * minimapCharWidth\n        // contentWidth = remainingWidth - minimapWidth\n        // What are good values for contentWidth and minimapWidth ?\n        // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)\n        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);\n        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);\n        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);\n        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;\n        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);\n        const renderMinimap = (minimapRenderCharacters ? 1 /* RenderMinimap.Text */ : 2 /* RenderMinimap.Blocks */);\n        const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));\n        return {\n            renderMinimap,\n            minimapLeft,\n            minimapWidth,\n            minimapHeightIsEditorHeight,\n            minimapIsSampling,\n            minimapScale,\n            minimapLineHeight,\n            minimapCanvasInnerWidth,\n            minimapCanvasInnerHeight,\n            minimapCanvasOuterWidth,\n            minimapCanvasOuterHeight,\n        };\n    }\n    static computeLayout(options, env) {\n        const outerWidth = env.outerWidth | 0;\n        const outerHeight = env.outerHeight | 0;\n        const lineHeight = env.lineHeight | 0;\n        const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;\n        const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;\n        const maxDigitWidth = env.maxDigitWidth;\n        const pixelRatio = env.pixelRatio;\n        const viewLineCount = env.viewLineCount;\n        const wordWrapOverride2 = options.get(138 /* EditorOption.wordWrapOverride2 */);\n        const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(137 /* EditorOption.wordWrapOverride1 */) : wordWrapOverride2);\n        const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(133 /* EditorOption.wordWrap */) : wordWrapOverride1);\n        const wordWrapColumn = options.get(136 /* EditorOption.wordWrapColumn */);\n        const isDominatedByLongLines = env.isDominatedByLongLines;\n        const showGlyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n        const showLineNumbers = (options.get(68 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */);\n        const lineNumbersMinChars = options.get(69 /* EditorOption.lineNumbersMinChars */);\n        const scrollBeyondLastLine = options.get(106 /* EditorOption.scrollBeyondLastLine */);\n        const padding = options.get(84 /* EditorOption.padding */);\n        const minimap = options.get(73 /* EditorOption.minimap */);\n        const scrollbar = options.get(104 /* EditorOption.scrollbar */);\n        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;\n        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;\n        const scrollbarArrowSize = scrollbar.arrowSize;\n        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;\n        const folding = options.get(43 /* EditorOption.folding */);\n        const showFoldingDecoration = options.get(111 /* EditorOption.showFoldingControls */) !== 'never';\n        let lineDecorationsWidth = options.get(66 /* EditorOption.lineDecorationsWidth */);\n        if (folding && showFoldingDecoration) {\n            lineDecorationsWidth += 16;\n        }\n        let lineNumbersWidth = 0;\n        if (showLineNumbers) {\n            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);\n            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);\n        }\n        let glyphMarginWidth = 0;\n        if (showGlyphMargin) {\n            glyphMarginWidth = lineHeight * env.glyphMarginDecorationLaneCount;\n        }\n        let glyphMarginLeft = 0;\n        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;\n        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;\n        let contentLeft = decorationsLeft + lineDecorationsWidth;\n        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;\n        let isWordWrapMinified = false;\n        let isViewportWrapping = false;\n        let wrappingColumn = -1;\n        if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {\n            // Force viewport width wrapping if model is dominated by long lines\n            isWordWrapMinified = true;\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'on' || wordWrap === 'bounded') {\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'wordWrapColumn') {\n            wrappingColumn = wordWrapColumn;\n        }\n        const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({\n            outerWidth: outerWidth,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,\n            pixelRatio: pixelRatio,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            minimap: minimap,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            viewLineCount: viewLineCount,\n            remainingWidth: remainingWidth,\n            isViewportWrapping: isViewportWrapping,\n        }, env.memory || new ComputeOptionsMemory());\n        if (minimapLayout.renderMinimap !== 0 /* RenderMinimap.None */ && minimapLayout.minimapLeft === 0) {\n            // the minimap is rendered to the left, so move everything to the right\n            glyphMarginLeft += minimapLayout.minimapWidth;\n            lineNumbersLeft += minimapLayout.minimapWidth;\n            decorationsLeft += minimapLayout.minimapWidth;\n            contentLeft += minimapLayout.minimapWidth;\n        }\n        const contentWidth = remainingWidth - minimapLayout.minimapWidth;\n        // (leaving 2px for the cursor to have space after the last character)\n        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));\n        const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);\n        if (isViewportWrapping) {\n            // compute the actual wrappingColumn\n            wrappingColumn = Math.max(1, viewportColumn);\n            if (wordWrap === 'bounded') {\n                wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);\n            }\n        }\n        return {\n            width: outerWidth,\n            height: outerHeight,\n            glyphMarginLeft: glyphMarginLeft,\n            glyphMarginWidth: glyphMarginWidth,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount,\n            lineNumbersLeft: lineNumbersLeft,\n            lineNumbersWidth: lineNumbersWidth,\n            decorationsLeft: decorationsLeft,\n            decorationsWidth: lineDecorationsWidth,\n            contentLeft: contentLeft,\n            contentWidth: contentWidth,\n            minimap: minimapLayout,\n            viewportColumn: viewportColumn,\n            isWordWrapMinified: isWordWrapMinified,\n            isViewportWrapping: isViewportWrapping,\n            wrappingColumn: wrappingColumn,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            horizontalScrollbarHeight: horizontalScrollbarHeight,\n            overviewRuler: {\n                top: verticalArrowSize,\n                width: verticalScrollbarWidth,\n                height: (outerHeight - 2 * verticalArrowSize),\n                right: 0\n            }\n        };\n    }\n}\n//#endregion\n//#region WrappingStrategy\nclass WrappingStrategy extends BaseEditorOption {\n    constructor() {\n        super(140 /* EditorOption.wrappingStrategy */, 'wrappingStrategy', 'simple', {\n            'editor.wrappingStrategy': {\n                enumDescriptions: [\n                    nls.localize('wrappingStrategy.simple', \"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.\"),\n                    nls.localize('wrappingStrategy.advanced', \"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.\")\n                ],\n                type: 'string',\n                enum: ['simple', 'advanced'],\n                default: 'simple',\n                description: nls.localize('wrappingStrategy', \"Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.\")\n            }\n        });\n    }\n    validate(input) {\n        return stringSet(input, 'simple', ['simple', 'advanced']);\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // if we know for a fact that a screen reader is attached, we switch our strategy to advanced to\n            // help that the editor's wrapping points match the textarea's wrapping points\n            return 'advanced';\n        }\n        return value;\n    }\n}\n//#endregion\n//#region lightbulb\nexport var ShowLightbulbIconMode;\n(function (ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\nclass EditorLightbulb extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: ShowLightbulbIconMode.OnCode };\n        super(65 /* EditorOption.lightbulb */, 'lightbulb', defaults, {\n            'editor.lightbulb.enabled': {\n                type: 'string',\n                tags: ['experimental'],\n                enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],\n                default: defaults.enabled,\n                enumDescriptions: [\n                    nls.localize('editor.lightbulb.enabled.off', 'Disable the code action menu.'),\n                    nls.localize('editor.lightbulb.enabled.onCode', 'Show the code action menu when the cursor is on lines with code.'),\n                    nls.localize('editor.lightbulb.enabled.on', 'Show the code action menu when the cursor is on lines with code or on empty lines.'),\n                ],\n                description: nls.localize('enabled', \"Enables the Code Action lightbulb in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])\n        };\n    }\n}\nclass EditorStickyScroll extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, maxLineCount: 5, defaultModel: 'outlineModel', scrollWithEditor: true };\n        super(116 /* EditorOption.stickyScroll */, 'stickyScroll', defaults, {\n            'editor.stickyScroll.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('editor.stickyScroll.enabled', \"Shows the nested current scopes during the scroll at the top of the editor.\"),\n                tags: ['experimental']\n            },\n            'editor.stickyScroll.maxLineCount': {\n                type: 'number',\n                default: defaults.maxLineCount,\n                minimum: 1,\n                maximum: 20,\n                description: nls.localize('editor.stickyScroll.maxLineCount', \"Defines the maximum number of sticky lines to show.\")\n            },\n            'editor.stickyScroll.defaultModel': {\n                type: 'string',\n                enum: ['outlineModel', 'foldingProviderModel', 'indentationModel'],\n                default: defaults.defaultModel,\n                description: nls.localize('editor.stickyScroll.defaultModel', \"Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.\")\n            },\n            'editor.stickyScroll.scrollWithEditor': {\n                type: 'boolean',\n                default: defaults.scrollWithEditor,\n                description: nls.localize('editor.stickyScroll.scrollWithEditor', \"Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),\n            defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ['outlineModel', 'foldingProviderModel', 'indentationModel']),\n            scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)\n        };\n    }\n}\nclass EditorInlayHints extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: 'on', fontSize: 0, fontFamily: '', padding: false };\n        super(142 /* EditorOption.inlayHints */, 'inlayHints', defaults, {\n            'editor.inlayHints.enabled': {\n                type: 'string',\n                default: defaults.enabled,\n                description: nls.localize('inlayHints.enable', \"Enables the inlay hints in the editor.\"),\n                enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],\n                markdownEnumDescriptions: [\n                    nls.localize('editor.inlayHints.on', \"Inlay hints are enabled\"),\n                    nls.localize('editor.inlayHints.onUnlessPressed', \"Inlay hints are showing by default and hide when holding {0}\", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),\n                    nls.localize('editor.inlayHints.offUnlessPressed', \"Inlay hints are hidden by default and show when holding {0}\", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),\n                    nls.localize('editor.inlayHints.off', \"Inlay hints are disabled\"),\n                ],\n            },\n            'editor.inlayHints.fontSize': {\n                type: 'number',\n                default: defaults.fontSize,\n                markdownDescription: nls.localize('inlayHints.fontSize', \"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.\", '`#editor.fontSize#`', '`5`')\n            },\n            'editor.inlayHints.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                markdownDescription: nls.localize('inlayHints.fontFamily', \"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.\", '`#editor.fontFamily#`')\n            },\n            'editor.inlayHints.padding': {\n                type: 'boolean',\n                default: defaults.padding,\n                description: nls.localize('inlayHints.padding', \"Enables the padding around the inlay hints in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        if (typeof input.enabled === 'boolean') {\n            input.enabled = input.enabled ? 'on' : 'off';\n        }\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, ['on', 'off', 'offUnlessPressed', 'onUnlessPressed']),\n            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            padding: boolean(input.padding, this.defaultValue.padding)\n        };\n    }\n}\n//#endregion\n//#region lineDecorationsWidth\nclass EditorLineDecorationsWidth extends BaseEditorOption {\n    constructor() {\n        super(66 /* EditorOption.lineDecorationsWidth */, 'lineDecorationsWidth', 10);\n    }\n    validate(input) {\n        if (typeof input === 'string' && /^\\d+(\\.\\d+)?ch$/.test(input)) {\n            const multiple = parseFloat(input.substring(0, input.length - 2));\n            return -multiple; // negative numbers signal a multiple\n        }\n        else {\n            return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1000);\n        }\n    }\n    compute(env, options, value) {\n        if (value < 0) {\n            // negative numbers signal a multiple\n            return EditorIntOption.clampedInt(-value * env.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1000);\n        }\n        else {\n            return value;\n        }\n    }\n}\n//#endregion\n//#region lineHeight\nclass EditorLineHeight extends EditorFloatOption {\n    constructor() {\n        super(67 /* EditorOption.lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localize('lineHeight', \"Controls the line height. \\n - Use 0 to automatically compute the line height from the font size.\\n - Values between 0 and 8 will be used as a multiplier with the font size.\\n - Values greater than or equal to 8 will be used as effective values.\") });\n    }\n    compute(env, options, value) {\n        // The lineHeight is computed from the fontSize if it is 0.\n        // Moreover, the final lineHeight respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.lineHeight;\n    }\n}\nclass EditorMinimap extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            size: 'proportional',\n            side: 'right',\n            showSlider: 'mouseover',\n            autohide: false,\n            renderCharacters: true,\n            maxColumn: 120,\n            scale: 1,\n            showRegionSectionHeaders: true,\n            showMarkSectionHeaders: true,\n            sectionHeaderFontSize: 9,\n            sectionHeaderLetterSpacing: 1,\n        };\n        super(73 /* EditorOption.minimap */, 'minimap', defaults, {\n            'editor.minimap.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('minimap.enabled', \"Controls whether the minimap is shown.\")\n            },\n            'editor.minimap.autohide': {\n                type: 'boolean',\n                default: defaults.autohide,\n                description: nls.localize('minimap.autohide', \"Controls whether the minimap is hidden automatically.\")\n            },\n            'editor.minimap.size': {\n                type: 'string',\n                enum: ['proportional', 'fill', 'fit'],\n                enumDescriptions: [\n                    nls.localize('minimap.size.proportional', \"The minimap has the same size as the editor contents (and might scroll).\"),\n                    nls.localize('minimap.size.fill', \"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).\"),\n                    nls.localize('minimap.size.fit', \"The minimap will shrink as necessary to never be larger than the editor (no scrolling).\"),\n                ],\n                default: defaults.size,\n                description: nls.localize('minimap.size', \"Controls the size of the minimap.\")\n            },\n            'editor.minimap.side': {\n                type: 'string',\n                enum: ['left', 'right'],\n                default: defaults.side,\n                description: nls.localize('minimap.side', \"Controls the side where to render the minimap.\")\n            },\n            'editor.minimap.showSlider': {\n                type: 'string',\n                enum: ['always', 'mouseover'],\n                default: defaults.showSlider,\n                description: nls.localize('minimap.showSlider', \"Controls when the minimap slider is shown.\")\n            },\n            'editor.minimap.scale': {\n                type: 'number',\n                default: defaults.scale,\n                minimum: 1,\n                maximum: 3,\n                enum: [1, 2, 3],\n                description: nls.localize('minimap.scale', \"Scale of content drawn in the minimap: 1, 2 or 3.\")\n            },\n            'editor.minimap.renderCharacters': {\n                type: 'boolean',\n                default: defaults.renderCharacters,\n                description: nls.localize('minimap.renderCharacters', \"Render the actual characters on a line as opposed to color blocks.\")\n            },\n            'editor.minimap.maxColumn': {\n                type: 'number',\n                default: defaults.maxColumn,\n                description: nls.localize('minimap.maxColumn', \"Limit the width of the minimap to render at most a certain number of columns.\")\n            },\n            'editor.minimap.showRegionSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showRegionSectionHeaders,\n                description: nls.localize('minimap.showRegionSectionHeaders', \"Controls whether named regions are shown as section headers in the minimap.\")\n            },\n            'editor.minimap.showMarkSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showMarkSectionHeaders,\n                description: nls.localize('minimap.showMarkSectionHeaders', \"Controls whether MARK: comments are shown as section headers in the minimap.\")\n            },\n            'editor.minimap.sectionHeaderFontSize': {\n                type: 'number',\n                default: defaults.sectionHeaderFontSize,\n                description: nls.localize('minimap.sectionHeaderFontSize', \"Controls the font size of section headers in the minimap.\")\n            },\n            'editor.minimap.sectionHeaderLetterSpacing': {\n                type: 'number',\n                default: defaults.sectionHeaderLetterSpacing,\n                description: nls.localize('minimap.sectionHeaderLetterSpacing', \"Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            autohide: boolean(input.autohide, this.defaultValue.autohide),\n            size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),\n            side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),\n            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),\n            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),\n            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),\n            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),\n            showRegionSectionHeaders: boolean(input.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),\n            showMarkSectionHeaders: boolean(input.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),\n            sectionHeaderFontSize: EditorFloatOption.clamp(input.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),\n            sectionHeaderLetterSpacing: EditorFloatOption.clamp(input.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5),\n        };\n    }\n}\n//#endregion\n//#region multiCursorModifier\nfunction _multiCursorModifierFromString(multiCursorModifier) {\n    if (multiCursorModifier === 'ctrlCmd') {\n        return (platform.isMacintosh ? 'metaKey' : 'ctrlKey');\n    }\n    return 'altKey';\n}\nclass EditorPadding extends BaseEditorOption {\n    constructor() {\n        super(84 /* EditorOption.padding */, 'padding', { top: 0, bottom: 0 }, {\n            'editor.padding.top': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.top', \"Controls the amount of space between the top edge of the editor and the first line.\")\n            },\n            'editor.padding.bottom': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.bottom', \"Controls the amount of space between the bottom edge of the editor and the last line.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),\n            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)\n        };\n    }\n}\nclass EditorParameterHints extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            cycle: true\n        };\n        super(86 /* EditorOption.parameterHints */, 'parameterHints', defaults, {\n            'editor.parameterHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('parameterHints.enabled', \"Enables a pop-up that shows parameter documentation and type information as you type.\")\n            },\n            'editor.parameterHints.cycle': {\n                type: 'boolean',\n                default: defaults.cycle,\n                description: nls.localize('parameterHints.cycle', \"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            cycle: boolean(input.cycle, this.defaultValue.cycle)\n        };\n    }\n}\n//#endregion\n//#region pixelRatio\nclass EditorPixelRatio extends ComputedEditorOption {\n    constructor() {\n        super(144 /* EditorOption.pixelRatio */);\n    }\n    compute(env, options, _) {\n        return env.pixelRatio;\n    }\n}\n//#endregion\n//#region\nclass PlaceholderOption extends BaseEditorOption {\n    constructor() {\n        super(88 /* EditorOption.placeholder */, 'placeholder', undefined);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            return input;\n        }\n        return this.defaultValue;\n    }\n}\nclass EditorQuickSuggestions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            other: 'on',\n            comments: 'off',\n            strings: 'off'\n        };\n        const types = [\n            { type: 'boolean' },\n            {\n                type: 'string',\n                enum: ['on', 'inline', 'off'],\n                enumDescriptions: [nls.localize('on', \"Quick suggestions show inside the suggest widget\"), nls.localize('inline', \"Quick suggestions show as ghost text\"), nls.localize('off', \"Quick suggestions are disabled\")]\n            }\n        ];\n        super(90 /* EditorOption.quickSuggestions */, 'quickSuggestions', defaults, {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                strings: {\n                    anyOf: types,\n                    default: defaults.strings,\n                    description: nls.localize('quickSuggestions.strings', \"Enable quick suggestions inside strings.\")\n                },\n                comments: {\n                    anyOf: types,\n                    default: defaults.comments,\n                    description: nls.localize('quickSuggestions.comments', \"Enable quick suggestions inside comments.\")\n                },\n                other: {\n                    anyOf: types,\n                    default: defaults.other,\n                    description: nls.localize('quickSuggestions.other', \"Enable quick suggestions outside of strings and comments.\")\n                },\n            },\n            default: defaults,\n            markdownDescription: nls.localize('quickSuggestions', \"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.\", '`#editor.suggestOnTriggerCharacters#`')\n        });\n        this.defaultValue = defaults;\n    }\n    validate(input) {\n        if (typeof input === 'boolean') {\n            // boolean -> all on/off\n            const value = input ? 'on' : 'off';\n            return { comments: value, strings: value, other: value };\n        }\n        if (!input || typeof input !== 'object') {\n            // invalid object\n            return this.defaultValue;\n        }\n        const { other, comments, strings } = input;\n        const allowedValues = ['on', 'inline', 'off'];\n        let validatedOther;\n        let validatedComments;\n        let validatedStrings;\n        if (typeof other === 'boolean') {\n            validatedOther = other ? 'on' : 'off';\n        }\n        else {\n            validatedOther = stringSet(other, this.defaultValue.other, allowedValues);\n        }\n        if (typeof comments === 'boolean') {\n            validatedComments = comments ? 'on' : 'off';\n        }\n        else {\n            validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);\n        }\n        if (typeof strings === 'boolean') {\n            validatedStrings = strings ? 'on' : 'off';\n        }\n        else {\n            validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);\n        }\n        return {\n            other: validatedOther,\n            comments: validatedComments,\n            strings: validatedStrings\n        };\n    }\n}\nclass EditorRenderLineNumbersOption extends BaseEditorOption {\n    constructor() {\n        super(68 /* EditorOption.lineNumbers */, 'lineNumbers', { renderType: 1 /* RenderLineNumbersType.On */, renderFn: null }, {\n            type: 'string',\n            enum: ['off', 'on', 'relative', 'interval'],\n            enumDescriptions: [\n                nls.localize('lineNumbers.off', \"Line numbers are not rendered.\"),\n                nls.localize('lineNumbers.on', \"Line numbers are rendered as absolute number.\"),\n                nls.localize('lineNumbers.relative', \"Line numbers are rendered as distance in lines to cursor position.\"),\n                nls.localize('lineNumbers.interval', \"Line numbers are rendered every 10 lines.\")\n            ],\n            default: 'on',\n            description: nls.localize('lineNumbers', \"Controls the display of line numbers.\")\n        });\n    }\n    validate(lineNumbers) {\n        let renderType = this.defaultValue.renderType;\n        let renderFn = this.defaultValue.renderFn;\n        if (typeof lineNumbers !== 'undefined') {\n            if (typeof lineNumbers === 'function') {\n                renderType = 4 /* RenderLineNumbersType.Custom */;\n                renderFn = lineNumbers;\n            }\n            else if (lineNumbers === 'interval') {\n                renderType = 3 /* RenderLineNumbersType.Interval */;\n            }\n            else if (lineNumbers === 'relative') {\n                renderType = 2 /* RenderLineNumbersType.Relative */;\n            }\n            else if (lineNumbers === 'on') {\n                renderType = 1 /* RenderLineNumbersType.On */;\n            }\n            else {\n                renderType = 0 /* RenderLineNumbersType.Off */;\n            }\n        }\n        return {\n            renderType,\n            renderFn\n        };\n    }\n}\n//#endregion\n//#region renderValidationDecorations\n/**\n * @internal\n */\nexport function filterValidationDecorations(options) {\n    const renderValidationDecorations = options.get(99 /* EditorOption.renderValidationDecorations */);\n    if (renderValidationDecorations === 'editable') {\n        return options.get(92 /* EditorOption.readOnly */);\n    }\n    return renderValidationDecorations === 'on' ? false : true;\n}\nclass EditorRulers extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        const columnSchema = { type: 'number', description: nls.localize('rulers.size', \"Number of monospace characters at which this editor ruler will render.\") };\n        super(103 /* EditorOption.rulers */, 'rulers', defaults, {\n            type: 'array',\n            items: {\n                anyOf: [\n                    columnSchema,\n                    {\n                        type: [\n                            'object'\n                        ],\n                        properties: {\n                            column: columnSchema,\n                            color: {\n                                type: 'string',\n                                description: nls.localize('rulers.color', \"Color of this editor ruler.\"),\n                                format: 'color-hex'\n                            }\n                        }\n                    }\n                ]\n            },\n            default: defaults,\n            description: nls.localize('rulers', \"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.\")\n        });\n    }\n    validate(input) {\n        if (Array.isArray(input)) {\n            const rulers = [];\n            for (const _element of input) {\n                if (typeof _element === 'number') {\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(_element, 0, 0, 10000),\n                        color: null\n                    });\n                }\n                else if (_element && typeof _element === 'object') {\n                    const element = _element;\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),\n                        color: element.color\n                    });\n                }\n            }\n            rulers.sort((a, b) => a.column - b.column);\n            return rulers;\n        }\n        return this.defaultValue;\n    }\n}\n//#endregion\n//#region readonly\n/**\n * Configuration options for readonly message\n */\nclass ReadonlyMessage extends BaseEditorOption {\n    constructor() {\n        const defaults = undefined;\n        super(93 /* EditorOption.readOnlyMessage */, 'readOnlyMessage', defaults);\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        return _input;\n    }\n}\nfunction _scrollbarVisibilityFromString(visibility, defaultValue) {\n    if (typeof visibility !== 'string') {\n        return defaultValue;\n    }\n    switch (visibility) {\n        case 'hidden': return 2 /* ScrollbarVisibility.Hidden */;\n        case 'visible': return 3 /* ScrollbarVisibility.Visible */;\n        default: return 1 /* ScrollbarVisibility.Auto */;\n    }\n}\nclass EditorScrollbar extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            vertical: 1 /* ScrollbarVisibility.Auto */,\n            horizontal: 1 /* ScrollbarVisibility.Auto */,\n            arrowSize: 11,\n            useShadows: true,\n            verticalHasArrows: false,\n            horizontalHasArrows: false,\n            horizontalScrollbarSize: 12,\n            horizontalSliderSize: 12,\n            verticalScrollbarSize: 14,\n            verticalSliderSize: 14,\n            handleMouseWheel: true,\n            alwaysConsumeMouseWheel: true,\n            scrollByPage: false,\n            ignoreHorizontalScrollbarInContentHeight: false,\n        };\n        super(104 /* EditorOption.scrollbar */, 'scrollbar', defaults, {\n            'editor.scrollbar.vertical': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.vertical.auto', \"The vertical scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.vertical.visible', \"The vertical scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.vertical.fit', \"The vertical scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.vertical', \"Controls the visibility of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontal': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.horizontal.auto', \"The horizontal scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.horizontal.visible', \"The horizontal scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.horizontal.fit', \"The horizontal scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.horizontal', \"Controls the visibility of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.verticalScrollbarSize': {\n                type: 'number',\n                default: defaults.verticalScrollbarSize,\n                description: nls.localize('scrollbar.verticalScrollbarSize', \"The width of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontalScrollbarSize': {\n                type: 'number',\n                default: defaults.horizontalScrollbarSize,\n                description: nls.localize('scrollbar.horizontalScrollbarSize', \"The height of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.scrollByPage': {\n                type: 'boolean',\n                default: defaults.scrollByPage,\n                description: nls.localize('scrollbar.scrollByPage', \"Controls whether clicks scroll by page or jump to click position.\")\n            },\n            'editor.scrollbar.ignoreHorizontalScrollbarInContentHeight': {\n                type: 'boolean',\n                default: defaults.ignoreHorizontalScrollbarInContentHeight,\n                description: nls.localize('scrollbar.ignoreHorizontalScrollbarInContentHeight', \"When set, the horizontal scrollbar will not increase the size of the editor's content.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);\n        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);\n        return {\n            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),\n            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),\n            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),\n            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),\n            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),\n            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),\n            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),\n            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),\n            horizontalScrollbarSize: horizontalScrollbarSize,\n            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),\n            verticalScrollbarSize: verticalScrollbarSize,\n            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),\n            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),\n            ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight),\n        };\n    }\n}\n/**\n * @internal\n*/\nexport const inUntrustedWorkspace = 'inUntrustedWorkspace';\n/**\n * @internal\n */\nexport const unicodeHighlightConfigKeys = {\n    allowedCharacters: 'editor.unicodeHighlight.allowedCharacters',\n    invisibleCharacters: 'editor.unicodeHighlight.invisibleCharacters',\n    nonBasicASCII: 'editor.unicodeHighlight.nonBasicASCII',\n    ambiguousCharacters: 'editor.unicodeHighlight.ambiguousCharacters',\n    includeComments: 'editor.unicodeHighlight.includeComments',\n    includeStrings: 'editor.unicodeHighlight.includeStrings',\n    allowedLocales: 'editor.unicodeHighlight.allowedLocales',\n};\nclass UnicodeHighlight extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            nonBasicASCII: inUntrustedWorkspace,\n            invisibleCharacters: true,\n            ambiguousCharacters: true,\n            includeComments: inUntrustedWorkspace,\n            includeStrings: true,\n            allowedCharacters: {},\n            allowedLocales: { _os: true, _vscode: true },\n        };\n        super(126 /* EditorOption.unicodeHighlighting */, 'unicodeHighlight', defaults, {\n            [unicodeHighlightConfigKeys.nonBasicASCII]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.nonBasicASCII,\n                description: nls.localize('unicodeHighlight.nonBasicASCII', \"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.\")\n            },\n            [unicodeHighlightConfigKeys.invisibleCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.invisibleCharacters,\n                description: nls.localize('unicodeHighlight.invisibleCharacters', \"Controls whether characters that just reserve space or have no width at all are highlighted.\")\n            },\n            [unicodeHighlightConfigKeys.ambiguousCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.ambiguousCharacters,\n                description: nls.localize('unicodeHighlight.ambiguousCharacters', \"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.\")\n            },\n            [unicodeHighlightConfigKeys.includeComments]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeComments,\n                description: nls.localize('unicodeHighlight.includeComments', \"Controls whether characters in comments should also be subject to Unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.includeStrings]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeStrings,\n                description: nls.localize('unicodeHighlight.includeStrings', \"Controls whether characters in strings should also be subject to Unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.allowedCharacters]: {\n                restricted: true,\n                type: 'object',\n                default: defaults.allowedCharacters,\n                description: nls.localize('unicodeHighlight.allowedCharacters', \"Defines allowed characters that are not being highlighted.\"),\n                additionalProperties: {\n                    type: 'boolean'\n                }\n            },\n            [unicodeHighlightConfigKeys.allowedLocales]: {\n                restricted: true,\n                type: 'object',\n                additionalProperties: {\n                    type: 'boolean'\n                },\n                default: defaults.allowedLocales,\n                description: nls.localize('unicodeHighlight.allowedLocales', \"Unicode characters that are common in allowed locales are not being highlighted.\")\n            },\n        });\n    }\n    applyUpdate(value, update) {\n        let didChange = false;\n        if (update.allowedCharacters && value) {\n            // Treat allowedCharacters atomically\n            if (!objects.equals(value.allowedCharacters, update.allowedCharacters)) {\n                value = { ...value, allowedCharacters: update.allowedCharacters };\n                didChange = true;\n            }\n        }\n        if (update.allowedLocales && value) {\n            // Treat allowedLocales atomically\n            if (!objects.equals(value.allowedLocales, update.allowedLocales)) {\n                value = { ...value, allowedLocales: update.allowedLocales };\n                didChange = true;\n            }\n        }\n        const result = super.applyUpdate(value, update);\n        if (didChange) {\n            return new ApplyUpdateResult(result.newValue, true);\n        }\n        return result;\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),\n            ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),\n            includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),\n            allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales),\n        };\n    }\n    validateBooleanMap(map, defaultValue) {\n        if ((typeof map !== 'object') || !map) {\n            return defaultValue;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(map)) {\n            if (value === true) {\n                result[key] = true;\n            }\n        }\n        return result;\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass InlineEditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            mode: 'subwordSmart',\n            showToolbar: 'onHover',\n            suppressSuggestions: false,\n            keepOnBlur: false,\n            fontFamily: 'default'\n        };\n        super(62 /* EditorOption.inlineSuggest */, 'inlineSuggest', defaults, {\n            'editor.inlineSuggest.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineSuggest.enabled', \"Controls whether to automatically show inline suggestions in the editor.\")\n            },\n            'editor.inlineSuggest.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    nls.localize('inlineSuggest.showToolbar.always', \"Show the inline suggestion toolbar whenever an inline suggestion is shown.\"),\n                    nls.localize('inlineSuggest.showToolbar.onHover', \"Show the inline suggestion toolbar when hovering over an inline suggestion.\"),\n                    nls.localize('inlineSuggest.showToolbar.never', \"Never show the inline suggestion toolbar.\"),\n                ],\n                description: nls.localize('inlineSuggest.showToolbar', \"Controls when to show the inline suggestion toolbar.\"),\n            },\n            'editor.inlineSuggest.suppressSuggestions': {\n                type: 'boolean',\n                default: defaults.suppressSuggestions,\n                description: nls.localize('inlineSuggest.suppressSuggestions', \"Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.\")\n            },\n            'editor.inlineSuggest.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: nls.localize('inlineSuggest.fontFamily', \"Controls the font family of the inline suggestions.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            mode: stringSet(input.mode, this.defaultValue.mode, ['prefix', 'subword', 'subwordSmart']),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily)\n        };\n    }\n}\nclass InlineEditorEdit extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: false,\n            showToolbar: 'onHover',\n            fontFamily: 'default',\n            keepOnBlur: false,\n        };\n        super(63 /* EditorOption.inlineEdit */, 'experimentalInlineEdit', defaults, {\n            'editor.experimentalInlineEdit.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineEdit.enabled', \"Controls whether to show inline edits in the editor.\")\n            },\n            'editor.experimentalInlineEdit.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    nls.localize('inlineEdit.showToolbar.always', \"Show the inline edit toolbar whenever an inline suggestion is shown.\"),\n                    nls.localize('inlineEdit.showToolbar.onHover', \"Show the inline edit toolbar when hovering over an inline suggestion.\"),\n                    nls.localize('inlineEdit.showToolbar.never', \"Never show the inline edit toolbar.\"),\n                ],\n                description: nls.localize('inlineEdit.showToolbar', \"Controls when to show the inline edit toolbar.\"),\n            },\n            'editor.experimentalInlineEdit.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: nls.localize('inlineEdit.fontFamily', \"Controls the font family of the inline edit.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass BracketPairColorization extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,\n            independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType,\n        };\n        super(15 /* EditorOption.bracketPairColorization */, 'bracketPairColorization', defaults, {\n            'editor.bracketPairColorization.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('bracketPairColorization.enabled', \"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.\", '`#workbench.colorCustomizations#`')\n            },\n            'editor.bracketPairColorization.independentColorPoolPerBracketType': {\n                type: 'boolean',\n                default: defaults.independentColorPoolPerBracketType,\n                description: nls.localize('bracketPairColorization.independentColorPoolPerBracketType', \"Controls whether each bracket type has its own independent color pool.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass GuideOptions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            bracketPairs: false,\n            bracketPairsHorizontal: 'active',\n            highlightActiveBracketPair: true,\n            indentation: true,\n            highlightActiveIndentation: true\n        };\n        super(16 /* EditorOption.guides */, 'guides', defaults, {\n            'editor.guides.bracketPairs': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairs.true', \"Enables bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairs.active', \"Enables bracket pair guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairs.false', \"Disables bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairs,\n                description: nls.localize('editor.guides.bracketPairs', \"Controls whether bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.bracketPairsHorizontal': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairsHorizontal.true', \"Enables horizontal guides as addition to vertical bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.active', \"Enables horizontal guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.false', \"Disables horizontal bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairsHorizontal,\n                description: nls.localize('editor.guides.bracketPairsHorizontal', \"Controls whether horizontal bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.highlightActiveBracketPair': {\n                type: 'boolean',\n                default: defaults.highlightActiveBracketPair,\n                description: nls.localize('editor.guides.highlightActiveBracketPair', \"Controls whether the editor should highlight the active bracket pair.\")\n            },\n            'editor.guides.indentation': {\n                type: 'boolean',\n                default: defaults.indentation,\n                description: nls.localize('editor.guides.indentation', \"Controls whether the editor should render indent guides.\")\n            },\n            'editor.guides.highlightActiveIndentation': {\n                type: ['boolean', 'string'],\n                enum: [true, 'always', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.highlightActiveIndentation.true', \"Highlights the active indent guide.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.always', \"Highlights the active indent guide even if bracket guides are highlighted.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.false', \"Do not highlight the active indent guide.\"),\n                ],\n                default: defaults.highlightActiveIndentation,\n                description: nls.localize('editor.guides.highlightActiveIndentation', \"Controls whether the editor should highlight the active indent guide.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, 'active']),\n            bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, 'active']),\n            highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),\n            indentation: boolean(input.indentation, this.defaultValue.indentation),\n            highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, 'always']),\n        };\n    }\n}\nfunction primitiveSet(value, defaultValue, allowedValues) {\n    const idx = allowedValues.indexOf(value);\n    if (idx === -1) {\n        return defaultValue;\n    }\n    return allowedValues[idx];\n}\nclass EditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertMode: 'insert',\n            filterGraceful: true,\n            snippetsPreventQuickSuggestions: false,\n            localityBonus: false,\n            shareSuggestSelections: false,\n            selectionMode: 'always',\n            showIcons: true,\n            showStatusBar: false,\n            preview: false,\n            previewMode: 'subwordSmart',\n            showInlineDetails: true,\n            showMethods: true,\n            showFunctions: true,\n            showConstructors: true,\n            showDeprecated: true,\n            matchOnWordStartOnly: true,\n            showFields: true,\n            showVariables: true,\n            showClasses: true,\n            showStructs: true,\n            showInterfaces: true,\n            showModules: true,\n            showProperties: true,\n            showEvents: true,\n            showOperators: true,\n            showUnits: true,\n            showValues: true,\n            showConstants: true,\n            showEnums: true,\n            showEnumMembers: true,\n            showKeywords: true,\n            showWords: true,\n            showColors: true,\n            showFiles: true,\n            showReferences: true,\n            showFolders: true,\n            showTypeParameters: true,\n            showSnippets: true,\n            showUsers: true,\n            showIssues: true,\n        };\n        super(119 /* EditorOption.suggest */, 'suggest', defaults, {\n            'editor.suggest.insertMode': {\n                type: 'string',\n                enum: ['insert', 'replace'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.insert', \"Insert suggestion without overwriting text right of the cursor.\"),\n                    nls.localize('suggest.insertMode.replace', \"Insert suggestion and overwrite text right of the cursor.\"),\n                ],\n                default: defaults.insertMode,\n                description: nls.localize('suggest.insertMode', \"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.\")\n            },\n            'editor.suggest.filterGraceful': {\n                type: 'boolean',\n                default: defaults.filterGraceful,\n                description: nls.localize('suggest.filterGraceful', \"Controls whether filtering and sorting suggestions accounts for small typos.\")\n            },\n            'editor.suggest.localityBonus': {\n                type: 'boolean',\n                default: defaults.localityBonus,\n                description: nls.localize('suggest.localityBonus', \"Controls whether sorting favors words that appear close to the cursor.\")\n            },\n            'editor.suggest.shareSuggestSelections': {\n                type: 'boolean',\n                default: defaults.shareSuggestSelections,\n                markdownDescription: nls.localize('suggest.shareSuggestSelections', \"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).\")\n            },\n            'editor.suggest.selectionMode': {\n                type: 'string',\n                enum: ['always', 'never', 'whenTriggerCharacter', 'whenQuickSuggestion'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.always', \"Always select a suggestion when automatically triggering IntelliSense.\"),\n                    nls.localize('suggest.insertMode.never', \"Never select a suggestion when automatically triggering IntelliSense.\"),\n                    nls.localize('suggest.insertMode.whenTriggerCharacter', \"Select a suggestion only when triggering IntelliSense from a trigger character.\"),\n                    nls.localize('suggest.insertMode.whenQuickSuggestion', \"Select a suggestion only when triggering IntelliSense as you type.\"),\n                ],\n                default: defaults.selectionMode,\n                markdownDescription: nls.localize('suggest.selectionMode', \"Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.\", '`#editor.quickSuggestions#`', '`#editor.suggestOnTriggerCharacters#`')\n            },\n            'editor.suggest.snippetsPreventQuickSuggestions': {\n                type: 'boolean',\n                default: defaults.snippetsPreventQuickSuggestions,\n                description: nls.localize('suggest.snippetsPreventQuickSuggestions', \"Controls whether an active snippet prevents quick suggestions.\")\n            },\n            'editor.suggest.showIcons': {\n                type: 'boolean',\n                default: defaults.showIcons,\n                description: nls.localize('suggest.showIcons', \"Controls whether to show or hide icons in suggestions.\")\n            },\n            'editor.suggest.showStatusBar': {\n                type: 'boolean',\n                default: defaults.showStatusBar,\n                description: nls.localize('suggest.showStatusBar', \"Controls the visibility of the status bar at the bottom of the suggest widget.\")\n            },\n            'editor.suggest.preview': {\n                type: 'boolean',\n                default: defaults.preview,\n                description: nls.localize('suggest.preview', \"Controls whether to preview the suggestion outcome in the editor.\")\n            },\n            'editor.suggest.showInlineDetails': {\n                type: 'boolean',\n                default: defaults.showInlineDetails,\n                description: nls.localize('suggest.showInlineDetails', \"Controls whether suggest details show inline with the label or only in the details widget.\")\n            },\n            'editor.suggest.maxVisibleSuggestions': {\n                type: 'number',\n                deprecationMessage: nls.localize('suggest.maxVisibleSuggestions.dep', \"This setting is deprecated. The suggest widget can now be resized.\"),\n            },\n            'editor.suggest.filteredTypes': {\n                type: 'object',\n                deprecationMessage: nls.localize('deprecated', \"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.\")\n            },\n            'editor.suggest.showMethods': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showMethods', \"When enabled IntelliSense shows `method`-suggestions.\")\n            },\n            'editor.suggest.showFunctions': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFunctions', \"When enabled IntelliSense shows `function`-suggestions.\")\n            },\n            'editor.suggest.showConstructors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstructors', \"When enabled IntelliSense shows `constructor`-suggestions.\")\n            },\n            'editor.suggest.showDeprecated': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showDeprecated', \"When enabled IntelliSense shows `deprecated`-suggestions.\")\n            },\n            'editor.suggest.matchOnWordStartOnly': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.matchOnWordStartOnly', \"When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.\")\n            },\n            'editor.suggest.showFields': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFields', \"When enabled IntelliSense shows `field`-suggestions.\")\n            },\n            'editor.suggest.showVariables': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showVariables', \"When enabled IntelliSense shows `variable`-suggestions.\")\n            },\n            'editor.suggest.showClasses': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showClasss', \"When enabled IntelliSense shows `class`-suggestions.\")\n            },\n            'editor.suggest.showStructs': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showStructs', \"When enabled IntelliSense shows `struct`-suggestions.\")\n            },\n            'editor.suggest.showInterfaces': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showInterfaces', \"When enabled IntelliSense shows `interface`-suggestions.\")\n            },\n            'editor.suggest.showModules': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showModules', \"When enabled IntelliSense shows `module`-suggestions.\")\n            },\n            'editor.suggest.showProperties': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showPropertys', \"When enabled IntelliSense shows `property`-suggestions.\")\n            },\n            'editor.suggest.showEvents': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEvents', \"When enabled IntelliSense shows `event`-suggestions.\")\n            },\n            'editor.suggest.showOperators': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showOperators', \"When enabled IntelliSense shows `operator`-suggestions.\")\n            },\n            'editor.suggest.showUnits': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUnits', \"When enabled IntelliSense shows `unit`-suggestions.\")\n            },\n            'editor.suggest.showValues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showValues', \"When enabled IntelliSense shows `value`-suggestions.\")\n            },\n            'editor.suggest.showConstants': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstants', \"When enabled IntelliSense shows `constant`-suggestions.\")\n            },\n            'editor.suggest.showEnums': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnums', \"When enabled IntelliSense shows `enum`-suggestions.\")\n            },\n            'editor.suggest.showEnumMembers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnumMembers', \"When enabled IntelliSense shows `enumMember`-suggestions.\")\n            },\n            'editor.suggest.showKeywords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showKeywords', \"When enabled IntelliSense shows `keyword`-suggestions.\")\n            },\n            'editor.suggest.showWords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTexts', \"When enabled IntelliSense shows `text`-suggestions.\")\n            },\n            'editor.suggest.showColors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showColors', \"When enabled IntelliSense shows `color`-suggestions.\")\n            },\n            'editor.suggest.showFiles': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFiles', \"When enabled IntelliSense shows `file`-suggestions.\")\n            },\n            'editor.suggest.showReferences': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showReferences', \"When enabled IntelliSense shows `reference`-suggestions.\")\n            },\n            'editor.suggest.showCustomcolors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showCustomcolors', \"When enabled IntelliSense shows `customcolor`-suggestions.\")\n            },\n            'editor.suggest.showFolders': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFolders', \"When enabled IntelliSense shows `folder`-suggestions.\")\n            },\n            'editor.suggest.showTypeParameters': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTypeParameters', \"When enabled IntelliSense shows `typeParameter`-suggestions.\")\n            },\n            'editor.suggest.showSnippets': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showSnippets', \"When enabled IntelliSense shows `snippet`-suggestions.\")\n            },\n            'editor.suggest.showUsers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUsers', \"When enabled IntelliSense shows `user`-suggestions.\")\n            },\n            'editor.suggest.showIssues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showIssues', \"When enabled IntelliSense shows `issues`-suggestions.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),\n            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),\n            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),\n            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),\n            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),\n            selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ['always', 'never', 'whenQuickSuggestion', 'whenTriggerCharacter']),\n            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),\n            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),\n            preview: boolean(input.preview, this.defaultValue.preview),\n            previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ['prefix', 'subword', 'subwordSmart']),\n            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),\n            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),\n            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),\n            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),\n            showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),\n            matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),\n            showFields: boolean(input.showFields, this.defaultValue.showFields),\n            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),\n            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),\n            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),\n            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),\n            showModules: boolean(input.showModules, this.defaultValue.showModules),\n            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),\n            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),\n            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),\n            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),\n            showValues: boolean(input.showValues, this.defaultValue.showValues),\n            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),\n            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),\n            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),\n            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),\n            showWords: boolean(input.showWords, this.defaultValue.showWords),\n            showColors: boolean(input.showColors, this.defaultValue.showColors),\n            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),\n            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),\n            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),\n            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),\n            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),\n            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),\n            showIssues: boolean(input.showIssues, this.defaultValue.showIssues),\n        };\n    }\n}\nclass SmartSelect extends BaseEditorOption {\n    constructor() {\n        super(114 /* EditorOption.smartSelect */, 'smartSelect', {\n            selectLeadingAndTrailingWhitespace: true,\n            selectSubwords: true,\n        }, {\n            'editor.smartSelect.selectLeadingAndTrailingWhitespace': {\n                description: nls.localize('selectLeadingAndTrailingWhitespace', \"Whether leading and trailing whitespace should always be selected.\"),\n                default: true,\n                type: 'boolean'\n            },\n            'editor.smartSelect.selectSubwords': {\n                description: nls.localize('selectSubwords', \"Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected.\"),\n                default: true,\n                type: 'boolean'\n            }\n        });\n    }\n    validate(input) {\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        return {\n            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),\n            selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords),\n        };\n    }\n}\n//#endregion\n//#region wordSegmenterLocales\n/**\n * Locales used for segmenting lines into words when doing word related navigations or operations.\n *\n * Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\n */\nclass WordSegmenterLocales extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        super(131 /* EditorOption.wordSegmenterLocales */, 'wordSegmenterLocales', defaults, {\n            anyOf: [\n                {\n                    description: nls.localize('wordSegmenterLocales', \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"),\n                    type: 'string',\n                }, {\n                    description: nls.localize('wordSegmenterLocales', \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"),\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    }\n                }\n            ]\n        });\n    }\n    validate(input) {\n        if (typeof input === 'string') {\n            input = [input];\n        }\n        if (Array.isArray(input)) {\n            const validLocales = [];\n            for (const locale of input) {\n                if (typeof locale === 'string') {\n                    try {\n                        if (Intl.Segmenter.supportedLocalesOf(locale).length > 0) {\n                            validLocales.push(locale);\n                        }\n                    }\n                    catch {\n                        // ignore invalid locales\n                    }\n                }\n            }\n            return validLocales;\n        }\n        return this.defaultValue;\n    }\n}\nclass WrappingIndentOption extends BaseEditorOption {\n    constructor() {\n        super(139 /* EditorOption.wrappingIndent */, 'wrappingIndent', 1 /* WrappingIndent.Same */, {\n            'editor.wrappingIndent': {\n                type: 'string',\n                enum: ['none', 'same', 'indent', 'deepIndent'],\n                enumDescriptions: [\n                    nls.localize('wrappingIndent.none', \"No indentation. Wrapped lines begin at column 1.\"),\n                    nls.localize('wrappingIndent.same', \"Wrapped lines get the same indentation as the parent.\"),\n                    nls.localize('wrappingIndent.indent', \"Wrapped lines get +1 indentation toward the parent.\"),\n                    nls.localize('wrappingIndent.deepIndent', \"Wrapped lines get +2 indentation toward the parent.\"),\n                ],\n                description: nls.localize('wrappingIndent', \"Controls the indentation of wrapped lines.\"),\n                default: 'same'\n            }\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'none': return 0 /* WrappingIndent.None */;\n            case 'same': return 1 /* WrappingIndent.Same */;\n            case 'indent': return 2 /* WrappingIndent.Indent */;\n            case 'deepIndent': return 3 /* WrappingIndent.DeepIndent */;\n        }\n        return 1 /* WrappingIndent.Same */;\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // if we know for a fact that a screen reader is attached, we use no indent wrapping to\n            // help that the editor's wrapping points match the textarea's wrapping points\n            return 0 /* WrappingIndent.None */;\n        }\n        return value;\n    }\n}\nclass EditorWrappingInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(147 /* EditorOption.wrappingInfo */);\n    }\n    compute(env, options, _) {\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        return {\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            isWordWrapMinified: layoutInfo.isWordWrapMinified,\n            isViewportWrapping: layoutInfo.isViewportWrapping,\n            wrappingColumn: layoutInfo.wrappingColumn,\n        };\n    }\n}\nclass EditorDropIntoEditor extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showDropSelector: 'afterDrop' };\n        super(36 /* EditorOption.dropIntoEditor */, 'dropIntoEditor', defaults, {\n            'editor.dropIntoEditor.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('dropIntoEditor.enabled', \"Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).\"),\n            },\n            'editor.dropIntoEditor.showDropSelector': {\n                type: 'string',\n                markdownDescription: nls.localize('dropIntoEditor.showDropSelector', \"Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped.\"),\n                enum: [\n                    'afterDrop',\n                    'never'\n                ],\n                enumDescriptions: [\n                    nls.localize('dropIntoEditor.showDropSelector.afterDrop', \"Show the drop selector widget after a file is dropped into the editor.\"),\n                    nls.localize('dropIntoEditor.showDropSelector.never', \"Never show the drop selector widget. Instead the default drop provider is always used.\"),\n                ],\n                default: 'afterDrop',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ['afterDrop', 'never']),\n        };\n    }\n}\nclass EditorPasteAs extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showPasteSelector: 'afterPaste' };\n        super(85 /* EditorOption.pasteAs */, 'pasteAs', defaults, {\n            'editor.pasteAs.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('pasteAs.enabled', \"Controls whether you can paste content in different ways.\"),\n            },\n            'editor.pasteAs.showPasteSelector': {\n                type: 'string',\n                markdownDescription: nls.localize('pasteAs.showPasteSelector', \"Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted.\"),\n                enum: [\n                    'afterPaste',\n                    'never'\n                ],\n                enumDescriptions: [\n                    nls.localize('pasteAs.showPasteSelector.afterPaste', \"Show the paste selector widget after content is pasted into the editor.\"),\n                    nls.localize('pasteAs.showPasteSelector.never', \"Never show the paste selector widget. Instead the default pasting behavior is always used.\"),\n                ],\n                default: 'afterPaste',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ['afterPaste', 'never']),\n        };\n    }\n}\n//#endregion\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'monospace\\', monospace';\n/**\n * @internal\n */\nexport const EDITOR_FONT_DEFAULTS = {\n    fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\n    fontWeight: 'normal',\n    fontSize: (platform.isMacintosh ? 12 : 14),\n    lineHeight: 0,\n    letterSpacing: 0,\n};\n/**\n * @internal\n */\nexport const editorOptionsRegistry = [];\nfunction register(option) {\n    editorOptionsRegistry[option.id] = option;\n    return option;\n}\nexport const EditorOptions = {\n    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* EditorOption.acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize('acceptSuggestionOnCommitCharacter', \"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.\") })),\n    acceptSuggestionOnEnter: register(new EditorStringEnumOption(1 /* EditorOption.acceptSuggestionOnEnter */, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {\n        markdownEnumDescriptions: [\n            '',\n            nls.localize('acceptSuggestionOnEnterSmart', \"Only accept a suggestion with `Enter` when it makes a textual change.\"),\n            ''\n        ],\n        markdownDescription: nls.localize('acceptSuggestionOnEnter', \"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.\")\n    })),\n    accessibilitySupport: register(new EditorAccessibilitySupport()),\n    accessibilityPageSize: register(new EditorIntOption(3 /* EditorOption.accessibilityPageSize */, 'accessibilityPageSize', 10, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        description: nls.localize('accessibilityPageSize', \"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.\"),\n        tags: ['accessibility']\n    })),\n    ariaLabel: register(new EditorStringOption(4 /* EditorOption.ariaLabel */, 'ariaLabel', nls.localize('editorViewAccessibleLabel', \"Editor content\"))),\n    ariaRequired: register(new EditorBooleanOption(5 /* EditorOption.ariaRequired */, 'ariaRequired', false, undefined)),\n    screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(8 /* EditorOption.screenReaderAnnounceInlineSuggestion */, 'screenReaderAnnounceInlineSuggestion', true, {\n        description: nls.localize('screenReaderAnnounceInlineSuggestion', \"Control whether inline suggestions are announced by a screen reader.\"),\n        tags: ['accessibility']\n    })),\n    autoClosingBrackets: register(new EditorStringEnumOption(6 /* EditorOption.autoClosingBrackets */, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingBrackets.languageDefined', \"Use language configurations to determine when to autoclose brackets.\"),\n            nls.localize('editor.autoClosingBrackets.beforeWhitespace', \"Autoclose brackets only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingBrackets', \"Controls whether the editor should automatically close brackets after the user adds an opening bracket.\")\n    })),\n    autoClosingComments: register(new EditorStringEnumOption(7 /* EditorOption.autoClosingComments */, 'autoClosingComments', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingComments.languageDefined', \"Use language configurations to determine when to autoclose comments.\"),\n            nls.localize('editor.autoClosingComments.beforeWhitespace', \"Autoclose comments only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingComments', \"Controls whether the editor should automatically close comments after the user adds an opening comment.\")\n    })),\n    autoClosingDelete: register(new EditorStringEnumOption(9 /* EditorOption.autoClosingDelete */, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingDelete.auto', \"Remove adjacent closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingDelete', \"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.\")\n    })),\n    autoClosingOvertype: register(new EditorStringEnumOption(10 /* EditorOption.autoClosingOvertype */, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingOvertype.auto', \"Type over closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingOvertype', \"Controls whether the editor should type over closing quotes or brackets.\")\n    })),\n    autoClosingQuotes: register(new EditorStringEnumOption(11 /* EditorOption.autoClosingQuotes */, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingQuotes.languageDefined', \"Use language configurations to determine when to autoclose quotes.\"),\n            nls.localize('editor.autoClosingQuotes.beforeWhitespace', \"Autoclose quotes only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingQuotes', \"Controls whether the editor should automatically close quotes after the user adds an opening quote.\")\n    })),\n    autoIndent: register(new EditorEnumOption(12 /* EditorOption.autoIndent */, 'autoIndent', 4 /* EditorAutoIndentStrategy.Full */, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {\n        enumDescriptions: [\n            nls.localize('editor.autoIndent.none', \"The editor will not insert indentation automatically.\"),\n            nls.localize('editor.autoIndent.keep', \"The editor will keep the current line's indentation.\"),\n            nls.localize('editor.autoIndent.brackets', \"The editor will keep the current line's indentation and honor language defined brackets.\"),\n            nls.localize('editor.autoIndent.advanced', \"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.\"),\n            nls.localize('editor.autoIndent.full', \"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.\"),\n        ],\n        description: nls.localize('autoIndent', \"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.\")\n    })),\n    automaticLayout: register(new EditorBooleanOption(13 /* EditorOption.automaticLayout */, 'automaticLayout', false)),\n    autoSurround: register(new EditorStringEnumOption(14 /* EditorOption.autoSurround */, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {\n        enumDescriptions: [\n            nls.localize('editor.autoSurround.languageDefined', \"Use language configurations to determine when to automatically surround selections.\"),\n            nls.localize('editor.autoSurround.quotes', \"Surround with quotes but not brackets.\"),\n            nls.localize('editor.autoSurround.brackets', \"Surround with brackets but not quotes.\"),\n            ''\n        ],\n        description: nls.localize('autoSurround', \"Controls whether the editor should automatically surround selections when typing quotes or brackets.\")\n    })),\n    bracketPairColorization: register(new BracketPairColorization()),\n    bracketPairGuides: register(new GuideOptions()),\n    stickyTabStops: register(new EditorBooleanOption(117 /* EditorOption.stickyTabStops */, 'stickyTabStops', false, { description: nls.localize('stickyTabStops', \"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.\") })),\n    codeLens: register(new EditorBooleanOption(17 /* EditorOption.codeLens */, 'codeLens', true, { description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\") })),\n    codeLensFontFamily: register(new EditorStringOption(18 /* EditorOption.codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localize('codeLensFontFamily', \"Controls the font family for CodeLens.\") })),\n    codeLensFontSize: register(new EditorIntOption(19 /* EditorOption.codeLensFontSize */, 'codeLensFontSize', 0, 0, 100, {\n        type: 'number',\n        default: 0,\n        minimum: 0,\n        maximum: 100,\n        markdownDescription: nls.localize('codeLensFontSize', \"Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.\")\n    })),\n    colorDecorators: register(new EditorBooleanOption(20 /* EditorOption.colorDecorators */, 'colorDecorators', true, { description: nls.localize('colorDecorators', \"Controls whether the editor should render the inline color decorators and color picker.\") })),\n    colorDecoratorActivatedOn: register(new EditorStringEnumOption(149 /* EditorOption.colorDecoratorsActivatedOn */, 'colorDecoratorsActivatedOn', 'clickAndHover', ['clickAndHover', 'hover', 'click'], {\n        enumDescriptions: [\n            nls.localize('editor.colorDecoratorActivatedOn.clickAndHover', \"Make the color picker appear both on click and hover of the color decorator\"),\n            nls.localize('editor.colorDecoratorActivatedOn.hover', \"Make the color picker appear on hover of the color decorator\"),\n            nls.localize('editor.colorDecoratorActivatedOn.click', \"Make the color picker appear on click of the color decorator\")\n        ],\n        description: nls.localize('colorDecoratorActivatedOn', \"Controls the condition to make a color picker appear from a color decorator\")\n    })),\n    colorDecoratorsLimit: register(new EditorIntOption(21 /* EditorOption.colorDecoratorsLimit */, 'colorDecoratorsLimit', 500, 1, 1000000, {\n        markdownDescription: nls.localize('colorDecoratorsLimit', \"Controls the max number of color decorators that can be rendered in an editor at once.\")\n    })),\n    columnSelection: register(new EditorBooleanOption(22 /* EditorOption.columnSelection */, 'columnSelection', false, { description: nls.localize('columnSelection', \"Enable that the selection with the mouse and keys is doing column selection.\") })),\n    comments: register(new EditorComments()),\n    contextmenu: register(new EditorBooleanOption(24 /* EditorOption.contextmenu */, 'contextmenu', true)),\n    copyWithSyntaxHighlighting: register(new EditorBooleanOption(25 /* EditorOption.copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localize('copyWithSyntaxHighlighting', \"Controls whether syntax highlighting should be copied into the clipboard.\") })),\n    cursorBlinking: register(new EditorEnumOption(26 /* EditorOption.cursorBlinking */, 'cursorBlinking', 1 /* TextEditorCursorBlinkingStyle.Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize('cursorBlinking', \"Control the cursor animation style.\") })),\n    cursorSmoothCaretAnimation: register(new EditorStringEnumOption(27 /* EditorOption.cursorSmoothCaretAnimation */, 'cursorSmoothCaretAnimation', 'off', ['off', 'explicit', 'on'], {\n        enumDescriptions: [\n            nls.localize('cursorSmoothCaretAnimation.off', \"Smooth caret animation is disabled.\"),\n            nls.localize('cursorSmoothCaretAnimation.explicit', \"Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture.\"),\n            nls.localize('cursorSmoothCaretAnimation.on', \"Smooth caret animation is always enabled.\")\n        ],\n        description: nls.localize('cursorSmoothCaretAnimation', \"Controls whether the smooth caret animation should be enabled.\")\n    })),\n    cursorStyle: register(new EditorEnumOption(28 /* EditorOption.cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize('cursorStyle', \"Controls the cursor style.\") })),\n    cursorSurroundingLines: register(new EditorIntOption(29 /* EditorOption.cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('cursorSurroundingLines', \"Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.\") })),\n    cursorSurroundingLinesStyle: register(new EditorStringEnumOption(30 /* EditorOption.cursorSurroundingLinesStyle */, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {\n        enumDescriptions: [\n            nls.localize('cursorSurroundingLinesStyle.default', \"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.\"),\n            nls.localize('cursorSurroundingLinesStyle.all', \"`cursorSurroundingLines` is enforced always.\")\n        ],\n        markdownDescription: nls.localize('cursorSurroundingLinesStyle', \"Controls when `#editor.cursorSurroundingLines#` should be enforced.\")\n    })),\n    cursorWidth: register(new EditorIntOption(31 /* EditorOption.cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localize('cursorWidth', \"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.\") })),\n    disableLayerHinting: register(new EditorBooleanOption(32 /* EditorOption.disableLayerHinting */, 'disableLayerHinting', false)),\n    disableMonospaceOptimizations: register(new EditorBooleanOption(33 /* EditorOption.disableMonospaceOptimizations */, 'disableMonospaceOptimizations', false)),\n    domReadOnly: register(new EditorBooleanOption(34 /* EditorOption.domReadOnly */, 'domReadOnly', false)),\n    dragAndDrop: register(new EditorBooleanOption(35 /* EditorOption.dragAndDrop */, 'dragAndDrop', true, { description: nls.localize('dragAndDrop', \"Controls whether the editor should allow moving selections via drag and drop.\") })),\n    emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),\n    dropIntoEditor: register(new EditorDropIntoEditor()),\n    stickyScroll: register(new EditorStickyScroll()),\n    experimentalWhitespaceRendering: register(new EditorStringEnumOption(38 /* EditorOption.experimentalWhitespaceRendering */, 'experimentalWhitespaceRendering', 'svg', ['svg', 'font', 'off'], {\n        enumDescriptions: [\n            nls.localize('experimentalWhitespaceRendering.svg', \"Use a new rendering method with svgs.\"),\n            nls.localize('experimentalWhitespaceRendering.font', \"Use a new rendering method with font characters.\"),\n            nls.localize('experimentalWhitespaceRendering.off', \"Use the stable rendering method.\"),\n        ],\n        description: nls.localize('experimentalWhitespaceRendering', \"Controls whether whitespace is rendered with a new, experimental method.\")\n    })),\n    extraEditorClassName: register(new EditorStringOption(39 /* EditorOption.extraEditorClassName */, 'extraEditorClassName', '')),\n    fastScrollSensitivity: register(new EditorFloatOption(40 /* EditorOption.fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize('fastScrollSensitivity', \"Scrolling speed multiplier when pressing `Alt`.\") })),\n    find: register(new EditorFind()),\n    fixedOverflowWidgets: register(new EditorBooleanOption(42 /* EditorOption.fixedOverflowWidgets */, 'fixedOverflowWidgets', false)),\n    folding: register(new EditorBooleanOption(43 /* EditorOption.folding */, 'folding', true, { description: nls.localize('folding', \"Controls whether the editor has code folding enabled.\") })),\n    foldingStrategy: register(new EditorStringEnumOption(44 /* EditorOption.foldingStrategy */, 'foldingStrategy', 'auto', ['auto', 'indentation'], {\n        enumDescriptions: [\n            nls.localize('foldingStrategy.auto', \"Use a language-specific folding strategy if available, else the indentation-based one.\"),\n            nls.localize('foldingStrategy.indentation', \"Use the indentation-based folding strategy.\"),\n        ],\n        description: nls.localize('foldingStrategy', \"Controls the strategy for computing folding ranges.\")\n    })),\n    foldingHighlight: register(new EditorBooleanOption(45 /* EditorOption.foldingHighlight */, 'foldingHighlight', true, { description: nls.localize('foldingHighlight', \"Controls whether the editor should highlight folded ranges.\") })),\n    foldingImportsByDefault: register(new EditorBooleanOption(46 /* EditorOption.foldingImportsByDefault */, 'foldingImportsByDefault', false, { description: nls.localize('foldingImportsByDefault', \"Controls whether the editor automatically collapses import ranges.\") })),\n    foldingMaximumRegions: register(new EditorIntOption(47 /* EditorOption.foldingMaximumRegions */, 'foldingMaximumRegions', 5000, 10, 65000, // limit must be less than foldingRanges MAX_FOLDING_REGIONS\n    { description: nls.localize('foldingMaximumRegions', \"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.\") })),\n    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(48 /* EditorOption.unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize('unfoldOnClickAfterEndOfLine', \"Controls whether clicking on the empty content after a folded line will unfold the line.\") })),\n    fontFamily: register(new EditorStringOption(49 /* EditorOption.fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize('fontFamily', \"Controls the font family.\") })),\n    fontInfo: register(new EditorFontInfo()),\n    fontLigatures2: register(new EditorFontLigatures()),\n    fontSize: register(new EditorFontSize()),\n    fontWeight: register(new EditorFontWeight()),\n    fontVariations: register(new EditorFontVariations()),\n    formatOnPaste: register(new EditorBooleanOption(55 /* EditorOption.formatOnPaste */, 'formatOnPaste', false, { description: nls.localize('formatOnPaste', \"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.\") })),\n    formatOnType: register(new EditorBooleanOption(56 /* EditorOption.formatOnType */, 'formatOnType', false, { description: nls.localize('formatOnType', \"Controls whether the editor should automatically format the line after typing.\") })),\n    glyphMargin: register(new EditorBooleanOption(57 /* EditorOption.glyphMargin */, 'glyphMargin', true, { description: nls.localize('glyphMargin', \"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.\") })),\n    gotoLocation: register(new EditorGoToLocation()),\n    hideCursorInOverviewRuler: register(new EditorBooleanOption(59 /* EditorOption.hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localize('hideCursorInOverviewRuler', \"Controls whether the cursor should be hidden in the overview ruler.\") })),\n    hover: register(new EditorHover()),\n    inDiffEditor: register(new EditorBooleanOption(61 /* EditorOption.inDiffEditor */, 'inDiffEditor', false)),\n    letterSpacing: register(new EditorFloatOption(64 /* EditorOption.letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize('letterSpacing', \"Controls the letter spacing in pixels.\") })),\n    lightbulb: register(new EditorLightbulb()),\n    lineDecorationsWidth: register(new EditorLineDecorationsWidth()),\n    lineHeight: register(new EditorLineHeight()),\n    lineNumbers: register(new EditorRenderLineNumbersOption()),\n    lineNumbersMinChars: register(new EditorIntOption(69 /* EditorOption.lineNumbersMinChars */, 'lineNumbersMinChars', 5, 1, 300)),\n    linkedEditing: register(new EditorBooleanOption(70 /* EditorOption.linkedEditing */, 'linkedEditing', false, { description: nls.localize('linkedEditing', \"Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.\") })),\n    links: register(new EditorBooleanOption(71 /* EditorOption.links */, 'links', true, { description: nls.localize('links', \"Controls whether the editor should detect links and make them clickable.\") })),\n    matchBrackets: register(new EditorStringEnumOption(72 /* EditorOption.matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize('matchBrackets', \"Highlight matching brackets.\") })),\n    minimap: register(new EditorMinimap()),\n    mouseStyle: register(new EditorStringEnumOption(74 /* EditorOption.mouseStyle */, 'mouseStyle', 'text', ['text', 'default', 'copy'])),\n    mouseWheelScrollSensitivity: register(new EditorFloatOption(75 /* EditorOption.mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize('mouseWheelScrollSensitivity', \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\") })),\n    mouseWheelZoom: register(new EditorBooleanOption(76 /* EditorOption.mouseWheelZoom */, 'mouseWheelZoom', false, {\n        markdownDescription: platform.isMacintosh\n            ? nls.localize('mouseWheelZoom.mac', \"Zoom the font of the editor when using mouse wheel and holding `Cmd`.\")\n            : nls.localize('mouseWheelZoom', \"Zoom the font of the editor when using mouse wheel and holding `Ctrl`.\")\n    })),\n    multiCursorMergeOverlapping: register(new EditorBooleanOption(77 /* EditorOption.multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localize('multiCursorMergeOverlapping', \"Merge multiple cursors when they are overlapping.\") })),\n    multiCursorModifier: register(new EditorEnumOption(78 /* EditorOption.multiCursorModifier */, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n            nls.localize('multiCursorModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n        ],\n        markdownDescription: nls.localize({\n            key: 'multiCursorModifier',\n            comment: [\n                '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n            ]\n        }, \"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).\")\n    })),\n    multiCursorPaste: register(new EditorStringEnumOption(79 /* EditorOption.multiCursorPaste */, 'multiCursorPaste', 'spread', ['spread', 'full'], {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorPaste.spread', \"Each cursor pastes a single line of the text.\"),\n            nls.localize('multiCursorPaste.full', \"Each cursor pastes the full text.\")\n        ],\n        markdownDescription: nls.localize('multiCursorPaste', \"Controls pasting when the line count of the pasted text matches the cursor count.\")\n    })),\n    multiCursorLimit: register(new EditorIntOption(80 /* EditorOption.multiCursorLimit */, 'multiCursorLimit', 10000, 1, 100000, {\n        markdownDescription: nls.localize('multiCursorLimit', \"Controls the max number of cursors that can be in an active editor at once.\")\n    })),\n    occurrencesHighlight: register(new EditorStringEnumOption(81 /* EditorOption.occurrencesHighlight */, 'occurrencesHighlight', 'singleFile', ['off', 'singleFile', 'multiFile'], {\n        markdownEnumDescriptions: [\n            nls.localize('occurrencesHighlight.off', \"Does not highlight occurrences.\"),\n            nls.localize('occurrencesHighlight.singleFile', \"Highlights occurrences only in the current file.\"),\n            nls.localize('occurrencesHighlight.multiFile', \"Experimental: Highlights occurrences across all valid open files.\")\n        ],\n        markdownDescription: nls.localize('occurrencesHighlight', \"Controls whether occurrences should be highlighted across open files.\")\n    })),\n    overviewRulerBorder: register(new EditorBooleanOption(82 /* EditorOption.overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localize('overviewRulerBorder', \"Controls whether a border should be drawn around the overview ruler.\") })),\n    overviewRulerLanes: register(new EditorIntOption(83 /* EditorOption.overviewRulerLanes */, 'overviewRulerLanes', 3, 0, 3)),\n    padding: register(new EditorPadding()),\n    pasteAs: register(new EditorPasteAs()),\n    parameterHints: register(new EditorParameterHints()),\n    peekWidgetDefaultFocus: register(new EditorStringEnumOption(87 /* EditorOption.peekWidgetDefaultFocus */, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {\n        enumDescriptions: [\n            nls.localize('peekWidgetDefaultFocus.tree', \"Focus the tree when opening peek\"),\n            nls.localize('peekWidgetDefaultFocus.editor', \"Focus the editor when opening peek\")\n        ],\n        description: nls.localize('peekWidgetDefaultFocus', \"Controls whether to focus the inline editor or the tree in the peek widget.\")\n    })),\n    placeholder: register(new PlaceholderOption()),\n    definitionLinkOpensInPeek: register(new EditorBooleanOption(89 /* EditorOption.definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localize('definitionLinkOpensInPeek', \"Controls whether the Go to Definition mouse gesture always opens the peek widget.\") })),\n    quickSuggestions: register(new EditorQuickSuggestions()),\n    quickSuggestionsDelay: register(new EditorIntOption(91 /* EditorOption.quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('quickSuggestionsDelay', \"Controls the delay in milliseconds after which quick suggestions will show up.\") })),\n    readOnly: register(new EditorBooleanOption(92 /* EditorOption.readOnly */, 'readOnly', false)),\n    readOnlyMessage: register(new ReadonlyMessage()),\n    renameOnType: register(new EditorBooleanOption(94 /* EditorOption.renameOnType */, 'renameOnType', false, { description: nls.localize('renameOnType', \"Controls whether the editor auto renames on type.\"), markdownDeprecationMessage: nls.localize('renameOnTypeDeprecate', \"Deprecated, use `editor.linkedEditing` instead.\") })),\n    renderControlCharacters: register(new EditorBooleanOption(95 /* EditorOption.renderControlCharacters */, 'renderControlCharacters', true, { description: nls.localize('renderControlCharacters', \"Controls whether the editor should render control characters.\"), restricted: true })),\n    renderFinalNewline: register(new EditorStringEnumOption(96 /* EditorOption.renderFinalNewline */, 'renderFinalNewline', (platform.isLinux ? 'dimmed' : 'on'), ['off', 'on', 'dimmed'], { description: nls.localize('renderFinalNewline', \"Render last line number when the file ends with a newline.\") })),\n    renderLineHighlight: register(new EditorStringEnumOption(97 /* EditorOption.renderLineHighlight */, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {\n        enumDescriptions: [\n            '',\n            '',\n            '',\n            nls.localize('renderLineHighlight.all', \"Highlights both the gutter and the current line.\"),\n        ],\n        description: nls.localize('renderLineHighlight', \"Controls how the editor should render the current line highlight.\")\n    })),\n    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(98 /* EditorOption.renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize('renderLineHighlightOnlyWhenFocus', \"Controls if the editor should render the current line highlight only when the editor is focused.\") })),\n    renderValidationDecorations: register(new EditorStringEnumOption(99 /* EditorOption.renderValidationDecorations */, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),\n    renderWhitespace: register(new EditorStringEnumOption(100 /* EditorOption.renderWhitespace */, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {\n        enumDescriptions: [\n            '',\n            nls.localize('renderWhitespace.boundary', \"Render whitespace characters except for single spaces between words.\"),\n            nls.localize('renderWhitespace.selection', \"Render whitespace characters only on selected text.\"),\n            nls.localize('renderWhitespace.trailing', \"Render only trailing whitespace characters.\"),\n            ''\n        ],\n        description: nls.localize('renderWhitespace', \"Controls how the editor should render whitespace characters.\")\n    })),\n    revealHorizontalRightPadding: register(new EditorIntOption(101 /* EditorOption.revealHorizontalRightPadding */, 'revealHorizontalRightPadding', 15, 0, 1000)),\n    roundedSelection: register(new EditorBooleanOption(102 /* EditorOption.roundedSelection */, 'roundedSelection', true, { description: nls.localize('roundedSelection', \"Controls whether selections should have rounded corners.\") })),\n    rulers: register(new EditorRulers()),\n    scrollbar: register(new EditorScrollbar()),\n    scrollBeyondLastColumn: register(new EditorIntOption(105 /* EditorOption.scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 4, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('scrollBeyondLastColumn', \"Controls the number of extra characters beyond which the editor will scroll horizontally.\") })),\n    scrollBeyondLastLine: register(new EditorBooleanOption(106 /* EditorOption.scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localize('scrollBeyondLastLine', \"Controls whether the editor will scroll beyond the last line.\") })),\n    scrollPredominantAxis: register(new EditorBooleanOption(107 /* EditorOption.scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localize('scrollPredominantAxis', \"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.\") })),\n    selectionClipboard: register(new EditorBooleanOption(108 /* EditorOption.selectionClipboard */, 'selectionClipboard', true, {\n        description: nls.localize('selectionClipboard', \"Controls whether the Linux primary clipboard should be supported.\"),\n        included: platform.isLinux\n    })),\n    selectionHighlight: register(new EditorBooleanOption(109 /* EditorOption.selectionHighlight */, 'selectionHighlight', true, { description: nls.localize('selectionHighlight', \"Controls whether the editor should highlight matches similar to the selection.\") })),\n    selectOnLineNumbers: register(new EditorBooleanOption(110 /* EditorOption.selectOnLineNumbers */, 'selectOnLineNumbers', true)),\n    showFoldingControls: register(new EditorStringEnumOption(111 /* EditorOption.showFoldingControls */, 'showFoldingControls', 'mouseover', ['always', 'never', 'mouseover'], {\n        enumDescriptions: [\n            nls.localize('showFoldingControls.always', \"Always show the folding controls.\"),\n            nls.localize('showFoldingControls.never', \"Never show the folding controls and reduce the gutter size.\"),\n            nls.localize('showFoldingControls.mouseover', \"Only show the folding controls when the mouse is over the gutter.\"),\n        ],\n        description: nls.localize('showFoldingControls', \"Controls when the folding controls on the gutter are shown.\")\n    })),\n    showUnused: register(new EditorBooleanOption(112 /* EditorOption.showUnused */, 'showUnused', true, { description: nls.localize('showUnused', \"Controls fading out of unused code.\") })),\n    showDeprecated: register(new EditorBooleanOption(141 /* EditorOption.showDeprecated */, 'showDeprecated', true, { description: nls.localize('showDeprecated', \"Controls strikethrough deprecated variables.\") })),\n    inlayHints: register(new EditorInlayHints()),\n    snippetSuggestions: register(new EditorStringEnumOption(113 /* EditorOption.snippetSuggestions */, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {\n        enumDescriptions: [\n            nls.localize('snippetSuggestions.top', \"Show snippet suggestions on top of other suggestions.\"),\n            nls.localize('snippetSuggestions.bottom', \"Show snippet suggestions below other suggestions.\"),\n            nls.localize('snippetSuggestions.inline', \"Show snippets suggestions with other suggestions.\"),\n            nls.localize('snippetSuggestions.none', \"Do not show snippet suggestions.\"),\n        ],\n        description: nls.localize('snippetSuggestions', \"Controls whether snippets are shown with other suggestions and how they are sorted.\")\n    })),\n    smartSelect: register(new SmartSelect()),\n    smoothScrolling: register(new EditorBooleanOption(115 /* EditorOption.smoothScrolling */, 'smoothScrolling', false, { description: nls.localize('smoothScrolling', \"Controls whether the editor will scroll using an animation.\") })),\n    stopRenderingLineAfter: register(new EditorIntOption(118 /* EditorOption.stopRenderingLineAfter */, 'stopRenderingLineAfter', 10000, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    suggest: register(new EditorSuggest()),\n    inlineSuggest: register(new InlineEditorSuggest()),\n    inlineEdit: register(new InlineEditorEdit()),\n    inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(150 /* EditorOption.inlineCompletionsAccessibilityVerbose */, 'inlineCompletionsAccessibilityVerbose', false, { description: nls.localize('inlineCompletionsAccessibilityVerbose', \"Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.\") })),\n    suggestFontSize: register(new EditorIntOption(120 /* EditorOption.suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize('suggestFontSize', \"Font size for the suggest widget. When set to {0}, the value of {1} is used.\", '`0`', '`#editor.fontSize#`') })),\n    suggestLineHeight: register(new EditorIntOption(121 /* EditorOption.suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize('suggestLineHeight', \"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.\", '`0`', '`#editor.lineHeight#`') })),\n    suggestOnTriggerCharacters: register(new EditorBooleanOption(122 /* EditorOption.suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localize('suggestOnTriggerCharacters', \"Controls whether suggestions should automatically show up when typing trigger characters.\") })),\n    suggestSelection: register(new EditorStringEnumOption(123 /* EditorOption.suggestSelection */, 'suggestSelection', 'first', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {\n        markdownEnumDescriptions: [\n            nls.localize('suggestSelection.first', \"Always select the first suggestion.\"),\n            nls.localize('suggestSelection.recentlyUsed', \"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.\"),\n            nls.localize('suggestSelection.recentlyUsedByPrefix', \"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.\"),\n        ],\n        description: nls.localize('suggestSelection', \"Controls how suggestions are pre-selected when showing the suggest list.\")\n    })),\n    tabCompletion: register(new EditorStringEnumOption(124 /* EditorOption.tabCompletion */, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {\n        enumDescriptions: [\n            nls.localize('tabCompletion.on', \"Tab complete will insert the best matching suggestion when pressing tab.\"),\n            nls.localize('tabCompletion.off', \"Disable tab completions.\"),\n            nls.localize('tabCompletion.onlySnippets', \"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.\"),\n        ],\n        description: nls.localize('tabCompletion', \"Enables tab completions.\")\n    })),\n    tabIndex: register(new EditorIntOption(125 /* EditorOption.tabIndex */, 'tabIndex', 0, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    unicodeHighlight: register(new UnicodeHighlight()),\n    unusualLineTerminators: register(new EditorStringEnumOption(127 /* EditorOption.unusualLineTerminators */, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {\n        enumDescriptions: [\n            nls.localize('unusualLineTerminators.auto', \"Unusual line terminators are automatically removed.\"),\n            nls.localize('unusualLineTerminators.off', \"Unusual line terminators are ignored.\"),\n            nls.localize('unusualLineTerminators.prompt', \"Unusual line terminators prompt to be removed.\"),\n        ],\n        description: nls.localize('unusualLineTerminators', \"Remove unusual line terminators that might cause problems.\")\n    })),\n    useShadowDOM: register(new EditorBooleanOption(128 /* EditorOption.useShadowDOM */, 'useShadowDOM', true)),\n    useTabStops: register(new EditorBooleanOption(129 /* EditorOption.useTabStops */, 'useTabStops', true, { description: nls.localize('useTabStops', \"Spaces and tabs are inserted and deleted in alignment with tab stops.\") })),\n    wordBreak: register(new EditorStringEnumOption(130 /* EditorOption.wordBreak */, 'wordBreak', 'normal', ['normal', 'keepAll'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordBreak.normal', \"Use the default line break rule.\"),\n            nls.localize('wordBreak.keepAll', \"Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.\"),\n        ],\n        description: nls.localize('wordBreak', \"Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.\")\n    })),\n    wordSegmenterLocales: register(new WordSegmenterLocales()),\n    wordSeparators: register(new EditorStringOption(132 /* EditorOption.wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localize('wordSeparators', \"Characters that will be used as word separators when doing word related navigations or operations.\") })),\n    wordWrap: register(new EditorStringEnumOption(133 /* EditorOption.wordWrap */, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n            nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n            nls.localize({\n                key: 'wordWrap.wordWrapColumn',\n                comment: [\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at `#editor.wordWrapColumn#`.\"),\n            nls.localize({\n                key: 'wordWrap.bounded',\n                comment: [\n                    '- viewport means the edge of the visible window size.',\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.\"),\n        ],\n        description: nls.localize({\n            key: 'wordWrap',\n            comment: [\n                '- \\'off\\', \\'on\\', \\'wordWrapColumn\\' and \\'bounded\\' refer to values the setting can take and should not be localized.',\n                '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n            ]\n        }, \"Controls how lines should wrap.\")\n    })),\n    wordWrapBreakAfterCharacters: register(new EditorStringOption(134 /* EditorOption.wordWrapBreakAfterCharacters */, 'wordWrapBreakAfterCharacters', \n    // allow-any-unicode-next-line\n    ' \\t})]?|/&.,;')),\n    wordWrapBreakBeforeCharacters: register(new EditorStringOption(135 /* EditorOption.wordWrapBreakBeforeCharacters */, 'wordWrapBreakBeforeCharacters', \n    // allow-any-unicode-next-line\n    '([{+')),\n    wordWrapColumn: register(new EditorIntOption(136 /* EditorOption.wordWrapColumn */, 'wordWrapColumn', 80, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        markdownDescription: nls.localize({\n            key: 'wordWrapColumn',\n            comment: [\n                '- `editor.wordWrap` refers to a different setting and should not be localized.',\n                '- \\'wordWrapColumn\\' and \\'bounded\\' refer to values the different setting can take and should not be localized.'\n            ]\n        }, \"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.\")\n    })),\n    wordWrapOverride1: register(new EditorStringEnumOption(137 /* EditorOption.wordWrapOverride1 */, 'wordWrapOverride1', 'inherit', ['off', 'on', 'inherit'])),\n    wordWrapOverride2: register(new EditorStringEnumOption(138 /* EditorOption.wordWrapOverride2 */, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),\n    // Leave these at the end (because they have dependencies!)\n    editorClassName: register(new EditorClassName()),\n    defaultColorDecorators: register(new EditorBooleanOption(148 /* EditorOption.defaultColorDecorators */, 'defaultColorDecorators', false, { markdownDescription: nls.localize('defaultColorDecorators', \"Controls whether inline color decorations should be shown using the default document color provider\") })),\n    pixelRatio: register(new EditorPixelRatio()),\n    tabFocusMode: register(new EditorBooleanOption(145 /* EditorOption.tabFocusMode */, 'tabFocusMode', false, { markdownDescription: nls.localize('tabFocusMode', \"Controls whether the editor receives tabs or defers them to the workbench for navigation.\") })),\n    layoutInfo: register(new EditorLayoutInfoComputer()),\n    wrappingInfo: register(new EditorWrappingInfoComputer()),\n    wrappingIndent: register(new WrappingIndentOption()),\n    wrappingStrategy: register(new WrappingStrategy())\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nexport class NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CodeExpectedError';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'CodeExpectedError';\n    }\n}\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n}\n","import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd?.();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Given an event, returns another event which only fires once, and only when the condition is met.\n     *\n     * @param event The event source for the new event.\n     */\n    function onceIf(event, condition) {\n        return Event.once(Event.filter(event, condition));\n    }\n    Event.onceIf = onceIf;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener?.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire?.();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer?.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    /**\n     * A convenience function for forwarding an event to another emitter which\n     * improves readability.\n     *\n     * This is similar to {@link Relay} but allows instantiating and forwarding\n     * on a single line and also allows for multiple source events.\n     * @param from The event to forward.\n     * @param to The emitter to forward the event to.\n     * @example\n     * Event.forward(event, emitter);\n     * // equivalent to\n     * event(e => emitter.fire(e));\n     * // equivalent to\n     * event(emitter.fire, emitter);\n     */\n    function forward(from, to) {\n        return from(e => to.fire(e));\n    }\n    Event.forward = forward;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                    // Communicate to the observable that we received its current value and would like to be notified about future changes.\n                    this._observable.reportChanges();\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n    static { this.all = new Set(); }\n    static { this._idPool = 0; }\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    static { this._idPool = 1; }\n    constructor(_errorHandler, threshold, name = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')) {\n        this._errorHandler = _errorHandler;\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        this._stacks?.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            const [topStack, topCount] = this.getMostFrequentStack();\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n            console.warn(message);\n            console.warn(topStack);\n            const error = new ListenerLeakError(message, topStack);\n            this._errorHandler(error);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n    getMostFrequentStack() {\n        if (!this._stacks) {\n            return undefined;\n        }\n        let topStack;\n        let topCount = 0;\n        for (const [stack, count] of this._stacks) {\n            if (!topStack || topCount < count) {\n                topStack = [stack, count];\n                topCount = count;\n            }\n        }\n        return topStack;\n    }\n}\nclass Stacktrace {\n    static create() {\n        const err = new Error();\n        return new Stacktrace(err.stack ?? '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerLeakError';\n        this.stack = stack;\n    }\n}\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerRefusalError';\n        this.stack = stack;\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nlet _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n    const leaks = [];\n    setInterval(() => {\n        if (leaks.length === 0) {\n            return;\n        }\n        console.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n        console.warn(leaks.join('\\n'));\n        leaks.length = 0;\n    }, 3000);\n    _listenerFinalizers = new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            leaks.push(heldValue);\n        }\n    });\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n            ? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n            undefined;\n        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = this._options?.deliveryQueue;\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._deliveryQueue?.current === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => l.stack?.print());\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            this._options?.onDidRemoveLastListener?.();\n            this._leakageMon?.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        this._event ??= (callback, thisArgs, disposables) => {\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n                console.warn(message);\n                const tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n                const errorHandler = this._options?.onListenerError || onUnexpectedError;\n                errorHandler(error);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack ?? Stacktrace.create();\n            }\n            if (!this._listeners) {\n                this._options?.onWillAddFirstListener?.(this);\n                this._listeners = contained;\n                this._options?.onDidAddFirstListener?.(this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => {\n                _listenerFinalizers?.unregister(result);\n                removeMonitor?.();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2, 3).join('\\n').trim();\n                const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n                _listenerFinalizers.register(result, match?.[2] ?? stack, result);\n            }\n            return result;\n        };\n        return this._event;\n    }\n    _removeListener(listener) {\n        this._options?.onWillRemoveListener?.(this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            this._options?.onDidRemoveLastListener?.(this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        if (!listener) {\n            return;\n        }\n        const errorHandler = this._options?.onListenerError || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._deliveryQueue?.current) {\n            this._deliverQueue(this._deliveryQueue);\n            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        this._perfMon?.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        this._perfMon?.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options?.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        super(options);\n        this._delay = options.delay ?? 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options?.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        e.listener?.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n        for (const e of this.events) {\n            e.listener?.dispose();\n        }\n        this.events = [];\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.data = [];\n    }\n    wrapEvent(event, reduce, initial) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const data = this.data[this.data.length - 1];\n                // Non-reduce scenario\n                if (!reduce) {\n                    // Buffering case\n                    if (data) {\n                        data.buffers.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        // Not buffering case\n                        listener.call(thisArgs, i);\n                    }\n                    return;\n                }\n                // Reduce scenario\n                const reduceData = data;\n                // Not buffering case\n                if (!reduceData) {\n                    // TODO: Is there a way to cache this reduce call for all listeners?\n                    listener.call(thisArgs, reduce(initial, i));\n                    return;\n                }\n                // Buffering case\n                reduceData.items ??= [];\n                reduceData.items.push(i);\n                if (reduceData.buffers.length === 0) {\n                    // Include a single buffered function that will reduce all events when we're done buffering events\n                    data.buffers.push(() => {\n                        // cache the reduced result so that the value can be shared across all listeners\n                        reduceData.reducedResult ??= initial\n                            ? reduceData.items.reduce(reduce, initial)\n                            : reduceData.items.reduce(reduce);\n                        listener.call(thisArgs, reduceData.reducedResult);\n                    });\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const data = { buffers: new Array() };\n        this.data.push(data);\n        const r = fn();\n        this.data.pop();\n        data.buffers.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n","/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */\n\nconst {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor\n} = Object;\nlet {\n  freeze,\n  seal,\n  create\n} = Object; // eslint-disable-line import/no-mutable-exports\nlet {\n  apply,\n  construct\n} = typeof Reflect !== 'undefined' && Reflect;\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new Func(...args);\n  };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param {Function} func - The function to be wrapped and called.\n * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return apply(func, thisArg, args);\n  };\n}\n\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param {Function} func - The constructor function to be wrapped and called.\n * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return construct(func, args);\n  };\n}\n\n/**\n * Add properties to a lookup table\n *\n * @param {Object} set - The set to which elements will be added.\n * @param {Array} array - The array containing elements to be added to the set.\n * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns {Object} The modified set with added elements.\n */\nfunction addToSet(set, array) {\n  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n        element = lcElement;\n      }\n    }\n    set[element] = true;\n  }\n  return set;\n}\n\n/**\n * Clean up an array to harden against CSPP\n *\n * @param {Array} array - The array to be cleaned.\n * @returns {Array} The cleaned version of the array\n */\nfunction cleanArray(array) {\n  for (let index = 0; index < array.length; index++) {\n    const isPropertyExist = objectHasOwnProperty(array, index);\n    if (!isPropertyExist) {\n      array[index] = null;\n    }\n  }\n  return array;\n}\n\n/**\n * Shallow clone an object\n *\n * @param {Object} object - The object to be cloned.\n * @returns {Object} A new object that copies the original.\n */\nfunction clone(object) {\n  const newObject = create(null);\n  for (const [property, value] of entries(object)) {\n    const isPropertyExist = objectHasOwnProperty(object, property);\n    if (isPropertyExist) {\n      if (Array.isArray(value)) {\n        newObject[property] = cleanArray(value);\n      } else if (value && typeof value === 'object' && value.constructor === Object) {\n        newObject[property] = clone(value);\n      } else {\n        newObject[property] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param {Object} object - The object to look up the getter function in its prototype chain.\n * @param {String} prop - The property name for which to find the getter function.\n * @returns {Function} The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n    object = getPrototypeOf(object);\n  }\n  function fallbackValue() {\n    return null;\n  }\n  return fallbackValue;\n}\n\nconst html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nconst svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\nconst svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\nconst mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\nconst text = freeze(['#text']);\n\nconst html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\nconst svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\nconst mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\nconst xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n\nvar EXPRESSIONS = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MUSTACHE_EXPR: MUSTACHE_EXPR,\n  ERB_EXPR: ERB_EXPR,\n  TMPLIT_EXPR: TMPLIT_EXPR,\n  DATA_ATTR: DATA_ATTR,\n  ARIA_ATTR: ARIA_ATTR,\n  IS_ALLOWED_URI: IS_ALLOWED_URI,\n  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n  ATTR_WHITESPACE: ATTR_WHITESPACE,\n  DOCTYPE_NAME: DOCTYPE_NAME,\n  CUSTOM_ELEMENT: CUSTOM_ELEMENT\n});\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n  element: 1,\n  attribute: 2,\n  text: 3,\n  cdataSection: 4,\n  entityReference: 5,\n  // Deprecated\n  entityNode: 6,\n  // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9,\n  documentType: 10,\n  documentFragment: 11,\n  notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return {TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\nfunction createDOMPurify() {\n  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n  const DOMPurify = root => createDOMPurify(root);\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '3.1.7';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n    return DOMPurify;\n  }\n  let {\n    document\n  } = window;\n  const originalDocument = document;\n  const currentScript = originalDocument.currentScript;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes\n  } = window;\n  const ElementPrototype = Element.prototype;\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const remove = lookupGetter(ElementPrototype, 'remove');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName\n  } = document;\n  const {\n    importNode\n  } = originalDocument;\n  let hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n    CUSTOM_ELEMENT\n  } = EXPRESSIONS;\n  let {\n    IS_ALLOWED_URI: IS_ALLOWED_URI$1\n  } = EXPRESSIONS;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n\n  /*\n   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n    tagNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    attributeNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    allowCustomizedBuiltInElements: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: false\n    }\n  }));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */\n  let SAFE_FOR_XML = true;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (7.3.3)\n   *   - DOM Tree Accessors (3.1.5)\n   *   - Form Element Parent-Child Relations (4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)\n   *   - HTMLCollection (4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc = null;\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n  const isRegexOrFunction = function isRegexOrFunction(testValue) {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function _parseConfig() {\n    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n    PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n      // eslint-disable-line indent\n      cfg.ADD_URI_SAFE_ATTR,\n      // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n    ) // eslint-disable-line indent\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS),\n      // eslint-disable-line indent\n      cfg.ADD_DATA_URI_TAGS,\n      // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n    ) // eslint-disable-line indent\n      : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, text);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$1);\n        addToSet(ALLOWED_ATTR, html);\n      }\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg$1);\n        addToSet(ALLOWED_ATTR, svg);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl$1);\n        addToSet(ALLOWED_ATTR, mathMl);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n    }\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n    }\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n      }\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n      }\n\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n      }\n\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n    CONFIG = cfg;\n  };\n  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n  const HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n\n  /**\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function _checkValidNamespace(element) {\n    let parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template'\n      };\n    }\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // For XHTML and XML documents that support custom namespaces\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return true;\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  const _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, {\n      element: node\n    });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      getParentNode(node).removeChild(node);\n    } catch (_) {\n      remove(node);\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  const _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) { }\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) { }\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  const _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n    }\n    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) { }\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n    const body = doc.body || doc.documentElement;\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param  {Node} root The root element or node to start traversing on.\n   * @return {NodeIterator} The created NodeIterator\n   */\n  const _createNodeIterator = function _createNodeIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  const _isClobbered = function _isClobbered(elm) {\n    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n  };\n\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param  {Node} object object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  const _isNode = function _isNode(object) {\n    return typeof Node === 'function' && object instanceof Node;\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n    arrayForEach(hooks[entryPoint], hook => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function _sanitizeElements(currentNode) {\n    let content = null;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any occurrence of processing instructions */\n    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any kind of possibly harmful comments */\n    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n          return false;\n        }\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n          return false;\n        }\n      }\n\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n          for (let i = childCount - 1; i >= 0; --i) {\n            const childClone = cloneNode(childNodes[i], true);\n            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n          }\n        }\n      }\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n        content = stringReplace(content, expr, ' ');\n      });\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, {\n          element: currentNode.cloneNode()\n        });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)); else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)); else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))); else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]); else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))); else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]); else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))); else if (value) {\n      return false;\n    } else;\n    return true;\n  };\n\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param {string} tagName name of the tag of the node to sanitize\n   * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n    const {\n      attributes\n    } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes) {\n      return;\n    }\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    let l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const {\n        name,\n        namespaceURI,\n        value: attrValue\n      } = attr;\n      const lcName = transformCaseFunc(name);\n      let value = name === 'value' ? attrValue : stringTrim(attrValue);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n\n      /* Work around a security issue with comments inside attributes */\n      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Handle attributes that require Trusted Types */\n      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n        if (namespaceURI); else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML':\n              {\n                value = trustedTypesPolicy.createHTML(value);\n                break;\n              }\n            case 'TrustedScriptURL':\n              {\n                value = trustedTypesPolicy.createScriptURL(value);\n                break;\n              }\n          }\n        }\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n        } else {\n          arrayPop(DOMPurify.removed);\n        }\n      } catch (_) { }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} cfg object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty) {\n    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if (dirty.nodeName) {\n        const tagName = transformCaseFunc(dirty.nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n    }\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n      return returnNode;\n    }\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Serialize doctype if allowed */\n    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function () {\n    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {String} tag Tag name of containing element.\n   * @param  {String} attr Attribute name.\n   * @param  {String} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   * @return {Function} removed(popped) hook\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      return arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n  return DOMPurify;\n}\nvar purify = createDOMPurify();\n\n// ESM-comment-begin\n// define(function () { return purify; });\n// ESM-comment-end\n\n// ESM-uncomment-begin\nexport default purify;\nexport const version = purify.version;\nexport const isSupported = purify.isSupported;\nexport const sanitize = purify.sanitize;\nexport const setConfig = purify.setConfig;\nexport const clearConfig = purify.clearConfig;\nexport const isValidAttribute = purify.isValidAttribute;\nexport const addHook = purify.addHook;\nexport const removeHook = purify.removeHook;\nexport const removeHooks = purify.removeHooks;\nexport const removeAllHooks = purify.removeAllHooks;\n// ESM-uncomment-end\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n    // Note: this doesn't produce an exact syntax tree but a normalized one\n    // ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n    static { this._parseError = new Error(); }\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n        this._scanner = new Scanner();\n        // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n        this._tokens = [];\n        this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    /**\n     * Parse a context key expression.\n     *\n     * @param input the expression to parse\n     * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n     */\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 /* TokenType.Or */)) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 /* TokenType.And */)) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n    }\n    _term() {\n        if (this._matchOne(2 /* TokenType.Neg */)) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 /* TokenType.True */:\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 /* TokenType.False */:\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 /* TokenType.LParen */: {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                    return expr?.negate();\n                }\n                case 17 /* TokenType.Str */:\n                    this._advance();\n                    return ContextKeyNotExpr.create(peek.lexeme);\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 /* TokenType.True */:\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 /* TokenType.False */:\n                this._advance();\n                return ContextKeyExpr.false();\n            case 0 /* TokenType.LParen */: {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                return expr;\n            }\n            case 17 /* TokenType.Str */: {\n                // KEY\n                const key = peek.lexeme;\n                this._advance();\n                // =~ regex\n                if (this._matchOne(9 /* TokenType.RegexOp */)) {\n                    // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 /* TokenType.RegexStr */) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 /* TokenType.RegexStr */:\n                        case 19 /* TokenType.Error */: { // also handle an ErrorToken in case of smth such as /(/file)/\n                            const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                                switch (followingToken.type) {\n                                    case 0 /* TokenType.LParen */:\n                                        parenBalance++;\n                                        break;\n                                    case 1 /* TokenType.RParen */:\n                                        parenBalance--;\n                                        break;\n                                    case 10 /* TokenType.RegexStr */:\n                                    case 18 /* TokenType.QuotedStr */:\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return ContextKeyExpr.regex(key, regexp);\n                        }\n                        case 18 /* TokenType.QuotedStr */: {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            // replicate old regex parsing behavior\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = new RegExp(value, caseIgnoreFlag);\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                // [ 'not' 'in' value ]\n                if (this._matchOne(14 /* TokenType.Not */)) {\n                    this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 /* TokenType.Eq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                            return ContextKeyExpr.equals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.has(key);\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return ContextKeyExpr.equals(key, right);\n                        }\n                    }\n                    case 4 /* TokenType.NotEq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // same as above with \"foo != 'true'\"\n                            return ContextKeyExpr.notEquals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return ContextKeyExpr.has(key);\n                            default:\n                                return ContextKeyExpr.notEquals(key, right);\n                        }\n                    }\n                    // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n                    // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n                    case 5 /* TokenType.Lt */:\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 /* TokenType.LtEq */:\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 /* TokenType.Gt */:\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 /* TokenType.GtEq */:\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 /* TokenType.In */:\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return ContextKeyExpr.has(key);\n                }\n            }\n            case 20 /* TokenType.EOF */:\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 /* TokenType.Str */:\n            case 18 /* TokenType.QuotedStr */:\n                this._advance();\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                this._advance();\n                return 'true';\n            case 12 /* TokenType.False */:\n                this._advance();\n                return 'false';\n            case 13 /* TokenType.In */: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n                this._advance();\n                return 'in';\n            default:\n                // this allows \"when\": \"foo == \" which's used by existing extensions\n                // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    // careful: this can throw if current token is the initial one (ie index = 0)\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 /* TokenType.EOF */;\n    }\n}\nexport class ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static { this._parser = new Parser({ regexParsingWithErrorRecovery: false }); }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    static { this.INSTANCE = new ContextKeyFalseExpr(); }\n    constructor() {\n        this.type = 0 /* ContextKeyExprType.False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nexport class ContextKeyTrueExpr {\n    static { this.INSTANCE = new ContextKeyTrueExpr(); }\n    constructor() {\n        this.type = 1 /* ContextKeyExprType.True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nexport class ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* ContextKeyExprType.Defined */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* ContextKeyExprType.Equals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* ContextKeyExprType.In */;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyNotInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 /* ContextKeyExprType.NotIn */;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return this._negated.keys();\n    }\n    negate() {\n        return this._negated;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* ContextKeyExprType.NotEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* ContextKeyExprType.Not */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* ContextKeyExprType.Greater */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* ContextKeyExprType.Smaller */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* ContextKeyExprType.Regex */;\n        this.negated = null;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* ContextKeyExprType.NotRegex */;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nexport class ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* ContextKeyExprType.And */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* ContextKeyExprType.True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* ContextKeyExprType.False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* ContextKeyExprType.And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve false AND expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A && !A case\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* ContextKeyExprType.Or */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* ContextKeyExprType.False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* ContextKeyExprType.True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* ContextKeyExprType.Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve true OR expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A || !A case\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    static { this._info = []; }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nexport const IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n        // false implies anything\n        // anything implies true\n        return true;\n    }\n    if (p.type === 9 /* ContextKeyExprType.Or */) {\n        if (q.type === 9 /* ContextKeyExprType.Or */) {\n            // `a || b || c` can only imply something like `a || b || c || d`\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 /* ContextKeyExprType.And */) {\n        if (q.type === 6 /* ContextKeyExprType.And */) {\n            // `a && b && c` implies `a && c`\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            // an element from `p` is missing from `q`\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* ContextKeyExprType.Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n    static { this.zero = new TextLength(0, 0); }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\n","import { OffsetRange } from './offsetRange.js';\nimport { TextLength } from './textLength.js';\nexport class PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 0 /* UndoRedoElementType.Resource */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this.resourceLabels = [this.resourceLabel];\n        this.strResources = [this.strResource];\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.isValid = true;\n    }\n    setValid(isValid) {\n        this.isValid = isValid;\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceReasonPair {\n    constructor(resourceLabel, reason) {\n        this.resourceLabel = resourceLabel;\n        this.reason = reason;\n    }\n}\nclass RemovedResources {\n    constructor() {\n        this.elements = new Map();\n    }\n    createMessage() {\n        const externalRemoval = [];\n        const noParallelUniverses = [];\n        for (const [, element] of this.elements) {\n            const dest = (element.reason === 0 /* RemovedResourceReason.ExternalRemoval */\n                ? externalRemoval\n                : noParallelUniverses);\n            dest.push(element.resourceLabel);\n        }\n        const messages = [];\n        if (externalRemoval.length > 0) {\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n        }\n        if (noParallelUniverses.length > 0) {\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n        }\n        return messages.join('\\n');\n    }\n    get size() {\n        return this.elements.size;\n    }\n    has(strResource) {\n        return this.elements.has(strResource);\n    }\n    set(strResource, value) {\n        this.elements.set(strResource, value);\n    }\n    delete(strResource) {\n        return this.elements.delete(strResource);\n    }\n}\nclass WorkspaceStackElement {\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabels = resourceLabels;\n        this.strResources = strResources;\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.removedResources = null;\n        this.invalidatedResources = null;\n    }\n    canSplit() {\n        return (typeof this.actual.split === 'function');\n    }\n    removeResource(resourceLabel, strResource, reason) {\n        if (!this.removedResources) {\n            this.removedResources = new RemovedResources();\n        }\n        if (!this.removedResources.has(strResource)) {\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n        }\n    }\n    setValid(resourceLabel, strResource, isValid) {\n        if (isValid) {\n            if (this.invalidatedResources) {\n                this.invalidatedResources.delete(strResource);\n                if (this.invalidatedResources.size === 0) {\n                    this.invalidatedResources = null;\n                }\n            }\n        }\n        else {\n            if (!this.invalidatedResources) {\n                this.invalidatedResources = new RemovedResources();\n            }\n            if (!this.invalidatedResources.has(strResource)) {\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n            }\n        }\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceEditStack {\n    constructor(resourceLabel, strResource) {\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this._past = [];\n        this._future = [];\n        this.locked = false;\n        this.versionId = 1;\n    }\n    dispose() {\n        for (const element of this._past) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        for (const element of this._future) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        this.versionId++;\n    }\n    toString() {\n        const result = [];\n        result.push(`* ${this.strResource}:`);\n        for (let i = 0; i < this._past.length; i++) {\n            result.push(`   * [UNDO] ${this._past[i]}`);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            result.push(`   * [REDO] ${this._future[i]}`);\n        }\n        return result.join('\\n');\n    }\n    flushAllElements() {\n        this._past = [];\n        this._future = [];\n        this.versionId++;\n    }\n    _setElementValidFlag(element, isValid) {\n        if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n            element.setValid(this.resourceLabel, this.strResource, isValid);\n        }\n        else {\n            element.setValid(isValid);\n        }\n    }\n    setElementsValidFlag(isValid, filter) {\n        for (const element of this._past) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n        for (const element of this._future) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n    }\n    pushElement(element) {\n        // remove the future\n        for (const futureElement of this._future) {\n            if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n            }\n        }\n        this._future = [];\n        this._past.push(element);\n        this.versionId++;\n    }\n    createSnapshot(resource) {\n        const elements = [];\n        for (let i = 0, len = this._past.length; i < len; i++) {\n            elements.push(this._past[i].id);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            elements.push(this._future[i].id);\n        }\n        return new ResourceEditStackSnapshot(resource, elements);\n    }\n    restoreSnapshot(snapshot) {\n        const snapshotLength = snapshot.elements.length;\n        let isOK = true;\n        let snapshotIndex = 0;\n        let removePastAfter = -1;\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n            const element = this._past[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removePastAfter = 0;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        let removeFutureBefore = -1;\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n            const element = this._future[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removeFutureBefore = i;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        if (removePastAfter !== -1) {\n            this._past = this._past.slice(0, removePastAfter);\n        }\n        if (removeFutureBefore !== -1) {\n            this._future = this._future.slice(removeFutureBefore + 1);\n        }\n        this.versionId++;\n    }\n    getElements() {\n        const past = [];\n        const future = [];\n        for (const element of this._past) {\n            past.push(element.actual);\n        }\n        for (const element of this._future) {\n            future.push(element.actual);\n        }\n        return { past, future };\n    }\n    getClosestPastElement() {\n        if (this._past.length === 0) {\n            return null;\n        }\n        return this._past[this._past.length - 1];\n    }\n    getSecondClosestPastElement() {\n        if (this._past.length < 2) {\n            return null;\n        }\n        return this._past[this._past.length - 2];\n    }\n    getClosestFutureElement() {\n        if (this._future.length === 0) {\n            return null;\n        }\n        return this._future[this._future.length - 1];\n    }\n    hasPastElements() {\n        return (this._past.length > 0);\n    }\n    hasFutureElements() {\n        return (this._future.length > 0);\n    }\n    splitPastWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._past.length - 1; j >= 0; j--) {\n            if (this._past[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._past[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._past.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    splitFutureWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._future.length - 1; j >= 0; j--) {\n            if (this._future[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._future[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._future.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    moveBackward(element) {\n        this._past.pop();\n        this._future.push(element);\n        this.versionId++;\n    }\n    moveForward(element) {\n        this._future.pop();\n        this._past.push(element);\n        this.versionId++;\n    }\n}\nclass EditStackSnapshot {\n    constructor(editStacks) {\n        this.editStacks = editStacks;\n        this._versionIds = [];\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            this._versionIds[i] = this.editStacks[i].versionId;\n        }\n    }\n    isValid() {\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n    constructor(_dialogService, _notificationService) {\n        this._dialogService = _dialogService;\n        this._notificationService = _notificationService;\n        this._editStacks = new Map();\n        this._uriComparisonKeyComputers = [];\n    }\n    getUriComparisonKey(resource) {\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\n            }\n        }\n        return resource.toString();\n    }\n    _print(label) {\n        console.log(`------------------------------------`);\n        console.log(`AFTER ${label}: `);\n        const str = [];\n        for (const element of this._editStacks) {\n            str.push(element[1].toString());\n        }\n        console.log(str.join('\\n'));\n    }\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n        if (element.type === 0 /* UndoRedoElementType.Resource */) {\n            const resourceLabel = getResourceLabel(element.resource);\n            const strResource = this.getUriComparisonKey(element.resource);\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n        else {\n            const seen = new Set();\n            const resourceLabels = [];\n            const strResources = [];\n            for (const resource of element.resources) {\n                const resourceLabel = getResourceLabel(resource);\n                const strResource = this.getUriComparisonKey(resource);\n                if (seen.has(strResource)) {\n                    continue;\n                }\n                seen.add(strResource);\n                resourceLabels.push(resourceLabel);\n                strResources.push(strResource);\n            }\n            if (resourceLabels.length === 1) {\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n            else {\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n        }\n        if (DEBUG) {\n            this._print('pushElement');\n        }\n    }\n    _pushElement(element) {\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\n            const resourceLabel = element.resourceLabels[i];\n            const strResource = element.strResources[i];\n            let editStack;\n            if (this._editStacks.has(strResource)) {\n                editStack = this._editStacks.get(strResource);\n            }\n            else {\n                editStack = new ResourceEditStack(resourceLabel, strResource);\n                this._editStacks.set(strResource, editStack);\n            }\n            editStack.pushElement(element);\n        }\n    }\n    getLastElement(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            if (editStack.hasFutureElements()) {\n                return null;\n            }\n            const closestPastElement = editStack.getClosestPastElement();\n            return closestPastElement ? closestPastElement.actual : null;\n        }\n        return null;\n    }\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    removeElements(resource) {\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.dispose();\n            this._editStacks.delete(strResource);\n        }\n        if (DEBUG) {\n            this._print('removeElements');\n        }\n    }\n    setElementsValidFlag(resource, isValid, filter) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.setElementsValidFlag(isValid, filter);\n        }\n        if (DEBUG) {\n            this._print('setElementsValidFlag');\n        }\n    }\n    createSnapshot(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.createSnapshot(resource);\n        }\n        return new ResourceEditStackSnapshot(resource, []);\n    }\n    restoreSnapshot(snapshot) {\n        const strResource = this.getUriComparisonKey(snapshot.resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.restoreSnapshot(snapshot);\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n                // the edit stack is now empty, just remove it entirely\n                editStack.dispose();\n                this._editStacks.delete(strResource);\n            }\n        }\n        if (DEBUG) {\n            this._print('restoreSnapshot');\n        }\n    }\n    getElements(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.getElements();\n        }\n        return { past: [], future: [] };\n    }\n    _findClosestUndoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canUndo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasPastElements();\n        }\n        return false;\n    }\n    _onError(err, element) {\n        onUnexpectedError(err);\n        // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n        for (const strResource of element.strResources) {\n            this.removeElements(strResource);\n        }\n        this._notificationService.error(err);\n    }\n    _acquireLocks(editStackSnapshot) {\n        // first, check if all locks can be acquired\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                throw new Error('Cannot acquire edit stack lock');\n            }\n        }\n        // can acquire all locks\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.locked = true;\n        }\n        return () => {\n            // release all locks\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.locked = false;\n            }\n        };\n    }\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\n        let result;\n        try {\n            result = invoke();\n        }\n        catch (err) {\n            releaseLocks();\n            cleanup.dispose();\n            return this._onError(err, element);\n        }\n        if (result) {\n            // result is Promise<void>\n            return result.then(() => {\n                releaseLocks();\n                cleanup.dispose();\n                return continuation();\n            }, (err) => {\n                releaseLocks();\n                cleanup.dispose();\n                return this._onError(err, element);\n            });\n        }\n        else {\n            // result is void\n            releaseLocks();\n            cleanup.dispose();\n            return continuation();\n        }\n    }\n    async _invokeWorkspacePrepare(element) {\n        if (typeof element.actual.prepareUndoRedo === 'undefined') {\n            return Disposable.None;\n        }\n        const result = element.actual.prepareUndoRedo();\n        if (typeof result === 'undefined') {\n            return Disposable.None;\n        }\n        return result;\n    }\n    _invokeResourcePrepare(element, callback) {\n        if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n            // no preparation needed\n            return callback(Disposable.None);\n        }\n        const r = element.actual.prepareUndoRedo();\n        if (!r) {\n            // nothing to clean up\n            return callback(Disposable.None);\n        }\n        if (isDisposable(r)) {\n            return callback(r);\n        }\n        return r.then((disposable) => {\n            return callback(disposable);\n        });\n    }\n    _getAffectedEditStacks(element) {\n        const affectedEditStacks = [];\n        for (const strResource of element.strResources) {\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n        return new EditStackSnapshot(affectedEditStacks);\n    }\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitPastWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last past element in all the impacted resources!\n        const cannotUndoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestPastElement() !== element) {\n                cannotUndoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotUndoDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceUndo(strResource, element, undoConfirmed) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n    _isPartOfUndoGroup(element) {\n        if (!element.groupId) {\n            return false;\n        }\n        // check that there is at least another element with the same groupId ready to be undone\n        for (const [, editStack] of this._editStacks) {\n            const pastElement = editStack.getClosestPastElement();\n            if (!pastElement) {\n                continue;\n            }\n            if (pastElement === element) {\n                const secondPastElement = editStack.getSecondClosestPastElement();\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\n                    // there is another element with the same group id in the same stack!\n                    return true;\n                }\n            }\n            if (pastElement.groupId === element.groupId) {\n                // there is another element with the same group id in another stack!\n                return true;\n            }\n        }\n        return false;\n    }\n    async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n        if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n            // this element can be split\n            let UndoChoice;\n            (function (UndoChoice) {\n                UndoChoice[UndoChoice[\"All\"] = 0] = \"All\";\n                UndoChoice[UndoChoice[\"This\"] = 1] = \"This\";\n                UndoChoice[UndoChoice[\"Cancel\"] = 2] = \"Cancel\";\n            })(UndoChoice || (UndoChoice = {}));\n            const { result } = await this._dialogService.prompt({\n                type: Severity.Info,\n                message: nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label),\n                buttons: [\n                    {\n                        label: nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1, && denotes a mnemonic'] }, \"&&Undo in {0} Files\", editStackSnapshot.editStacks.length),\n                        run: () => UndoChoice.All\n                    },\n                    {\n                        label: nls.localize({ key: 'nok', comment: ['&& denotes a mnemonic'] }, \"Undo this &&File\"),\n                        run: () => UndoChoice.This\n                    }\n                ],\n                cancelButton: {\n                    run: () => UndoChoice.Cancel\n                }\n            });\n            if (result === UndoChoice.Cancel) {\n                // choice: cancel\n                return;\n            }\n            if (result === UndoChoice.This) {\n                // choice: undo this file\n                this._splitPastWorkspaceElement(element, null);\n                return this._undo(strResource, 0, true);\n            }\n            // choice: undo in all files\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n            const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\n            if (verificationError1) {\n                return verificationError1.returnValue;\n            }\n            undoConfirmed = true;\n        }\n        // prepare\n        let cleanup;\n        try {\n            cleanup = await this._invokeWorkspacePrepare(element);\n        }\n        catch (err) {\n            return this._onError(err, element);\n        }\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n        const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n        if (verificationError2) {\n            cleanup.dispose();\n            return verificationError2.returnValue;\n        }\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.moveBackward(element);\n        }\n        return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    }\n    _resourceUndo(editStack, element, undoConfirmed) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveBackward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _findClosestUndoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueUndoInGroup(groupId, undoConfirmed) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._undo(matchedStrResource, 0, undoConfirmed);\n        }\n    }\n    undo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._undo(resourceOrSource, 0, false);\n        }\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n    _undo(strResource, sourceId = 0, undoConfirmed) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestPastElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure undoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be undone before this one\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\n            }\n        }\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\n        if (shouldPromptForConfirmation && !undoConfirmed) {\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceUndo(strResource, element, undoConfirmed);\n            }\n            else {\n                return this._resourceUndo(editStack, element, undoConfirmed);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('undo');\n            }\n        }\n    }\n    async _confirmAndContinueUndo(strResource, sourceId, element) {\n        const result = await this._dialogService.confirm({\n            message: nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label),\n            primaryButton: nls.localize({ key: 'confirmDifferentSource.yes', comment: ['&& denotes a mnemonic'] }, \"&&Yes\"),\n            cancelButton: nls.localize('confirmDifferentSource.no', \"No\")\n        });\n        if (!result.confirmed) {\n            return;\n        }\n        return this._undo(strResource, sourceId, true);\n    }\n    _findClosestRedoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canRedo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasFutureElements();\n        }\n        return false;\n    }\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitFutureWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._redo(strResource));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last future element in all the impacted resources!\n        const cannotRedoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestFutureElement() !== element) {\n                cannotRedoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotRedoDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceRedo(strResource, element) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n    async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n        // prepare\n        let cleanup;\n        try {\n            cleanup = await this._invokeWorkspacePrepare(element);\n        }\n        catch (err) {\n            return this._onError(err, element);\n        }\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n        const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n        if (verificationError) {\n            cleanup.dispose();\n            return verificationError.returnValue;\n        }\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.moveForward(element);\n        }\n        return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n    }\n    _resourceRedo(editStack, element) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveForward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _findClosestRedoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueRedoInGroup(groupId) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._redo(matchedStrResource);\n        }\n    }\n    redo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._redo(resourceOrSource);\n        }\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n    _redo(strResource) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestFutureElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure redoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be redone before this one\n                return this._redo(matchedStrResource);\n            }\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceRedo(strResource, element);\n            }\n            else {\n                return this._resourceRedo(editStack, element);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('redo');\n            }\n        }\n    }\n};\nUndoRedoService = __decorate([\n    __param(0, IDialogService),\n    __param(1, INotificationService)\n], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n    constructor(returnValue) {\n        this.returnValue = returnValue;\n    }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../base/common/assert.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\nimport * as nls from '../../../nls.js';\n/**\n * Returns the css variable name for the given color identifier. Dots (`.`) are replaced with hyphens (`-`) and\n * everything is prefixed with `--vscode-`.\n *\n * @sample `editorSuggestWidget.background` is `--vscode-editorSuggestWidget-background`.\n */\nexport function asCssVariableName(colorIdent) {\n    return `--vscode-${colorIdent.replace(/\\./g, '-')}`;\n}\nexport function asCssVariable(color) {\n    return `var(${asCssVariableName(color)})`;\n}\nexport function asCssVariableWithDefault(color, defaultCssValue) {\n    return `var(${asCssVariableName(color)}, ${defaultCssValue})`;\n}\nexport function isColorDefaults(value) {\n    return value !== null && typeof value === 'object' && 'light' in value && 'dark' in value;\n}\n// color registry\nexport const Extensions = {\n    ColorContribution: 'base.contributions.colors'\n};\nexport const DEFAULT_COLOR_CONFIG_VALUE = 'default';\nclass ColorRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.colorSchema = { type: 'object', properties: {} };\n        this.colorReferenceSchema = { type: 'string', enum: [], enumDescriptions: [] };\n        this.colorsById = {};\n    }\n    registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {\n        const colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };\n        this.colorsById[id] = colorContribution;\n        const propertySchema = { type: 'string', format: 'color-hex', defaultSnippets: [{ body: '${1:#ff0000}' }] };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (needsTransparency) {\n            propertySchema.pattern = '^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$';\n            propertySchema.patternErrorMessage = nls.localize('transparecyRequired', 'This color must be transparent or it will obscure content');\n        }\n        this.colorSchema.properties[id] = {\n            description,\n            oneOf: [\n                propertySchema,\n                { type: 'string', const: DEFAULT_COLOR_CONFIG_VALUE, description: nls.localize('useDefault', 'Use the default color.') }\n            ]\n        };\n        this.colorReferenceSchema.enum.push(id);\n        this.colorReferenceSchema.enumDescriptions.push(description);\n        this._onDidChangeSchema.fire();\n        return id;\n    }\n    getColors() {\n        return Object.keys(this.colorsById).map(id => this.colorsById[id]);\n    }\n    resolveDefaultColor(id, theme) {\n        const colorDesc = this.colorsById[id];\n        if (colorDesc?.defaults) {\n            const colorValue = isColorDefaults(colorDesc.defaults) ? colorDesc.defaults[theme.type] : colorDesc.defaults;\n            return resolveColorValue(colorValue, theme);\n        }\n        return undefined;\n    }\n    getColorSchema() {\n        return this.colorSchema;\n    }\n    toString() {\n        const sorter = (a, b) => {\n            const cat1 = a.indexOf('.') === -1 ? 0 : 1;\n            const cat2 = b.indexOf('.') === -1 ? 0 : 1;\n            if (cat1 !== cat2) {\n                return cat1 - cat2;\n            }\n            return a.localeCompare(b);\n        };\n        return Object.keys(this.colorsById).sort(sorter).map(k => `- \\`${k}\\`: ${this.colorsById[k].description}`).join('\\n');\n    }\n}\nconst colorRegistry = new ColorRegistry();\nplatform.Registry.add(Extensions.ColorContribution, colorRegistry);\nexport function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {\n    return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);\n}\n// ----- color functions\nexport function executeTransform(transform, theme) {\n    switch (transform.op) {\n        case 0 /* ColorTransformType.Darken */:\n            return resolveColorValue(transform.value, theme)?.darken(transform.factor);\n        case 1 /* ColorTransformType.Lighten */:\n            return resolveColorValue(transform.value, theme)?.lighten(transform.factor);\n        case 2 /* ColorTransformType.Transparent */:\n            return resolveColorValue(transform.value, theme)?.transparent(transform.factor);\n        case 3 /* ColorTransformType.Opaque */: {\n            const backgroundColor = resolveColorValue(transform.background, theme);\n            if (!backgroundColor) {\n                return resolveColorValue(transform.value, theme);\n            }\n            return resolveColorValue(transform.value, theme)?.makeOpaque(backgroundColor);\n        }\n        case 4 /* ColorTransformType.OneOf */:\n            for (const candidate of transform.values) {\n                const color = resolveColorValue(candidate, theme);\n                if (color) {\n                    return color;\n                }\n            }\n            return undefined;\n        case 6 /* ColorTransformType.IfDefinedThenElse */:\n            return resolveColorValue(theme.defines(transform.if) ? transform.then : transform.else, theme);\n        case 5 /* ColorTransformType.LessProminent */: {\n            const from = resolveColorValue(transform.value, theme);\n            if (!from) {\n                return undefined;\n            }\n            const backgroundColor = resolveColorValue(transform.background, theme);\n            if (!backgroundColor) {\n                return from.transparent(transform.factor * transform.transparency);\n            }\n            return from.isDarkerThan(backgroundColor)\n                ? Color.getLighterColor(from, backgroundColor, transform.factor).transparent(transform.transparency)\n                : Color.getDarkerColor(from, backgroundColor, transform.factor).transparent(transform.transparency);\n        }\n        default:\n            throw assertNever(transform);\n    }\n}\nexport function darken(colorValue, factor) {\n    return { op: 0 /* ColorTransformType.Darken */, value: colorValue, factor };\n}\nexport function lighten(colorValue, factor) {\n    return { op: 1 /* ColorTransformType.Lighten */, value: colorValue, factor };\n}\nexport function transparent(colorValue, factor) {\n    return { op: 2 /* ColorTransformType.Transparent */, value: colorValue, factor };\n}\nexport function oneOf(...colorValues) {\n    return { op: 4 /* ColorTransformType.OneOf */, values: colorValues };\n}\nexport function ifDefinedThenElse(ifArg, thenArg, elseArg) {\n    return { op: 6 /* ColorTransformType.IfDefinedThenElse */, if: ifArg, then: thenArg, else: elseArg };\n}\nexport function lessProminent(colorValue, backgroundColorValue, factor, transparency) {\n    return { op: 5 /* ColorTransformType.LessProminent */, value: colorValue, background: backgroundColorValue, factor, transparency };\n}\n// ----- implementation\n/**\n * @param colorValue Resolve a color value in the context of a theme\n */\nexport function resolveColorValue(colorValue, theme) {\n    if (colorValue === null) {\n        return undefined;\n    }\n    else if (typeof colorValue === 'string') {\n        if (colorValue[0] === '#') {\n            return Color.fromHex(colorValue);\n        }\n        return theme.getColor(colorValue);\n    }\n    else if (colorValue instanceof Color) {\n        return colorValue;\n    }\n    else if (typeof colorValue === 'object') {\n        return executeTransform(colorValue, theme);\n    }\n    return undefined;\n}\nexport const workbenchColorsSchemaId = 'vscode://schemas/workbench-colors';\nconst schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);\ncolorRegistry.onDidChangeSchema(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n// setTimeout(_ => console.log(colorRegistry.toString()), 5000);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nexport function renderText(text, options = {}) {\n    const element = createElement(options);\n    element.textContent = text;\n    return element;\n}\nexport function renderFormattedText(formattedText, options = {}) {\n    const element = createElement(options);\n    _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);\n    return element;\n}\nexport function createElement(options) {\n    const tagName = options.inline ? 'span' : 'div';\n    const element = document.createElement(tagName);\n    if (options.className) {\n        element.className = options.className;\n    }\n    return element;\n}\nclass StringStream {\n    constructor(source) {\n        this.source = source;\n        this.index = 0;\n    }\n    eos() {\n        return this.index >= this.source.length;\n    }\n    next() {\n        const next = this.peek();\n        this.advance();\n        return next;\n    }\n    peek() {\n        return this.source[this.index];\n    }\n    advance() {\n        this.index++;\n    }\n}\nfunction _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {\n    let child;\n    if (treeNode.type === 2 /* FormatType.Text */) {\n        child = document.createTextNode(treeNode.content || '');\n    }\n    else if (treeNode.type === 3 /* FormatType.Bold */) {\n        child = document.createElement('b');\n    }\n    else if (treeNode.type === 4 /* FormatType.Italics */) {\n        child = document.createElement('i');\n    }\n    else if (treeNode.type === 7 /* FormatType.Code */ && renderCodeSegments) {\n        child = document.createElement('code');\n    }\n    else if (treeNode.type === 5 /* FormatType.Action */ && actionHandler) {\n        const a = document.createElement('a');\n        actionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n            actionHandler.callback(String(treeNode.index), event);\n        }));\n        child = a;\n    }\n    else if (treeNode.type === 8 /* FormatType.NewLine */) {\n        child = document.createElement('br');\n    }\n    else if (treeNode.type === 1 /* FormatType.Root */) {\n        child = element;\n    }\n    if (child && element !== child) {\n        element.appendChild(child);\n    }\n    if (child && Array.isArray(treeNode.children)) {\n        treeNode.children.forEach((nodeChild) => {\n            _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n        });\n    }\n}\nfunction parseFormattedText(content, parseCodeSegments) {\n    const root = {\n        type: 1 /* FormatType.Root */,\n        children: []\n    };\n    let actionViewItemIndex = 0;\n    let current = root;\n    const stack = [];\n    const stream = new StringStream(content);\n    while (!stream.eos()) {\n        let next = stream.next();\n        const isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== 0 /* FormatType.Invalid */);\n        if (isEscapedFormatType) {\n            next = stream.next(); // unread the backslash if it escapes a format tag type\n        }\n        if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n            stream.advance();\n            if (current.type === 2 /* FormatType.Text */) {\n                current = stack.pop();\n            }\n            const type = formatTagType(next, parseCodeSegments);\n            if (current.type === type || (current.type === 5 /* FormatType.Action */ && type === 6 /* FormatType.ActionClose */)) {\n                current = stack.pop();\n            }\n            else {\n                const newCurrent = {\n                    type: type,\n                    children: []\n                };\n                if (type === 5 /* FormatType.Action */) {\n                    newCurrent.index = actionViewItemIndex;\n                    actionViewItemIndex++;\n                }\n                current.children.push(newCurrent);\n                stack.push(current);\n                current = newCurrent;\n            }\n        }\n        else if (next === '\\n') {\n            if (current.type === 2 /* FormatType.Text */) {\n                current = stack.pop();\n            }\n            current.children.push({\n                type: 8 /* FormatType.NewLine */\n            });\n        }\n        else {\n            if (current.type !== 2 /* FormatType.Text */) {\n                const textCurrent = {\n                    type: 2 /* FormatType.Text */,\n                    content: next\n                };\n                current.children.push(textCurrent);\n                stack.push(current);\n                current = textCurrent;\n            }\n            else {\n                current.content += next;\n            }\n        }\n    }\n    if (current.type === 2 /* FormatType.Text */) {\n        current = stack.pop();\n    }\n    if (stack.length) {\n        // incorrectly formatted string literal\n    }\n    return root;\n}\nfunction isFormatTag(char, supportCodeSegments) {\n    return formatTagType(char, supportCodeSegments) !== 0 /* FormatType.Invalid */;\n}\nfunction formatTagType(char, supportCodeSegments) {\n    switch (char) {\n        case '*':\n            return 3 /* FormatType.Bold */;\n        case '_':\n            return 4 /* FormatType.Italics */;\n        case '[':\n            return 5 /* FormatType.Action */;\n        case ']':\n            return 6 /* FormatType.ActionClose */;\n        case '`':\n            return supportCodeSegments ? 7 /* FormatType.Code */ : 0 /* FormatType.Invalid */;\n        default:\n            return 0 /* FormatType.Invalid */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalArgument } from './errors.js';\nimport { escapeIcons } from './iconLabels.js';\nimport { isEqual } from './resources.js';\nimport { escapeRegExpCharacters } from './strings.js';\nimport { URI } from './uri.js';\nexport class MarkdownString {\n    constructor(value = '', isTrustedOrOptions = false) {\n        this.value = value;\n        if (typeof this.value !== 'string') {\n            throw illegalArgument('value');\n        }\n        if (typeof isTrustedOrOptions === 'boolean') {\n            this.isTrusted = isTrustedOrOptions;\n            this.supportThemeIcons = false;\n            this.supportHtml = false;\n        }\n        else {\n            this.isTrusted = isTrustedOrOptions.isTrusted ?? undefined;\n            this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;\n            this.supportHtml = isTrustedOrOptions.supportHtml ?? false;\n        }\n    }\n    appendText(value, newlineStyle = 0 /* MarkdownStringTextNewlineStyle.Paragraph */) {\n        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value) // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.\n            .replace(/([ \\t]+)/g, (_match, g1) => '&nbsp;'.repeat(g1.length)) // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.\n            .replace(/\\>/gm, '\\\\>') // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.\n            .replace(/\\n/g, newlineStyle === 1 /* MarkdownStringTextNewlineStyle.Break */ ? '\\\\\\n' : '\\n\\n'); // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.\n        return this;\n    }\n    appendMarkdown(value) {\n        this.value += value;\n        return this;\n    }\n    appendCodeblock(langId, code) {\n        this.value += `\\n${appendEscapedMarkdownCodeBlockFence(code, langId)}\\n`;\n        return this;\n    }\n    appendLink(target, label, title) {\n        this.value += '[';\n        this.value += this._escape(label, ']');\n        this.value += '](';\n        this.value += this._escape(String(target), ')');\n        if (title) {\n            this.value += ` \"${this._escape(this._escape(title, '\"'), ')')}\"`;\n        }\n        this.value += ')';\n        return this;\n    }\n    _escape(value, ch) {\n        const r = new RegExp(escapeRegExpCharacters(ch), 'g');\n        return value.replace(r, (match, offset) => {\n            if (value.charAt(offset - 1) !== '\\\\') {\n                return `\\\\${match}`;\n            }\n            else {\n                return match;\n            }\n        });\n    }\n}\nexport function isEmptyMarkdownString(oneOrMany) {\n    if (isMarkdownString(oneOrMany)) {\n        return !oneOrMany.value;\n    }\n    else if (Array.isArray(oneOrMany)) {\n        return oneOrMany.every(isEmptyMarkdownString);\n    }\n    else {\n        return true;\n    }\n}\nexport function isMarkdownString(thing) {\n    if (thing instanceof MarkdownString) {\n        return true;\n    }\n    else if (thing && typeof thing === 'object') {\n        return typeof thing.value === 'string'\n            && (typeof thing.isTrusted === 'boolean' || typeof thing.isTrusted === 'object' || thing.isTrusted === undefined)\n            && (typeof thing.supportThemeIcons === 'boolean' || thing.supportThemeIcons === undefined);\n    }\n    return false;\n}\nexport function markdownStringEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (!a || !b) {\n        return false;\n    }\n    else {\n        return a.value === b.value\n            && a.isTrusted === b.isTrusted\n            && a.supportThemeIcons === b.supportThemeIcons\n            && a.supportHtml === b.supportHtml\n            && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && isEqual(URI.from(a.baseUri), URI.from(b.baseUri)));\n    }\n}\nexport function escapeMarkdownSyntaxTokens(text) {\n    // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    return text.replace(/[\\\\`*_{}[\\]()#+\\-!~]/g, '\\\\$&'); // CodeQL [SM02383] Backslash is escaped in the character class\n}\n/**\n * @see https://github.com/microsoft/vscode/issues/193746\n */\nexport function appendEscapedMarkdownCodeBlockFence(code, langId) {\n    const longestFenceLength = code.match(/^`+/gm)?.reduce((a, b) => (a.length > b.length ? a : b)).length ??\n        0;\n    const desiredFenceLength = longestFenceLength >= 3 ? longestFenceLength + 1 : 3;\n    // the markdown result\n    return [\n        `${'`'.repeat(desiredFenceLength)}${langId}`,\n        code,\n        `${'`'.repeat(desiredFenceLength)}`,\n    ].join('\\n');\n}\nexport function escapeDoubleQuotes(input) {\n    return input.replace(/\"/g, '&quot;');\n}\nexport function removeMarkdownEscapes(text) {\n    if (!text) {\n        return text;\n    }\n    return text.replace(/\\\\([\\\\`*_{}[\\]()#+\\-.!~])/g, '$1');\n}\nexport function parseHrefAndDimensions(href) {\n    const dimensions = [];\n    const splitted = href.split('|').map(s => s.trim());\n    href = splitted[0];\n    const parameters = splitted[1];\n    if (parameters) {\n        const heightFromParams = /height=(\\d+)/.exec(parameters);\n        const widthFromParams = /width=(\\d+)/.exec(parameters);\n        const height = heightFromParams ? heightFromParams[1] : '';\n        const width = widthFromParams ? widthFromParams[1] : '';\n        const widthIsFinite = isFinite(parseInt(width));\n        const heightIsFinite = isFinite(parseInt(height));\n        if (widthIsFinite) {\n            dimensions.push(`width=\"${width}\"`);\n        }\n        if (heightIsFinite) {\n            dimensions.push(`height=\"${height}\"`);\n        }\n    }\n    return { href, dimensions };\n}\n","/**\n * marked v14.0.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n// ESM-uncomment-begin\nlet __marked_exports = {};\n(function() {\n  function define(deps, factory) {\n    factory(__marked_exports);\n  }\n  define.amd = true;\n// ESM-uncomment-end\n\n(function (global, factory) {\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n  })(this, (function (exports) {\n\t'use strict';\n\n\t/**\n\t * Gets the original marked default options.\n\t */\n\tfunction _getDefaults() {\n\t\treturn {\n\t\t\tasync: false,\n\t\t\tbreaks: false,\n\t\t\textensions: null,\n\t\t\tgfm: true,\n\t\t\thooks: null,\n\t\t\tpedantic: false,\n\t\t\trenderer: null,\n\t\t\tsilent: false,\n\t\t\ttokenizer: null,\n\t\t\twalkTokens: null,\n\t\t};\n\t}\n\texports.defaults = _getDefaults();\n\tfunction changeDefaults(newDefaults) {\n\t\texports.defaults = newDefaults;\n\t}\n\n\t/**\n\t * Helpers\n\t */\n\tconst escapeTest = /[&<>\"']/;\n\tconst escapeReplace = new RegExp(escapeTest.source, 'g');\n\tconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n\tconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n\tconst escapeReplacements = {\n\t\t'&': '&amp;',\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'\"': '&quot;',\n\t\t\"'\": '&#39;',\n\t};\n\tconst getEscapeReplacement = (ch) => escapeReplacements[ch];\n\tfunction escape$1(html, encode) {\n\t\tif (encode) {\n\t\t\tif (escapeTest.test(html)) {\n\t\t\t\treturn html.replace(escapeReplace, getEscapeReplacement);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (escapeTestNoEncode.test(html)) {\n\t\t\t\treturn html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n\t\t\t}\n\t\t}\n\t\treturn html;\n\t}\n\tconst caret = /(^|[^\\[])\\^/g;\n\tfunction edit(regex, opt) {\n\t\tlet source = typeof regex === 'string' ? regex : regex.source;\n\t\topt = opt || '';\n\t\tconst obj = {\n\t\t\treplace: (name, val) => {\n\t\t\t\tlet valSource = typeof val === 'string' ? val : val.source;\n\t\t\t\tvalSource = valSource.replace(caret, '$1');\n\t\t\t\tsource = source.replace(name, valSource);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tgetRegex: () => {\n\t\t\t\treturn new RegExp(source, opt);\n\t\t\t},\n\t\t};\n\t\treturn obj;\n\t}\n\tfunction cleanUrl(href) {\n\t\ttry {\n\t\t\thref = encodeURI(href).replace(/%25/g, '%');\n\t\t}\n\t\tcatch {\n\t\t\treturn null;\n\t\t}\n\t\treturn href;\n\t}\n\tconst noopTest = { exec: () => null };\n\tfunction splitCells(tableRow, count) {\n\t\t// ensure that every cell-delimiting pipe has a space\n\t\t// before it to distinguish it from an escaped pipe\n\t\tconst row = tableRow.replace(/\\|/g, (match, offset, str) => {\n\t\t\tlet escaped = false;\n\t\t\tlet curr = offset;\n\t\t\twhile (--curr >= 0 && str[curr] === '\\\\')\n\t\t\t\tescaped = !escaped;\n\t\t\tif (escaped) {\n\t\t\t\t// odd number of slashes means | is escaped\n\t\t\t\t// so we leave it alone\n\t\t\t\treturn '|';\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// add space before unescaped |\n\t\t\t\treturn ' |';\n\t\t\t}\n\t\t}), cells = row.split(/ \\|/);\n\t\tlet i = 0;\n\t\t// First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\t\tif (!cells[0].trim()) {\n\t\t\tcells.shift();\n\t\t}\n\t\tif (cells.length > 0 && !cells[cells.length - 1].trim()) {\n\t\t\tcells.pop();\n\t\t}\n\t\tif (count) {\n\t\t\tif (cells.length > count) {\n\t\t\t\tcells.splice(count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cells.length < count)\n\t\t\t\t\tcells.push('');\n\t\t\t}\n\t\t}\n\t\tfor (; i < cells.length; i++) {\n\t\t\t// leading or trailing whitespace is ignored per the gfm spec\n\t\t\tcells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n\t\t}\n\t\treturn cells;\n\t}\n\t/**\n\t * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n\t * /c*$/ is vulnerable to REDOS.\n\t *\n\t * @param str\n\t * @param c\n\t * @param invert Remove suffix of non-c chars instead. Default falsey.\n\t */\n\tfunction rtrim(str, c, invert) {\n\t\tconst l = str.length;\n\t\tif (l === 0) {\n\t\t\treturn '';\n\t\t}\n\t\t// Length of suffix matching the invert condition.\n\t\tlet suffLen = 0;\n\t\t// Step left until we fail to match the invert condition.\n\t\twhile (suffLen < l) {\n\t\t\tconst currChar = str.charAt(l - suffLen - 1);\n\t\t\tif (currChar === c && !invert) {\n\t\t\t\tsuffLen++;\n\t\t\t}\n\t\t\telse if (currChar !== c && invert) {\n\t\t\t\tsuffLen++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str.slice(0, l - suffLen);\n\t}\n\tfunction findClosingBracket(str, b) {\n\t\tif (str.indexOf(b[1]) === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet level = 0;\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (str[i] === '\\\\') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (str[i] === b[0]) {\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\telse if (str[i] === b[1]) {\n\t\t\t\tlevel--;\n\t\t\t\tif (level < 0) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tfunction outputLink(cap, link, raw, lexer) {\n\t\tconst href = link.href;\n\t\tconst title = link.title ? escape$1(link.title) : null;\n\t\tconst text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\t\tif (cap[0].charAt(0) !== '!') {\n\t\t\tlexer.state.inLink = true;\n\t\t\tconst token = {\n\t\t\t\ttype: 'link',\n\t\t\t\traw,\n\t\t\t\thref,\n\t\t\t\ttitle,\n\t\t\t\ttext,\n\t\t\t\ttokens: lexer.inlineTokens(text),\n\t\t\t};\n\t\t\tlexer.state.inLink = false;\n\t\t\treturn token;\n\t\t}\n\t\treturn {\n\t\t\ttype: 'image',\n\t\t\traw,\n\t\t\thref,\n\t\t\ttitle,\n\t\t\ttext: escape$1(text),\n\t\t};\n\t}\n\tfunction indentCodeCompensation(raw, text) {\n\t\tconst matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\t\tif (matchIndentToCode === null) {\n\t\t\treturn text;\n\t\t}\n\t\tconst indentToCode = matchIndentToCode[1];\n\t\treturn text\n\t\t\t.split('\\n')\n\t\t\t.map(node => {\n\t\t\t\tconst matchIndentInNode = node.match(/^\\s+/);\n\t\t\t\tif (matchIndentInNode === null) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tconst [indentInNode] = matchIndentInNode;\n\t\t\t\tif (indentInNode.length >= indentToCode.length) {\n\t\t\t\t\treturn node.slice(indentToCode.length);\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t})\n\t\t\t.join('\\n');\n\t}\n\t/**\n\t * Tokenizer\n\t */\n\tclass _Tokenizer {\n\t\toptions;\n\t\trules; // set by the lexer\n\t\tlexer; // set by the lexer\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tspace(src) {\n\t\t\tconst cap = this.rules.block.newline.exec(src);\n\t\t\tif (cap && cap[0].length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'space',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcode(src) {\n\t\t\tconst cap = this.rules.block.code.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst text = cap[0].replace(/^ {1,4}/gm, '');\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'code',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tcodeBlockStyle: 'indented',\n\t\t\t\t\ttext: !this.options.pedantic\n\t\t\t\t\t\t? rtrim(text, '\\n')\n\t\t\t\t\t\t: text,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tfences(src) {\n\t\t\tconst cap = this.rules.block.fences.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst raw = cap[0];\n\t\t\t\tconst text = indentCodeCompensation(raw, cap[3] || '');\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'code',\n\t\t\t\t\traw,\n\t\t\t\t\tlang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\theading(src) {\n\t\t\tconst cap = this.rules.block.heading.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text = cap[2].trim();\n\t\t\t\t// remove trailing #s\n\t\t\t\tif (/#$/.test(text)) {\n\t\t\t\t\tconst trimmed = rtrim(text, '#');\n\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\ttext = trimmed.trim();\n\t\t\t\t\t}\n\t\t\t\t\telse if (!trimmed || / $/.test(trimmed)) {\n\t\t\t\t\t\t// CommonMark requires space before trailing #s\n\t\t\t\t\t\ttext = trimmed.trim();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tdepth: cap[1].length,\n\t\t\t\t\ttext,\n\t\t\t\t\ttokens: this.lexer.inline(text),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\thr(src) {\n\t\t\tconst cap = this.rules.block.hr.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'hr',\n\t\t\t\t\traw: rtrim(cap[0], '\\n'),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tblockquote(src) {\n\t\t\tconst cap = this.rules.block.blockquote.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet lines = rtrim(cap[0], '\\n').split('\\n');\n\t\t\t\tlet raw = '';\n\t\t\t\tlet text = '';\n\t\t\t\tconst tokens = [];\n\t\t\t\twhile (lines.length > 0) {\n\t\t\t\t\tlet inBlockquote = false;\n\t\t\t\t\tconst currentLines = [];\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\t\t\t// get lines up to a continuation\n\t\t\t\t\t\tif (/^ {0,3}>/.test(lines[i])) {\n\t\t\t\t\t\t\tcurrentLines.push(lines[i]);\n\t\t\t\t\t\t\tinBlockquote = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!inBlockquote) {\n\t\t\t\t\t\t\tcurrentLines.push(lines[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlines = lines.slice(i);\n\t\t\t\t\tconst currentRaw = currentLines.join('\\n');\n\t\t\t\t\tconst currentText = currentRaw\n\t\t\t\t\t\t// precede setext continuation with 4 spaces so it isn't a setext\n\t\t\t\t\t\t.replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n\t\t\t\t\t\t.replace(/^ {0,3}>[ \\t]?/gm, '');\n\t\t\t\t\traw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n\t\t\t\t\ttext = text ? `${text}\\n${currentText}` : currentText;\n\t\t\t\t\t// parse blockquote lines as top level tokens\n\t\t\t\t\t// merge paragraphs if this is a continuation\n\t\t\t\t\tconst top = this.lexer.state.top;\n\t\t\t\t\tthis.lexer.state.top = true;\n\t\t\t\t\tthis.lexer.blockTokens(currentText, tokens, true);\n\t\t\t\t\tthis.lexer.state.top = top;\n\t\t\t\t\t// if there is no continuation then we are done\n\t\t\t\t\tif (lines.length === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken?.type === 'code') {\n\t\t\t\t\t\t// blockquote continuation cannot be preceded by a code block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (lastToken?.type === 'blockquote') {\n\t\t\t\t\t\t// include continuation in nested blockquote\n\t\t\t\t\t\tconst oldToken = lastToken;\n\t\t\t\t\t\tconst newText = oldToken.raw + '\\n' + lines.join('\\n');\n\t\t\t\t\t\tconst newToken = this.blockquote(newText);\n\t\t\t\t\t\ttokens[tokens.length - 1] = newToken;\n\t\t\t\t\t\traw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n\t\t\t\t\t\ttext = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (lastToken?.type === 'list') {\n\t\t\t\t\t\t// include continuation in nested list\n\t\t\t\t\t\tconst oldToken = lastToken;\n\t\t\t\t\t\tconst newText = oldToken.raw + '\\n' + lines.join('\\n');\n\t\t\t\t\t\tconst newToken = this.list(newText);\n\t\t\t\t\t\ttokens[tokens.length - 1] = newToken;\n\t\t\t\t\t\traw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n\t\t\t\t\t\ttext = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n\t\t\t\t\t\tlines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'blockquote',\n\t\t\t\t\traw,\n\t\t\t\t\ttokens,\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tlist(src) {\n\t\t\tlet cap = this.rules.block.list.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet bull = cap[1].trim();\n\t\t\t\tconst isordered = bull.length > 1;\n\t\t\t\tconst list = {\n\t\t\t\t\ttype: 'list',\n\t\t\t\t\traw: '',\n\t\t\t\t\tordered: isordered,\n\t\t\t\t\tstart: isordered ? +bull.slice(0, -1) : '',\n\t\t\t\t\tloose: false,\n\t\t\t\t\titems: [],\n\t\t\t\t};\n\t\t\t\tbull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\tbull = isordered ? bull : '[*+-]';\n\t\t\t\t}\n\t\t\t\t// Get next list item\n\t\t\t\tconst itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\t\t\t\tlet endsWithBlankLine = false;\n\t\t\t\t// Check if current bullet point can start a new List Item\n\t\t\t\twhile (src) {\n\t\t\t\t\tlet endEarly = false;\n\t\t\t\t\tlet raw = '';\n\t\t\t\t\tlet itemContents = '';\n\t\t\t\t\tif (!(cap = itemRegex.exec(src))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\traw = cap[0];\n\t\t\t\t\tsrc = src.substring(raw.length);\n\t\t\t\t\tlet line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n\t\t\t\t\tlet nextLine = src.split('\\n', 1)[0];\n\t\t\t\t\tlet blankLine = !line.trim();\n\t\t\t\t\tlet indent = 0;\n\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\tindent = 2;\n\t\t\t\t\t\titemContents = line.trimStart();\n\t\t\t\t\t}\n\t\t\t\t\telse if (blankLine) {\n\t\t\t\t\t\tindent = cap[1].length + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent = cap[2].search(/[^ ]/); // Find first non-space char\n\t\t\t\t\t\tindent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n\t\t\t\t\t\titemContents = line.slice(indent);\n\t\t\t\t\t\tindent += cap[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tif (blankLine && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n\t\t\t\t\t\traw += nextLine + '\\n';\n\t\t\t\t\t\tsrc = src.substring(nextLine.length + 1);\n\t\t\t\t\t\tendEarly = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!endEarly) {\n\t\t\t\t\t\tconst nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n\t\t\t\t\t\tconst hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n\t\t\t\t\t\tconst fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n\t\t\t\t\t\tconst headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\t\t\t\t\t\t// Check if following lines should be included in List Item\n\t\t\t\t\t\twhile (src) {\n\t\t\t\t\t\t\tconst rawLine = src.split('\\n', 1)[0];\n\t\t\t\t\t\t\tnextLine = rawLine;\n\t\t\t\t\t\t\t// Re-align to follow commonmark nesting rules\n\t\t\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\t\t\tnextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found code fences\n\t\t\t\t\t\t\tif (fencesBeginRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found start of new heading\n\t\t\t\t\t\t\tif (headingBeginRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found start of new bullet\n\t\t\t\t\t\t\tif (nextBulletRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Horizontal rule found\n\t\t\t\t\t\t\tif (hrRegex.test(src)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n\t\t\t\t\t\t\t\titemContents += '\\n' + nextLine.slice(indent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// not enough indentation\n\t\t\t\t\t\t\t\tif (blankLine) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// paragraph continuation unless last line was a different block level element\n\t\t\t\t\t\t\t\tif (line.search(/[^ ]/) >= 4) { // indented code block\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (fencesBeginRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (headingBeginRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (hrRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemContents += '\\n' + nextLine;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!blankLine && !nextLine.trim()) { // Check if current line is blank\n\t\t\t\t\t\t\t\tblankLine = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\traw += rawLine + '\\n';\n\t\t\t\t\t\t\tsrc = src.substring(rawLine.length + 1);\n\t\t\t\t\t\t\tline = nextLine.slice(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!list.loose) {\n\t\t\t\t\t\t// If the previous item ended with a blank line, the list is loose\n\t\t\t\t\t\tif (endsWithBlankLine) {\n\t\t\t\t\t\t\tlist.loose = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (/\\n *\\n *$/.test(raw)) {\n\t\t\t\t\t\t\tendsWithBlankLine = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet istask = null;\n\t\t\t\t\tlet ischecked;\n\t\t\t\t\t// Check for task list items\n\t\t\t\t\tif (this.options.gfm) {\n\t\t\t\t\t\tistask = /^\\[[ xX]\\] /.exec(itemContents);\n\t\t\t\t\t\tif (istask) {\n\t\t\t\t\t\t\tischecked = istask[0] !== '[ ] ';\n\t\t\t\t\t\t\titemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.items.push({\n\t\t\t\t\t\ttype: 'list_item',\n\t\t\t\t\t\traw,\n\t\t\t\t\t\ttask: !!istask,\n\t\t\t\t\t\tchecked: ischecked,\n\t\t\t\t\t\tloose: false,\n\t\t\t\t\t\ttext: itemContents,\n\t\t\t\t\t\ttokens: [],\n\t\t\t\t\t});\n\t\t\t\t\tlist.raw += raw;\n\t\t\t\t}\n\t\t\t\t// Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\t\t\t\tlist.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n\t\t\t\tlist.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n\t\t\t\tlist.raw = list.raw.trimEnd();\n\t\t\t\t// Item child tokens handled here at end because we needed to have the final item to trim it first\n\t\t\t\tfor (let i = 0; i < list.items.length; i++) {\n\t\t\t\t\tthis.lexer.state.top = false;\n\t\t\t\t\tlist.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\t\t\t\t\tif (!list.loose) {\n\t\t\t\t\t\t// Check if list should be loose\n\t\t\t\t\t\tconst spacers = list.items[i].tokens.filter(t => t.type === 'space');\n\t\t\t\t\t\tconst hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\t\t\t\t\t\tlist.loose = hasMultipleLineBreaks;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Set all items to loose if list is loose\n\t\t\t\tif (list.loose) {\n\t\t\t\t\tfor (let i = 0; i < list.items.length; i++) {\n\t\t\t\t\t\tlist.items[i].loose = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t}\n\t\thtml(src) {\n\t\t\tconst cap = this.rules.block.html.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst token = {\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tblock: true,\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tpre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t};\n\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t\tdef(src) {\n\t\t\tconst cap = this.rules.block.def.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n\t\t\t\tconst href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n\t\t\t\tconst title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'def',\n\t\t\t\t\ttag,\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\thref,\n\t\t\t\t\ttitle,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttable(src) {\n\t\t\tconst cap = this.rules.block.table.exec(src);\n\t\t\tif (!cap) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!/[:|]/.test(cap[2])) {\n\t\t\t\t// delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst headers = splitCells(cap[1]);\n\t\t\tconst aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n\t\t\tconst rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n\t\t\tconst item = {\n\t\t\t\ttype: 'table',\n\t\t\t\traw: cap[0],\n\t\t\t\theader: [],\n\t\t\t\talign: [],\n\t\t\t\trows: [],\n\t\t\t};\n\t\t\tif (headers.length !== aligns.length) {\n\t\t\t\t// header and align columns must be equal, rows can be different.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const align of aligns) {\n\t\t\t\tif (/^ *-+: *$/.test(align)) {\n\t\t\t\t\titem.align.push('right');\n\t\t\t\t}\n\t\t\t\telse if (/^ *:-+: *$/.test(align)) {\n\t\t\t\t\titem.align.push('center');\n\t\t\t\t}\n\t\t\t\telse if (/^ *:-+ *$/.test(align)) {\n\t\t\t\t\titem.align.push('left');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titem.align.push(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < headers.length; i++) {\n\t\t\t\titem.header.push({\n\t\t\t\t\ttext: headers[i],\n\t\t\t\t\ttokens: this.lexer.inline(headers[i]),\n\t\t\t\t\theader: true,\n\t\t\t\t\talign: item.align[i],\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (const row of rows) {\n\t\t\t\titem.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: cell,\n\t\t\t\t\t\ttokens: this.lexer.inline(cell),\n\t\t\t\t\t\theader: false,\n\t\t\t\t\t\talign: item.align[i],\n\t\t\t\t\t};\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t\tlheading(src) {\n\t\t\tconst cap = this.rules.block.lheading.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tdepth: cap[2].charAt(0) === '=' ? 1 : 2,\n\t\t\t\t\ttext: cap[1],\n\t\t\t\t\ttokens: this.lexer.inline(cap[1]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tparagraph(src) {\n\t\t\tconst cap = this.rules.block.paragraph.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst text = cap[1].charAt(cap[1].length - 1) === '\\n'\n\t\t\t\t\t? cap[1].slice(0, -1)\n\t\t\t\t\t: cap[1];\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'paragraph',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\ttokens: this.lexer.inline(text),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttext(src) {\n\t\t\tconst cap = this.rules.block.text.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t\ttokens: this.lexer.inline(cap[0]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tescape(src) {\n\t\t\tconst cap = this.rules.inline.escape.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'escape',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: escape$1(cap[1]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttag(src) {\n\t\t\tconst cap = this.rules.inline.tag.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tif (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inLink = true;\n\t\t\t\t}\n\t\t\t\telse if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inLink = false;\n\t\t\t\t}\n\t\t\t\tif (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inRawBlock = true;\n\t\t\t\t}\n\t\t\t\telse if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inRawBlock = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tinLink: this.lexer.state.inLink,\n\t\t\t\t\tinRawBlock: this.lexer.state.inRawBlock,\n\t\t\t\t\tblock: false,\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tlink(src) {\n\t\t\tconst cap = this.rules.inline.link.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst trimmedUrl = cap[2].trim();\n\t\t\t\tif (!this.options.pedantic && /^</.test(trimmedUrl)) {\n\t\t\t\t\t// commonmark requires matching angle brackets\n\t\t\t\t\tif (!(/>$/.test(trimmedUrl))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// ending angle bracket cannot be escaped\n\t\t\t\t\tconst rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\t\t\t\t\tif ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// find closing parenthesis\n\t\t\t\t\tconst lastParenIndex = findClosingBracket(cap[2], '()');\n\t\t\t\t\tif (lastParenIndex > -1) {\n\t\t\t\t\t\tconst start = cap[0].indexOf('!') === 0 ? 5 : 4;\n\t\t\t\t\t\tconst linkLen = start + cap[1].length + lastParenIndex;\n\t\t\t\t\t\tcap[2] = cap[2].substring(0, lastParenIndex);\n\t\t\t\t\t\tcap[0] = cap[0].substring(0, linkLen).trim();\n\t\t\t\t\t\tcap[3] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet href = cap[2];\n\t\t\t\tlet title = '';\n\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t// split pedantic href and title\n\t\t\t\t\tconst link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\t\t\t\t\tif (link) {\n\t\t\t\t\t\thref = link[1];\n\t\t\t\t\t\ttitle = link[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitle = cap[3] ? cap[3].slice(1, -1) : '';\n\t\t\t\t}\n\t\t\t\thref = href.trim();\n\t\t\t\tif (/^</.test(href)) {\n\t\t\t\t\tif (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n\t\t\t\t\t\t// pedantic allows starting angle bracket without ending angle bracket\n\t\t\t\t\t\thref = href.slice(1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thref = href.slice(1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn outputLink(cap, {\n\t\t\t\t\thref: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n\t\t\t\t\ttitle: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n\t\t\t\t}, cap[0], this.lexer);\n\t\t\t}\n\t\t}\n\t\treflink(src, links) {\n\t\t\tlet cap;\n\t\t\tif ((cap = this.rules.inline.reflink.exec(src))\n\t\t\t\t|| (cap = this.rules.inline.nolink.exec(src))) {\n\t\t\t\tconst linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n\t\t\t\tconst link = links[linkString.toLowerCase()];\n\t\t\t\tif (!link) {\n\t\t\t\t\tconst text = cap[0].charAt(0);\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\traw: text,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn outputLink(cap, link, cap[0], this.lexer);\n\t\t\t}\n\t\t}\n\t\temStrong(src, maskedSrc, prevChar = '') {\n\t\t\tlet match = this.rules.inline.emStrongLDelim.exec(src);\n\t\t\tif (!match)\n\t\t\t\treturn;\n\t\t\t// _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\t\t\tif (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n\t\t\t\treturn;\n\t\t\tconst nextChar = match[1] || match[2] || '';\n\t\t\tif (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n\t\t\t\t// unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n\t\t\t\tconst lLength = [...match[0]].length - 1;\n\t\t\t\tlet rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\t\t\t\tconst endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n\t\t\t\tendReg.lastIndex = 0;\n\t\t\t\t// Clip maskedSrc to same section of string as src (move to lexer?)\n\t\t\t\tmaskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\t\t\t\twhile ((match = endReg.exec(maskedSrc)) != null) {\n\t\t\t\t\trDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\t\t\t\t\tif (!rDelim)\n\t\t\t\t\t\tcontinue; // skip single * in __abc*abc__\n\t\t\t\t\trLength = [...rDelim].length;\n\t\t\t\t\tif (match[3] || match[4]) { // found another Left Delim\n\t\t\t\t\t\tdelimTotal += rLength;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (match[5] || match[6]) { // either Left or Right Delim\n\t\t\t\t\t\tif (lLength % 3 && !((lLength + rLength) % 3)) {\n\t\t\t\t\t\t\tmidDelimTotal += rLength;\n\t\t\t\t\t\t\tcontinue; // CommonMark Emphasis Rules 9-10\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelimTotal -= rLength;\n\t\t\t\t\tif (delimTotal > 0)\n\t\t\t\t\t\tcontinue; // Haven't found enough closing delimiters\n\t\t\t\t\t// Remove extra characters. *a*** -> *a*\n\t\t\t\t\trLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\t\t\t\t\t// char length can be >1 for unicode characters;\n\t\t\t\t\tconst lastCharLength = [...match[0]][0].length;\n\t\t\t\t\tconst raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\t\t\t\t\t// Create `em` if smallest delimiter has odd char count. *a***\n\t\t\t\t\tif (Math.min(lLength, rLength) % 2) {\n\t\t\t\t\t\tconst text = raw.slice(1, -1);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'em',\n\t\t\t\t\t\t\traw,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\ttokens: this.lexer.inlineTokens(text),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// Create 'strong' if smallest delimiter has even char count. **a***\n\t\t\t\t\tconst text = raw.slice(2, -2);\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'strong',\n\t\t\t\t\t\traw,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\ttokens: this.lexer.inlineTokens(text),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcodespan(src) {\n\t\t\tconst cap = this.rules.inline.code.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text = cap[2].replace(/\\n/g, ' ');\n\t\t\t\tconst hasNonSpaceChars = /[^ ]/.test(text);\n\t\t\t\tconst hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\t\t\t\tif (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n\t\t\t\t\ttext = text.substring(1, text.length - 1);\n\t\t\t\t}\n\t\t\t\ttext = escape$1(text, true);\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'codespan',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tbr(src) {\n\t\t\tconst cap = this.rules.inline.br.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'br',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tdel(src) {\n\t\t\tconst cap = this.rules.inline.del.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'del',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: cap[2],\n\t\t\t\t\ttokens: this.lexer.inlineTokens(cap[2]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tautolink(src) {\n\t\t\tconst cap = this.rules.inline.autolink.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text, href;\n\t\t\t\tif (cap[2] === '@') {\n\t\t\t\t\ttext = escape$1(cap[1]);\n\t\t\t\t\thref = 'mailto:' + text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = escape$1(cap[1]);\n\t\t\t\t\thref = text;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'link',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\thref,\n\t\t\t\t\ttokens: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: text,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\turl(src) {\n\t\t\tlet cap;\n\t\t\tif (cap = this.rules.inline.url.exec(src)) {\n\t\t\t\tlet text, href;\n\t\t\t\tif (cap[2] === '@') {\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t\thref = 'mailto:' + text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// do extended autolink path validation\n\t\t\t\t\tlet prevCapZero;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tprevCapZero = cap[0];\n\t\t\t\t\t\tcap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n\t\t\t\t\t} while (prevCapZero !== cap[0]);\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t\tif (cap[1] === 'www.') {\n\t\t\t\t\t\thref = 'http://' + cap[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thref = cap[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'link',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\thref,\n\t\t\t\t\ttokens: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: text,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tinlineText(src) {\n\t\t\tconst cap = this.rules.inline.text.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text;\n\t\t\t\tif (this.lexer.state.inRawBlock) {\n\t\t\t\t\ttext = cap[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Block-Level Grammar\n\t */\n\tconst newline = /^(?: *(?:\\n|$))+/;\n\tconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n\tconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n\tconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n\tconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n\tconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n\tconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n\t\t.replace(/bull/g, bullet) // lists can interrupt\n\t\t.replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n\t\t.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n\t\t.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n\t\t.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n\t\t.replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n\t\t.getRegex();\n\tconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n\tconst blockText = /^[^\\n]+/;\n\tconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n\tconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n\t\t.replace('label', _blockLabel)\n\t\t.replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n\t\t.getRegex();\n\tconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n\t\t.replace(/bull/g, bullet)\n\t\t.getRegex();\n\tconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n\t\t+ '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n\t\t+ '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n\t\t+ '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n\t\t+ '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n\t\t+ '|tr|track|ul';\n\tconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n\tconst html = edit('^ {0,3}(?:' // optional indentation\n\t\t+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n\t\t+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n\t\t+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n\t\t+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n\t\t+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n\t\t+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n\t\t+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n\t\t+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n\t\t+ ')', 'i')\n\t\t.replace('comment', _comment)\n\t\t.replace('tag', _tag)\n\t\t.replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n\t\t.getRegex();\n\tconst paragraph = edit(_paragraph)\n\t\t.replace('hr', hr)\n\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n\t\t.replace('|table', '')\n\t\t.replace('blockquote', ' {0,3}>')\n\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t.replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n\t\t.getRegex();\n\tconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n\t\t.replace('paragraph', paragraph)\n\t\t.getRegex();\n\t/**\n\t * Normal Block Grammar\n\t */\n\tconst blockNormal = {\n\t\tblockquote,\n\t\tcode: blockCode,\n\t\tdef,\n\t\tfences,\n\t\theading,\n\t\thr,\n\t\thtml,\n\t\tlheading,\n\t\tlist,\n\t\tnewline,\n\t\tparagraph,\n\t\ttable: noopTest,\n\t\ttext: blockText,\n\t};\n\t/**\n\t * GFM Block Grammar\n\t */\n\tconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n\t\t+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n\t\t+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n\t\t.replace('hr', hr)\n\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t.replace('blockquote', ' {0,3}>')\n\t\t.replace('code', ' {4}[^\\\\n]')\n\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t.replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n\t\t.getRegex();\n\tconst blockGfm = {\n\t\t...blockNormal,\n\t\ttable: gfmTable,\n\t\tparagraph: edit(_paragraph)\n\t\t\t.replace('hr', hr)\n\t\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t\t.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n\t\t\t.replace('table', gfmTable) // interrupt paragraphs with table\n\t\t\t.replace('blockquote', ' {0,3}>')\n\t\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t\t.replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * Pedantic grammar (original John Gruber's loose markdown specification)\n\t */\n\tconst blockPedantic = {\n\t\t...blockNormal,\n\t\thtml: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n\t\t\t+ '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n\t\t\t+ '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n\t\t\t.replace('comment', _comment)\n\t\t\t.replace(/tag/g, '(?!(?:'\n\t\t\t\t+ 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n\t\t\t\t+ '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n\t\t\t\t+ '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n\t\t\t.getRegex(),\n\t\tdef: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n\t\theading: /^(#{1,6})(.*)(?:\\n+|$)/,\n\t\tfences: noopTest, // fences not supported\n\t\tlheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n\t\tparagraph: edit(_paragraph)\n\t\t\t.replace('hr', hr)\n\t\t\t.replace('heading', ' *#{1,6} *[^\\n]')\n\t\t\t.replace('lheading', lheading)\n\t\t\t.replace('|table', '')\n\t\t\t.replace('blockquote', ' {0,3}>')\n\t\t\t.replace('|fences', '')\n\t\t\t.replace('|list', '')\n\t\t\t.replace('|html', '')\n\t\t\t.replace('|tag', '')\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * Inline-Level Grammar\n\t */\n\tconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n\tconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n\tconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n\tconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\t// list of unicode punctuation marks, plus any missing characters from CommonMark spec\n\tconst _punctuation = '\\\\p{P}\\\\p{S}';\n\tconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n\t\t.replace(/punctuation/g, _punctuation).getRegex();\n\t// sequences em should skip over [title](link), `code`, <html>\n\tconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n\tconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n\t\t+ '|[^*]+(?=[^*])' // Consume to delim\n\t\t+ '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n\t\t+ '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n\t\t+ '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n\t\t+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n\t\t+ '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n\t\t+ '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\t// (6) Not allowed for _\n\tconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n\t\t+ '|[^_]+(?=[^_])' // Consume to delim\n\t\t+ '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n\t\t+ '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n\t\t+ '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n\t\t+ '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n\t\t+ '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n\t\t.replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n\t\t.replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n\t\t.getRegex();\n\tconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n\tconst tag = edit('^comment'\n\t\t+ '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n\t\t+ '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n\t\t+ '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n\t\t+ '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n\t\t+ '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n\t\t.replace('comment', _inlineComment)\n\t\t.replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n\t\t.getRegex();\n\tconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\tconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n\t\t.replace('label', _inlineLabel)\n\t\t.replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n\t\t.replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n\t\t.getRegex();\n\tconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n\t\t.replace('label', _inlineLabel)\n\t\t.replace('ref', _blockLabel)\n\t\t.getRegex();\n\tconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n\t\t.replace('ref', _blockLabel)\n\t\t.getRegex();\n\tconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n\t\t.replace('reflink', reflink)\n\t\t.replace('nolink', nolink)\n\t\t.getRegex();\n\t/**\n\t * Normal Inline Grammar\n\t */\n\tconst inlineNormal = {\n\t\t_backpedal: noopTest, // only used for GFM url\n\t\tanyPunctuation,\n\t\tautolink,\n\t\tblockSkip,\n\t\tbr,\n\t\tcode: inlineCode,\n\t\tdel: noopTest,\n\t\temStrongLDelim,\n\t\temStrongRDelimAst,\n\t\temStrongRDelimUnd,\n\t\tescape,\n\t\tlink,\n\t\tnolink,\n\t\tpunctuation,\n\t\treflink,\n\t\treflinkSearch,\n\t\ttag,\n\t\ttext: inlineText,\n\t\turl: noopTest,\n\t};\n\t/**\n\t * Pedantic Inline Grammar\n\t */\n\tconst inlinePedantic = {\n\t\t...inlineNormal,\n\t\tlink: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n\t\t\t.replace('label', _inlineLabel)\n\t\t\t.getRegex(),\n\t\treflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n\t\t\t.replace('label', _inlineLabel)\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * GFM Inline Grammar\n\t */\n\tconst inlineGfm = {\n\t\t...inlineNormal,\n\t\tescape: edit(escape).replace('])', '~|])').getRegex(),\n\t\turl: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n\t\t\t.replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n\t\t\t.getRegex(),\n\t\t_backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n\t\tdel: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n\t\ttext: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n\t};\n\t/**\n\t * GFM + Line Breaks Inline Grammar\n\t */\n\tconst inlineBreaks = {\n\t\t...inlineGfm,\n\t\tbr: edit(br).replace('{2,}', '*').getRegex(),\n\t\ttext: edit(inlineGfm.text)\n\t\t\t.replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n\t\t\t.replace(/\\{2,\\}/g, '*')\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * exports\n\t */\n\tconst block = {\n\t\tnormal: blockNormal,\n\t\tgfm: blockGfm,\n\t\tpedantic: blockPedantic,\n\t};\n\tconst inline = {\n\t\tnormal: inlineNormal,\n\t\tgfm: inlineGfm,\n\t\tbreaks: inlineBreaks,\n\t\tpedantic: inlinePedantic,\n\t};\n\n\t/**\n\t * Block Lexer\n\t */\n\tclass _Lexer {\n\t\ttokens;\n\t\toptions;\n\t\tstate;\n\t\ttokenizer;\n\t\tinlineQueue;\n\t\tconstructor(options) {\n\t\t\t// TokenList cannot be created in one go\n\t\t\tthis.tokens = [];\n\t\t\tthis.tokens.links = Object.create(null);\n\t\t\tthis.options = options || exports.defaults;\n\t\t\tthis.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n\t\t\tthis.tokenizer = this.options.tokenizer;\n\t\t\tthis.tokenizer.options = this.options;\n\t\t\tthis.tokenizer.lexer = this;\n\t\t\tthis.inlineQueue = [];\n\t\t\tthis.state = {\n\t\t\t\tinLink: false,\n\t\t\t\tinRawBlock: false,\n\t\t\t\ttop: true,\n\t\t\t};\n\t\t\tconst rules = {\n\t\t\t\tblock: block.normal,\n\t\t\t\tinline: inline.normal,\n\t\t\t};\n\t\t\tif (this.options.pedantic) {\n\t\t\t\trules.block = block.pedantic;\n\t\t\t\trules.inline = inline.pedantic;\n\t\t\t}\n\t\t\telse if (this.options.gfm) {\n\t\t\t\trules.block = block.gfm;\n\t\t\t\tif (this.options.breaks) {\n\t\t\t\t\trules.inline = inline.breaks;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trules.inline = inline.gfm;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tokenizer.rules = rules;\n\t\t}\n\t\t/**\n\t\t * Expose Rules\n\t\t */\n\t\tstatic get rules() {\n\t\t\treturn {\n\t\t\t\tblock,\n\t\t\t\tinline,\n\t\t\t};\n\t\t}\n\t\t/**\n\t\t * Static Lex Method\n\t\t */\n\t\tstatic lex(src, options) {\n\t\t\tconst lexer = new _Lexer(options);\n\t\t\treturn lexer.lex(src);\n\t\t}\n\t\t/**\n\t\t * Static Lex Inline Method\n\t\t */\n\t\tstatic lexInline(src, options) {\n\t\t\tconst lexer = new _Lexer(options);\n\t\t\treturn lexer.inlineTokens(src);\n\t\t}\n\t\t/**\n\t\t * Preprocessing\n\t\t */\n\t\tlex(src) {\n\t\t\tsrc = src\n\t\t\t\t.replace(/\\r\\n|\\r/g, '\\n');\n\t\t\tthis.blockTokens(src, this.tokens);\n\t\t\tfor (let i = 0; i < this.inlineQueue.length; i++) {\n\t\t\t\tconst next = this.inlineQueue[i];\n\t\t\t\tthis.inlineTokens(next.src, next.tokens);\n\t\t\t}\n\t\t\tthis.inlineQueue = [];\n\t\t\treturn this.tokens;\n\t\t}\n\t\tblockTokens(src, tokens = [], lastParagraphClipped = false) {\n\t\t\tif (this.options.pedantic) {\n\t\t\t\tsrc = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrc = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n\t\t\t\t\treturn leading + '    '.repeat(tabs.length);\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet token;\n\t\t\tlet lastToken;\n\t\t\tlet cutSrc;\n\t\t\twhile (src) {\n\t\t\t\tif (this.options.extensions\n\t\t\t\t\t&& this.options.extensions.block\n\t\t\t\t\t&& this.options.extensions.block.some((extTokenizer) => {\n\t\t\t\t\t\tif (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n\t\t\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t})) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// newline\n\t\t\t\tif (token = this.tokenizer.space(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tif (token.raw.length === 1 && tokens.length > 0) {\n\t\t\t\t\t\t// if there's a single \\n as a spacer, it's terminating the last line,\n\t\t\t\t\t\t// so move it there so that we don't get unnecessary paragraph tags\n\t\t\t\t\t\ttokens[tokens.length - 1].raw += '\\n';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// code\n\t\t\t\tif (token = this.tokenizer.code(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\t// An indented code block cannot interrupt a paragraph.\n\t\t\t\t\tif (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// fences\n\t\t\t\tif (token = this.tokenizer.fences(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// heading\n\t\t\t\tif (token = this.tokenizer.heading(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// hr\n\t\t\t\tif (token = this.tokenizer.hr(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// blockquote\n\t\t\t\tif (token = this.tokenizer.blockquote(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// list\n\t\t\t\tif (token = this.tokenizer.list(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// html\n\t\t\t\tif (token = this.tokenizer.html(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// def\n\t\t\t\tif (token = this.tokenizer.def(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.raw;\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.tokens.links[token.tag]) {\n\t\t\t\t\t\tthis.tokens.links[token.tag] = {\n\t\t\t\t\t\t\thref: token.href,\n\t\t\t\t\t\t\ttitle: token.title,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// table (gfm)\n\t\t\t\tif (token = this.tokenizer.table(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// lheading\n\t\t\t\tif (token = this.tokenizer.lheading(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// top-level paragraph\n\t\t\t\t// prevent paragraph consuming extensions by clipping 'src' to extension start\n\t\t\t\tcutSrc = src;\n\t\t\t\tif (this.options.extensions && this.options.extensions.startBlock) {\n\t\t\t\t\tlet startIndex = Infinity;\n\t\t\t\t\tconst tempSrc = src.slice(1);\n\t\t\t\t\tlet tempStart;\n\t\t\t\t\tthis.options.extensions.startBlock.forEach((getStartIndex) => {\n\t\t\t\t\t\ttempStart = getStartIndex.call({ lexer: this }, tempSrc);\n\t\t\t\t\t\tif (typeof tempStart === 'number' && tempStart >= 0) {\n\t\t\t\t\t\t\tstartIndex = Math.min(startIndex, tempStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (startIndex < Infinity && startIndex >= 0) {\n\t\t\t\t\t\tcutSrc = src.substring(0, startIndex + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastParagraphClipped && lastToken?.type === 'paragraph') {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue.pop();\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tlastParagraphClipped = (cutSrc.length !== src.length);\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// text\n\t\t\t\tif (token = this.tokenizer.text(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue.pop();\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tconst errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.state.top = true;\n\t\t\treturn tokens;\n\t\t}\n\t\tinline(src, tokens = []) {\n\t\t\tthis.inlineQueue.push({ src, tokens });\n\t\t\treturn tokens;\n\t\t}\n\t\t/**\n\t\t * Lexing/Compiling\n\t\t */\n\t\tinlineTokens(src, tokens = []) {\n\t\t\tlet token, lastToken, cutSrc;\n\t\t\t// String with links masked to avoid interference with em and strong\n\t\t\tlet maskedSrc = src;\n\t\t\tlet match;\n\t\t\tlet keepPrevChar, prevChar;\n\t\t\t// Mask out reflinks\n\t\t\tif (this.tokens.links) {\n\t\t\t\tconst links = Object.keys(this.tokens.links);\n\t\t\t\tif (links.length > 0) {\n\t\t\t\t\twhile ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n\t\t\t\t\t\tif (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n\t\t\t\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Mask out other blocks\n\t\t\twhile ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n\t\t\t}\n\t\t\t// Mask out escaped characters\n\t\t\twhile ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n\t\t\t}\n\t\t\twhile (src) {\n\t\t\t\tif (!keepPrevChar) {\n\t\t\t\t\tprevChar = '';\n\t\t\t\t}\n\t\t\t\tkeepPrevChar = false;\n\t\t\t\t// extensions\n\t\t\t\tif (this.options.extensions\n\t\t\t\t\t&& this.options.extensions.inline\n\t\t\t\t\t&& this.options.extensions.inline.some((extTokenizer) => {\n\t\t\t\t\t\tif (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n\t\t\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t})) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// escape\n\t\t\t\tif (token = this.tokenizer.escape(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// tag\n\t\t\t\tif (token = this.tokenizer.tag(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && token.type === 'text' && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// link\n\t\t\t\tif (token = this.tokenizer.link(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// reflink, nolink\n\t\t\t\tif (token = this.tokenizer.reflink(src, this.tokens.links)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && token.type === 'text' && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// em & strong\n\t\t\t\tif (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// code\n\t\t\t\tif (token = this.tokenizer.codespan(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// br\n\t\t\t\tif (token = this.tokenizer.br(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// del (gfm)\n\t\t\t\tif (token = this.tokenizer.del(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// autolink\n\t\t\t\tif (token = this.tokenizer.autolink(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// url (gfm)\n\t\t\t\tif (!this.state.inLink && (token = this.tokenizer.url(src))) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// text\n\t\t\t\t// prevent inlineText consuming extensions by clipping 'src' to extension start\n\t\t\t\tcutSrc = src;\n\t\t\t\tif (this.options.extensions && this.options.extensions.startInline) {\n\t\t\t\t\tlet startIndex = Infinity;\n\t\t\t\t\tconst tempSrc = src.slice(1);\n\t\t\t\t\tlet tempStart;\n\t\t\t\t\tthis.options.extensions.startInline.forEach((getStartIndex) => {\n\t\t\t\t\t\ttempStart = getStartIndex.call({ lexer: this }, tempSrc);\n\t\t\t\t\t\tif (typeof tempStart === 'number' && tempStart >= 0) {\n\t\t\t\t\t\t\tstartIndex = Math.min(startIndex, tempStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (startIndex < Infinity && startIndex >= 0) {\n\t\t\t\t\t\tcutSrc = src.substring(0, startIndex + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (token = this.tokenizer.inlineText(cutSrc)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tif (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n\t\t\t\t\t\tprevChar = token.raw.slice(-1);\n\t\t\t\t\t}\n\t\t\t\t\tkeepPrevChar = true;\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tconst errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\t/**\n\t * Renderer\n\t */\n\tclass _Renderer {\n\t\toptions;\n\t\tparser; // set by the parser\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tspace(token) {\n\t\t\treturn '';\n\t\t}\n\t\tcode({ text, lang, escaped }) {\n\t\t\tconst langString = (lang || '').match(/^\\S*/)?.[0];\n\t\t\tconst code = text.replace(/\\n$/, '') + '\\n';\n\t\t\tif (!langString) {\n\t\t\t\treturn '<pre><code>'\n\t\t\t\t\t+ (escaped ? code : escape$1(code, true))\n\t\t\t\t\t+ '</code></pre>\\n';\n\t\t\t}\n\t\t\treturn '<pre><code class=\"language-'\n\t\t\t\t+ escape$1(langString)\n\t\t\t\t+ '\">'\n\t\t\t\t+ (escaped ? code : escape$1(code, true))\n\t\t\t\t+ '</code></pre>\\n';\n\t\t}\n\t\tblockquote({ tokens }) {\n\t\t\tconst body = this.parser.parse(tokens);\n\t\t\treturn `<blockquote>\\n${body}</blockquote>\\n`;\n\t\t}\n\t\thtml({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\theading({ tokens, depth }) {\n\t\t\treturn `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n\t\t}\n\t\thr(token) {\n\t\t\treturn '<hr>\\n';\n\t\t}\n\t\tlist(token) {\n\t\t\tconst ordered = token.ordered;\n\t\t\tconst start = token.start;\n\t\t\tlet body = '';\n\t\t\tfor (let j = 0; j < token.items.length; j++) {\n\t\t\t\tconst item = token.items[j];\n\t\t\t\tbody += this.listitem(item);\n\t\t\t}\n\t\t\tconst type = ordered ? 'ol' : 'ul';\n\t\t\tconst startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n\t\t\treturn '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n\t\t}\n\t\tlistitem(item) {\n\t\t\tlet itemBody = '';\n\t\t\tif (item.task) {\n\t\t\t\tconst checkbox = this.checkbox({ checked: !!item.checked });\n\t\t\t\tif (item.loose) {\n\t\t\t\t\tif (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n\t\t\t\t\t\titem.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\t\t\t\t\t\tif (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n\t\t\t\t\t\t\titem.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.tokens.unshift({\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: checkbox + ' ',\n\t\t\t\t\t\t\ttext: checkbox + ' ',\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titemBody += checkbox + ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\titemBody += this.parser.parse(item.tokens, !!item.loose);\n\t\t\treturn `<li>${itemBody}</li>\\n`;\n\t\t}\n\t\tcheckbox({ checked }) {\n\t\t\treturn '<input '\n\t\t\t\t+ (checked ? 'checked=\"\" ' : '')\n\t\t\t\t+ 'disabled=\"\" type=\"checkbox\">';\n\t\t}\n\t\tparagraph({ tokens }) {\n\t\t\treturn `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n\t\t}\n\t\ttable(token) {\n\t\t\tlet header = '';\n\t\t\t// header\n\t\t\tlet cell = '';\n\t\t\tfor (let j = 0; j < token.header.length; j++) {\n\t\t\t\tcell += this.tablecell(token.header[j]);\n\t\t\t}\n\t\t\theader += this.tablerow({ text: cell });\n\t\t\tlet body = '';\n\t\t\tfor (let j = 0; j < token.rows.length; j++) {\n\t\t\t\tconst row = token.rows[j];\n\t\t\t\tcell = '';\n\t\t\t\tfor (let k = 0; k < row.length; k++) {\n\t\t\t\t\tcell += this.tablecell(row[k]);\n\t\t\t\t}\n\t\t\t\tbody += this.tablerow({ text: cell });\n\t\t\t}\n\t\t\tif (body)\n\t\t\t\tbody = `<tbody>${body}</tbody>`;\n\t\t\treturn '<table>\\n'\n\t\t\t\t+ '<thead>\\n'\n\t\t\t\t+ header\n\t\t\t\t+ '</thead>\\n'\n\t\t\t\t+ body\n\t\t\t\t+ '</table>\\n';\n\t\t}\n\t\ttablerow({ text }) {\n\t\t\treturn `<tr>\\n${text}</tr>\\n`;\n\t\t}\n\t\ttablecell(token) {\n\t\t\tconst content = this.parser.parseInline(token.tokens);\n\t\t\tconst type = token.header ? 'th' : 'td';\n\t\t\tconst tag = token.align\n\t\t\t\t? `<${type} align=\"${token.align}\">`\n\t\t\t\t: `<${type}>`;\n\t\t\treturn tag + content + `</${type}>\\n`;\n\t\t}\n\t\t/**\n\t\t * span level renderer\n\t\t */\n\t\tstrong({ tokens }) {\n\t\t\treturn `<strong>${this.parser.parseInline(tokens)}</strong>`;\n\t\t}\n\t\tem({ tokens }) {\n\t\t\treturn `<em>${this.parser.parseInline(tokens)}</em>`;\n\t\t}\n\t\tcodespan({ text }) {\n\t\t\treturn `<code>${text}</code>`;\n\t\t}\n\t\tbr(token) {\n\t\t\treturn '<br>';\n\t\t}\n\t\tdel({ tokens }) {\n\t\t\treturn `<del>${this.parser.parseInline(tokens)}</del>`;\n\t\t}\n\t\tlink({ href, title, tokens }) {\n\t\t\tconst text = this.parser.parseInline(tokens);\n\t\t\tconst cleanHref = cleanUrl(href);\n\t\t\tif (cleanHref === null) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\thref = cleanHref;\n\t\t\tlet out = '<a href=\"' + href + '\"';\n\t\t\tif (title) {\n\t\t\t\tout += ' title=\"' + title + '\"';\n\t\t\t}\n\t\t\tout += '>' + text + '</a>';\n\t\t\treturn out;\n\t\t}\n\t\timage({ href, title, text }) {\n\t\t\tconst cleanHref = cleanUrl(href);\n\t\t\tif (cleanHref === null) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\thref = cleanHref;\n\t\t\tlet out = `<img src=\"${href}\" alt=\"${text}\"`;\n\t\t\tif (title) {\n\t\t\t\tout += ` title=\"${title}\"`;\n\t\t\t}\n\t\t\tout += '>';\n\t\t\treturn out;\n\t\t}\n\t\ttext(token) {\n\t\t\treturn 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n\t\t}\n\t}\n\n\t/**\n\t * TextRenderer\n\t * returns only the textual part of the token\n\t */\n\tclass _TextRenderer {\n\t\t// no need for block level renderers\n\t\tstrong({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tem({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tcodespan({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tdel({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\thtml({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\ttext({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tlink({ text }) {\n\t\t\treturn '' + text;\n\t\t}\n\t\timage({ text }) {\n\t\t\treturn '' + text;\n\t\t}\n\t\tbr() {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\t/**\n\t * Parsing & Compiling\n\t */\n\tclass _Parser {\n\t\toptions;\n\t\trenderer;\n\t\ttextRenderer;\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t\tthis.options.renderer = this.options.renderer || new _Renderer();\n\t\t\tthis.renderer = this.options.renderer;\n\t\t\tthis.renderer.options = this.options;\n\t\t\tthis.renderer.parser = this;\n\t\t\tthis.textRenderer = new _TextRenderer();\n\t\t}\n\t\t/**\n\t\t * Static Parse Method\n\t\t */\n\t\tstatic parse(tokens, options) {\n\t\t\tconst parser = new _Parser(options);\n\t\t\treturn parser.parse(tokens);\n\t\t}\n\t\t/**\n\t\t * Static Parse Inline Method\n\t\t */\n\t\tstatic parseInline(tokens, options) {\n\t\t\tconst parser = new _Parser(options);\n\t\t\treturn parser.parseInline(tokens);\n\t\t}\n\t\t/**\n\t\t * Parse Loop\n\t\t */\n\t\tparse(tokens, top = true) {\n\t\t\tlet out = '';\n\t\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\t\tconst anyToken = tokens[i];\n\t\t\t\t// Run any renderer extensions\n\t\t\t\tif (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n\t\t\t\t\tconst genericToken = anyToken;\n\t\t\t\t\tconst ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n\t\t\t\t\tif (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n\t\t\t\t\t\tout += ret || '';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst token = anyToken;\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'space': {\n\t\t\t\t\t\tout += this.renderer.space(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'hr': {\n\t\t\t\t\t\tout += this.renderer.hr(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'heading': {\n\t\t\t\t\t\tout += this.renderer.heading(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'code': {\n\t\t\t\t\t\tout += this.renderer.code(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'table': {\n\t\t\t\t\t\tout += this.renderer.table(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'blockquote': {\n\t\t\t\t\t\tout += this.renderer.blockquote(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'list': {\n\t\t\t\t\t\tout += this.renderer.list(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'html': {\n\t\t\t\t\t\tout += this.renderer.html(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'paragraph': {\n\t\t\t\t\t\tout += this.renderer.paragraph(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'text': {\n\t\t\t\t\t\tlet textToken = token;\n\t\t\t\t\t\tlet body = this.renderer.text(textToken);\n\t\t\t\t\t\twhile (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n\t\t\t\t\t\t\ttextToken = tokens[++i];\n\t\t\t\t\t\t\tbody += '\\n' + this.renderer.text(textToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (top) {\n\t\t\t\t\t\t\tout += this.renderer.paragraph({\n\t\t\t\t\t\t\t\ttype: 'paragraph',\n\t\t\t\t\t\t\t\traw: body,\n\t\t\t\t\t\t\t\ttext: body,\n\t\t\t\t\t\t\t\ttokens: [{ type: 'text', raw: body, text: body }],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tout += body;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\t\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\t/**\n\t\t * Parse Inline Tokens\n\t\t */\n\t\tparseInline(tokens, renderer) {\n\t\t\trenderer = renderer || this.renderer;\n\t\t\tlet out = '';\n\t\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\t\tconst anyToken = tokens[i];\n\t\t\t\t// Run any renderer extensions\n\t\t\t\tif (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n\t\t\t\t\tconst ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n\t\t\t\t\tif (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n\t\t\t\t\t\tout += ret || '';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst token = anyToken;\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'escape': {\n\t\t\t\t\t\tout += renderer.text(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'html': {\n\t\t\t\t\t\tout += renderer.html(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'link': {\n\t\t\t\t\t\tout += renderer.link(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'image': {\n\t\t\t\t\t\tout += renderer.image(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'strong': {\n\t\t\t\t\t\tout += renderer.strong(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'em': {\n\t\t\t\t\t\tout += renderer.em(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'codespan': {\n\t\t\t\t\t\tout += renderer.codespan(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'br': {\n\t\t\t\t\t\tout += renderer.br(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'del': {\n\t\t\t\t\t\tout += renderer.del(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'text': {\n\t\t\t\t\t\tout += renderer.text(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\t\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t}\n\n\tclass _Hooks {\n\t\toptions;\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tstatic passThroughHooks = new Set([\n\t\t\t'preprocess',\n\t\t\t'postprocess',\n\t\t\t'processAllTokens',\n\t\t]);\n\t\t/**\n\t\t * Process markdown before marked\n\t\t */\n\t\tpreprocess(markdown) {\n\t\t\treturn markdown;\n\t\t}\n\t\t/**\n\t\t * Process HTML after marked is finished\n\t\t */\n\t\tpostprocess(html) {\n\t\t\treturn html;\n\t\t}\n\t\t/**\n\t\t * Process all tokens before walk tokens\n\t\t */\n\t\tprocessAllTokens(tokens) {\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tclass Marked {\n\t\tdefaults = _getDefaults();\n\t\toptions = this.setOptions;\n\t\tparse = this.parseMarkdown(_Lexer.lex, _Parser.parse);\n\t\tparseInline = this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n\t\tParser = _Parser;\n\t\tRenderer = _Renderer;\n\t\tTextRenderer = _TextRenderer;\n\t\tLexer = _Lexer;\n\t\tTokenizer = _Tokenizer;\n\t\tHooks = _Hooks;\n\t\tconstructor(...args) {\n\t\t\tthis.use(...args);\n\t\t}\n\t\t/**\n\t\t * Run callback for every token\n\t\t */\n\t\twalkTokens(tokens, callback) {\n\t\t\tlet values = [];\n\t\t\tfor (const token of tokens) {\n\t\t\t\tvalues = values.concat(callback.call(this, token));\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'table': {\n\t\t\t\t\t\tconst tableToken = token;\n\t\t\t\t\t\tfor (const cell of tableToken.header) {\n\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(cell.tokens, callback));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const row of tableToken.rows) {\n\t\t\t\t\t\t\tfor (const cell of row) {\n\t\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(cell.tokens, callback));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'list': {\n\t\t\t\t\t\tconst listToken = token;\n\t\t\t\t\t\tvalues = values.concat(this.walkTokens(listToken.items, callback));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst genericToken = token;\n\t\t\t\t\t\tif (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n\t\t\t\t\t\t\tthis.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n\t\t\t\t\t\t\t\tconst tokens = genericToken[childTokens].flat(Infinity);\n\t\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(tokens, callback));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (genericToken.tokens) {\n\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(genericToken.tokens, callback));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t\tuse(...args) {\n\t\t\tconst extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\t\t\targs.forEach((pack) => {\n\t\t\t\t// copy options to new object\n\t\t\t\tconst opts = { ...pack };\n\t\t\t\t// set async to true if it was set to true before\n\t\t\t\topts.async = this.defaults.async || opts.async || false;\n\t\t\t\t// ==-- Parse \"addon\" extensions --== //\n\t\t\t\tif (pack.extensions) {\n\t\t\t\t\tpack.extensions.forEach((ext) => {\n\t\t\t\t\t\tif (!ext.name) {\n\t\t\t\t\t\t\tthrow new Error('extension name required');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('renderer' in ext) { // Renderer extensions\n\t\t\t\t\t\t\tconst prevRenderer = extensions.renderers[ext.name];\n\t\t\t\t\t\t\tif (prevRenderer) {\n\t\t\t\t\t\t\t\t// Replace extension with func to run new extension but fall back if false\n\t\t\t\t\t\t\t\textensions.renderers[ext.name] = function (...args) {\n\t\t\t\t\t\t\t\t\tlet ret = ext.renderer.apply(this, args);\n\t\t\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\t\t\tret = prevRenderer.apply(this, args);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\textensions.renderers[ext.name] = ext.renderer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('tokenizer' in ext) { // Tokenizer Extensions\n\t\t\t\t\t\t\tif (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n\t\t\t\t\t\t\t\tthrow new Error(\"extension level must be 'block' or 'inline'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst extLevel = extensions[ext.level];\n\t\t\t\t\t\t\tif (extLevel) {\n\t\t\t\t\t\t\t\textLevel.unshift(ext.tokenizer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\textensions[ext.level] = [ext.tokenizer];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ext.start) { // Function to check for start of token\n\t\t\t\t\t\t\t\tif (ext.level === 'block') {\n\t\t\t\t\t\t\t\t\tif (extensions.startBlock) {\n\t\t\t\t\t\t\t\t\t\textensions.startBlock.push(ext.start);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\textensions.startBlock = [ext.start];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ext.level === 'inline') {\n\t\t\t\t\t\t\t\t\tif (extensions.startInline) {\n\t\t\t\t\t\t\t\t\t\textensions.startInline.push(ext.start);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\textensions.startInline = [ext.start];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n\t\t\t\t\t\t\textensions.childTokens[ext.name] = ext.childTokens;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\topts.extensions = extensions;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse \"overwrite\" extensions --== //\n\t\t\t\tif (pack.renderer) {\n\t\t\t\t\tconst renderer = this.defaults.renderer || new _Renderer(this.defaults);\n\t\t\t\t\tfor (const prop in pack.renderer) {\n\t\t\t\t\t\tif (!(prop in renderer)) {\n\t\t\t\t\t\t\tthrow new Error(`renderer '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (['options', 'parser'].includes(prop)) {\n\t\t\t\t\t\t\t// ignore options property\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst rendererProp = prop;\n\t\t\t\t\t\tconst rendererFunc = pack.renderer[rendererProp];\n\t\t\t\t\t\tconst prevRenderer = renderer[rendererProp];\n\t\t\t\t\t\t// Replace renderer with func to run extension, but fall back if false\n\t\t\t\t\t\trenderer[rendererProp] = (...args) => {\n\t\t\t\t\t\t\tlet ret = rendererFunc.apply(renderer, args);\n\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\tret = prevRenderer.apply(renderer, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ret || '';\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\topts.renderer = renderer;\n\t\t\t\t}\n\t\t\t\tif (pack.tokenizer) {\n\t\t\t\t\tconst tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n\t\t\t\t\tfor (const prop in pack.tokenizer) {\n\t\t\t\t\t\tif (!(prop in tokenizer)) {\n\t\t\t\t\t\t\tthrow new Error(`tokenizer '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (['options', 'rules', 'lexer'].includes(prop)) {\n\t\t\t\t\t\t\t// ignore options, rules, and lexer properties\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst tokenizerProp = prop;\n\t\t\t\t\t\tconst tokenizerFunc = pack.tokenizer[tokenizerProp];\n\t\t\t\t\t\tconst prevTokenizer = tokenizer[tokenizerProp];\n\t\t\t\t\t\t// Replace tokenizer with func to run extension, but fall back if false\n\t\t\t\t\t\t// @ts-expect-error cannot type tokenizer function dynamically\n\t\t\t\t\t\ttokenizer[tokenizerProp] = (...args) => {\n\t\t\t\t\t\t\tlet ret = tokenizerFunc.apply(tokenizer, args);\n\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\tret = prevTokenizer.apply(tokenizer, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\topts.tokenizer = tokenizer;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse Hooks extensions --== //\n\t\t\t\tif (pack.hooks) {\n\t\t\t\t\tconst hooks = this.defaults.hooks || new _Hooks();\n\t\t\t\t\tfor (const prop in pack.hooks) {\n\t\t\t\t\t\tif (!(prop in hooks)) {\n\t\t\t\t\t\t\tthrow new Error(`hook '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (prop === 'options') {\n\t\t\t\t\t\t\t// ignore options property\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hooksProp = prop;\n\t\t\t\t\t\tconst hooksFunc = pack.hooks[hooksProp];\n\t\t\t\t\t\tconst prevHook = hooks[hooksProp];\n\t\t\t\t\t\tif (_Hooks.passThroughHooks.has(prop)) {\n\t\t\t\t\t\t\t// @ts-expect-error cannot type hook function dynamically\n\t\t\t\t\t\t\thooks[hooksProp] = (arg) => {\n\t\t\t\t\t\t\t\tif (this.defaults.async) {\n\t\t\t\t\t\t\t\t\treturn Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n\t\t\t\t\t\t\t\t\t\treturn prevHook.call(hooks, ret);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst ret = hooksFunc.call(hooks, arg);\n\t\t\t\t\t\t\t\treturn prevHook.call(hooks, ret);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// @ts-expect-error cannot type hook function dynamically\n\t\t\t\t\t\t\thooks[hooksProp] = (...args) => {\n\t\t\t\t\t\t\t\tlet ret = hooksFunc.apply(hooks, args);\n\t\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\t\tret = prevHook.apply(hooks, args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\topts.hooks = hooks;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse WalkTokens extensions --== //\n\t\t\t\tif (pack.walkTokens) {\n\t\t\t\t\tconst walkTokens = this.defaults.walkTokens;\n\t\t\t\t\tconst packWalktokens = pack.walkTokens;\n\t\t\t\t\topts.walkTokens = function (token) {\n\t\t\t\t\t\tlet values = [];\n\t\t\t\t\t\tvalues.push(packWalktokens.call(this, token));\n\t\t\t\t\t\tif (walkTokens) {\n\t\t\t\t\t\t\tvalues = values.concat(walkTokens.call(this, token));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn values;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.defaults = { ...this.defaults, ...opts };\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tsetOptions(opt) {\n\t\t\tthis.defaults = { ...this.defaults, ...opt };\n\t\t\treturn this;\n\t\t}\n\t\tlexer(src, options) {\n\t\t\treturn _Lexer.lex(src, options ?? this.defaults);\n\t\t}\n\t\tparser(tokens, options) {\n\t\t\treturn _Parser.parse(tokens, options ?? this.defaults);\n\t\t}\n\t\tparseMarkdown(lexer, parser) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst parse = (src, options) => {\n\t\t\t\tconst origOpt = { ...options };\n\t\t\t\tconst opt = { ...this.defaults, ...origOpt };\n\t\t\t\tconst throwError = this.onError(!!opt.silent, !!opt.async);\n\t\t\t\t// throw error if an extension set async to true but parse was called with async: false\n\t\t\t\tif (this.defaults.async === true && origOpt.async === false) {\n\t\t\t\t\treturn throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n\t\t\t\t}\n\t\t\t\t// throw error in case of non string input\n\t\t\t\tif (typeof src === 'undefined' || src === null) {\n\t\t\t\t\treturn throwError(new Error('marked(): input parameter is undefined or null'));\n\t\t\t\t}\n\t\t\t\tif (typeof src !== 'string') {\n\t\t\t\t\treturn throwError(new Error('marked(): input parameter is of type '\n\t\t\t\t\t\t+ Object.prototype.toString.call(src) + ', string expected'));\n\t\t\t\t}\n\t\t\t\tif (opt.hooks) {\n\t\t\t\t\topt.hooks.options = opt;\n\t\t\t\t}\n\t\t\t\tif (opt.async) {\n\t\t\t\t\treturn Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n\t\t\t\t\t\t.then(src => lexer(src, opt))\n\t\t\t\t\t\t.then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n\t\t\t\t\t\t.then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n\t\t\t\t\t\t.then(tokens => parser(tokens, opt))\n\t\t\t\t\t\t.then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n\t\t\t\t\t\t.catch(throwError);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\tsrc = opt.hooks.preprocess(src);\n\t\t\t\t\t}\n\t\t\t\t\tlet tokens = lexer(src, opt);\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\ttokens = opt.hooks.processAllTokens(tokens);\n\t\t\t\t\t}\n\t\t\t\t\tif (opt.walkTokens) {\n\t\t\t\t\t\tthis.walkTokens(tokens, opt.walkTokens);\n\t\t\t\t\t}\n\t\t\t\t\tlet html = parser(tokens, opt);\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\thtml = opt.hooks.postprocess(html);\n\t\t\t\t\t}\n\t\t\t\t\treturn html;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\treturn throwError(e);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn parse;\n\t\t}\n\t\tonError(silent, async) {\n\t\t\treturn (e) => {\n\t\t\t\te.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\t\t\t\tif (silent) {\n\t\t\t\t\tconst msg = '<p>An error occurred:</p><pre>'\n\t\t\t\t\t\t+ escape$1(e.message + '', true)\n\t\t\t\t\t\t+ '</pre>';\n\t\t\t\t\tif (async) {\n\t\t\t\t\t\treturn Promise.resolve(msg);\n\t\t\t\t\t}\n\t\t\t\t\treturn msg;\n\t\t\t\t}\n\t\t\t\tif (async) {\n\t\t\t\t\treturn Promise.reject(e);\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t};\n\t\t}\n\t}\n\n\tconst markedInstance = new Marked();\n\tfunction marked(src, opt) {\n\t\treturn markedInstance.parse(src, opt);\n\t}\n\t/**\n\t * Sets the default options.\n\t *\n\t * @param options Hash of options\n\t */\n\tmarked.options =\n\t\tmarked.setOptions = function (options) {\n\t\t\tmarkedInstance.setOptions(options);\n\t\t\tmarked.defaults = markedInstance.defaults;\n\t\t\tchangeDefaults(marked.defaults);\n\t\t\treturn marked;\n\t\t};\n\t/**\n\t * Gets the original marked default options.\n\t */\n\tmarked.getDefaults = _getDefaults;\n\tmarked.defaults = exports.defaults;\n\t/**\n\t * Use Extension\n\t */\n\tmarked.use = function (...args) {\n\t\tmarkedInstance.use(...args);\n\t\tmarked.defaults = markedInstance.defaults;\n\t\tchangeDefaults(marked.defaults);\n\t\treturn marked;\n\t};\n\t/**\n\t * Run callback for every token\n\t */\n\tmarked.walkTokens = function (tokens, callback) {\n\t\treturn markedInstance.walkTokens(tokens, callback);\n\t};\n\t/**\n\t * Compiles markdown to HTML without enclosing `p` tag.\n\t *\n\t * @param src String of markdown source to be compiled\n\t * @param options Hash of options\n\t * @return String of compiled HTML\n\t */\n\tmarked.parseInline = markedInstance.parseInline;\n\t/**\n\t * Expose\n\t */\n\tmarked.Parser = _Parser;\n\tmarked.parser = _Parser.parse;\n\tmarked.Renderer = _Renderer;\n\tmarked.TextRenderer = _TextRenderer;\n\tmarked.Lexer = _Lexer;\n\tmarked.lexer = _Lexer.lex;\n\tmarked.Tokenizer = _Tokenizer;\n\tmarked.Hooks = _Hooks;\n\tmarked.parse = marked;\n\tconst options = marked.options;\n\tconst setOptions = marked.setOptions;\n\tconst use = marked.use;\n\tconst walkTokens = marked.walkTokens;\n\tconst parseInline = marked.parseInline;\n\tconst parse = marked;\n\tconst parser = _Parser.parse;\n\tconst lexer = _Lexer.lex;\n\n\texports.Hooks = _Hooks;\n\texports.Lexer = _Lexer;\n\texports.Marked = Marked;\n\texports.Parser = _Parser;\n\texports.Renderer = _Renderer;\n\texports.TextRenderer = _TextRenderer;\n\texports.Tokenizer = _Tokenizer;\n\texports.getDefaults = _getDefaults;\n\texports.lexer = lexer;\n\texports.marked = marked;\n\texports.options = options;\n\texports.parse = parse;\n\texports.parseInline = parseInline;\n\texports.parser = parser;\n\texports.setOptions = setOptions;\n\texports.use = use;\n\texports.walkTokens = walkTokens;\n}));\n\n// ESM-uncomment-begin\n})();\nexport var Hooks = (__marked_exports.Hooks || exports.Hooks);\nexport var Lexer = (__marked_exports.Lexer || exports.Lexer);\nexport var Marked = (__marked_exports.Marked || exports.Marked);\nexport var Parser = (__marked_exports.Parser || exports.Parser);\nexport var Renderer = (__marked_exports.Renderer || exports.Renderer);\nexport var TextRenderer = (__marked_exports.TextRenderer || exports.TextRenderer);\nexport var Tokenizer = (__marked_exports.Tokenizer || exports.Tokenizer);\nexport var defaults = (__marked_exports.defaults || exports.defaults);\nexport var getDefaults = (__marked_exports.getDefaults || exports.getDefaults);\nexport var lexer = (__marked_exports.lexer || exports.lexer);\nexport var marked = (__marked_exports.marked || exports.marked);\nexport var options = (__marked_exports.options || exports.options);\nexport var parse = (__marked_exports.parse || exports.parse);\nexport var parseInline = (__marked_exports.parseInline || exports.parseInline);\nexport var parser = (__marked_exports.parser || exports.parser);\nexport var setOptions = (__marked_exports.setOptions || exports.setOptions);\nexport var use = (__marked_exports.use || exports.use);\nexport var walkTokens = (__marked_exports.walkTokens || exports.walkTokens);\n// ESM-uncomment-end\n\n//# sourceMappingURL=marked.umd.js.map\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nimport * as dompurify from './dompurify/dompurify.js';\nimport { DomEmitter } from './event.js';\nimport { createElement } from './formattedTextRenderer.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\nimport { onUnexpectedError } from '../common/errors.js';\nimport { Event } from '../common/event.js';\nimport { escapeDoubleQuotes, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore, toDisposable } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nconst defaultMarkedRenderers = Object.freeze({\n    image: ({ href, title, text }) => {\n        let dimensions = [];\n        let attributes = [];\n        if (href) {\n            ({ href, dimensions } = parseHrefAndDimensions(href));\n            attributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n        }\n        if (text) {\n            attributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n        }\n        if (title) {\n            attributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n        }\n        if (dimensions.length) {\n            attributes = attributes.concat(dimensions);\n        }\n        return '<img ' + attributes.join(' ') + '>';\n    },\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>`;\n    },\n    link({ href, title, tokens }) {\n        let text = this.parser.parseInline(tokens);\n        if (typeof href !== 'string') {\n            return '';\n        }\n        // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n        if (href === text) { // raw link case\n            text = removeMarkdownEscapes(text);\n        }\n        title = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n        href = removeMarkdownEscapes(href);\n        // HTML Encode href\n        href = href.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n        return `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n    },\n});\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown, options = {}, markedOptions = {}) {\n    const disposables = new DisposableStore();\n    let isDisposed = false;\n    const element = createElement(options);\n    const _uriMassage = function (part) {\n        let data;\n        try {\n            data = parse(decodeURIComponent(part));\n        }\n        catch (e) {\n            // ignore\n        }\n        if (!data) {\n            return part;\n        }\n        data = cloneAndChange(data, value => {\n            if (markdown.uris && markdown.uris[value]) {\n                return URI.revive(markdown.uris[value]);\n            }\n            else {\n                return undefined;\n            }\n        });\n        return encodeURIComponent(JSON.stringify(data));\n    };\n    const _href = function (href, isDomUri) {\n        const data = markdown.uris && markdown.uris[href];\n        let uri = URI.revive(data);\n        if (isDomUri) {\n            if (href.startsWith(Schemas.data + ':')) {\n                return href;\n            }\n            if (!uri) {\n                uri = URI.parse(href);\n            }\n            // this URI will end up as \"src\"-attribute of a dom node\n            // and because of that special rewriting needs to be done\n            // so that the URI uses a protocol that's understood by\n            // browsers (like http or https)\n            return FileAccess.uriToBrowserUri(uri).toString(true);\n        }\n        if (!uri) {\n            return href;\n        }\n        if (URI.parse(href).toString() === uri.toString()) {\n            return href; // no transformation performed\n        }\n        if (uri.query) {\n            uri = uri.with({ query: _uriMassage(uri.query) });\n        }\n        return uri.toString();\n    };\n    const renderer = new marked.Renderer();\n    renderer.image = defaultMarkedRenderers.image;\n    renderer.link = defaultMarkedRenderers.link;\n    renderer.paragraph = defaultMarkedRenderers.paragraph;\n    // Will collect [id, renderedElement] tuples\n    const codeBlocks = [];\n    const syncCodeBlocks = [];\n    if (options.codeBlockRendererSync) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), text);\n            syncCodeBlocks.push([id, value]);\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    else if (options.codeBlockRenderer) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), text);\n            codeBlocks.push(value.then(element => [id, element]));\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    if (options.actionHandler) {\n        const _activateLink = function (event) {\n            let target = event.target;\n            if (target.tagName !== 'A') {\n                target = target.parentElement;\n                if (!target || target.tagName !== 'A') {\n                    return;\n                }\n            }\n            try {\n                let href = target.dataset['href'];\n                if (href) {\n                    if (markdown.baseUri) {\n                        href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                    }\n                    options.actionHandler.callback(href, event);\n                }\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n            finally {\n                event.preventDefault();\n            }\n        };\n        const onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n        const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n        options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n            const mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n            if (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n                return;\n            }\n            _activateLink(mouseEvent);\n        }));\n        options.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', (e) => {\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            if (!keyboardEvent.equals(10 /* KeyCode.Space */) && !keyboardEvent.equals(3 /* KeyCode.Enter */)) {\n                return;\n            }\n            _activateLink(keyboardEvent);\n        }));\n    }\n    if (!markdown.supportHtml) {\n        // Note: we always pass the output through dompurify after this so that we don't rely on\n        // marked for real sanitization.\n        renderer.html = ({ text }) => {\n            if (options.sanitizerOptions?.replaceWithPlaintext) {\n                return escape(text);\n            }\n            const match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n            return match ? text : '';\n        };\n    }\n    markedOptions.renderer = renderer;\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}`;\n    }\n    // escape theme icons\n    if (markdown.supportThemeIcons) {\n        value = markdownEscapeEscapedIcons(value);\n    }\n    let renderedMarkdown;\n    if (options.fillInIncompleteTokens) {\n        // The defaults are applied by parse but not lexer()/parser(), and they need to be present\n        const opts = {\n            ...marked.defaults,\n            ...markedOptions\n        };\n        const tokens = marked.lexer(value, opts);\n        const newTokens = fillInIncompleteTokens(tokens);\n        renderedMarkdown = marked.parser(newTokens, opts);\n    }\n    else {\n        renderedMarkdown = marked.parse(value, { ...markedOptions, async: false });\n    }\n    // Rewrite theme icons\n    if (markdown.supportThemeIcons) {\n        const elements = renderLabelWithIcons(renderedMarkdown);\n        renderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n    }\n    const htmlParser = new DOMParser();\n    const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, renderedMarkdown), 'text/html');\n    markdownHtmlDoc.body.querySelectorAll('img, audio, video, source')\n        .forEach(img => {\n        const src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n        if (src) {\n            let href = src;\n            try {\n                if (markdown.baseUri) { // absolute or relative local path, or file: uri\n                    href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                }\n            }\n            catch (err) { }\n            img.setAttribute('src', _href(href, true));\n            if (options.remoteImageIsAllowed) {\n                const uri = URI.parse(href);\n                if (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.remoteImageIsAllowed(uri)) {\n                    img.replaceWith(DOM.$('', undefined, img.outerHTML));\n                }\n            }\n        }\n    });\n    markdownHtmlDoc.body.querySelectorAll('a')\n        .forEach(a => {\n        const href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n        a.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n        if (!href\n            || /^data:|javascript:/i.test(href)\n            || (/^command:/i.test(href) && !markdown.isTrusted)\n            || /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n            // drop the link\n            a.replaceWith(...a.childNodes);\n        }\n        else {\n            let resolvedHref = _href(href, false);\n            if (markdown.baseUri) {\n                resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n            }\n            a.dataset.href = resolvedHref;\n        }\n    });\n    element.innerHTML = sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, markdownHtmlDoc.body.innerHTML);\n    if (codeBlocks.length > 0) {\n        Promise.all(codeBlocks).then((tuples) => {\n            if (isDisposed) {\n                return;\n            }\n            const renderedElements = new Map(tuples);\n            const placeholderElements = element.querySelectorAll(`div[data-code]`);\n            for (const placeholderElement of placeholderElements) {\n                const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n                if (renderedElement) {\n                    DOM.reset(placeholderElement, renderedElement);\n                }\n            }\n            options.asyncRenderCallback?.();\n        });\n    }\n    else if (syncCodeBlocks.length > 0) {\n        const renderedElements = new Map(syncCodeBlocks);\n        const placeholderElements = element.querySelectorAll(`div[data-code]`);\n        for (const placeholderElement of placeholderElements) {\n            const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n            if (renderedElement) {\n                DOM.reset(placeholderElement, renderedElement);\n            }\n        }\n    }\n    // signal size changes for image tags\n    if (options.asyncRenderCallback) {\n        for (const img of element.getElementsByTagName('img')) {\n            const listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n                listener.dispose();\n                options.asyncRenderCallback();\n            }));\n        }\n    }\n    return {\n        element,\n        dispose: () => {\n            isDisposed = true;\n            disposables.dispose();\n        }\n    };\n}\nfunction postProcessCodeBlockLanguageId(lang) {\n    if (!lang) {\n        return '';\n    }\n    const parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n    if (parts.length) {\n        return parts[0];\n    }\n    return lang;\n}\nfunction resolveWithBaseUri(baseUri, href) {\n    const hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n    if (hasScheme) {\n        return href;\n    }\n    if (baseUri.path.endsWith('/')) {\n        return resolvePath(baseUri, href).toString();\n    }\n    else {\n        return resolvePath(dirname(baseUri), href).toString();\n    }\n}\nconst selfClosingTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nfunction sanitizeRenderedMarkdown(options, renderedMarkdown) {\n    const { config, allowedSchemes } = getSanitizerOptions(options);\n    const store = new DisposableStore();\n    store.add(addDompurifyHook('uponSanitizeAttribute', (element, e) => {\n        if (e.attrName === 'style' || e.attrName === 'class') {\n            if (element.tagName === 'SPAN') {\n                if (e.attrName === 'style') {\n                    e.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(e.attrValue);\n                    return;\n                }\n                else if (e.attrName === 'class') {\n                    e.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n                    return;\n                }\n            }\n            e.keepAttr = false;\n            return;\n        }\n        else if (element.tagName === 'INPUT' && element.attributes.getNamedItem('type')?.value === 'checkbox') {\n            if ((e.attrName === 'type' && e.attrValue === 'checkbox') || e.attrName === 'disabled' || e.attrName === 'checked') {\n                e.keepAttr = true;\n                return;\n            }\n            e.keepAttr = false;\n        }\n    }));\n    store.add(addDompurifyHook('uponSanitizeElement', (element, e) => {\n        if (e.tagName === 'input') {\n            if (element.attributes.getNamedItem('type')?.value === 'checkbox') {\n                element.setAttribute('disabled', '');\n            }\n            else if (!options.replaceWithPlaintext) {\n                element.remove();\n            }\n        }\n        if (options.replaceWithPlaintext && !e.allowedTags[e.tagName] && e.tagName !== 'body') {\n            if (element.parentElement) {\n                let startTagText;\n                let endTagText;\n                if (e.tagName === '#comment') {\n                    startTagText = `<!--${element.textContent}-->`;\n                }\n                else {\n                    const isSelfClosing = selfClosingTags.includes(e.tagName);\n                    const attrString = element.attributes.length ?\n                        ' ' + Array.from(element.attributes)\n                            .map(attr => `${attr.name}=\"${attr.value}\"`)\n                            .join(' ')\n                        : '';\n                    startTagText = `<${e.tagName}${attrString}>`;\n                    if (!isSelfClosing) {\n                        endTagText = `</${e.tagName}>`;\n                    }\n                }\n                const fragment = document.createDocumentFragment();\n                const textNode = element.parentElement.ownerDocument.createTextNode(startTagText);\n                fragment.appendChild(textNode);\n                const endTagTextNode = endTagText ? element.parentElement.ownerDocument.createTextNode(endTagText) : undefined;\n                while (element.firstChild) {\n                    fragment.appendChild(element.firstChild);\n                }\n                if (endTagTextNode) {\n                    fragment.appendChild(endTagTextNode);\n                }\n                if (element.nodeType === Node.COMMENT_NODE) {\n                    // Workaround for https://github.com/cure53/DOMPurify/issues/1005\n                    // The comment will be deleted in the next phase. However if we try to remove it now, it will cause\n                    // an exception. Instead we insert the text node before the comment.\n                    element.parentElement.insertBefore(fragment, element);\n                }\n                else {\n                    element.parentElement.replaceChild(fragment, element);\n                }\n            }\n        }\n    }));\n    store.add(DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes));\n    try {\n        return dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });\n    }\n    finally {\n        store.dispose();\n    }\n}\nexport const allowedMarkdownAttr = [\n    'align',\n    'autoplay',\n    'alt',\n    'checked',\n    'class',\n    'colspan',\n    'controls',\n    'data-code',\n    'data-href',\n    'disabled',\n    'draggable',\n    'height',\n    'href',\n    'loop',\n    'muted',\n    'playsinline',\n    'poster',\n    'rowspan',\n    'src',\n    'style',\n    'target',\n    'title',\n    'type',\n    'width',\n    'start',\n];\nfunction getSanitizerOptions(options) {\n    const allowedSchemes = [\n        Schemas.http,\n        Schemas.https,\n        Schemas.mailto,\n        Schemas.data,\n        Schemas.file,\n        Schemas.vscodeFileResource,\n        Schemas.vscodeRemote,\n        Schemas.vscodeRemoteResource,\n    ];\n    if (options.isTrusted) {\n        allowedSchemes.push(Schemas.command);\n    }\n    return {\n        config: {\n            // allowedTags should included everything that markdown renders to.\n            // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n            // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n            // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n            ALLOWED_TAGS: options.allowedTags ?? [...DOM.basicMarkupHtmlTags],\n            ALLOWED_ATTR: allowedMarkdownAttr,\n            ALLOW_UNKNOWN_PROTOCOLS: true,\n        },\n        allowedSchemes\n    };\n}\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string) {\n    return typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n * provide @param withCodeBlocks to retain code blocks\n */\nexport function renderMarkdownAsPlaintext(markdown, withCodeBlocks) {\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}`;\n    }\n    const html = marked.parse(value, { async: false, renderer: withCodeBlocks ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);\n    return sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();\n}\nconst unescapeInfo = new Map([\n    ['&quot;', '\"'],\n    ['&nbsp;', ' '],\n    ['&amp;', '&'],\n    ['&#39;', '\\''],\n    ['&lt;', '<'],\n    ['&gt;', '>'],\n]);\nfunction createRenderer() {\n    const renderer = new marked.Renderer();\n    renderer.code = ({ text }) => {\n        return text;\n    };\n    renderer.blockquote = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.html = (_) => {\n        return '';\n    };\n    renderer.heading = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.hr = () => {\n        return '';\n    };\n    renderer.list = function ({ items }) {\n        return items.map(x => this.listitem(x)).join('\\n') + '\\n';\n    };\n    renderer.listitem = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.paragraph = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.table = function ({ header, rows }) {\n        return header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n    };\n    renderer.tablerow = ({ text }) => {\n        return text;\n    };\n    renderer.tablecell = function ({ tokens }) {\n        return this.parser.parseInline(tokens);\n    };\n    renderer.strong = ({ text }) => {\n        return text;\n    };\n    renderer.em = ({ text }) => {\n        return text;\n    };\n    renderer.codespan = ({ text }) => {\n        return text;\n    };\n    renderer.br = (_) => {\n        return '\\n';\n    };\n    renderer.del = ({ text }) => {\n        return text;\n    };\n    renderer.image = (_) => {\n        return '';\n    };\n    renderer.text = ({ text }) => {\n        return text;\n    };\n    renderer.link = ({ text }) => {\n        return text;\n    };\n    return renderer;\n}\nconst plainTextRenderer = new Lazy((withCodeBlocks) => createRenderer());\nconst plainTextWithCodeBlocksRenderer = new Lazy(() => {\n    const renderer = createRenderer();\n    renderer.code = ({ text }) => {\n        return `\\n\\`\\`\\`\\n${text}\\n\\`\\`\\`\\n`;\n    };\n    return renderer;\n});\nfunction mergeRawTokenText(tokens) {\n    let mergedTokenText = '';\n    tokens.forEach(token => {\n        mergedTokenText += token.raw;\n    });\n    return mergedTokenText;\n}\nfunction completeSingleLinePattern(token) {\n    if (!token.tokens) {\n        return undefined;\n    }\n    for (let i = token.tokens.length - 1; i >= 0; i--) {\n        const subtoken = token.tokens[i];\n        if (subtoken.type === 'text') {\n            const lines = subtoken.raw.split('\\n');\n            const lastLine = lines[lines.length - 1];\n            if (lastLine.includes('`')) {\n                return completeCodespan(token);\n            }\n            else if (lastLine.includes('**')) {\n                return completeDoublestar(token);\n            }\n            else if (lastLine.match(/\\*\\w/)) {\n                return completeStar(token);\n            }\n            else if (lastLine.match(/(^|\\s)__\\w/)) {\n                return completeDoubleUnderscore(token);\n            }\n            else if (lastLine.match(/(^|\\s)_\\w/)) {\n                return completeUnderscore(token);\n            }\n            else if (\n            // Text with start of link target\n            hasLinkTextAndStartOfLinkTarget(lastLine) ||\n                // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n                // But some preceding token does have an unbalanced [ at least\n                hasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))) {\n                const nextTwoSubTokens = token.tokens.slice(i + 1);\n                // A markdown link can look like\n                // [link text](https://microsoft.com \"more text\")\n                // Where \"more text\" is a title for the link or an argument to a vscode command link\n                if (\n                // If the link was parsed as a link, then look for a link token and a text token with a quote\n                nextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n                    // And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n                    lastLine.match(/^[^\"]* +\"[^\"]*$/)) {\n                    return completeLinkTargetArg(token);\n                }\n                return completeLinkTarget(token);\n            }\n            // Contains the start of link text, and no following tokens contain the link target\n            else if (lastLine.match(/(^|\\s)\\[\\w*/)) {\n                return completeLinkText(token);\n            }\n        }\n    }\n    return undefined;\n}\nfunction hasLinkTextAndStartOfLinkTarget(str) {\n    return !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\nfunction hasStartOfLinkTargetAndNoLinkText(str) {\n    return !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\nfunction completeListItemPattern(list) {\n    // Patch up this one list item\n    const lastListItem = list.items[list.items.length - 1];\n    const lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n    /*\n    Example list token structures:\n\n    list\n        list_item\n            text\n                text\n                codespan\n                link\n        list_item\n            text\n            code // Complete indented codeblock\n        list_item\n            text\n            space\n            text\n                text // Incomplete indented codeblock\n        list_item\n            text\n            list // Nested list\n                list_item\n                    text\n                        text\n\n    Contrast with paragraph:\n    paragraph\n        text\n        codespan\n    */\n    let newToken;\n    if (lastListSubToken?.type === 'text' && !('inRawBlock' in lastListItem)) { // Why does Tag have a type of 'text'\n        newToken = completeSingleLinePattern(lastListSubToken);\n    }\n    if (!newToken || newToken.type !== 'paragraph') { // 'text' item inside the list item turns into paragraph\n        // Nothing to fix, or not a pattern we were expecting\n        return;\n    }\n    const previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n    // Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n    const lastListItemLead = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)?.[0];\n    if (!lastListItemLead) {\n        // Is badly formatted\n        return;\n    }\n    const newListItemText = lastListItemLead +\n        mergeRawTokenText(lastListItem.tokens.slice(0, -1)) +\n        newToken.raw;\n    const newList = marked.lexer(previousListItemsText + newListItemText)[0];\n    if (newList.type !== 'list') {\n        // Something went wrong\n        return;\n    }\n    return newList;\n}\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens) {\n    for (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n        const newTokens = fillInIncompleteTokensOnce(tokens);\n        if (newTokens) {\n            tokens = newTokens;\n        }\n        else {\n            break;\n        }\n    }\n    return tokens;\n}\nfunction fillInIncompleteTokensOnce(tokens) {\n    let i;\n    let newTokens;\n    for (i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n            newTokens = completeTable(tokens.slice(i));\n            break;\n        }\n        if (i === tokens.length - 1 && token.type === 'list') {\n            const newListToken = completeListItemPattern(token);\n            if (newListToken) {\n                newTokens = [newListToken];\n                break;\n            }\n        }\n        if (i === tokens.length - 1 && token.type === 'paragraph') {\n            // Only operates on a single token, because any newline that follows this should break these patterns\n            const newToken = completeSingleLinePattern(token);\n            if (newToken) {\n                newTokens = [newToken];\n                break;\n            }\n        }\n    }\n    if (newTokens) {\n        const newTokensList = [\n            ...tokens.slice(0, i),\n            ...newTokens\n        ];\n        newTokensList.links = tokens.links;\n        return newTokensList;\n    }\n    return null;\n}\nfunction completeCodespan(token) {\n    return completeWithString(token, '`');\n}\nfunction completeStar(tokens) {\n    return completeWithString(tokens, '*');\n}\nfunction completeUnderscore(tokens) {\n    return completeWithString(tokens, '_');\n}\nfunction completeLinkTarget(tokens) {\n    return completeWithString(tokens, ')');\n}\nfunction completeLinkTargetArg(tokens) {\n    return completeWithString(tokens, '\")');\n}\nfunction completeLinkText(tokens) {\n    return completeWithString(tokens, '](https://microsoft.com)');\n}\nfunction completeDoublestar(tokens) {\n    return completeWithString(tokens, '**');\n}\nfunction completeDoubleUnderscore(tokens) {\n    return completeWithString(tokens, '__');\n}\nfunction completeWithString(tokens, closingString) {\n    const mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n    // If it was completed correctly, this should be a single token.\n    // Expecting either a Paragraph or a List\n    return marked.lexer(mergedRawText + closingString)[0];\n}\nfunction completeTable(tokens) {\n    const mergedRawText = mergeRawTokenText(tokens);\n    const lines = mergedRawText.split('\\n');\n    let numCols; // The number of line1 col headers\n    let hasSeparatorRow = false;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n            const line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n            if (line1Matches) {\n                numCols = line1Matches.length;\n            }\n        }\n        else if (typeof numCols === 'number') {\n            if (line.match(/^\\s*\\|/)) {\n                if (i !== lines.length - 1) {\n                    // We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n                    // That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n                    return undefined;\n                }\n                // Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n                hasSeparatorRow = true;\n            }\n            else {\n                // The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n                return undefined;\n            }\n        }\n    }\n    if (typeof numCols === 'number' && numCols > 0) {\n        const prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n        const line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n        const newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n        return marked.lexer(newRawText);\n    }\n    return undefined;\n}\nfunction addDompurifyHook(hook, cb) {\n    dompurify.addHook(hook, cb);\n    return toDisposable(() => dompurify.removeHook(hook));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BrowserFeatures } from '../../canIUse.js';\nimport * as DOM from '../../dom.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../common/lifecycle.js';\nimport * as platform from '../../../common/platform.js';\nimport { Range } from '../../../common/range.js';\nimport './contextview.css';\nexport function isAnchor(obj) {\n    const anchor = obj;\n    return !!anchor && typeof anchor.x === 'number' && typeof anchor.y === 'number';\n}\nexport var LayoutAnchorMode;\n(function (LayoutAnchorMode) {\n    LayoutAnchorMode[LayoutAnchorMode[\"AVOID\"] = 0] = \"AVOID\";\n    LayoutAnchorMode[LayoutAnchorMode[\"ALIGN\"] = 1] = \"ALIGN\";\n})(LayoutAnchorMode || (LayoutAnchorMode = {}));\n/**\n * Lays out a one dimensional view next to an anchor in a viewport.\n *\n * @returns The view offset within the viewport.\n */\nexport function layout(viewportSize, viewSize, anchor) {\n    const layoutAfterAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset : anchor.offset + anchor.size;\n    const layoutBeforeAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset + anchor.size : anchor.offset;\n    if (anchor.position === 0 /* LayoutAnchorPosition.Before */) {\n        if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {\n            return layoutAfterAnchorBoundary; // happy case, lay it out after the anchor\n        }\n        if (viewSize <= layoutBeforeAnchorBoundary) {\n            return layoutBeforeAnchorBoundary - viewSize; // ok case, lay it out before the anchor\n        }\n        return Math.max(viewportSize - viewSize, 0); // sad case, lay it over the anchor\n    }\n    else {\n        if (viewSize <= layoutBeforeAnchorBoundary) {\n            return layoutBeforeAnchorBoundary - viewSize; // happy case, lay it out before the anchor\n        }\n        if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {\n            return layoutAfterAnchorBoundary; // ok case, lay it out after the anchor\n        }\n        return 0; // sad case, lay it over the anchor\n    }\n}\nexport class ContextView extends Disposable {\n    static { this.BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur']; }\n    static { this.BUBBLE_DOWN_EVENTS = ['click']; }\n    constructor(container, domPosition) {\n        super();\n        this.container = null;\n        this.useFixedPosition = false;\n        this.useShadowDOM = false;\n        this.delegate = null;\n        this.toDisposeOnClean = Disposable.None;\n        this.toDisposeOnSetContainer = Disposable.None;\n        this.shadowRoot = null;\n        this.shadowRootHostElement = null;\n        this.view = DOM.$('.context-view');\n        DOM.hide(this.view);\n        this.setContainer(container, domPosition);\n        this._register(toDisposable(() => this.setContainer(null, 1 /* ContextViewDOMPosition.ABSOLUTE */)));\n    }\n    setContainer(container, domPosition) {\n        this.useFixedPosition = domPosition !== 1 /* ContextViewDOMPosition.ABSOLUTE */;\n        const usedShadowDOM = this.useShadowDOM;\n        this.useShadowDOM = domPosition === 3 /* ContextViewDOMPosition.FIXED_SHADOW */;\n        if (container === this.container && usedShadowDOM === this.useShadowDOM) {\n            return; // container is the same and no shadow DOM usage has changed\n        }\n        if (this.container) {\n            this.toDisposeOnSetContainer.dispose();\n            this.view.remove();\n            if (this.shadowRoot) {\n                this.shadowRoot = null;\n                this.shadowRootHostElement?.remove();\n                this.shadowRootHostElement = null;\n            }\n            this.container = null;\n        }\n        if (container) {\n            this.container = container;\n            if (this.useShadowDOM) {\n                this.shadowRootHostElement = DOM.$('.shadow-root-host');\n                this.container.appendChild(this.shadowRootHostElement);\n                this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: 'open' });\n                const style = document.createElement('style');\n                style.textContent = SHADOW_ROOT_CSS;\n                this.shadowRoot.appendChild(style);\n                this.shadowRoot.appendChild(this.view);\n                this.shadowRoot.appendChild(DOM.$('slot'));\n            }\n            else {\n                this.container.appendChild(this.view);\n            }\n            const toDisposeOnSetContainer = new DisposableStore();\n            ContextView.BUBBLE_UP_EVENTS.forEach(event => {\n                toDisposeOnSetContainer.add(DOM.addStandardDisposableListener(this.container, event, e => {\n                    this.onDOMEvent(e, false);\n                }));\n            });\n            ContextView.BUBBLE_DOWN_EVENTS.forEach(event => {\n                toDisposeOnSetContainer.add(DOM.addStandardDisposableListener(this.container, event, e => {\n                    this.onDOMEvent(e, true);\n                }, true));\n            });\n            this.toDisposeOnSetContainer = toDisposeOnSetContainer;\n        }\n    }\n    show(delegate) {\n        if (this.isVisible()) {\n            this.hide();\n        }\n        // Show static box\n        DOM.clearNode(this.view);\n        this.view.className = 'context-view monaco-component';\n        this.view.style.top = '0px';\n        this.view.style.left = '0px';\n        this.view.style.zIndex = `${2575 + (delegate.layer ?? 0)}`;\n        this.view.style.position = this.useFixedPosition ? 'fixed' : 'absolute';\n        DOM.show(this.view);\n        // Render content\n        this.toDisposeOnClean = delegate.render(this.view) || Disposable.None;\n        // Set active delegate\n        this.delegate = delegate;\n        // Layout\n        this.doLayout();\n        // Focus\n        this.delegate.focus?.();\n    }\n    getViewElement() {\n        return this.view;\n    }\n    layout() {\n        if (!this.isVisible()) {\n            return;\n        }\n        if (this.delegate.canRelayout === false && !(platform.isIOS && BrowserFeatures.pointerEvents)) {\n            this.hide();\n            return;\n        }\n        this.delegate?.layout?.();\n        this.doLayout();\n    }\n    doLayout() {\n        // Check that we still have a delegate - this.delegate.layout may have hidden\n        if (!this.isVisible()) {\n            return;\n        }\n        // Get anchor\n        const anchor = this.delegate.getAnchor();\n        // Compute around\n        let around;\n        // Get the element's position and size (to anchor the view)\n        if (DOM.isHTMLElement(anchor)) {\n            const elementPosition = DOM.getDomNodePagePosition(anchor);\n            // In areas where zoom is applied to the element or its ancestors, we need to adjust the size of the element\n            // e.g. The title bar has counter zoom behavior meaning it applies the inverse of zoom level.\n            // Window Zoom Level: 1.5, Title Bar Zoom: 1/1.5, Size Multiplier: 1.5\n            const zoom = DOM.getDomNodeZoomLevel(anchor);\n            around = {\n                top: elementPosition.top * zoom,\n                left: elementPosition.left * zoom,\n                width: elementPosition.width * zoom,\n                height: elementPosition.height * zoom\n            };\n        }\n        else if (isAnchor(anchor)) {\n            around = {\n                top: anchor.y,\n                left: anchor.x,\n                width: anchor.width || 1,\n                height: anchor.height || 2\n            };\n        }\n        else {\n            around = {\n                top: anchor.posy,\n                left: anchor.posx,\n                // We are about to position the context view where the mouse\n                // cursor is. To prevent the view being exactly under the mouse\n                // when showing and thus potentially triggering an action within,\n                // we treat the mouse location like a small sized block element.\n                width: 2,\n                height: 2\n            };\n        }\n        const viewSizeWidth = DOM.getTotalWidth(this.view);\n        const viewSizeHeight = DOM.getTotalHeight(this.view);\n        const anchorPosition = this.delegate.anchorPosition || 0 /* AnchorPosition.BELOW */;\n        const anchorAlignment = this.delegate.anchorAlignment || 0 /* AnchorAlignment.LEFT */;\n        const anchorAxisAlignment = this.delegate.anchorAxisAlignment || 0 /* AnchorAxisAlignment.VERTICAL */;\n        let top;\n        let left;\n        const activeWindow = DOM.getActiveWindow();\n        if (anchorAxisAlignment === 0 /* AnchorAxisAlignment.VERTICAL */) {\n            const verticalAnchor = { offset: around.top - activeWindow.pageYOffset, size: around.height, position: anchorPosition === 0 /* AnchorPosition.BELOW */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */ };\n            const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, mode: LayoutAnchorMode.ALIGN };\n            top = layout(activeWindow.innerHeight, viewSizeHeight, verticalAnchor) + activeWindow.pageYOffset;\n            // if view intersects vertically with anchor,  we must avoid the anchor\n            if (Range.intersects({ start: top, end: top + viewSizeHeight }, { start: verticalAnchor.offset, end: verticalAnchor.offset + verticalAnchor.size })) {\n                horizontalAnchor.mode = LayoutAnchorMode.AVOID;\n            }\n            left = layout(activeWindow.innerWidth, viewSizeWidth, horizontalAnchor);\n        }\n        else {\n            const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */ };\n            const verticalAnchor = { offset: around.top, size: around.height, position: anchorPosition === 0 /* AnchorPosition.BELOW */ ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, mode: LayoutAnchorMode.ALIGN };\n            left = layout(activeWindow.innerWidth, viewSizeWidth, horizontalAnchor);\n            // if view intersects horizontally with anchor, we must avoid the anchor\n            if (Range.intersects({ start: left, end: left + viewSizeWidth }, { start: horizontalAnchor.offset, end: horizontalAnchor.offset + horizontalAnchor.size })) {\n                verticalAnchor.mode = LayoutAnchorMode.AVOID;\n            }\n            top = layout(activeWindow.innerHeight, viewSizeHeight, verticalAnchor) + activeWindow.pageYOffset;\n        }\n        this.view.classList.remove('top', 'bottom', 'left', 'right');\n        this.view.classList.add(anchorPosition === 0 /* AnchorPosition.BELOW */ ? 'bottom' : 'top');\n        this.view.classList.add(anchorAlignment === 0 /* AnchorAlignment.LEFT */ ? 'left' : 'right');\n        this.view.classList.toggle('fixed', this.useFixedPosition);\n        const containerPosition = DOM.getDomNodePagePosition(this.container);\n        this.view.style.top = `${top - (this.useFixedPosition ? DOM.getDomNodePagePosition(this.view).top : containerPosition.top)}px`;\n        this.view.style.left = `${left - (this.useFixedPosition ? DOM.getDomNodePagePosition(this.view).left : containerPosition.left)}px`;\n        this.view.style.width = 'initial';\n    }\n    hide(data) {\n        const delegate = this.delegate;\n        this.delegate = null;\n        if (delegate?.onHide) {\n            delegate.onHide(data);\n        }\n        this.toDisposeOnClean.dispose();\n        DOM.hide(this.view);\n    }\n    isVisible() {\n        return !!this.delegate;\n    }\n    onDOMEvent(e, onCapture) {\n        if (this.delegate) {\n            if (this.delegate.onDOMEvent) {\n                this.delegate.onDOMEvent(e, DOM.getWindow(e).document.activeElement);\n            }\n            else if (onCapture && !DOM.isAncestor(e.target, this.container)) {\n                this.hide();\n            }\n        }\n    }\n    dispose() {\n        this.hide();\n        super.dispose();\n    }\n}\nconst SHADOW_ROOT_CSS = /* css */ `\n\t:host {\n\t\tall: initial; /* 1st rule so subsequent properties are reset. */\n\t}\n\n\t.codicon[class*='codicon-'] {\n\t\tfont: normal normal normal 16px/1 codicon;\n\t\tdisplay: inline-block;\n\t\ttext-decoration: none;\n\t\ttext-rendering: auto;\n\t\ttext-align: center;\n\t\t-webkit-font-smoothing: antialiased;\n\t\t-moz-osx-font-smoothing: grayscale;\n\t\tuser-select: none;\n\t\t-webkit-user-select: none;\n\t\t-ms-user-select: none;\n\t}\n\n\t:host {\n\t\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe WPC\", \"Segoe UI\", \"HelveticaNeue-Light\", system-ui, \"Ubuntu\", \"Droid Sans\", sans-serif;\n\t}\n\n\t:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }\n\t:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, \"PingFang SC\", \"Hiragino Sans GB\", sans-serif; }\n\t:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, \"PingFang TC\", sans-serif; }\n\t:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, \"Hiragino Kaku Gothic Pro\", sans-serif; }\n\t:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, \"Nanum Gothic\", \"Apple SD Gothic Neo\", \"AppleGothic\", sans-serif; }\n\n\t:host-context(.windows) { font-family: \"Segoe WPC\", \"Segoe UI\", sans-serif; }\n\t:host-context(.windows:lang(zh-Hans)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Microsoft YaHei\", sans-serif; }\n\t:host-context(.windows:lang(zh-Hant)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Microsoft Jhenghei\", sans-serif; }\n\t:host-context(.windows:lang(ja)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Yu Gothic UI\", \"Meiryo UI\", sans-serif; }\n\t:host-context(.windows:lang(ko)) { font-family: \"Segoe WPC\", \"Segoe UI\", \"Malgun Gothic\", \"Dotom\", sans-serif; }\n\n\t:host-context(.linux) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", sans-serif; }\n\t:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans SC\", \"Source Han Sans CN\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans TC\", \"Source Han Sans TW\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(ja)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans J\", \"Source Han Sans JP\", \"Source Han Sans\", sans-serif; }\n\t:host-context(.linux:lang(ko)) { font-family: system-ui, \"Ubuntu\", \"Droid Sans\", \"Source Han Sans K\", \"Source Han Sans JR\", \"Source Han Sans\", \"UnDotum\", \"FBaekmuk Gulim\", sans-serif; }\n`;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ContextView } from '../../../base/browser/ui/contextview/contextview.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { getWindow } from '../../../base/browser/dom.js';\nlet ContextViewHandler = class ContextViewHandler extends Disposable {\n    constructor(layoutService) {\n        super();\n        this.layoutService = layoutService;\n        this.contextView = this._register(new ContextView(this.layoutService.mainContainer, 1 /* ContextViewDOMPosition.ABSOLUTE */));\n        this.layout();\n        this._register(layoutService.onDidLayoutContainer(() => this.layout()));\n    }\n    // ContextView\n    showContextView(delegate, container, shadowRoot) {\n        let domPosition;\n        if (container) {\n            if (container === this.layoutService.getContainer(getWindow(container))) {\n                domPosition = 1 /* ContextViewDOMPosition.ABSOLUTE */;\n            }\n            else if (shadowRoot) {\n                domPosition = 3 /* ContextViewDOMPosition.FIXED_SHADOW */;\n            }\n            else {\n                domPosition = 2 /* ContextViewDOMPosition.FIXED */;\n            }\n        }\n        else {\n            domPosition = 1 /* ContextViewDOMPosition.ABSOLUTE */;\n        }\n        this.contextView.setContainer(container ?? this.layoutService.activeContainer, domPosition);\n        this.contextView.show(delegate);\n        const openContextView = {\n            close: () => {\n                if (this.openContextView === openContextView) {\n                    this.hideContextView();\n                }\n            }\n        };\n        this.openContextView = openContextView;\n        return openContextView;\n    }\n    layout() {\n        this.contextView.layout();\n    }\n    hideContextView(data) {\n        this.contextView.hide(data);\n        this.openContextView = undefined;\n    }\n};\nContextViewHandler = __decorate([\n    __param(0, ILayoutService)\n], ContextViewHandler);\nexport { ContextViewHandler };\nexport class ContextViewService extends ContextViewHandler {\n    getContextViewElement() {\n        return this.contextView.getViewElement();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport * as objects from '../../../base/common/objects.js';\nimport * as types from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { addToValueTree, getConfigurationValue, removeFromValueTree, toValuesTree } from './configuration.js';\nimport { Extensions, overrideIdentifiersFromKey, OVERRIDE_PROPERTY_REGEX } from './configurationRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nfunction freeze(data) {\n    return Object.isFrozen(data) ? data : objects.deepFreeze(data);\n}\nexport class ConfigurationModel {\n    static createEmptyModel(logService) {\n        return new ConfigurationModel({}, [], [], undefined, logService);\n    }\n    constructor(_contents, _keys, _overrides, raw, logService) {\n        this._contents = _contents;\n        this._keys = _keys;\n        this._overrides = _overrides;\n        this.raw = raw;\n        this.logService = logService;\n        this.overrideConfigurations = new Map();\n    }\n    get rawConfiguration() {\n        if (!this._rawConfiguration) {\n            if (this.raw?.length) {\n                const rawConfigurationModels = this.raw.map(raw => {\n                    if (raw instanceof ConfigurationModel) {\n                        return raw;\n                    }\n                    const parser = new ConfigurationModelParser('', this.logService);\n                    parser.parseRaw(raw);\n                    return parser.configurationModel;\n                });\n                this._rawConfiguration = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);\n            }\n            else {\n                // raw is same as current\n                this._rawConfiguration = this;\n            }\n        }\n        return this._rawConfiguration;\n    }\n    get contents() {\n        return this._contents;\n    }\n    get overrides() {\n        return this._overrides;\n    }\n    get keys() {\n        return this._keys;\n    }\n    isEmpty() {\n        return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;\n    }\n    getValue(section) {\n        return section ? getConfigurationValue(this.contents, section) : this.contents;\n    }\n    inspect(section, overrideIdentifier) {\n        const that = this;\n        return {\n            get value() {\n                return freeze(that.rawConfiguration.getValue(section));\n            },\n            get override() {\n                return overrideIdentifier ? freeze(that.rawConfiguration.getOverrideValue(section, overrideIdentifier)) : undefined;\n            },\n            get merged() {\n                return freeze(overrideIdentifier ? that.rawConfiguration.override(overrideIdentifier).getValue(section) : that.rawConfiguration.getValue(section));\n            },\n            get overrides() {\n                const overrides = [];\n                for (const { contents, identifiers, keys } of that.rawConfiguration.overrides) {\n                    const value = new ConfigurationModel(contents, keys, [], undefined, that.logService).getValue(section);\n                    if (value !== undefined) {\n                        overrides.push({ identifiers, value });\n                    }\n                }\n                return overrides.length ? freeze(overrides) : undefined;\n            }\n        };\n    }\n    getOverrideValue(section, overrideIdentifier) {\n        const overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);\n        return overrideContents\n            ? section ? getConfigurationValue(overrideContents, section) : overrideContents\n            : undefined;\n    }\n    override(identifier) {\n        let overrideConfigurationModel = this.overrideConfigurations.get(identifier);\n        if (!overrideConfigurationModel) {\n            overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);\n            this.overrideConfigurations.set(identifier, overrideConfigurationModel);\n        }\n        return overrideConfigurationModel;\n    }\n    merge(...others) {\n        const contents = objects.deepClone(this.contents);\n        const overrides = objects.deepClone(this.overrides);\n        const keys = [...this.keys];\n        const raws = this.raw?.length ? [...this.raw] : [this];\n        for (const other of others) {\n            raws.push(...(other.raw?.length ? other.raw : [other]));\n            if (other.isEmpty()) {\n                continue;\n            }\n            this.mergeContents(contents, other.contents);\n            for (const otherOverride of other.overrides) {\n                const [override] = overrides.filter(o => arrays.equals(o.identifiers, otherOverride.identifiers));\n                if (override) {\n                    this.mergeContents(override.contents, otherOverride.contents);\n                    override.keys.push(...otherOverride.keys);\n                    override.keys = arrays.distinct(override.keys);\n                }\n                else {\n                    overrides.push(objects.deepClone(otherOverride));\n                }\n            }\n            for (const key of other.keys) {\n                if (keys.indexOf(key) === -1) {\n                    keys.push(key);\n                }\n            }\n        }\n        return new ConfigurationModel(contents, keys, overrides, raws.every(raw => raw instanceof ConfigurationModel) ? undefined : raws, this.logService);\n    }\n    createOverrideConfigurationModel(identifier) {\n        const overrideContents = this.getContentsForOverrideIdentifer(identifier);\n        if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {\n            // If there are no valid overrides, return self\n            return this;\n        }\n        const contents = {};\n        for (const key of arrays.distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {\n            let contentsForKey = this.contents[key];\n            const overrideContentsForKey = overrideContents[key];\n            // If there are override contents for the key, clone and merge otherwise use base contents\n            if (overrideContentsForKey) {\n                // Clone and merge only if base contents and override contents are of type object otherwise just override\n                if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {\n                    contentsForKey = objects.deepClone(contentsForKey);\n                    this.mergeContents(contentsForKey, overrideContentsForKey);\n                }\n                else {\n                    contentsForKey = overrideContentsForKey;\n                }\n            }\n            contents[key] = contentsForKey;\n        }\n        return new ConfigurationModel(contents, this.keys, this.overrides, undefined, this.logService);\n    }\n    mergeContents(source, target) {\n        for (const key of Object.keys(target)) {\n            if (key in source) {\n                if (types.isObject(source[key]) && types.isObject(target[key])) {\n                    this.mergeContents(source[key], target[key]);\n                    continue;\n                }\n            }\n            source[key] = objects.deepClone(target[key]);\n        }\n    }\n    getContentsForOverrideIdentifer(identifier) {\n        let contentsForIdentifierOnly = null;\n        let contents = null;\n        const mergeContents = (contentsToMerge) => {\n            if (contentsToMerge) {\n                if (contents) {\n                    this.mergeContents(contents, contentsToMerge);\n                }\n                else {\n                    contents = objects.deepClone(contentsToMerge);\n                }\n            }\n        };\n        for (const override of this.overrides) {\n            if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {\n                contentsForIdentifierOnly = override.contents;\n            }\n            else if (override.identifiers.includes(identifier)) {\n                mergeContents(override.contents);\n            }\n        }\n        // Merge contents of the identifier only at the end to take precedence.\n        mergeContents(contentsForIdentifierOnly);\n        return contents;\n    }\n    toJSON() {\n        return {\n            contents: this.contents,\n            overrides: this.overrides,\n            keys: this.keys\n        };\n    }\n    setValue(key, value) {\n        this.updateValue(key, value, false);\n    }\n    removeValue(key) {\n        const index = this.keys.indexOf(key);\n        if (index === -1) {\n            return;\n        }\n        this.keys.splice(index, 1);\n        removeFromValueTree(this.contents, key);\n        if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n            this.overrides.splice(this.overrides.findIndex(o => arrays.equals(o.identifiers, overrideIdentifiersFromKey(key))), 1);\n        }\n    }\n    updateValue(key, value, add) {\n        addToValueTree(this.contents, key, value, e => this.logService.error(e));\n        add = add || this.keys.indexOf(key) === -1;\n        if (add) {\n            this.keys.push(key);\n        }\n        if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n            const identifiers = overrideIdentifiersFromKey(key);\n            const override = {\n                identifiers,\n                keys: Object.keys(this.contents[key]),\n                contents: toValuesTree(this.contents[key], message => this.logService.error(message)),\n            };\n            const index = this.overrides.findIndex(o => arrays.equals(o.identifiers, identifiers));\n            if (index !== -1) {\n                this.overrides[index] = override;\n            }\n            else {\n                this.overrides.push(override);\n            }\n        }\n    }\n}\nexport class ConfigurationModelParser {\n    constructor(_name, logService) {\n        this._name = _name;\n        this.logService = logService;\n        this._raw = null;\n        this._configurationModel = null;\n        this._restrictedConfigurations = [];\n    }\n    get configurationModel() {\n        return this._configurationModel || ConfigurationModel.createEmptyModel(this.logService);\n    }\n    parseRaw(raw, options) {\n        this._raw = raw;\n        const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options);\n        this._configurationModel = new ConfigurationModel(contents, keys, overrides, hasExcludedProperties ? [raw] : undefined /* raw has not changed */, this.logService);\n        this._restrictedConfigurations = restricted || [];\n    }\n    doParseRaw(raw, options) {\n        const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();\n        const filtered = this.filter(raw, configurationProperties, true, options);\n        raw = filtered.raw;\n        const contents = toValuesTree(raw, message => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));\n        const keys = Object.keys(raw);\n        const overrides = this.toOverrides(raw, message => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));\n        return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };\n    }\n    filter(properties, configurationProperties, filterOverriddenProperties, options) {\n        let hasExcludedProperties = false;\n        if (!options?.scopes && !options?.skipRestricted && !options?.exclude?.length) {\n            return { raw: properties, restricted: [], hasExcludedProperties };\n        }\n        const raw = {};\n        const restricted = [];\n        for (const key in properties) {\n            if (OVERRIDE_PROPERTY_REGEX.test(key) && filterOverriddenProperties) {\n                const result = this.filter(properties[key], configurationProperties, false, options);\n                raw[key] = result.raw;\n                hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;\n                restricted.push(...result.restricted);\n            }\n            else {\n                const propertySchema = configurationProperties[key];\n                const scope = propertySchema ? typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : 3 /* ConfigurationScope.WINDOW */ : undefined;\n                if (propertySchema?.restricted) {\n                    restricted.push(key);\n                }\n                if (!options.exclude?.includes(key) /* Check exclude */\n                    && (options.include?.includes(key) /* Check include */\n                        || ((scope === undefined || options.scopes === undefined || options.scopes.includes(scope)) /* Check scopes */\n                            && !(options.skipRestricted && propertySchema?.restricted)))) /* Check restricted */ {\n                    raw[key] = properties[key];\n                }\n                else {\n                    hasExcludedProperties = true;\n                }\n            }\n        }\n        return { raw, restricted, hasExcludedProperties };\n    }\n    toOverrides(raw, conflictReporter) {\n        const overrides = [];\n        for (const key of Object.keys(raw)) {\n            if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                const overrideRaw = {};\n                for (const keyInOverrideRaw in raw[key]) {\n                    overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];\n                }\n                overrides.push({\n                    identifiers: overrideIdentifiersFromKey(key),\n                    keys: Object.keys(overrideRaw),\n                    contents: toValuesTree(overrideRaw, conflictReporter)\n                });\n            }\n        }\n        return overrides;\n    }\n}\nclass ConfigurationInspectValue {\n    constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {\n        this.key = key;\n        this.overrides = overrides;\n        this._value = _value;\n        this.overrideIdentifiers = overrideIdentifiers;\n        this.defaultConfiguration = defaultConfiguration;\n        this.policyConfiguration = policyConfiguration;\n        this.applicationConfiguration = applicationConfiguration;\n        this.userConfiguration = userConfiguration;\n        this.localUserConfiguration = localUserConfiguration;\n        this.remoteUserConfiguration = remoteUserConfiguration;\n        this.workspaceConfiguration = workspaceConfiguration;\n        this.folderConfigurationModel = folderConfigurationModel;\n        this.memoryConfigurationModel = memoryConfigurationModel;\n    }\n    toInspectValue(inspectValue) {\n        return inspectValue?.value !== undefined || inspectValue?.override !== undefined || inspectValue?.overrides !== undefined ? inspectValue : undefined;\n    }\n    get userInspectValue() {\n        if (!this._userInspectValue) {\n            this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._userInspectValue;\n    }\n    get user() {\n        return this.toInspectValue(this.userInspectValue);\n    }\n}\nexport class Configuration {\n    constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, logService) {\n        this._defaultConfiguration = _defaultConfiguration;\n        this._policyConfiguration = _policyConfiguration;\n        this._applicationConfiguration = _applicationConfiguration;\n        this._localUserConfiguration = _localUserConfiguration;\n        this._remoteUserConfiguration = _remoteUserConfiguration;\n        this._workspaceConfiguration = _workspaceConfiguration;\n        this._folderConfigurations = _folderConfigurations;\n        this._memoryConfiguration = _memoryConfiguration;\n        this._memoryConfigurationByResource = _memoryConfigurationByResource;\n        this.logService = logService;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations = new ResourceMap();\n        this._userConfiguration = null;\n    }\n    getValue(section, overrides, workspace) {\n        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(section, overrides, workspace);\n        return consolidateConfigurationModel.getValue(section);\n    }\n    updateValue(key, value, overrides = {}) {\n        let memoryConfiguration;\n        if (overrides.resource) {\n            memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);\n            if (!memoryConfiguration) {\n                memoryConfiguration = ConfigurationModel.createEmptyModel(this.logService);\n                this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);\n            }\n        }\n        else {\n            memoryConfiguration = this._memoryConfiguration;\n        }\n        if (value === undefined) {\n            memoryConfiguration.removeValue(key);\n        }\n        else {\n            memoryConfiguration.setValue(key, value);\n        }\n        if (!overrides.resource) {\n            this._workspaceConsolidatedConfiguration = null;\n        }\n    }\n    inspect(key, overrides, workspace) {\n        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(key, overrides, workspace);\n        const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);\n        const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;\n        const overrideIdentifiers = new Set();\n        for (const override of consolidateConfigurationModel.overrides) {\n            for (const overrideIdentifier of override.identifiers) {\n                if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== undefined) {\n                    overrideIdentifiers.add(overrideIdentifier);\n                }\n            }\n        }\n        return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : undefined, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? undefined : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : undefined, folderConfigurationModel ? folderConfigurationModel : undefined, memoryConfigurationModel);\n    }\n    get applicationConfiguration() {\n        return this._applicationConfiguration;\n    }\n    get userConfiguration() {\n        if (!this._userConfiguration) {\n            this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);\n        }\n        return this._userConfiguration;\n    }\n    get localUserConfiguration() {\n        return this._localUserConfiguration;\n    }\n    get remoteUserConfiguration() {\n        return this._remoteUserConfiguration;\n    }\n    getConsolidatedConfigurationModel(section, overrides, workspace) {\n        let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);\n        if (overrides.overrideIdentifier) {\n            configurationModel = configurationModel.override(overrides.overrideIdentifier);\n        }\n        if (!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(section) !== undefined) {\n            configurationModel = configurationModel.merge(this._policyConfiguration);\n        }\n        return configurationModel;\n    }\n    getConsolidatedConfigurationModelForResource({ resource }, workspace) {\n        let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n        if (workspace && resource) {\n            const root = workspace.getFolder(resource);\n            if (root) {\n                consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;\n            }\n            const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);\n            if (memoryConfigurationForResource) {\n                consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);\n            }\n        }\n        return consolidateConfiguration;\n    }\n    getWorkspaceConsolidatedConfiguration() {\n        if (!this._workspaceConsolidatedConfiguration) {\n            this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);\n        }\n        return this._workspaceConsolidatedConfiguration;\n    }\n    getFolderConsolidatedConfiguration(folder) {\n        let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);\n        if (!folderConsolidatedConfiguration) {\n            const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n            const folderConfiguration = this._folderConfigurations.get(folder);\n            if (folderConfiguration) {\n                folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);\n                this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);\n            }\n            else {\n                folderConsolidatedConfiguration = workspaceConsolidateConfiguration;\n            }\n        }\n        return folderConsolidatedConfiguration;\n    }\n    getFolderConfigurationModelForResource(resource, workspace) {\n        if (workspace && resource) {\n            const root = workspace.getFolder(resource);\n            if (root) {\n                return this._folderConfigurations.get(root.uri);\n            }\n        }\n        return undefined;\n    }\n    toData() {\n        return {\n            defaults: {\n                contents: this._defaultConfiguration.contents,\n                overrides: this._defaultConfiguration.overrides,\n                keys: this._defaultConfiguration.keys\n            },\n            policy: {\n                contents: this._policyConfiguration.contents,\n                overrides: this._policyConfiguration.overrides,\n                keys: this._policyConfiguration.keys\n            },\n            application: {\n                contents: this.applicationConfiguration.contents,\n                overrides: this.applicationConfiguration.overrides,\n                keys: this.applicationConfiguration.keys\n            },\n            user: {\n                contents: this.userConfiguration.contents,\n                overrides: this.userConfiguration.overrides,\n                keys: this.userConfiguration.keys\n            },\n            workspace: {\n                contents: this._workspaceConfiguration.contents,\n                overrides: this._workspaceConfiguration.overrides,\n                keys: this._workspaceConfiguration.keys\n            },\n            folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {\n                const { contents, overrides, keys } = this._folderConfigurations.get(folder);\n                result.push([folder, { contents, overrides, keys }]);\n                return result;\n            }, [])\n        };\n    }\n    static parse(data, logService) {\n        const defaultConfiguration = this.parseConfigurationModel(data.defaults, logService);\n        const policyConfiguration = this.parseConfigurationModel(data.policy, logService);\n        const applicationConfiguration = this.parseConfigurationModel(data.application, logService);\n        const userConfiguration = this.parseConfigurationModel(data.user, logService);\n        const workspaceConfiguration = this.parseConfigurationModel(data.workspace, logService);\n        const folders = data.folders.reduce((result, value) => {\n            result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1], logService));\n            return result;\n        }, new ResourceMap());\n        return new Configuration(defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, ConfigurationModel.createEmptyModel(logService), workspaceConfiguration, folders, ConfigurationModel.createEmptyModel(logService), new ResourceMap(), logService);\n    }\n    static parseConfigurationModel(model, logService) {\n        return new ConfigurationModel(model.contents, model.keys, model.overrides, undefined, logService);\n    }\n}\nexport class ConfigurationChangeEvent {\n    constructor(change, previous, currentConfiguraiton, currentWorkspace, logService) {\n        this.change = change;\n        this.previous = previous;\n        this.currentConfiguraiton = currentConfiguraiton;\n        this.currentWorkspace = currentWorkspace;\n        this.logService = logService;\n        this._marker = '\\n';\n        this._markerCode1 = this._marker.charCodeAt(0);\n        this._markerCode2 = '.'.charCodeAt(0);\n        this.affectedKeys = new Set();\n        this._previousConfiguration = undefined;\n        for (const key of change.keys) {\n            this.affectedKeys.add(key);\n        }\n        for (const [, keys] of change.overrides) {\n            for (const key of keys) {\n                this.affectedKeys.add(key);\n            }\n        }\n        // Example: '\\nfoo.bar\\nabc.def\\n'\n        this._affectsConfigStr = this._marker;\n        for (const key of this.affectedKeys) {\n            this._affectsConfigStr += key + this._marker;\n        }\n    }\n    get previousConfiguration() {\n        if (!this._previousConfiguration && this.previous) {\n            this._previousConfiguration = Configuration.parse(this.previous.data, this.logService);\n        }\n        return this._previousConfiguration;\n    }\n    affectsConfiguration(section, overrides) {\n        // we have one large string with all keys that have changed. we pad (marker) the section\n        // and check that either find it padded or before a segment character\n        const needle = this._marker + section;\n        const idx = this._affectsConfigStr.indexOf(needle);\n        if (idx < 0) {\n            // NOT: (marker + section)\n            return false;\n        }\n        const pos = idx + needle.length;\n        if (pos >= this._affectsConfigStr.length) {\n            return false;\n        }\n        const code = this._affectsConfigStr.charCodeAt(pos);\n        if (code !== this._markerCode1 && code !== this._markerCode2) {\n            // NOT: section + (marker | segment)\n            return false;\n        }\n        if (overrides) {\n            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.previous?.workspace) : undefined;\n            const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);\n            return !objects.equals(value1, value2);\n        }\n        return true;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { asCssValueWithDefault, createStyleSheet, EventHelper, getActiveElement, getWindow, isHTMLElement, isMouseEvent } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Gesture } from '../../touch.js';\nimport { alert } from '../aria/aria.js';\nimport { CombinedSpliceable } from './splice.js';\nimport { binarySearch, firstOrDefault, range } from '../../../common/arrays.js';\nimport { timeout } from '../../../common/async.js';\nimport { Color } from '../../../common/color.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Emitter, Event, EventBufferer } from '../../../common/event.js';\nimport { matchesFuzzy2, matchesPrefix } from '../../../common/filters.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport * as platform from '../../../common/platform.js';\nimport { isNumber } from '../../../common/types.js';\nimport './list.css';\nimport { ListError } from './list.js';\nimport { ListView } from './listView.js';\nimport { StandardMouseEvent } from '../../mouseEvent.js';\nimport { autorun, constObservable } from '../../../common/observable.js';\nclass TraitRenderer {\n    constructor(trait) {\n        this.trait = trait;\n        this.renderedElements = [];\n    }\n    get templateId() {\n        return `template:${this.trait.name}`;\n    }\n    renderTemplate(container) {\n        return container;\n    }\n    renderElement(element, index, templateData) {\n        const renderedElementIndex = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (renderedElementIndex >= 0) {\n            const rendered = this.renderedElements[renderedElementIndex];\n            this.trait.unrender(templateData);\n            rendered.index = index;\n        }\n        else {\n            const rendered = { index, templateData };\n            this.renderedElements.push(rendered);\n        }\n        this.trait.renderIndex(index, templateData);\n    }\n    splice(start, deleteCount, insertCount) {\n        const rendered = [];\n        for (const renderedElement of this.renderedElements) {\n            if (renderedElement.index < start) {\n                rendered.push(renderedElement);\n            }\n            else if (renderedElement.index >= start + deleteCount) {\n                rendered.push({\n                    index: renderedElement.index + insertCount - deleteCount,\n                    templateData: renderedElement.templateData\n                });\n            }\n        }\n        this.renderedElements = rendered;\n    }\n    renderIndexes(indexes) {\n        for (const { index, templateData } of this.renderedElements) {\n            if (indexes.indexOf(index) > -1) {\n                this.trait.renderIndex(index, templateData);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        const index = this.renderedElements.findIndex(el => el.templateData === templateData);\n        if (index < 0) {\n            return;\n        }\n        this.renderedElements.splice(index, 1);\n    }\n}\nclass Trait {\n    get name() { return this._trait; }\n    get renderer() {\n        return new TraitRenderer(this);\n    }\n    constructor(_trait) {\n        this._trait = _trait;\n        this.indexes = [];\n        this.sortedIndexes = [];\n        this._onChange = new Emitter();\n        this.onChange = this._onChange.event;\n    }\n    splice(start, deleteCount, elements) {\n        const diff = elements.length - deleteCount;\n        const end = start + deleteCount;\n        const sortedIndexes = [];\n        let i = 0;\n        while (i < this.sortedIndexes.length && this.sortedIndexes[i] < start) {\n            sortedIndexes.push(this.sortedIndexes[i++]);\n        }\n        for (let j = 0; j < elements.length; j++) {\n            if (elements[j]) {\n                sortedIndexes.push(j + start);\n            }\n        }\n        while (i < this.sortedIndexes.length && this.sortedIndexes[i] >= end) {\n            sortedIndexes.push(this.sortedIndexes[i++] + diff);\n        }\n        this.renderer.splice(start, deleteCount, elements.length);\n        this._set(sortedIndexes, sortedIndexes);\n    }\n    renderIndex(index, container) {\n        container.classList.toggle(this._trait, this.contains(index));\n    }\n    unrender(container) {\n        container.classList.remove(this._trait);\n    }\n    /**\n     * Sets the indexes which should have this trait.\n     *\n     * @param indexes Indexes which should have this trait.\n     * @return The old indexes which had this trait.\n     */\n    set(indexes, browserEvent) {\n        return this._set(indexes, [...indexes].sort(numericSort), browserEvent);\n    }\n    _set(indexes, sortedIndexes, browserEvent) {\n        const result = this.indexes;\n        const sortedResult = this.sortedIndexes;\n        this.indexes = indexes;\n        this.sortedIndexes = sortedIndexes;\n        const toRender = disjunction(sortedResult, indexes);\n        this.renderer.renderIndexes(toRender);\n        this._onChange.fire({ indexes, browserEvent });\n        return result;\n    }\n    get() {\n        return this.indexes;\n    }\n    contains(index) {\n        return binarySearch(this.sortedIndexes, index, numericSort) >= 0;\n    }\n    dispose() {\n        dispose(this._onChange);\n    }\n}\n__decorate([\n    memoize\n], Trait.prototype, \"renderer\", null);\nclass SelectionTrait extends Trait {\n    constructor(setAriaSelected) {\n        super('selected');\n        this.setAriaSelected = setAriaSelected;\n    }\n    renderIndex(index, container) {\n        super.renderIndex(index, container);\n        if (this.setAriaSelected) {\n            if (this.contains(index)) {\n                container.setAttribute('aria-selected', 'true');\n            }\n            else {\n                container.setAttribute('aria-selected', 'false');\n            }\n        }\n    }\n}\n/**\n * The TraitSpliceable is used as a util class to be able\n * to preserve traits across splice calls, given an identity\n * provider.\n */\nclass TraitSpliceable {\n    constructor(trait, view, identityProvider) {\n        this.trait = trait;\n        this.view = view;\n        this.identityProvider = identityProvider;\n    }\n    splice(start, deleteCount, elements) {\n        if (!this.identityProvider) {\n            return this.trait.splice(start, deleteCount, new Array(elements.length).fill(false));\n        }\n        const pastElementsWithTrait = this.trait.get().map(i => this.identityProvider.getId(this.view.element(i)).toString());\n        if (pastElementsWithTrait.length === 0) {\n            return this.trait.splice(start, deleteCount, new Array(elements.length).fill(false));\n        }\n        const pastElementsWithTraitSet = new Set(pastElementsWithTrait);\n        const elementsWithTrait = elements.map(e => pastElementsWithTraitSet.has(this.identityProvider.getId(e).toString()));\n        this.trait.splice(start, deleteCount, elementsWithTrait);\n    }\n}\nexport function isInputElement(e) {\n    return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';\n}\nfunction isListElementDescendantOfClass(e, className) {\n    if (e.classList.contains(className)) {\n        return true;\n    }\n    if (e.classList.contains('monaco-list')) {\n        return false;\n    }\n    if (!e.parentElement) {\n        return false;\n    }\n    return isListElementDescendantOfClass(e.parentElement, className);\n}\nexport function isMonacoEditor(e) {\n    return isListElementDescendantOfClass(e, 'monaco-editor');\n}\nexport function isMonacoCustomToggle(e) {\n    return isListElementDescendantOfClass(e, 'monaco-custom-toggle');\n}\nexport function isActionItem(e) {\n    return isListElementDescendantOfClass(e, 'action-item');\n}\nexport function isStickyScrollElement(e) {\n    return isListElementDescendantOfClass(e, 'monaco-tree-sticky-row');\n}\nexport function isStickyScrollContainer(e) {\n    return e.classList.contains('monaco-tree-sticky-container');\n}\nexport function isButton(e) {\n    if ((e.tagName === 'A' && e.classList.contains('monaco-button')) ||\n        (e.tagName === 'DIV' && e.classList.contains('monaco-button-dropdown'))) {\n        return true;\n    }\n    if (e.classList.contains('monaco-list')) {\n        return false;\n    }\n    if (!e.parentElement) {\n        return false;\n    }\n    return isButton(e.parentElement);\n}\nclass KeyboardController {\n    get onKeyDown() {\n        return Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event, $ => $.filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e)));\n    }\n    constructor(list, view, options) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        this.multipleSelectionDisposables = new DisposableStore();\n        this.multipleSelectionSupport = options.multipleSelectionSupport;\n        this.disposables.add(this.onKeyDown(e => {\n            switch (e.keyCode) {\n                case 3 /* KeyCode.Enter */:\n                    return this.onEnter(e);\n                case 16 /* KeyCode.UpArrow */:\n                    return this.onUpArrow(e);\n                case 18 /* KeyCode.DownArrow */:\n                    return this.onDownArrow(e);\n                case 11 /* KeyCode.PageUp */:\n                    return this.onPageUpArrow(e);\n                case 12 /* KeyCode.PageDown */:\n                    return this.onPageDownArrow(e);\n                case 9 /* KeyCode.Escape */:\n                    return this.onEscape(e);\n                case 31 /* KeyCode.KeyA */:\n                    if (this.multipleSelectionSupport && (platform.isMacintosh ? e.metaKey : e.ctrlKey)) {\n                        this.onCtrlA(e);\n                    }\n            }\n        }));\n    }\n    updateOptions(optionsUpdate) {\n        if (optionsUpdate.multipleSelectionSupport !== undefined) {\n            this.multipleSelectionSupport = optionsUpdate.multipleSelectionSupport;\n        }\n    }\n    onEnter(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(this.list.getFocus(), e.browserEvent);\n    }\n    onUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPrevious(1, false, e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNext(1, false, e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onPageUpArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusPreviousPage(e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onPageDownArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.focusNextPage(e.browserEvent);\n        const el = this.list.getFocus()[0];\n        this.list.setAnchor(el);\n        this.list.reveal(el);\n        this.view.domNode.focus();\n    }\n    onCtrlA(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.list.setSelection(range(this.list.length), e.browserEvent);\n        this.list.setAnchor(undefined);\n        this.view.domNode.focus();\n    }\n    onEscape(e) {\n        if (this.list.getSelection().length) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.list.setSelection([], e.browserEvent);\n            this.list.setAnchor(undefined);\n            this.view.domNode.focus();\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n        this.multipleSelectionDisposables.dispose();\n    }\n}\n__decorate([\n    memoize\n], KeyboardController.prototype, \"onKeyDown\", null);\nexport var TypeNavigationMode;\n(function (TypeNavigationMode) {\n    TypeNavigationMode[TypeNavigationMode[\"Automatic\"] = 0] = \"Automatic\";\n    TypeNavigationMode[TypeNavigationMode[\"Trigger\"] = 1] = \"Trigger\";\n})(TypeNavigationMode || (TypeNavigationMode = {}));\nvar TypeNavigationControllerState;\n(function (TypeNavigationControllerState) {\n    TypeNavigationControllerState[TypeNavigationControllerState[\"Idle\"] = 0] = \"Idle\";\n    TypeNavigationControllerState[TypeNavigationControllerState[\"Typing\"] = 1] = \"Typing\";\n})(TypeNavigationControllerState || (TypeNavigationControllerState = {}));\nexport const DefaultKeyboardNavigationDelegate = new class {\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey || event.altKey) {\n            return false;\n        }\n        return (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)\n            || (event.keyCode >= 98 /* KeyCode.Numpad0 */ && event.keyCode <= 107 /* KeyCode.Numpad9 */)\n            || (event.keyCode >= 85 /* KeyCode.Semicolon */ && event.keyCode <= 95 /* KeyCode.Quote */);\n    }\n};\nclass TypeNavigationController {\n    constructor(list, view, keyboardNavigationLabelProvider, keyboardNavigationEventFilter, delegate) {\n        this.list = list;\n        this.view = view;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this.keyboardNavigationEventFilter = keyboardNavigationEventFilter;\n        this.delegate = delegate;\n        this.enabled = false;\n        this.state = TypeNavigationControllerState.Idle;\n        this.mode = TypeNavigationMode.Automatic;\n        this.triggered = false;\n        this.previouslyFocused = -1;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.updateOptions(list.options);\n    }\n    updateOptions(options) {\n        if (options.typeNavigationEnabled ?? true) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n        this.mode = options.typeNavigationMode ?? TypeNavigationMode.Automatic;\n    }\n    enable() {\n        if (this.enabled) {\n            return;\n        }\n        let typing = false;\n        const onChar = Event.chain(this.enabledDisposables.add(new DomEmitter(this.view.domNode, 'keydown')).event, $ => $.filter(e => !isInputElement(e.target))\n            .filter(() => this.mode === TypeNavigationMode.Automatic || this.triggered)\n            .map(event => new StandardKeyboardEvent(event))\n            .filter(e => typing || this.keyboardNavigationEventFilter(e))\n            .filter(e => this.delegate.mightProducePrintableCharacter(e))\n            .forEach(e => EventHelper.stop(e, true))\n            .map(event => event.browserEvent.key));\n        const onClear = Event.debounce(onChar, () => null, 800, undefined, undefined, undefined, this.enabledDisposables);\n        const onInput = Event.reduce(Event.any(onChar, onClear), (r, i) => i === null ? null : ((r || '') + i), undefined, this.enabledDisposables);\n        onInput(this.onInput, this, this.enabledDisposables);\n        onClear(this.onClear, this, this.enabledDisposables);\n        onChar(() => typing = true, undefined, this.enabledDisposables);\n        onClear(() => typing = false, undefined, this.enabledDisposables);\n        this.enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this.enabled) {\n            return;\n        }\n        this.enabledDisposables.clear();\n        this.enabled = false;\n        this.triggered = false;\n    }\n    onClear() {\n        const focus = this.list.getFocus();\n        if (focus.length > 0 && focus[0] === this.previouslyFocused) {\n            // List: re-announce element on typing end since typed keys will interrupt aria label of focused element\n            // Do not announce if there was a focus change at the end to prevent duplication https://github.com/microsoft/vscode/issues/95961\n            const ariaLabel = this.list.options.accessibilityProvider?.getAriaLabel(this.list.element(focus[0]));\n            if (typeof ariaLabel === 'string') {\n                alert(ariaLabel);\n            }\n            else if (ariaLabel) {\n                alert(ariaLabel.get());\n            }\n        }\n        this.previouslyFocused = -1;\n    }\n    onInput(word) {\n        if (!word) {\n            this.state = TypeNavigationControllerState.Idle;\n            this.triggered = false;\n            return;\n        }\n        const focus = this.list.getFocus();\n        const start = focus.length > 0 ? focus[0] : 0;\n        const delta = this.state === TypeNavigationControllerState.Idle ? 1 : 0;\n        this.state = TypeNavigationControllerState.Typing;\n        for (let i = 0; i < this.list.length; i++) {\n            const index = (start + i + delta) % this.list.length;\n            const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));\n            const labelStr = label && label.toString();\n            if (this.list.options.typeNavigationEnabled) {\n                if (typeof labelStr !== 'undefined') {\n                    // If prefix is found, focus and return early\n                    if (matchesPrefix(word, labelStr)) {\n                        this.previouslyFocused = start;\n                        this.list.setFocus([index]);\n                        this.list.reveal(index);\n                        return;\n                    }\n                    const fuzzy = matchesFuzzy2(word, labelStr);\n                    if (fuzzy) {\n                        const fuzzyScore = fuzzy[0].end - fuzzy[0].start;\n                        // ensures that when fuzzy matching, doesn't clash with prefix matching (1 input vs 1+ should be prefix and fuzzy respecitvely). Also makes sure that exact matches are prioritized.\n                        if (fuzzyScore > 1 && fuzzy.length === 1) {\n                            this.previouslyFocused = start;\n                            this.list.setFocus([index]);\n                            this.list.reveal(index);\n                            return;\n                        }\n                    }\n                }\n            }\n            else if (typeof labelStr === 'undefined' || matchesPrefix(word, labelStr)) {\n                this.previouslyFocused = start;\n                this.list.setFocus([index]);\n                this.list.reveal(index);\n                return;\n            }\n        }\n    }\n    dispose() {\n        this.disable();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nclass DOMFocusController {\n    constructor(list, view) {\n        this.list = list;\n        this.view = view;\n        this.disposables = new DisposableStore();\n        const onKeyDown = Event.chain(this.disposables.add(new DomEmitter(view.domNode, 'keydown')).event, $ => $\n            .filter(e => !isInputElement(e.target))\n            .map(e => new StandardKeyboardEvent(e)));\n        const onTab = Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 2 /* KeyCode.Tab */ && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey));\n        onTab(this.onTab, this, this.disposables);\n    }\n    onTab(e) {\n        if (e.target !== this.view.domNode) {\n            return;\n        }\n        const focus = this.list.getFocus();\n        if (focus.length === 0) {\n            return;\n        }\n        const focusedDomElement = this.view.domElement(focus[0]);\n        if (!focusedDomElement) {\n            return;\n        }\n        const tabIndexElement = focusedDomElement.querySelector('[tabIndex]');\n        if (!tabIndexElement || !(isHTMLElement(tabIndexElement)) || tabIndexElement.tabIndex === -1) {\n            return;\n        }\n        const style = getWindow(tabIndexElement).getComputedStyle(tabIndexElement);\n        if (style.visibility === 'hidden' || style.display === 'none') {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        tabIndexElement.focus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport function isSelectionSingleChangeEvent(event) {\n    return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n}\nexport function isSelectionRangeChangeEvent(event) {\n    return event.browserEvent.shiftKey;\n}\nfunction isMouseRightClick(event) {\n    return isMouseEvent(event) && event.button === 2;\n}\nconst DefaultMultipleSelectionController = {\n    isSelectionSingleChangeEvent,\n    isSelectionRangeChangeEvent\n};\nexport class MouseController {\n    constructor(list) {\n        this.list = list;\n        this.disposables = new DisposableStore();\n        this._onPointer = new Emitter();\n        this.onPointer = this._onPointer.event;\n        if (list.options.multipleSelectionSupport !== false) {\n            this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;\n        }\n        this.mouseSupport = typeof list.options.mouseSupport === 'undefined' || !!list.options.mouseSupport;\n        if (this.mouseSupport) {\n            list.onMouseDown(this.onMouseDown, this, this.disposables);\n            list.onContextMenu(this.onContextMenu, this, this.disposables);\n            list.onMouseDblClick(this.onDoubleClick, this, this.disposables);\n            list.onTouchStart(this.onMouseDown, this, this.disposables);\n            this.disposables.add(Gesture.addTarget(list.getHTMLElement()));\n        }\n        Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);\n    }\n    updateOptions(optionsUpdate) {\n        if (optionsUpdate.multipleSelectionSupport !== undefined) {\n            this.multipleSelectionController = undefined;\n            if (optionsUpdate.multipleSelectionSupport) {\n                this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;\n            }\n        }\n    }\n    isSelectionSingleChangeEvent(event) {\n        if (!this.multipleSelectionController) {\n            return false;\n        }\n        return this.multipleSelectionController.isSelectionSingleChangeEvent(event);\n    }\n    isSelectionRangeChangeEvent(event) {\n        if (!this.multipleSelectionController) {\n            return false;\n        }\n        return this.multipleSelectionController.isSelectionRangeChangeEvent(event);\n    }\n    isSelectionChangeEvent(event) {\n        return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);\n    }\n    onMouseDown(e) {\n        if (isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (getActiveElement() !== e.browserEvent.target) {\n            this.list.domFocus();\n        }\n    }\n    onContextMenu(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const focus = typeof e.index === 'undefined' ? [] : [e.index];\n        this.list.setFocus(focus, e.browserEvent);\n    }\n    onViewPointer(e) {\n        if (!this.mouseSupport) {\n            return;\n        }\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        e.browserEvent.isHandledByList = true;\n        const focus = e.index;\n        if (typeof focus === 'undefined') {\n            this.list.setFocus([], e.browserEvent);\n            this.list.setSelection([], e.browserEvent);\n            this.list.setAnchor(undefined);\n            return;\n        }\n        if (this.isSelectionChangeEvent(e)) {\n            return this.changeSelection(e);\n        }\n        this.list.setFocus([focus], e.browserEvent);\n        this.list.setAnchor(focus);\n        if (!isMouseRightClick(e.browserEvent)) {\n            this.list.setSelection([focus], e.browserEvent);\n        }\n        this._onPointer.fire(e);\n    }\n    onDoubleClick(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (this.isSelectionChangeEvent(e)) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        e.browserEvent.isHandledByList = true;\n        const focus = this.list.getFocus();\n        this.list.setSelection(focus, e.browserEvent);\n    }\n    changeSelection(e) {\n        const focus = e.index;\n        let anchor = this.list.getAnchor();\n        if (this.isSelectionRangeChangeEvent(e)) {\n            if (typeof anchor === 'undefined') {\n                const currentFocus = this.list.getFocus()[0];\n                anchor = currentFocus ?? focus;\n                this.list.setAnchor(anchor);\n            }\n            const min = Math.min(anchor, focus);\n            const max = Math.max(anchor, focus);\n            const rangeSelection = range(min, max + 1);\n            const selection = this.list.getSelection();\n            const contiguousRange = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);\n            if (contiguousRange.length === 0) {\n                return;\n            }\n            const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));\n            this.list.setSelection(newSelection, e.browserEvent);\n            this.list.setFocus([focus], e.browserEvent);\n        }\n        else if (this.isSelectionSingleChangeEvent(e)) {\n            const selection = this.list.getSelection();\n            const newSelection = selection.filter(i => i !== focus);\n            this.list.setFocus([focus]);\n            this.list.setAnchor(focus);\n            if (selection.length === newSelection.length) {\n                this.list.setSelection([...newSelection, focus], e.browserEvent);\n            }\n            else {\n                this.list.setSelection(newSelection, e.browserEvent);\n            }\n        }\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport class DefaultStyleController {\n    constructor(styleElement, selectorSuffix) {\n        this.styleElement = styleElement;\n        this.selectorSuffix = selectorSuffix;\n    }\n    style(styles) {\n        const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;\n        const content = [];\n        if (styles.listBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);\n        }\n        if (styles.listFocusBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listFocusForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);\n        }\n        if (styles.listActiveSelectionBackground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listActiveSelectionForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);\n        }\n        if (styles.listActiveSelectionIconForeground) {\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected .codicon { color: ${styles.listActiveSelectionIconForeground}; }`);\n        }\n        if (styles.listFocusAndSelectionBackground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }\n\t\t\t`);\n        }\n        if (styles.listFocusAndSelectionForeground) {\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }\n\t\t\t`);\n        }\n        if (styles.listInactiveFocusForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionIconForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused .codicon { color:  ${styles.listInactiveSelectionIconForeground}; }`);\n        }\n        if (styles.listInactiveFocusBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionBackground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`); // overwrite :hover style in this case!\n        }\n        if (styles.listInactiveSelectionForeground) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);\n        }\n        if (styles.listHoverBackground) {\n            content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);\n        }\n        if (styles.listHoverForeground) {\n            content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);\n        }\n        /**\n         * Outlines\n         */\n        const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, styles.listFocusOutline ?? ''));\n        if (focusAndSelectionOutline) { // default: listFocusOutline\n            content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);\n        }\n        if (styles.listFocusOutline) { // default: set\n            content.push(`\n\t\t\t\t.monaco-drag-image,\n\t\t\t\t.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }\n\t\t\t\t.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }\n\t\t\t`);\n        }\n        const inactiveFocusAndSelectionOutline = asCssValueWithDefault(styles.listSelectionOutline, styles.listInactiveFocusOutline ?? '');\n        if (inactiveFocusAndSelectionOutline) {\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused.selected { outline: 1px dotted ${inactiveFocusAndSelectionOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listSelectionOutline) { // default: activeContrastBorder\n            content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listInactiveFocusOutline) { // default: null\n            content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listHoverOutline) { // default: activeContrastBorder\n            content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);\n        }\n        if (styles.listDropOverBackground) {\n            content.push(`\n\t\t\t\t.monaco-list${suffix}.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-rows.drop-target,\n\t\t\t\t.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropOverBackground} !important; color: inherit !important; }\n\t\t\t`);\n        }\n        if (styles.listDropBetweenBackground) {\n            content.push(`\n\t\t\t.monaco-list${suffix} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,\n\t\t\t.monaco-list${suffix} .monaco-list-row.drop-target-before::before {\n\t\t\t\tcontent: \"\"; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;\n\t\t\t\tbackground-color: ${styles.listDropBetweenBackground};\n\t\t\t}`);\n            content.push(`\n\t\t\t.monaco-list${suffix} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,\n\t\t\t.monaco-list${suffix} .monaco-list-row.drop-target-after::after {\n\t\t\t\tcontent: \"\"; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;\n\t\t\t\tbackground-color: ${styles.listDropBetweenBackground};\n\t\t\t}`);\n        }\n        if (styles.tableColumnsBorder) {\n            content.push(`\n\t\t\t\t.monaco-table > .monaco-split-view2,\n\t\t\t\t.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,\n\t\t\t\t.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,\n\t\t\t\t.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\t\t\tborder-color: ${styles.tableColumnsBorder};\n\t\t\t\t}\n\n\t\t\t\t.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,\n\t\t\t\t.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\t\t\tborder-color: transparent;\n\t\t\t\t}\n\t\t\t`);\n        }\n        if (styles.tableOddRowsBackgroundColor) {\n            content.push(`\n\t\t\t\t.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,\n\t\t\t\t.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,\n\t\t\t\t.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {\n\t\t\t\t\tbackground-color: ${styles.tableOddRowsBackgroundColor};\n\t\t\t\t}\n\t\t\t`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n    }\n}\nexport const unthemedListStyles = {\n    listFocusBackground: '#7FB0D0',\n    listActiveSelectionBackground: '#0E639C',\n    listActiveSelectionForeground: '#FFFFFF',\n    listActiveSelectionIconForeground: '#FFFFFF',\n    listFocusAndSelectionOutline: '#90C2F9',\n    listFocusAndSelectionBackground: '#094771',\n    listFocusAndSelectionForeground: '#FFFFFF',\n    listInactiveSelectionBackground: '#3F3F46',\n    listInactiveSelectionIconForeground: '#FFFFFF',\n    listHoverBackground: '#2A2D2E',\n    listDropOverBackground: '#383B3D',\n    listDropBetweenBackground: '#EEEEEE',\n    treeIndentGuidesStroke: '#a9a9a9',\n    treeInactiveIndentGuidesStroke: Color.fromHex('#a9a9a9').transparent(0.4).toString(),\n    tableColumnsBorder: Color.fromHex('#cccccc').transparent(0.2).toString(),\n    tableOddRowsBackgroundColor: Color.fromHex('#cccccc').transparent(0.04).toString(),\n    listBackground: undefined,\n    listFocusForeground: undefined,\n    listInactiveSelectionForeground: undefined,\n    listInactiveFocusForeground: undefined,\n    listInactiveFocusBackground: undefined,\n    listHoverForeground: undefined,\n    listFocusOutline: undefined,\n    listInactiveFocusOutline: undefined,\n    listSelectionOutline: undefined,\n    listHoverOutline: undefined,\n    treeStickyScrollBackground: undefined,\n    treeStickyScrollBorder: undefined,\n    treeStickyScrollShadow: undefined\n};\nconst DefaultOptions = {\n    keyboardSupport: true,\n    mouseSupport: true,\n    multipleSelectionSupport: true,\n    dnd: {\n        getDragURI() { return null; },\n        onDragStart() { },\n        onDragOver() { return false; },\n        drop() { },\n        dispose() { }\n    }\n};\n// TODO@Joao: move these utils into a SortedArray class\nfunction getContiguousRangeContaining(range, value) {\n    const index = range.indexOf(value);\n    if (index === -1) {\n        return [];\n    }\n    const result = [];\n    let i = index - 1;\n    while (i >= 0 && range[i] === value - (index - i)) {\n        result.push(range[i--]);\n    }\n    result.reverse();\n    i = index;\n    while (i < range.length && range[i] === value + (i - index)) {\n        result.push(range[i++]);\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the intersection\n * between them (OR).\n */\nfunction disjunction(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            result.push(one[i]);\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            result.push(other[j++]);\n        }\n    }\n    return result;\n}\n/**\n * Given two sorted collections of numbers, returns the relative\n * complement between them (XOR).\n */\nfunction relativeComplement(one, other) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < one.length || j < other.length) {\n        if (i >= one.length) {\n            result.push(other[j++]);\n        }\n        else if (j >= other.length) {\n            result.push(one[i++]);\n        }\n        else if (one[i] === other[j]) {\n            i++;\n            j++;\n            continue;\n        }\n        else if (one[i] < other[j]) {\n            result.push(one[i++]);\n        }\n        else {\n            j++;\n        }\n    }\n    return result;\n}\nconst numericSort = (a, b) => a - b;\nclass PipelineRenderer {\n    constructor(_templateId, renderers) {\n        this._templateId = _templateId;\n        this.renderers = renderers;\n    }\n    get templateId() {\n        return this._templateId;\n    }\n    renderTemplate(container) {\n        return this.renderers.map(r => r.renderTemplate(container));\n    }\n    renderElement(element, index, templateData, height) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.renderElement(element, index, templateData[i++], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.disposeElement?.(element, index, templateData[i], height);\n            i += 1;\n        }\n    }\n    disposeTemplate(templateData) {\n        let i = 0;\n        for (const renderer of this.renderers) {\n            renderer.disposeTemplate(templateData[i++]);\n        }\n    }\n}\nclass AccessibiltyRenderer {\n    constructor(accessibilityProvider) {\n        this.accessibilityProvider = accessibilityProvider;\n        this.templateId = 'a18n';\n    }\n    renderTemplate(container) {\n        return { container, disposables: new DisposableStore() };\n    }\n    renderElement(element, index, data) {\n        const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n        const observable = (ariaLabel && typeof ariaLabel !== 'string') ? ariaLabel : constObservable(ariaLabel);\n        data.disposables.add(autorun(reader => {\n            this.setAriaLabel(reader.readObservable(observable), data.container);\n        }));\n        const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n        if (typeof ariaLevel === 'number') {\n            data.container.setAttribute('aria-level', `${ariaLevel}`);\n        }\n        else {\n            data.container.removeAttribute('aria-level');\n        }\n    }\n    setAriaLabel(ariaLabel, element) {\n        if (ariaLabel) {\n            element.setAttribute('aria-label', ariaLabel);\n        }\n        else {\n            element.removeAttribute('aria-label');\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        templateData.disposables.clear();\n    }\n    disposeTemplate(templateData) {\n        templateData.disposables.dispose();\n    }\n}\nclass ListViewDragAndDrop {\n    constructor(list, dnd) {\n        this.list = list;\n        this.dnd = dnd;\n    }\n    getDragElements(element) {\n        const selection = this.list.getSelectedElements();\n        const elements = selection.indexOf(element) > -1 ? selection : [element];\n        return elements;\n    }\n    getDragURI(element) {\n        return this.dnd.getDragURI(element);\n    }\n    getDragLabel(elements, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(elements, originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        this.dnd.onDragStart?.(data, originalEvent);\n    }\n    onDragOver(data, targetElement, targetIndex, targetSector, originalEvent) {\n        return this.dnd.onDragOver(data, targetElement, targetIndex, targetSector, originalEvent);\n    }\n    onDragLeave(data, targetElement, targetIndex, originalEvent) {\n        this.dnd.onDragLeave?.(data, targetElement, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        this.dnd.onDragEnd?.(originalEvent);\n    }\n    drop(data, targetElement, targetIndex, targetSector, originalEvent) {\n        this.dnd.drop(data, targetElement, targetIndex, targetSector, originalEvent);\n    }\n    dispose() {\n        this.dnd.dispose();\n    }\n}\n/**\n * The {@link List} is a virtual scrolling widget, built on top of the {@link ListView}\n * widget.\n *\n * Features:\n * - Customizable keyboard and mouse support\n * - Element traits: focus, selection, achor\n * - Accessibility support\n * - Touch support\n * - Performant template-based rendering\n * - Horizontal scrolling\n * - Variable element height support\n * - Dynamic element height support\n * - Drag-and-drop support\n */\nexport class List {\n    get onDidChangeFocus() {\n        return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), e => this.toListEvent(e), this.disposables);\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), e => this.toListEvent(e), this.disposables);\n    }\n    get domId() { return this.view.domId; }\n    get onDidScroll() { return this.view.onDidScroll; }\n    get onMouseClick() { return this.view.onMouseClick; }\n    get onMouseDblClick() { return this.view.onMouseDblClick; }\n    get onMouseMiddleClick() { return this.view.onMouseMiddleClick; }\n    get onPointer() { return this.mouseController.onPointer; }\n    get onMouseDown() { return this.view.onMouseDown; }\n    get onMouseOver() { return this.view.onMouseOver; }\n    get onMouseOut() { return this.view.onMouseOut; }\n    get onTouchStart() { return this.view.onTouchStart; }\n    get onTap() { return this.view.onTap; }\n    /**\n     * Possible context menu trigger events:\n     * - ContextMenu key\n     * - Shift F10\n     * - Ctrl Option Shift M (macOS with VoiceOver)\n     * - Mouse right click\n     */\n    get onContextMenu() {\n        let didJustPressContextMenuKey = false;\n        const fromKeyDown = Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event, $ => $.map(e => new StandardKeyboardEvent(e))\n            .filter(e => didJustPressContextMenuKey = e.keyCode === 58 /* KeyCode.ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* KeyCode.F10 */))\n            .map(e => EventHelper.stop(e, true))\n            .filter(() => false));\n        const fromKeyUp = Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, 'keyup')).event, $ => $.forEach(() => didJustPressContextMenuKey = false)\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(e => e.keyCode === 58 /* KeyCode.ContextMenu */ || (e.shiftKey && e.keyCode === 68 /* KeyCode.F10 */))\n            .map(e => EventHelper.stop(e, true))\n            .map(({ browserEvent }) => {\n            const focus = this.getFocus();\n            const index = focus.length ? focus[0] : undefined;\n            const element = typeof index !== 'undefined' ? this.view.element(index) : undefined;\n            const anchor = typeof index !== 'undefined' ? this.view.domElement(index) : this.view.domNode;\n            return { index, element, anchor, browserEvent };\n        }));\n        const fromMouse = Event.chain(this.view.onContextMenu, $ => $.filter(_ => !didJustPressContextMenuKey)\n            .map(({ element, index, browserEvent }) => ({ element, index, anchor: new StandardMouseEvent(getWindow(this.view.domNode), browserEvent), browserEvent })));\n        return Event.any(fromKeyDown, fromKeyUp, fromMouse);\n    }\n    get onKeyDown() { return this.disposables.add(new DomEmitter(this.view.domNode, 'keydown')).event; }\n    get onDidFocus() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'focus', true)).event); }\n    get onDidBlur() { return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, 'blur', true)).event); }\n    constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {\n        this.user = user;\n        this._options = _options;\n        this.focus = new Trait('focused');\n        this.anchor = new Trait('anchor');\n        this.eventBufferer = new EventBufferer();\n        this._ariaLabel = '';\n        this.disposables = new DisposableStore();\n        this._onDidDispose = new Emitter();\n        this.onDidDispose = this._onDidDispose.event;\n        const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? this._options.accessibilityProvider?.getWidgetRole() : 'list';\n        this.selection = new SelectionTrait(role !== 'listbox');\n        const baseRenderers = [this.focus.renderer, this.selection.renderer];\n        this.accessibilityProvider = _options.accessibilityProvider;\n        if (this.accessibilityProvider) {\n            baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));\n            this.accessibilityProvider.onDidChangeActiveDescendant?.(this.onDidChangeActiveDescendant, this, this.disposables);\n        }\n        renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));\n        const viewOptions = {\n            ..._options,\n            dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)\n        };\n        this.view = this.createListView(container, virtualDelegate, renderers, viewOptions);\n        this.view.domNode.setAttribute('role', role);\n        if (_options.styleController) {\n            this.styleController = _options.styleController(this.view.domId);\n        }\n        else {\n            const styleElement = createStyleSheet(this.view.domNode);\n            this.styleController = new DefaultStyleController(styleElement, this.view.domId);\n        }\n        this.spliceable = new CombinedSpliceable([\n            new TraitSpliceable(this.focus, this.view, _options.identityProvider),\n            new TraitSpliceable(this.selection, this.view, _options.identityProvider),\n            new TraitSpliceable(this.anchor, this.view, _options.identityProvider),\n            this.view\n        ]);\n        this.disposables.add(this.focus);\n        this.disposables.add(this.selection);\n        this.disposables.add(this.anchor);\n        this.disposables.add(this.view);\n        this.disposables.add(this._onDidDispose);\n        this.disposables.add(new DOMFocusController(this, this.view));\n        if (typeof _options.keyboardSupport !== 'boolean' || _options.keyboardSupport) {\n            this.keyboardController = new KeyboardController(this, this.view, _options);\n            this.disposables.add(this.keyboardController);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, _options.keyboardNavigationEventFilter ?? (() => true), delegate);\n            this.disposables.add(this.typeNavigationController);\n        }\n        this.mouseController = this.createMouseController(_options);\n        this.disposables.add(this.mouseController);\n        this.onDidChangeFocus(this._onFocusChange, this, this.disposables);\n        this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);\n        if (this.accessibilityProvider) {\n            this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();\n        }\n        if (this._options.multipleSelectionSupport !== false) {\n            this.view.domNode.setAttribute('aria-multiselectable', 'true');\n        }\n    }\n    createListView(container, virtualDelegate, renderers, viewOptions) {\n        return new ListView(container, virtualDelegate, renderers, viewOptions);\n    }\n    createMouseController(options) {\n        return new MouseController(this);\n    }\n    updateOptions(optionsUpdate = {}) {\n        this._options = { ...this._options, ...optionsUpdate };\n        this.typeNavigationController?.updateOptions(this._options);\n        if (this._options.multipleSelectionController !== undefined) {\n            if (this._options.multipleSelectionSupport) {\n                this.view.domNode.setAttribute('aria-multiselectable', 'true');\n            }\n            else {\n                this.view.domNode.removeAttribute('aria-multiselectable');\n            }\n        }\n        this.mouseController.updateOptions(optionsUpdate);\n        this.keyboardController?.updateOptions(optionsUpdate);\n        this.view.updateOptions(optionsUpdate);\n    }\n    get options() {\n        return this._options;\n    }\n    splice(start, deleteCount, elements = []) {\n        if (start < 0 || start > this.view.length) {\n            throw new ListError(this.user, `Invalid start index: ${start}`);\n        }\n        if (deleteCount < 0) {\n            throw new ListError(this.user, `Invalid delete count: ${deleteCount}`);\n        }\n        if (deleteCount === 0 && elements.length === 0) {\n            return;\n        }\n        this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));\n    }\n    rerender() {\n        this.view.rerender();\n    }\n    element(index) {\n        return this.view.element(index);\n    }\n    indexOf(element) {\n        return this.view.indexOf(element);\n    }\n    indexAt(position) {\n        return this.view.indexAt(position);\n    }\n    get length() {\n        return this.view.length;\n    }\n    get contentHeight() {\n        return this.view.contentHeight;\n    }\n    get onDidChangeContentHeight() {\n        return this.view.onDidChangeContentHeight;\n    }\n    get scrollTop() {\n        return this.view.getScrollTop();\n    }\n    set scrollTop(scrollTop) {\n        this.view.setScrollTop(scrollTop);\n    }\n    get scrollHeight() {\n        return this.view.scrollHeight;\n    }\n    get renderHeight() {\n        return this.view.renderHeight;\n    }\n    get firstVisibleIndex() {\n        return this.view.firstVisibleIndex;\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    set ariaLabel(value) {\n        this._ariaLabel = value;\n        this.view.domNode.setAttribute('aria-label', value);\n    }\n    domFocus() {\n        this.view.domNode.focus({ preventScroll: true });\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    setSelection(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.selection.set(indexes, browserEvent);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    getSelectedElements() {\n        return this.getSelection().map(i => this.view.element(i));\n    }\n    setAnchor(index) {\n        if (typeof index === 'undefined') {\n            this.anchor.set([]);\n            return;\n        }\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        this.anchor.set([index]);\n    }\n    getAnchor() {\n        return firstOrDefault(this.anchor.get(), undefined);\n    }\n    getAnchorElement() {\n        const anchor = this.getAnchor();\n        return typeof anchor === 'undefined' ? undefined : this.element(anchor);\n    }\n    setFocus(indexes, browserEvent) {\n        for (const index of indexes) {\n            if (index < 0 || index >= this.length) {\n                throw new ListError(this.user, `Invalid index ${index}`);\n            }\n        }\n        this.focus.set(indexes, browserEvent);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusPrevious(n = 1, loop = false, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const focus = this.focus.get();\n        const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    async focusNextPage(browserEvent, filter) {\n        let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);\n        lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;\n        const currentlyFocusedElementIndex = this.getFocus()[0];\n        if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === undefined || lastPageIndex > currentlyFocusedElementIndex)) {\n            const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);\n            if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {\n                this.setFocus([lastGoodPageIndex], browserEvent);\n            }\n            else {\n                this.setFocus([lastPageIndex], browserEvent);\n            }\n        }\n        else {\n            const previousScrollTop = this.view.getScrollTop();\n            let nextpageScrollTop = previousScrollTop + this.view.renderHeight;\n            if (lastPageIndex > currentlyFocusedElementIndex) {\n                // scroll last page element to the top only if the last page element is below the focused element\n                nextpageScrollTop -= this.view.elementHeight(lastPageIndex);\n            }\n            this.view.setScrollTop(nextpageScrollTop);\n            if (this.view.getScrollTop() !== previousScrollTop) {\n                this.setFocus([]);\n                // Let the scroll event listener run\n                await timeout(0);\n                await this.focusNextPage(browserEvent, filter);\n            }\n        }\n    }\n    async focusPreviousPage(browserEvent, filter, getPaddingTop = () => 0) {\n        let firstPageIndex;\n        const paddingTop = getPaddingTop();\n        const scrollTop = this.view.getScrollTop() + paddingTop;\n        if (scrollTop === 0) {\n            firstPageIndex = this.view.indexAt(scrollTop);\n        }\n        else {\n            firstPageIndex = this.view.indexAfter(scrollTop - 1);\n        }\n        const currentlyFocusedElementIndex = this.getFocus()[0];\n        if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === undefined || currentlyFocusedElementIndex >= firstPageIndex)) {\n            const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);\n            if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {\n                this.setFocus([firstGoodPageIndex], browserEvent);\n            }\n            else {\n                this.setFocus([firstPageIndex], browserEvent);\n            }\n        }\n        else {\n            const previousScrollTop = scrollTop;\n            this.view.setScrollTop(scrollTop - this.view.renderHeight - paddingTop);\n            if (this.view.getScrollTop() + getPaddingTop() !== previousScrollTop) {\n                this.setFocus([]);\n                // Let the scroll event listener run\n                await timeout(0);\n                await this.focusPreviousPage(browserEvent, filter, getPaddingTop);\n            }\n        }\n    }\n    focusLast(browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findPreviousIndex(this.length - 1, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    focusFirst(browserEvent, filter) {\n        this.focusNth(0, browserEvent, filter);\n    }\n    focusNth(n, browserEvent, filter) {\n        if (this.length === 0) {\n            return;\n        }\n        const index = this.findNextIndex(n, false, filter);\n        if (index > -1) {\n            this.setFocus([index], browserEvent);\n        }\n    }\n    findNextIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index >= this.length && !loop) {\n                return -1;\n            }\n            index = index % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n    findPreviousIndex(index, loop = false, filter) {\n        for (let i = 0; i < this.length; i++) {\n            if (index < 0 && !loop) {\n                return -1;\n            }\n            index = (this.length + (index % this.length)) % this.length;\n            if (!filter || filter(this.element(index))) {\n                return index;\n            }\n            index--;\n        }\n        return -1;\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    getFocusedElements() {\n        return this.getFocus().map(i => this.view.element(i));\n    }\n    reveal(index, relativeTop, paddingTop = 0) {\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        const scrollTop = this.view.getScrollTop();\n        const elementTop = this.view.elementTop(index);\n        const elementHeight = this.view.elementHeight(index);\n        if (isNumber(relativeTop)) {\n            // y = mx + b\n            const m = elementHeight - this.view.renderHeight + paddingTop;\n            this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop - paddingTop);\n        }\n        else {\n            const viewItemBottom = elementTop + elementHeight;\n            const scrollBottom = scrollTop + this.view.renderHeight;\n            if (elementTop < scrollTop + paddingTop && viewItemBottom >= scrollBottom) {\n                // The element is already overflowing the viewport, no-op\n            }\n            else if (elementTop < scrollTop + paddingTop || (viewItemBottom >= scrollBottom && elementHeight >= this.view.renderHeight)) {\n                this.view.setScrollTop(elementTop - paddingTop);\n            }\n            else if (viewItemBottom >= scrollBottom) {\n                this.view.setScrollTop(viewItemBottom - this.view.renderHeight);\n            }\n        }\n    }\n    /**\n     * Returns the relative position of an element rendered in the list.\n     * Returns `null` if the element isn't *entirely* in the visible viewport.\n     */\n    getRelativeTop(index, paddingTop = 0) {\n        if (index < 0 || index >= this.length) {\n            throw new ListError(this.user, `Invalid index ${index}`);\n        }\n        const scrollTop = this.view.getScrollTop();\n        const elementTop = this.view.elementTop(index);\n        const elementHeight = this.view.elementHeight(index);\n        if (elementTop < scrollTop + paddingTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {\n            return null;\n        }\n        // y = mx + b\n        const m = elementHeight - this.view.renderHeight + paddingTop;\n        return Math.abs((scrollTop + paddingTop - elementTop) / m);\n    }\n    getHTMLElement() {\n        return this.view.domNode;\n    }\n    getScrollableElement() {\n        return this.view.scrollableElementDomNode;\n    }\n    getElementID(index) {\n        return this.view.getElementDomId(index);\n    }\n    getElementTop(index) {\n        return this.view.elementTop(index);\n    }\n    style(styles) {\n        this.styleController.style(styles);\n    }\n    toListEvent({ indexes, browserEvent }) {\n        return { indexes, elements: indexes.map(i => this.view.element(i)), browserEvent };\n    }\n    _onFocusChange() {\n        const focus = this.focus.get();\n        this.view.domNode.classList.toggle('element-focused', focus.length > 0);\n        this.onDidChangeActiveDescendant();\n    }\n    onDidChangeActiveDescendant() {\n        const focus = this.focus.get();\n        if (focus.length > 0) {\n            let id;\n            if (this.accessibilityProvider?.getActiveDescendantId) {\n                id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));\n            }\n            this.view.domNode.setAttribute('aria-activedescendant', id || this.view.getElementDomId(focus[0]));\n        }\n        else {\n            this.view.domNode.removeAttribute('aria-activedescendant');\n        }\n    }\n    _onSelectionChange() {\n        const selection = this.selection.get();\n        this.view.domNode.classList.toggle('selection-none', selection.length === 0);\n        this.view.domNode.classList.toggle('selection-single', selection.length === 1);\n        this.view.domNode.classList.toggle('selection-multiple', selection.length > 1);\n    }\n    dispose() {\n        this._onDidDispose.fire();\n        this.disposables.dispose();\n        this._onDidDispose.dispose();\n    }\n}\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeFocus\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidChangeSelection\", null);\n__decorate([\n    memoize\n], List.prototype, \"onContextMenu\", null);\n__decorate([\n    memoize\n], List.prototype, \"onKeyDown\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidFocus\", null);\n__decorate([\n    memoize\n], List.prototype, \"onDidBlur\", null);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { renderMarkdown } from '../../markdownRenderer.js';\nimport { getBaseLayerHoverDelegate } from '../hover/hoverDelegate2.js';\nimport { getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { List } from '../list/listWidget.js';\nimport * as arrays from '../../../common/arrays.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { KeyCodeUtils } from '../../../common/keyCodes.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport './selectBoxCustom.css';\nimport { localize } from '../../../../nls.js';\nconst $ = dom.$;\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\nclass SelectListRenderer {\n    get templateId() { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n    renderTemplate(container) {\n        const data = Object.create(null);\n        data.root = container;\n        data.text = dom.append(container, $('.option-text'));\n        data.detail = dom.append(container, $('.option-detail'));\n        data.decoratorRight = dom.append(container, $('.option-decorator-right'));\n        return data;\n    }\n    renderElement(element, index, templateData) {\n        const data = templateData;\n        const text = element.text;\n        const detail = element.detail;\n        const decoratorRight = element.decoratorRight;\n        const isDisabled = element.isDisabled;\n        data.text.textContent = text;\n        data.detail.textContent = !!detail ? detail : '';\n        data.decoratorRight.innerText = !!decoratorRight ? decoratorRight : '';\n        // pseudo-select disabled option\n        if (isDisabled) {\n            data.root.classList.add('option-disabled');\n        }\n        else {\n            // Make sure we do class removal from prior template rendering\n            data.root.classList.remove('option-disabled');\n        }\n    }\n    disposeTemplate(_templateData) {\n        // noop\n    }\n}\nexport class SelectBoxList extends Disposable {\n    static { this.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32; }\n    static { this.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2; }\n    static { this.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3; }\n    constructor(options, selected, contextViewProvider, styles, selectBoxOptions) {\n        super();\n        this.options = [];\n        this._currentSelection = 0;\n        this._hasDetails = false;\n        this._skipLayout = false;\n        this._sticky = false; // for dev purposes only\n        this._isVisible = false;\n        this.styles = styles;\n        this.selectBoxOptions = selectBoxOptions || Object.create(null);\n        if (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n            this.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n        }\n        else if (this.selectBoxOptions.minBottomMargin < 0) {\n            this.selectBoxOptions.minBottomMargin = 0;\n        }\n        this.selectElement = document.createElement('select');\n        // Use custom CSS vars for padding calculation\n        this.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n        if (typeof this.selectBoxOptions.ariaLabel === 'string') {\n            this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n        }\n        if (typeof this.selectBoxOptions.ariaDescription === 'string') {\n            this.selectElement.setAttribute('aria-description', this.selectBoxOptions.ariaDescription);\n        }\n        this._onDidSelect = new Emitter();\n        this._register(this._onDidSelect);\n        this.registerListeners();\n        this.constructSelectDropDown(contextViewProvider);\n        this.selected = selected || 0;\n        if (options) {\n            this.setOptions(options, selected);\n        }\n        this.initStyleSheet();\n    }\n    setTitle(title) {\n        if (!this._hover && title) {\n            this._hover = this._register(getBaseLayerHoverDelegate().setupManagedHover(getDefaultHoverDelegate('mouse'), this.selectElement, title));\n        }\n        else if (this._hover) {\n            this._hover.update(title);\n        }\n    }\n    // IDelegate - List renderer\n    getHeight() {\n        return 22;\n    }\n    getTemplateId() {\n        return SELECT_OPTION_ENTRY_TEMPLATE_ID;\n    }\n    constructSelectDropDown(contextViewProvider) {\n        // SetUp ContextView container to hold select Dropdown\n        this.contextViewProvider = contextViewProvider;\n        this.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n        // Use custom CSS vars for padding calculation (shared with parent select)\n        this.selectDropDownContainer.classList.add('monaco-select-box-dropdown-padding');\n        // Setup container for select option details\n        this.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n        // Create span flex box item/div we can measure and control\n        const widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n        const widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n        this.widthControlElement = document.createElement('span');\n        this.widthControlElement.className = 'option-text-width-control';\n        dom.append(widthControlInnerDiv, this.widthControlElement);\n        // Always default to below position\n        this._dropDownPosition = 0 /* AnchorPosition.BELOW */;\n        // Inline stylesheet for themes\n        this.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n        // Prevent dragging of dropdown #114329\n        this.selectDropDownContainer.setAttribute('draggable', 'true');\n        this._register(dom.addDisposableListener(this.selectDropDownContainer, dom.EventType.DRAG_START, (e) => {\n            dom.EventHelper.stop(e, true);\n        }));\n    }\n    registerListeners() {\n        // Parent native select keyboard listeners\n        this._register(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n            this.selected = e.target.selectedIndex;\n            this._onDidSelect.fire({\n                index: e.target.selectedIndex,\n                selected: e.target.value\n            });\n            if (!!this.options[this.selected] && !!this.options[this.selected].text) {\n                this.setTitle(this.options[this.selected].text);\n            }\n        }));\n        // Have to implement both keyboard and mouse controllers to handle disabled options\n        // Intercept mouse events to override normal select actions on parents\n        this._register(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n            dom.EventHelper.stop(e);\n            if (this._isVisible) {\n                this.hideSelectDropDown(true);\n            }\n            else {\n                this.showSelectDropDown();\n            }\n        }));\n        this._register(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n            dom.EventHelper.stop(e);\n        }));\n        // Intercept touch events\n        // The following implementation is slightly different from the mouse event handlers above.\n        // Use the following helper variable, otherwise the list flickers.\n        let listIsVisibleOnTouchStart;\n        this._register(dom.addDisposableListener(this.selectElement, 'touchstart', (e) => {\n            listIsVisibleOnTouchStart = this._isVisible;\n        }));\n        this._register(dom.addDisposableListener(this.selectElement, 'touchend', (e) => {\n            dom.EventHelper.stop(e);\n            if (listIsVisibleOnTouchStart) {\n                this.hideSelectDropDown(true);\n            }\n            else {\n                this.showSelectDropDown();\n            }\n        }));\n        // Intercept keyboard handling\n        this._register(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            let showDropDown = false;\n            // Create and drop down select list on keyboard select\n            if (isMacintosh) {\n                if (event.keyCode === 18 /* KeyCode.DownArrow */ || event.keyCode === 16 /* KeyCode.UpArrow */ || event.keyCode === 10 /* KeyCode.Space */ || event.keyCode === 3 /* KeyCode.Enter */) {\n                    showDropDown = true;\n                }\n            }\n            else {\n                if (event.keyCode === 18 /* KeyCode.DownArrow */ && event.altKey || event.keyCode === 16 /* KeyCode.UpArrow */ && event.altKey || event.keyCode === 10 /* KeyCode.Space */ || event.keyCode === 3 /* KeyCode.Enter */) {\n                    showDropDown = true;\n                }\n            }\n            if (showDropDown) {\n                this.showSelectDropDown();\n                dom.EventHelper.stop(e, true);\n            }\n        }));\n    }\n    get onDidSelect() {\n        return this._onDidSelect.event;\n    }\n    setOptions(options, selected) {\n        if (!arrays.equals(this.options, options)) {\n            this.options = options;\n            this.selectElement.options.length = 0;\n            this._hasDetails = false;\n            this._cachedMaxDetailsHeight = undefined;\n            this.options.forEach((option, index) => {\n                this.selectElement.add(this.createOption(option.text, index, option.isDisabled));\n                if (typeof option.description === 'string') {\n                    this._hasDetails = true;\n                }\n            });\n        }\n        if (selected !== undefined) {\n            this.select(selected);\n            // Set current = selected since this is not necessarily a user exit\n            this._currentSelection = this.selected;\n        }\n    }\n    setOptionsList() {\n        // Mirror options in drop-down\n        // Populate select list for non-native select mode\n        this.selectList?.splice(0, this.selectList.length, this.options);\n    }\n    select(index) {\n        if (index >= 0 && index < this.options.length) {\n            this.selected = index;\n        }\n        else if (index > this.options.length - 1) {\n            // Adjust index to end of list\n            // This could make client out of sync with the select\n            this.select(this.options.length - 1);\n        }\n        else if (this.selected < 0) {\n            this.selected = 0;\n        }\n        this.selectElement.selectedIndex = this.selected;\n        if (!!this.options[this.selected] && !!this.options[this.selected].text) {\n            this.setTitle(this.options[this.selected].text);\n        }\n    }\n    focus() {\n        if (this.selectElement) {\n            this.selectElement.tabIndex = 0;\n            this.selectElement.focus();\n        }\n    }\n    blur() {\n        if (this.selectElement) {\n            this.selectElement.tabIndex = -1;\n            this.selectElement.blur();\n        }\n    }\n    setFocusable(focusable) {\n        this.selectElement.tabIndex = focusable ? 0 : -1;\n    }\n    render(container) {\n        this.container = container;\n        container.classList.add('select-container');\n        container.appendChild(this.selectElement);\n        this.styleSelectElement();\n    }\n    initStyleSheet() {\n        const content = [];\n        // Style non-native select mode\n        if (this.styles.listFocusBackground) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n        }\n        if (this.styles.listFocusForeground) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`);\n        }\n        if (this.styles.decoratorRightForeground) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`);\n        }\n        if (this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground) {\n            content.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n            content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n            content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n        }\n        else if (this.styles.selectListBorder) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n            content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n        }\n        // Hover foreground - ignore for disabled options\n        if (this.styles.listHoverForeground) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`);\n        }\n        // Hover background - ignore for disabled options\n        if (this.styles.listHoverBackground) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n        }\n        // Match quick input outline styles - ignore for disabled options\n        if (this.styles.listFocusOutline) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n        }\n        if (this.styles.listHoverOutline) {\n            content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n        }\n        // Clear list styles on focus and on hover for disabled options\n        content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }`);\n        content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }`);\n        this.styleElement.textContent = content.join('\\n');\n    }\n    styleSelectElement() {\n        const background = this.styles.selectBackground ?? '';\n        const foreground = this.styles.selectForeground ?? '';\n        const border = this.styles.selectBorder ?? '';\n        this.selectElement.style.backgroundColor = background;\n        this.selectElement.style.color = foreground;\n        this.selectElement.style.borderColor = border;\n    }\n    styleList() {\n        const background = this.styles.selectBackground ?? '';\n        const listBackground = dom.asCssValueWithDefault(this.styles.selectListBackground, background);\n        this.selectDropDownListContainer.style.backgroundColor = listBackground;\n        this.selectionDetailsPane.style.backgroundColor = listBackground;\n        const optionsBorder = this.styles.focusBorder ?? '';\n        this.selectDropDownContainer.style.outlineColor = optionsBorder;\n        this.selectDropDownContainer.style.outlineOffset = '-1px';\n        this.selectList.style(this.styles);\n    }\n    createOption(value, index, disabled) {\n        const option = document.createElement('option');\n        option.value = value;\n        option.text = value;\n        option.disabled = !!disabled;\n        return option;\n    }\n    // ContextView dropdown methods\n    showSelectDropDown() {\n        this.selectionDetailsPane.innerText = '';\n        if (!this.contextViewProvider || this._isVisible) {\n            return;\n        }\n        // Lazily create and populate list only at open, moved from constructor\n        this.createSelectList(this.selectDropDownContainer);\n        this.setOptionsList();\n        // This allows us to flip the position based on measurement\n        // Set drop-down position above/below from required height and margins\n        // If pre-layout cannot fit at least one option do not show drop-down\n        this.contextViewProvider.showContextView({\n            getAnchor: () => this.selectElement,\n            render: (container) => this.renderSelectDropDown(container, true),\n            layout: () => {\n                this.layoutSelectDropDown();\n            },\n            onHide: () => {\n                this.selectDropDownContainer.classList.remove('visible');\n                this.selectElement.classList.remove('synthetic-focus');\n            },\n            anchorPosition: this._dropDownPosition\n        }, this.selectBoxOptions.optionsAsChildren ? this.container : undefined);\n        // Hide so we can relay out\n        this._isVisible = true;\n        this.hideSelectDropDown(false);\n        this.contextViewProvider.showContextView({\n            getAnchor: () => this.selectElement,\n            render: (container) => this.renderSelectDropDown(container),\n            layout: () => this.layoutSelectDropDown(),\n            onHide: () => {\n                this.selectDropDownContainer.classList.remove('visible');\n                this.selectElement.classList.remove('synthetic-focus');\n            },\n            anchorPosition: this._dropDownPosition\n        }, this.selectBoxOptions.optionsAsChildren ? this.container : undefined);\n        // Track initial selection the case user escape, blur\n        this._currentSelection = this.selected;\n        this._isVisible = true;\n        this.selectElement.setAttribute('aria-expanded', 'true');\n    }\n    hideSelectDropDown(focusSelect) {\n        if (!this.contextViewProvider || !this._isVisible) {\n            return;\n        }\n        this._isVisible = false;\n        this.selectElement.setAttribute('aria-expanded', 'false');\n        if (focusSelect) {\n            this.selectElement.focus();\n        }\n        this.contextViewProvider.hideContextView();\n    }\n    renderSelectDropDown(container, preLayoutPosition) {\n        container.appendChild(this.selectDropDownContainer);\n        // Pre-Layout allows us to change position\n        this.layoutSelectDropDown(preLayoutPosition);\n        return {\n            dispose: () => {\n                // contextView will dispose itself if moving from one View to another\n                this.selectDropDownContainer.remove(); // remove to take out the CSS rules we add\n            }\n        };\n    }\n    // Iterate over detailed descriptions, find max height\n    measureMaxDetailsHeight() {\n        let maxDetailsPaneHeight = 0;\n        this.options.forEach((_option, index) => {\n            this.updateDetail(index);\n            if (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n                maxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n            }\n        });\n        return maxDetailsPaneHeight;\n    }\n    layoutSelectDropDown(preLayoutPosition) {\n        // Avoid recursion from layout called in onListFocus\n        if (this._skipLayout) {\n            return false;\n        }\n        // Layout ContextView drop down select list and container\n        // Have to manage our vertical overflow, sizing, position below or above\n        // Position has to be determined and set prior to contextView instantiation\n        if (this.selectList) {\n            // Make visible to enable measurements\n            this.selectDropDownContainer.classList.add('visible');\n            const window = dom.getWindow(this.selectElement);\n            const selectPosition = dom.getDomNodePagePosition(this.selectElement);\n            const styles = dom.getWindow(this.selectElement).getComputedStyle(this.selectElement);\n            const verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n            const maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - (this.selectBoxOptions.minBottomMargin || 0));\n            const maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n            // Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n            const selectWidth = this.selectElement.offsetWidth;\n            const selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n            const selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n            this.selectDropDownContainer.style.width = selectOptimalWidth;\n            // Get initial list height and determine space above and below\n            this.selectList.getHTMLElement().style.height = '';\n            this.selectList.layout();\n            let listHeight = this.selectList.contentHeight;\n            if (this._hasDetails && this._cachedMaxDetailsHeight === undefined) {\n                this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight();\n            }\n            const maxDetailsPaneHeight = this._hasDetails ? this._cachedMaxDetailsHeight : 0;\n            const minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n            const maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n            const maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n            // If we are only doing pre-layout check/adjust position only\n            // Calculate vertical space available, flip up if insufficient\n            // Use reflected padding on parent select, ContextView style\n            // properties not available before DOM attachment\n            if (preLayoutPosition) {\n                // Check if select moved out of viewport , do not open\n                // If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n                if ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n                    || selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n                    || ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n                    // Indicate we cannot open\n                    return false;\n                }\n                // Determine if we have to flip up\n                // Always show complete list items - never more than Max available vertical height\n                if (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n                    && maxVisibleOptionsAbove > maxVisibleOptionsBelow\n                    && this.options.length > maxVisibleOptionsBelow) {\n                    this._dropDownPosition = 1 /* AnchorPosition.ABOVE */;\n                    this.selectDropDownListContainer.remove();\n                    this.selectionDetailsPane.remove();\n                    this.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n                    this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n                    this.selectionDetailsPane.classList.remove('border-top');\n                    this.selectionDetailsPane.classList.add('border-bottom');\n                }\n                else {\n                    this._dropDownPosition = 0 /* AnchorPosition.BELOW */;\n                    this.selectDropDownListContainer.remove();\n                    this.selectionDetailsPane.remove();\n                    this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n                    this.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n                    this.selectionDetailsPane.classList.remove('border-bottom');\n                    this.selectionDetailsPane.classList.add('border-top');\n                }\n                // Do full layout on showSelectDropDown only\n                return true;\n            }\n            // Check if select out of viewport or cutting into status bar\n            if ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n                || selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n                || (this._dropDownPosition === 0 /* AnchorPosition.BELOW */ && maxVisibleOptionsBelow < 1)\n                || (this._dropDownPosition === 1 /* AnchorPosition.ABOVE */ && maxVisibleOptionsAbove < 1)) {\n                // Cannot properly layout, close and hide\n                this.hideSelectDropDown(true);\n                return false;\n            }\n            // SetUp list dimensions and layout - account for container padding\n            // Use position to check above or below available space\n            if (this._dropDownPosition === 0 /* AnchorPosition.BELOW */) {\n                if (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n                    // If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n                    // Hide drop-down, hide contextview, focus on parent select\n                    this.hideSelectDropDown(true);\n                    return false;\n                }\n                // Adjust list height to max from select bottom to margin (default/minBottomMargin)\n                if (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n                    listHeight = (maxVisibleOptionsBelow * this.getHeight());\n                }\n            }\n            else {\n                if (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n                    listHeight = (maxVisibleOptionsAbove * this.getHeight());\n                }\n            }\n            // Set adjusted list height and relayout\n            this.selectList.layout(listHeight);\n            this.selectList.domFocus();\n            // Finally set focus on selected item\n            if (this.selectList.length > 0) {\n                this.selectList.setFocus([this.selected || 0]);\n                this.selectList.reveal(this.selectList.getFocus()[0] || 0);\n            }\n            if (this._hasDetails) {\n                // Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n                this.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n                this.selectDropDownContainer.style.height = '';\n            }\n            else {\n                this.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n            }\n            this.updateDetail(this.selected);\n            this.selectDropDownContainer.style.width = selectOptimalWidth;\n            // Maintain focus outline on parent select as well as list container - tabindex for focus\n            this.selectDropDownListContainer.setAttribute('tabindex', '0');\n            this.selectElement.classList.add('synthetic-focus');\n            this.selectDropDownContainer.classList.add('synthetic-focus');\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    setWidthControlElement(container) {\n        let elementWidth = 0;\n        if (container) {\n            let longest = 0;\n            let longestLength = 0;\n            this.options.forEach((option, index) => {\n                const detailLength = !!option.detail ? option.detail.length : 0;\n                const rightDecoratorLength = !!option.decoratorRight ? option.decoratorRight.length : 0;\n                const len = option.text.length + detailLength + rightDecoratorLength;\n                if (len > longestLength) {\n                    longest = index;\n                    longestLength = len;\n                }\n            });\n            container.textContent = this.options[longest].text + (!!this.options[longest].decoratorRight ? (this.options[longest].decoratorRight + ' ') : '');\n            elementWidth = dom.getTotalWidth(container);\n        }\n        return elementWidth;\n    }\n    createSelectList(parent) {\n        // If we have already constructive list on open, skip\n        if (this.selectList) {\n            return;\n        }\n        // SetUp container for list\n        this.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n        this.listRenderer = new SelectListRenderer();\n        this.selectList = this._register(new List('SelectBoxCustom', this.selectDropDownListContainer, this, [this.listRenderer], {\n            useShadows: false,\n            verticalScrollMode: 3 /* ScrollbarVisibility.Visible */,\n            keyboardSupport: false,\n            mouseSupport: false,\n            accessibilityProvider: {\n                getAriaLabel: element => {\n                    let label = element.text;\n                    if (element.detail) {\n                        label += `. ${element.detail}`;\n                    }\n                    if (element.decoratorRight) {\n                        label += `. ${element.decoratorRight}`;\n                    }\n                    if (element.description) {\n                        label += `. ${element.description}`;\n                    }\n                    return label;\n                },\n                getWidgetAriaLabel: () => localize({ key: 'selectBox', comment: ['Behave like native select dropdown element.'] }, \"Select Box\"),\n                getRole: () => isMacintosh ? '' : 'option',\n                getWidgetRole: () => 'listbox'\n            }\n        }));\n        if (this.selectBoxOptions.ariaLabel) {\n            this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel;\n        }\n        // SetUp list keyboard controller - control navigation, disabled items, focus\n        const onKeyDown = this._register(new DomEmitter(this.selectDropDownListContainer, 'keydown'));\n        const onSelectDropDownKeyDown = Event.chain(onKeyDown.event, $ => $.filter(() => this.selectList.length > 0)\n            .map(e => new StandardKeyboardEvent(e)));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 3 /* KeyCode.Enter */))(this.onEnter, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 2 /* KeyCode.Tab */))(this.onEnter, this)); // Tab should behave the same as enter, #79339\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 9 /* KeyCode.Escape */))(this.onEscape, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 16 /* KeyCode.UpArrow */))(this.onUpArrow, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 18 /* KeyCode.DownArrow */))(this.onDownArrow, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 12 /* KeyCode.PageDown */))(this.onPageDown, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 11 /* KeyCode.PageUp */))(this.onPageUp, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 14 /* KeyCode.Home */))(this.onHome, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => e.keyCode === 13 /* KeyCode.End */))(this.onEnd, this));\n        this._register(Event.chain(onSelectDropDownKeyDown, $ => $.filter(e => (e.keyCode >= 21 /* KeyCode.Digit0 */ && e.keyCode <= 56 /* KeyCode.KeyZ */) || (e.keyCode >= 85 /* KeyCode.Semicolon */ && e.keyCode <= 113 /* KeyCode.NumpadDivide */)))(this.onCharacter, this));\n        // SetUp list mouse controller - control navigation, disabled items, focus\n        this._register(dom.addDisposableListener(this.selectList.getHTMLElement(), dom.EventType.POINTER_UP, e => this.onPointerUp(e)));\n        this._register(this.selectList.onMouseOver(e => typeof e.index !== 'undefined' && this.selectList.setFocus([e.index])));\n        this._register(this.selectList.onDidChangeFocus(e => this.onListFocus(e)));\n        this._register(dom.addDisposableListener(this.selectDropDownContainer, dom.EventType.FOCUS_OUT, e => {\n            if (!this._isVisible || dom.isAncestor(e.relatedTarget, this.selectDropDownContainer)) {\n                return;\n            }\n            this.onListBlur();\n        }));\n        this.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel || '');\n        this.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n        this.styleList();\n    }\n    // List methods\n    // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n    // Also takes in touchend events\n    onPointerUp(e) {\n        if (!this.selectList.length) {\n            return;\n        }\n        dom.EventHelper.stop(e);\n        const target = e.target;\n        if (!target) {\n            return;\n        }\n        // Check our mouse event is on an option (not scrollbar)\n        if (target.classList.contains('slider')) {\n            return;\n        }\n        const listRowElement = target.closest('.monaco-list-row');\n        if (!listRowElement) {\n            return;\n        }\n        const index = Number(listRowElement.getAttribute('data-index'));\n        const disabled = listRowElement.classList.contains('option-disabled');\n        // Ignore mouse selection of disabled options\n        if (index >= 0 && index < this.options.length && !disabled) {\n            this.selected = index;\n            this.select(this.selected);\n            this.selectList.setFocus([this.selected]);\n            this.selectList.reveal(this.selectList.getFocus()[0]);\n            // Only fire if selection change\n            if (this.selected !== this._currentSelection) {\n                // Set current = selected\n                this._currentSelection = this.selected;\n                this._onDidSelect.fire({\n                    index: this.selectElement.selectedIndex,\n                    selected: this.options[this.selected].text\n                });\n                if (!!this.options[this.selected] && !!this.options[this.selected].text) {\n                    this.setTitle(this.options[this.selected].text);\n                }\n            }\n            this.hideSelectDropDown(true);\n        }\n    }\n    // List Exit - passive - implicit no selection change, hide drop-down\n    onListBlur() {\n        if (this._sticky) {\n            return;\n        }\n        if (this.selected !== this._currentSelection) {\n            // Reset selected to current if no change\n            this.select(this._currentSelection);\n        }\n        this.hideSelectDropDown(false);\n    }\n    renderDescriptionMarkdown(text, actionHandler) {\n        const cleanRenderedMarkdown = (element) => {\n            for (let i = 0; i < element.childNodes.length; i++) {\n                const child = element.childNodes.item(i);\n                const tagName = child.tagName && child.tagName.toLowerCase();\n                if (tagName === 'img') {\n                    child.remove();\n                }\n                else {\n                    cleanRenderedMarkdown(child);\n                }\n            }\n        };\n        const rendered = renderMarkdown({ value: text, supportThemeIcons: true }, { actionHandler });\n        rendered.element.classList.add('select-box-description-markdown');\n        cleanRenderedMarkdown(rendered.element);\n        return rendered.element;\n    }\n    // List Focus Change - passive - update details pane with newly focused element's data\n    onListFocus(e) {\n        // Skip during initial layout\n        if (!this._isVisible || !this._hasDetails) {\n            return;\n        }\n        this.updateDetail(e.indexes[0]);\n    }\n    updateDetail(selectedIndex) {\n        this.selectionDetailsPane.innerText = '';\n        const option = this.options[selectedIndex];\n        const description = option?.description ?? '';\n        const descriptionIsMarkdown = option?.descriptionIsMarkdown ?? false;\n        if (description) {\n            if (descriptionIsMarkdown) {\n                const actionHandler = option.descriptionMarkdownActionHandler;\n                this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description, actionHandler));\n            }\n            else {\n                this.selectionDetailsPane.innerText = description;\n            }\n            this.selectionDetailsPane.style.display = 'block';\n        }\n        else {\n            this.selectionDetailsPane.style.display = 'none';\n        }\n        // Avoid recursion\n        this._skipLayout = true;\n        this.contextViewProvider.layout();\n        this._skipLayout = false;\n    }\n    // List keyboard controller\n    // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n    onEscape(e) {\n        dom.EventHelper.stop(e);\n        // Reset selection to value when opened\n        this.select(this._currentSelection);\n        this.hideSelectDropDown(true);\n    }\n    // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n    onEnter(e) {\n        dom.EventHelper.stop(e);\n        // Only fire if selection change\n        if (this.selected !== this._currentSelection) {\n            this._currentSelection = this.selected;\n            this._onDidSelect.fire({\n                index: this.selectElement.selectedIndex,\n                selected: this.options[this.selected].text\n            });\n            if (!!this.options[this.selected] && !!this.options[this.selected].text) {\n                this.setTitle(this.options[this.selected].text);\n            }\n        }\n        this.hideSelectDropDown(true);\n    }\n    // List navigation - have to handle a disabled option (jump over)\n    onDownArrow(e) {\n        if (this.selected < this.options.length - 1) {\n            dom.EventHelper.stop(e, true);\n            // Skip disabled options\n            const nextOptionDisabled = this.options[this.selected + 1].isDisabled;\n            if (nextOptionDisabled && this.options.length > this.selected + 2) {\n                this.selected += 2;\n            }\n            else if (nextOptionDisabled) {\n                return;\n            }\n            else {\n                this.selected++;\n            }\n            // Set focus/selection - only fire event when closing drop-down or on blur\n            this.select(this.selected);\n            this.selectList.setFocus([this.selected]);\n            this.selectList.reveal(this.selectList.getFocus()[0]);\n        }\n    }\n    onUpArrow(e) {\n        if (this.selected > 0) {\n            dom.EventHelper.stop(e, true);\n            // Skip disabled options\n            const previousOptionDisabled = this.options[this.selected - 1].isDisabled;\n            if (previousOptionDisabled && this.selected > 1) {\n                this.selected -= 2;\n            }\n            else {\n                this.selected--;\n            }\n            // Set focus/selection - only fire event when closing drop-down or on blur\n            this.select(this.selected);\n            this.selectList.setFocus([this.selected]);\n            this.selectList.reveal(this.selectList.getFocus()[0]);\n        }\n    }\n    onPageUp(e) {\n        dom.EventHelper.stop(e);\n        this.selectList.focusPreviousPage();\n        // Allow scrolling to settle\n        setTimeout(() => {\n            this.selected = this.selectList.getFocus()[0];\n            // Shift selection down if we land on a disabled option\n            if (this.options[this.selected].isDisabled && this.selected < this.options.length - 1) {\n                this.selected++;\n                this.selectList.setFocus([this.selected]);\n            }\n            this.selectList.reveal(this.selected);\n            this.select(this.selected);\n        }, 1);\n    }\n    onPageDown(e) {\n        dom.EventHelper.stop(e);\n        this.selectList.focusNextPage();\n        // Allow scrolling to settle\n        setTimeout(() => {\n            this.selected = this.selectList.getFocus()[0];\n            // Shift selection up if we land on a disabled option\n            if (this.options[this.selected].isDisabled && this.selected > 0) {\n                this.selected--;\n                this.selectList.setFocus([this.selected]);\n            }\n            this.selectList.reveal(this.selected);\n            this.select(this.selected);\n        }, 1);\n    }\n    onHome(e) {\n        dom.EventHelper.stop(e);\n        if (this.options.length < 2) {\n            return;\n        }\n        this.selected = 0;\n        if (this.options[this.selected].isDisabled && this.selected > 1) {\n            this.selected++;\n        }\n        this.selectList.setFocus([this.selected]);\n        this.selectList.reveal(this.selected);\n        this.select(this.selected);\n    }\n    onEnd(e) {\n        dom.EventHelper.stop(e);\n        if (this.options.length < 2) {\n            return;\n        }\n        this.selected = this.options.length - 1;\n        if (this.options[this.selected].isDisabled && this.selected > 1) {\n            this.selected--;\n        }\n        this.selectList.setFocus([this.selected]);\n        this.selectList.reveal(this.selected);\n        this.select(this.selected);\n    }\n    // Mimic option first character navigation of native select\n    onCharacter(e) {\n        const ch = KeyCodeUtils.toString(e.keyCode);\n        let optionIndex = -1;\n        for (let i = 0; i < this.options.length - 1; i++) {\n            optionIndex = (i + this.selected + 1) % this.options.length;\n            if (this.options[optionIndex].text.charAt(0).toUpperCase() === ch && !this.options[optionIndex].isDisabled) {\n                this.select(optionIndex);\n                this.selectList.setFocus([optionIndex]);\n                this.selectList.reveal(this.selectList.getFocus()[0]);\n                dom.EventHelper.stop(e);\n                break;\n            }\n        }\n    }\n    dispose() {\n        this.hideSelectDropDown(false);\n        super.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { $, addDisposableListener, append, asCSSUrl, EventType, ModifierKeyEmitter, prepend } from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { ActionViewItem, BaseActionViewItem, SelectActionViewItem } from '../../../base/browser/ui/actionbar/actionViewItems.js';\nimport { DropdownMenuActionViewItem } from '../../../base/browser/ui/dropdown/dropdownActionViewItem.js';\nimport { ActionRunner, Separator, SubmenuAction } from '../../../base/common/actions.js';\nimport { UILabelProvider } from '../../../base/common/keybindingLabels.js';\nimport { combinedDisposable, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { isLinux, isWindows, OS } from '../../../base/common/platform.js';\nimport './menuEntryActionViewItem.css';\nimport { localize } from '../../../nls.js';\nimport { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';\nimport { isICommandActionToggleInfo } from '../../action/common/action.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { IContextMenuService, IContextViewService } from '../../contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { IThemeService } from '../../theme/common/themeService.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { isDark } from '../../theme/common/theme.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { asCssVariable, selectBorder } from '../../theme/common/colorRegistry.js';\nimport { defaultSelectBoxStyles } from '../../theme/browser/defaultStyles.js';\nimport { IAccessibilityService } from '../../accessibility/common/accessibility.js';\nexport function createAndFillInContextMenuActions(menu, optionsOrTarget, targetOrPrimaryGroup, primaryGroupOrUndefined) {\n    let target;\n    let primaryGroup;\n    let groups;\n    if (Array.isArray(menu)) {\n        groups = menu;\n        target = optionsOrTarget;\n        primaryGroup = targetOrPrimaryGroup;\n    }\n    else {\n        const options = optionsOrTarget;\n        groups = menu.getActions(options);\n        target = targetOrPrimaryGroup;\n        primaryGroup = primaryGroupOrUndefined;\n    }\n    const modifierKeyEmitter = ModifierKeyEmitter.getInstance();\n    const useAlternativeActions = modifierKeyEmitter.keyStatus.altKey || ((isWindows || isLinux) && modifierKeyEmitter.keyStatus.shiftKey);\n    fillInActions(groups, target, useAlternativeActions, primaryGroup ? actionGroup => actionGroup === primaryGroup : actionGroup => actionGroup === 'navigation');\n}\nexport function createAndFillInActionBarActions(menu, optionsOrTarget, targetOrPrimaryGroup, primaryGroupOrShouldInlineSubmenu, shouldInlineSubmenuOrUseSeparatorsInPrimaryActions, useSeparatorsInPrimaryActionsOrUndefined) {\n    let target;\n    let primaryGroup;\n    let shouldInlineSubmenu;\n    let useSeparatorsInPrimaryActions;\n    let groups;\n    if (Array.isArray(menu)) {\n        groups = menu;\n        target = optionsOrTarget;\n        primaryGroup = targetOrPrimaryGroup;\n        shouldInlineSubmenu = primaryGroupOrShouldInlineSubmenu;\n        useSeparatorsInPrimaryActions = shouldInlineSubmenuOrUseSeparatorsInPrimaryActions;\n    }\n    else {\n        const options = optionsOrTarget;\n        groups = menu.getActions(options);\n        target = targetOrPrimaryGroup;\n        primaryGroup = primaryGroupOrShouldInlineSubmenu;\n        shouldInlineSubmenu = shouldInlineSubmenuOrUseSeparatorsInPrimaryActions;\n        useSeparatorsInPrimaryActions = useSeparatorsInPrimaryActionsOrUndefined;\n    }\n    const isPrimaryAction = typeof primaryGroup === 'string' ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;\n    // Action bars handle alternative actions on their own so the alternative actions should be ignored\n    fillInActions(groups, target, false, isPrimaryAction, shouldInlineSubmenu, useSeparatorsInPrimaryActions);\n}\nfunction fillInActions(groups, target, useAlternativeActions, isPrimaryAction = actionGroup => actionGroup === 'navigation', shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {\n    let primaryBucket;\n    let secondaryBucket;\n    if (Array.isArray(target)) {\n        primaryBucket = target;\n        secondaryBucket = target;\n    }\n    else {\n        primaryBucket = target.primary;\n        secondaryBucket = target.secondary;\n    }\n    const submenuInfo = new Set();\n    for (const [group, actions] of groups) {\n        let target;\n        if (isPrimaryAction(group)) {\n            target = primaryBucket;\n            if (target.length > 0 && useSeparatorsInPrimaryActions) {\n                target.push(new Separator());\n            }\n        }\n        else {\n            target = secondaryBucket;\n            if (target.length > 0) {\n                target.push(new Separator());\n            }\n        }\n        for (let action of actions) {\n            if (useAlternativeActions) {\n                action = action instanceof MenuItemAction && action.alt ? action.alt : action;\n            }\n            const newLen = target.push(action);\n            // keep submenu info for later inlining\n            if (action instanceof SubmenuAction) {\n                submenuInfo.add({ group, action, index: newLen - 1 });\n            }\n        }\n    }\n    // ask the outside if submenu should be inlined or not. only ask when\n    // there would be enough space\n    for (const { group, action, index } of submenuInfo) {\n        const target = isPrimaryAction(group) ? primaryBucket : secondaryBucket;\n        // inlining submenus with length 0 or 1 is easy,\n        // larger submenus need to be checked with the overall limit\n        const submenuActions = action.actions;\n        if (shouldInlineSubmenu(action, group, target.length)) {\n            target.splice(index, 1, ...submenuActions);\n        }\n    }\n}\nlet MenuEntryActionViewItem = class MenuEntryActionViewItem extends ActionViewItem {\n    constructor(action, _options, _keybindingService, _notificationService, _contextKeyService, _themeService, _contextMenuService, _accessibilityService) {\n        super(undefined, action, { icon: !!(action.class || action.item.icon), label: !action.class && !action.item.icon, draggable: _options?.draggable, keybinding: _options?.keybinding, hoverDelegate: _options?.hoverDelegate });\n        this._options = _options;\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextKeyService = _contextKeyService;\n        this._themeService = _themeService;\n        this._contextMenuService = _contextMenuService;\n        this._accessibilityService = _accessibilityService;\n        this._wantsAltCommand = false;\n        this._itemClassDispose = this._register(new MutableDisposable());\n        this._altKey = ModifierKeyEmitter.getInstance();\n    }\n    get _menuItemAction() {\n        return this._action;\n    }\n    get _commandAction() {\n        return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;\n    }\n    async onClick(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        try {\n            await this.actionRunner.run(this._commandAction, this._context);\n        }\n        catch (err) {\n            this._notificationService.error(err);\n        }\n    }\n    render(container) {\n        super.render(container);\n        container.classList.add('menu-entry');\n        if (this.options.icon) {\n            this._updateItemClass(this._menuItemAction.item);\n        }\n        if (this._menuItemAction.alt) {\n            let isMouseOver = false;\n            const updateAltState = () => {\n                const wantsAltCommand = !!this._menuItemAction.alt?.enabled &&\n                    (!this._accessibilityService.isMotionReduced() || isMouseOver) && (this._altKey.keyStatus.altKey ||\n                    (this._altKey.keyStatus.shiftKey && isMouseOver));\n                if (wantsAltCommand !== this._wantsAltCommand) {\n                    this._wantsAltCommand = wantsAltCommand;\n                    this.updateLabel();\n                    this.updateTooltip();\n                    this.updateClass();\n                }\n            };\n            this._register(this._altKey.event(updateAltState));\n            this._register(addDisposableListener(container, 'mouseleave', _ => {\n                isMouseOver = false;\n                updateAltState();\n            }));\n            this._register(addDisposableListener(container, 'mouseenter', _ => {\n                isMouseOver = true;\n                updateAltState();\n            }));\n            updateAltState();\n        }\n    }\n    updateLabel() {\n        if (this.options.label && this.label) {\n            this.label.textContent = this._commandAction.label;\n        }\n    }\n    getTooltip() {\n        const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);\n        const keybindingLabel = keybinding && keybinding.getLabel();\n        const tooltip = this._commandAction.tooltip || this._commandAction.label;\n        let title = keybindingLabel\n            ? localize('titleAndKb', \"{0} ({1})\", tooltip, keybindingLabel)\n            : tooltip;\n        if (!this._wantsAltCommand && this._menuItemAction.alt?.enabled) {\n            const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;\n            const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);\n            const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();\n            const altTitleSection = altKeybindingLabel\n                ? localize('titleAndKb', \"{0} ({1})\", altTooltip, altKeybindingLabel)\n                : altTooltip;\n            title = localize('titleAndKbAndAlt', \"{0}\\n[{1}] {2}\", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);\n        }\n        return title;\n    }\n    updateClass() {\n        if (this.options.icon) {\n            if (this._commandAction !== this._menuItemAction) {\n                if (this._menuItemAction.alt) {\n                    this._updateItemClass(this._menuItemAction.alt.item);\n                }\n            }\n            else {\n                this._updateItemClass(this._menuItemAction.item);\n            }\n        }\n    }\n    _updateItemClass(item) {\n        this._itemClassDispose.value = undefined;\n        const { element, label } = this;\n        if (!element || !label) {\n            return;\n        }\n        const icon = this._commandAction.checked && isICommandActionToggleInfo(item.toggled) && item.toggled.icon ? item.toggled.icon : item.icon;\n        if (!icon) {\n            return;\n        }\n        if (ThemeIcon.isThemeIcon(icon)) {\n            // theme icons\n            const iconClasses = ThemeIcon.asClassNameArray(icon);\n            label.classList.add(...iconClasses);\n            this._itemClassDispose.value = toDisposable(() => {\n                label.classList.remove(...iconClasses);\n            });\n        }\n        else {\n            // icon path/url\n            label.style.backgroundImage = (isDark(this._themeService.getColorTheme().type)\n                ? asCSSUrl(icon.dark)\n                : asCSSUrl(icon.light));\n            label.classList.add('icon');\n            this._itemClassDispose.value = combinedDisposable(toDisposable(() => {\n                label.style.backgroundImage = '';\n                label.classList.remove('icon');\n            }), this._themeService.onDidColorThemeChange(() => {\n                // refresh when the theme changes in case we go between dark <-> light\n                this.updateClass();\n            }));\n        }\n    }\n};\nMenuEntryActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextKeyService),\n    __param(5, IThemeService),\n    __param(6, IContextMenuService),\n    __param(7, IAccessibilityService)\n], MenuEntryActionViewItem);\nexport { MenuEntryActionViewItem };\nexport class TextOnlyMenuEntryActionViewItem extends MenuEntryActionViewItem {\n    render(container) {\n        this.options.label = true;\n        this.options.icon = false;\n        super.render(container);\n        container.classList.add('text-only');\n        container.classList.toggle('use-comma', this._options?.useComma ?? false);\n    }\n    updateLabel() {\n        const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);\n        if (!kb) {\n            return super.updateLabel();\n        }\n        if (this.label) {\n            const kb2 = TextOnlyMenuEntryActionViewItem._symbolPrintEnter(kb);\n            if (this._options?.conversational) {\n                this.label.textContent = localize({ key: 'content2', comment: ['A label with keybindg like \"ESC to dismiss\"'] }, '{1} to {0}', this._action.label, kb2);\n            }\n            else {\n                this.label.textContent = localize({ key: 'content', comment: ['A label', 'A keybinding'] }, '{0} ({1})', this._action.label, kb2);\n            }\n        }\n    }\n    static _symbolPrintEnter(kb) {\n        return kb.getLabel()\n            ?.replace(/\\benter\\b/gi, '\\u23CE')\n            .replace(/\\bEscape\\b/gi, 'Esc');\n    }\n}\nlet SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem extends DropdownMenuActionViewItem {\n    constructor(action, options, _keybindingService, _contextMenuService, _themeService) {\n        const dropdownOptions = {\n            ...options,\n            menuAsChild: options?.menuAsChild ?? false,\n            classNames: options?.classNames ?? (ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : undefined),\n            keybindingProvider: options?.keybindingProvider ?? (action => _keybindingService.lookupKeybinding(action.id))\n        };\n        super(action, { getActions: () => action.actions }, _contextMenuService, dropdownOptions);\n        this._keybindingService = _keybindingService;\n        this._contextMenuService = _contextMenuService;\n        this._themeService = _themeService;\n    }\n    render(container) {\n        super.render(container);\n        assertType(this.element);\n        container.classList.add('menu-entry');\n        const action = this._action;\n        const { icon } = action.item;\n        if (icon && !ThemeIcon.isThemeIcon(icon)) {\n            this.element.classList.add('icon');\n            const setBackgroundImage = () => {\n                if (this.element) {\n                    this.element.style.backgroundImage = (isDark(this._themeService.getColorTheme().type)\n                        ? asCSSUrl(icon.dark)\n                        : asCSSUrl(icon.light));\n                }\n            };\n            setBackgroundImage();\n            this._register(this._themeService.onDidColorThemeChange(() => {\n                // refresh when the theme changes in case we go between dark <-> light\n                setBackgroundImage();\n            }));\n        }\n    }\n};\nSubmenuEntryActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, IContextMenuService),\n    __param(4, IThemeService)\n], SubmenuEntryActionViewItem);\nexport { SubmenuEntryActionViewItem };\nlet DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends BaseActionViewItem {\n    constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {\n        super(null, submenuAction);\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextMenuService = _contextMenuService;\n        this._menuService = _menuService;\n        this._instaService = _instaService;\n        this._storageService = _storageService;\n        this._container = null;\n        this._options = options;\n        this._storageKey = `${submenuAction.item.submenu.id}_lastActionId`;\n        // determine default action\n        let defaultAction;\n        const defaultActionId = options?.persistLastActionId ? _storageService.get(this._storageKey, 1 /* StorageScope.WORKSPACE */) : undefined;\n        if (defaultActionId) {\n            defaultAction = submenuAction.actions.find(a => defaultActionId === a.id);\n        }\n        if (!defaultAction) {\n            defaultAction = submenuAction.actions[0];\n        }\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, { keybinding: this._getDefaultActionKeybindingLabel(defaultAction) });\n        const dropdownOptions = {\n            keybindingProvider: action => this._keybindingService.lookupKeybinding(action.id),\n            ...options,\n            menuAsChild: options?.menuAsChild ?? true,\n            classNames: options?.classNames ?? ['codicon', 'codicon-chevron-down'],\n            actionRunner: options?.actionRunner ?? new ActionRunner(),\n        };\n        this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);\n        this._register(this._dropdown.actionRunner.onDidRun((e) => {\n            if (e.action instanceof MenuItemAction) {\n                this.update(e.action);\n            }\n        }));\n    }\n    update(lastAction) {\n        if (this._options?.persistLastActionId) {\n            this._storageService.store(this._storageKey, lastAction.id, 1 /* StorageScope.WORKSPACE */, 1 /* StorageTarget.MACHINE */);\n        }\n        this._defaultAction.dispose();\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, { keybinding: this._getDefaultActionKeybindingLabel(lastAction) });\n        this._defaultAction.actionRunner = new class extends ActionRunner {\n            async runAction(action, context) {\n                await action.run(undefined);\n            }\n        }();\n        if (this._container) {\n            this._defaultAction.render(prepend(this._container, $('.action-container')));\n        }\n    }\n    _getDefaultActionKeybindingLabel(defaultAction) {\n        let defaultActionKeybinding;\n        if (this._options?.renderKeybindingWithDefaultActionLabel) {\n            const kb = this._keybindingService.lookupKeybinding(defaultAction.id);\n            if (kb) {\n                defaultActionKeybinding = `(${kb.getLabel()})`;\n            }\n        }\n        return defaultActionKeybinding;\n    }\n    setActionContext(newContext) {\n        super.setActionContext(newContext);\n        this._defaultAction.setActionContext(newContext);\n        this._dropdown.setActionContext(newContext);\n    }\n    render(container) {\n        this._container = container;\n        super.render(this._container);\n        this._container.classList.add('monaco-dropdown-with-default');\n        const primaryContainer = $('.action-container');\n        this._defaultAction.render(append(this._container, primaryContainer));\n        this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(17 /* KeyCode.RightArrow */)) {\n                this._defaultAction.element.tabIndex = -1;\n                this._dropdown.focus();\n                event.stopPropagation();\n            }\n        }));\n        const dropdownContainer = $('.dropdown-action-container');\n        this._dropdown.render(append(this._container, dropdownContainer));\n        this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                this._defaultAction.element.tabIndex = 0;\n                this._dropdown.setFocusable(false);\n                this._defaultAction.element?.focus();\n                event.stopPropagation();\n            }\n        }));\n    }\n    focus(fromRight) {\n        if (fromRight) {\n            this._dropdown.focus();\n        }\n        else {\n            this._defaultAction.element.tabIndex = 0;\n            this._defaultAction.element.focus();\n        }\n    }\n    blur() {\n        this._defaultAction.element.tabIndex = -1;\n        this._dropdown.blur();\n        this._container.blur();\n    }\n    setFocusable(focusable) {\n        if (focusable) {\n            this._defaultAction.element.tabIndex = 0;\n        }\n        else {\n            this._defaultAction.element.tabIndex = -1;\n            this._dropdown.setFocusable(false);\n        }\n    }\n    dispose() {\n        this._defaultAction.dispose();\n        this._dropdown.dispose();\n        super.dispose();\n    }\n};\nDropdownWithDefaultActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextMenuService),\n    __param(5, IMenuService),\n    __param(6, IInstantiationService),\n    __param(7, IStorageService)\n], DropdownWithDefaultActionViewItem);\nexport { DropdownWithDefaultActionViewItem };\nlet SubmenuEntrySelectActionViewItem = class SubmenuEntrySelectActionViewItem extends SelectActionViewItem {\n    constructor(action, contextViewService) {\n        super(null, action, action.actions.map(a => ({\n            text: a.id === Separator.ID ? '\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500' : a.label,\n            isDisabled: !a.enabled,\n        })), 0, contextViewService, defaultSelectBoxStyles, { ariaLabel: action.tooltip, optionsAsChildren: true });\n        this.select(Math.max(0, action.actions.findIndex(a => a.checked)));\n    }\n    render(container) {\n        super.render(container);\n        container.style.borderColor = asCssVariable(selectBorder);\n    }\n    runAction(option, index) {\n        const action = this.action.actions[index];\n        if (action) {\n            this.actionRunner.run(action);\n        }\n    }\n};\nSubmenuEntrySelectActionViewItem = __decorate([\n    __param(1, IContextViewService)\n], SubmenuEntrySelectActionViewItem);\n/**\n * Creates action view items for menu actions or submenu actions.\n */\nexport function createActionViewItem(instaService, action, options) {\n    if (action instanceof MenuItemAction) {\n        return instaService.createInstance(MenuEntryActionViewItem, action, options);\n    }\n    else if (action instanceof SubmenuItemAction) {\n        if (action.item.isSelection) {\n            return instaService.createInstance(SubmenuEntrySelectActionViewItem, action);\n        }\n        else {\n            if (action.item.rememberDefaultAction) {\n                return instaService.createInstance(DropdownWithDefaultActionViewItem, action, { ...options, persistLastActionId: true });\n            }\n            else {\n                return instaService.createInstance(SubmenuEntryActionViewItem, action, options);\n            }\n        }\n    }\n    else {\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFirefox } from '../../browser.js';\nimport { EventType as TouchEventType, Gesture } from '../../touch.js';\nimport { $, addDisposableListener, append, clearNode, createStyleSheet, Dimension, EventHelper, EventType, getActiveElement, getWindow, isAncestor, isInShadowDOM } from '../../dom.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { StandardMouseEvent } from '../../mouseEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { ActionViewItem, BaseActionViewItem } from '../actionbar/actionViewItems.js';\nimport { layout } from '../contextview/contextview.js';\nimport { DomScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { EmptySubmenuAction, Separator, SubmenuAction } from '../../../common/actions.js';\nimport { RunOnceScheduler } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { getCodiconFontCharacters } from '../../../common/codiconsUtil.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { stripIcons } from '../../../common/iconLabels.js';\nimport { DisposableStore } from '../../../common/lifecycle.js';\nimport { isLinux, isMacintosh } from '../../../common/platform.js';\nimport * as strings from '../../../common/strings.js';\nexport const MENU_MNEMONIC_REGEX = /\\(&([^\\s&])\\)|(^|[^&])&([^\\s&])/;\nexport const MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\\s&])/g;\nexport var HorizontalDirection;\n(function (HorizontalDirection) {\n    HorizontalDirection[HorizontalDirection[\"Right\"] = 0] = \"Right\";\n    HorizontalDirection[HorizontalDirection[\"Left\"] = 1] = \"Left\";\n})(HorizontalDirection || (HorizontalDirection = {}));\nexport var VerticalDirection;\n(function (VerticalDirection) {\n    VerticalDirection[VerticalDirection[\"Above\"] = 0] = \"Above\";\n    VerticalDirection[VerticalDirection[\"Below\"] = 1] = \"Below\";\n})(VerticalDirection || (VerticalDirection = {}));\nexport class Menu extends ActionBar {\n    constructor(container, actions, options, menuStyles) {\n        container.classList.add('monaco-menu-container');\n        container.setAttribute('role', 'presentation');\n        const menuElement = document.createElement('div');\n        menuElement.classList.add('monaco-menu');\n        menuElement.setAttribute('role', 'presentation');\n        super(menuElement, {\n            orientation: 1 /* ActionsOrientation.VERTICAL */,\n            actionViewItemProvider: action => this.doGetActionViewItem(action, options, parentData),\n            context: options.context,\n            actionRunner: options.actionRunner,\n            ariaLabel: options.ariaLabel,\n            ariaRole: 'menu',\n            focusOnlyEnabledItems: true,\n            triggerKeys: { keys: [3 /* KeyCode.Enter */, ...(isMacintosh || isLinux ? [10 /* KeyCode.Space */] : [])], keyDown: true }\n        });\n        this.menuStyles = menuStyles;\n        this.menuElement = menuElement;\n        this.actionsList.tabIndex = 0;\n        this.initializeOrUpdateStyleSheet(container, menuStyles);\n        this._register(Gesture.addTarget(menuElement));\n        this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            // Stop tab navigation of menus\n            if (event.equals(2 /* KeyCode.Tab */)) {\n                e.preventDefault();\n            }\n        }));\n        if (options.enableMnemonics) {\n            this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {\n                const key = e.key.toLocaleLowerCase();\n                if (this.mnemonics.has(key)) {\n                    EventHelper.stop(e, true);\n                    const actions = this.mnemonics.get(key);\n                    if (actions.length === 1) {\n                        if (actions[0] instanceof SubmenuMenuActionViewItem && actions[0].container) {\n                            this.focusItemByElement(actions[0].container);\n                        }\n                        actions[0].onClick(e);\n                    }\n                    if (actions.length > 1) {\n                        const action = actions.shift();\n                        if (action && action.container) {\n                            this.focusItemByElement(action.container);\n                            actions.push(action);\n                        }\n                        this.mnemonics.set(key, actions);\n                    }\n                }\n            }));\n        }\n        if (isLinux) {\n            this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(14 /* KeyCode.Home */) || event.equals(11 /* KeyCode.PageUp */)) {\n                    this.focusedItem = this.viewItems.length - 1;\n                    this.focusNext();\n                    EventHelper.stop(e, true);\n                }\n                else if (event.equals(13 /* KeyCode.End */) || event.equals(12 /* KeyCode.PageDown */)) {\n                    this.focusedItem = 0;\n                    this.focusPrevious();\n                    EventHelper.stop(e, true);\n                }\n            }));\n        }\n        this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, e => {\n            const relatedTarget = e.relatedTarget;\n            if (!isAncestor(relatedTarget, this.domNode)) {\n                this.focusedItem = undefined;\n                this.updateFocus();\n                e.stopPropagation();\n            }\n        }));\n        this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, e => {\n            let target = e.target;\n            if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {\n                return;\n            }\n            while (target.parentElement !== this.actionsList && target.parentElement !== null) {\n                target = target.parentElement;\n            }\n            if (target.classList.contains('action-item')) {\n                const lastFocusedItem = this.focusedItem;\n                this.setFocusedItem(target);\n                if (lastFocusedItem !== this.focusedItem) {\n                    this.updateFocus();\n                }\n            }\n        }));\n        // Support touch on actions list to focus items (needed for submenus)\n        this._register(Gesture.addTarget(this.actionsList));\n        this._register(addDisposableListener(this.actionsList, TouchEventType.Tap, e => {\n            let target = e.initialTarget;\n            if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {\n                return;\n            }\n            while (target.parentElement !== this.actionsList && target.parentElement !== null) {\n                target = target.parentElement;\n            }\n            if (target.classList.contains('action-item')) {\n                const lastFocusedItem = this.focusedItem;\n                this.setFocusedItem(target);\n                if (lastFocusedItem !== this.focusedItem) {\n                    this.updateFocus();\n                }\n            }\n        }));\n        const parentData = {\n            parent: this\n        };\n        this.mnemonics = new Map();\n        // Scroll Logic\n        this.scrollableElement = this._register(new DomScrollableElement(menuElement, {\n            alwaysConsumeMouseWheel: true,\n            horizontal: 2 /* ScrollbarVisibility.Hidden */,\n            vertical: 3 /* ScrollbarVisibility.Visible */,\n            verticalScrollbarSize: 7,\n            handleMouseWheel: true,\n            useShadows: true\n        }));\n        const scrollElement = this.scrollableElement.getDomNode();\n        scrollElement.style.position = '';\n        this.styleScrollElement(scrollElement, menuStyles);\n        // Support scroll on menu drag\n        this._register(addDisposableListener(menuElement, TouchEventType.Change, e => {\n            EventHelper.stop(e, true);\n            const scrollTop = this.scrollableElement.getScrollPosition().scrollTop;\n            this.scrollableElement.setScrollPosition({ scrollTop: scrollTop - e.translationY });\n        }));\n        this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, e => {\n            // Absorb clicks in menu dead space https://github.com/microsoft/vscode/issues/63575\n            // We do this on the scroll element so the scroll bar doesn't dismiss the menu either\n            e.preventDefault();\n        }));\n        const window = getWindow(container);\n        menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;\n        actions = actions.filter((a, idx) => {\n            if (options.submenuIds?.has(a.id)) {\n                console.warn(`Found submenu cycle: ${a.id}`);\n                return false;\n            }\n            // Filter out consecutive or useless separators\n            if (a instanceof Separator) {\n                if (idx === actions.length - 1 || idx === 0) {\n                    return false;\n                }\n                const prevAction = actions[idx - 1];\n                if (prevAction instanceof Separator) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        this.push(actions, { icon: true, label: true, isMenu: true });\n        container.appendChild(this.scrollableElement.getDomNode());\n        this.scrollableElement.scanDomNode();\n        this.viewItems.filter(item => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {\n            item.updatePositionInSet(index + 1, array.length);\n        });\n    }\n    initializeOrUpdateStyleSheet(container, style) {\n        if (!this.styleSheet) {\n            if (isInShadowDOM(container)) {\n                this.styleSheet = createStyleSheet(container);\n            }\n            else {\n                if (!Menu.globalStyleSheet) {\n                    Menu.globalStyleSheet = createStyleSheet();\n                }\n                this.styleSheet = Menu.globalStyleSheet;\n            }\n        }\n        this.styleSheet.textContent = getMenuWidgetCSS(style, isInShadowDOM(container));\n    }\n    styleScrollElement(scrollElement, style) {\n        const fgColor = style.foregroundColor ?? '';\n        const bgColor = style.backgroundColor ?? '';\n        const border = style.borderColor ? `1px solid ${style.borderColor}` : '';\n        const borderRadius = '5px';\n        const shadow = style.shadowColor ? `0 2px 8px ${style.shadowColor}` : '';\n        scrollElement.style.outline = border;\n        scrollElement.style.borderRadius = borderRadius;\n        scrollElement.style.color = fgColor;\n        scrollElement.style.backgroundColor = bgColor;\n        scrollElement.style.boxShadow = shadow;\n    }\n    getContainer() {\n        return this.scrollableElement.getDomNode();\n    }\n    get onScroll() {\n        return this.scrollableElement.onScroll;\n    }\n    focusItemByElement(element) {\n        const lastFocusedItem = this.focusedItem;\n        this.setFocusedItem(element);\n        if (lastFocusedItem !== this.focusedItem) {\n            this.updateFocus();\n        }\n    }\n    setFocusedItem(element) {\n        for (let i = 0; i < this.actionsList.children.length; i++) {\n            const elem = this.actionsList.children[i];\n            if (element === elem) {\n                this.focusedItem = i;\n                break;\n            }\n        }\n    }\n    updateFocus(fromRight) {\n        super.updateFocus(fromRight, true, true);\n        if (typeof this.focusedItem !== 'undefined') {\n            // Workaround for #80047 caused by an issue in chromium\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=414283\n            // When that's fixed, just call this.scrollableElement.scanDomNode()\n            this.scrollableElement.setScrollPosition({\n                scrollTop: Math.round(this.menuElement.scrollTop)\n            });\n        }\n    }\n    doGetActionViewItem(action, options, parentData) {\n        if (action instanceof Separator) {\n            return new MenuSeparatorActionViewItem(options.context, action, { icon: true }, this.menuStyles);\n        }\n        else if (action instanceof SubmenuAction) {\n            const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, { ...options, submenuIds: new Set([...(options.submenuIds || []), action.id]) }, this.menuStyles);\n            if (options.enableMnemonics) {\n                const mnemonic = menuActionViewItem.getMnemonic();\n                if (mnemonic && menuActionViewItem.isEnabled()) {\n                    let actionViewItems = [];\n                    if (this.mnemonics.has(mnemonic)) {\n                        actionViewItems = this.mnemonics.get(mnemonic);\n                    }\n                    actionViewItems.push(menuActionViewItem);\n                    this.mnemonics.set(mnemonic, actionViewItems);\n                }\n            }\n            return menuActionViewItem;\n        }\n        else {\n            const menuItemOptions = { enableMnemonics: options.enableMnemonics, useEventAsContext: options.useEventAsContext };\n            if (options.getKeyBinding) {\n                const keybinding = options.getKeyBinding(action);\n                if (keybinding) {\n                    const keybindingLabel = keybinding.getLabel();\n                    if (keybindingLabel) {\n                        menuItemOptions.keybinding = keybindingLabel;\n                    }\n                }\n            }\n            const menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions, this.menuStyles);\n            if (options.enableMnemonics) {\n                const mnemonic = menuActionViewItem.getMnemonic();\n                if (mnemonic && menuActionViewItem.isEnabled()) {\n                    let actionViewItems = [];\n                    if (this.mnemonics.has(mnemonic)) {\n                        actionViewItems = this.mnemonics.get(mnemonic);\n                    }\n                    actionViewItems.push(menuActionViewItem);\n                    this.mnemonics.set(mnemonic, actionViewItems);\n                }\n            }\n            return menuActionViewItem;\n        }\n    }\n}\nclass BaseMenuActionViewItem extends BaseActionViewItem {\n    constructor(ctx, action, options, menuStyle) {\n        options.isMenu = true;\n        super(action, action, options);\n        this.menuStyle = menuStyle;\n        this.options = options;\n        this.options.icon = options.icon !== undefined ? options.icon : false;\n        this.options.label = options.label !== undefined ? options.label : true;\n        this.cssClass = '';\n        // Set mnemonic\n        if (this.options.label && options.enableMnemonics) {\n            const label = this.action.label;\n            if (label) {\n                const matches = MENU_MNEMONIC_REGEX.exec(label);\n                if (matches) {\n                    this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();\n                }\n            }\n        }\n        // Add mouse up listener later to avoid accidental clicks\n        this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {\n            if (!this.element) {\n                return;\n            }\n            this._register(addDisposableListener(this.element, EventType.MOUSE_UP, e => {\n                // removed default prevention as it conflicts\n                // with BaseActionViewItem #101537\n                // add back if issues arise and link new issue\n                EventHelper.stop(e, true);\n                // See https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Interact_with_the_clipboard\n                // > Writing to the clipboard\n                // > You can use the \"cut\" and \"copy\" commands without any special\n                // permission if you are using them in a short-lived event handler\n                // for a user action (for example, a click handler).\n                // => to get the Copy and Paste context menu actions working on Firefox,\n                // there should be no timeout here\n                if (isFirefox) {\n                    const mouseEvent = new StandardMouseEvent(getWindow(this.element), e);\n                    // Allowing right click to trigger the event causes the issue described below,\n                    // but since the solution below does not work in FF, we must disable right click\n                    if (mouseEvent.rightButton) {\n                        return;\n                    }\n                    this.onClick(e);\n                }\n                // In all other cases, set timeout to allow context menu cancellation to trigger\n                // otherwise the action will destroy the menu and a second context menu\n                // will still trigger for right click.\n                else {\n                    setTimeout(() => {\n                        this.onClick(e);\n                    }, 0);\n                }\n            }));\n            this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, e => {\n                EventHelper.stop(e, true);\n            }));\n        }, 100);\n        this._register(this.runOnceToEnableMouseUp);\n    }\n    render(container) {\n        super.render(container);\n        if (!this.element) {\n            return;\n        }\n        this.container = container;\n        this.item = append(this.element, $('a.action-menu-item'));\n        if (this._action.id === Separator.ID) {\n            // A separator is a presentation item\n            this.item.setAttribute('role', 'presentation');\n        }\n        else {\n            this.item.setAttribute('role', 'menuitem');\n            if (this.mnemonic) {\n                this.item.setAttribute('aria-keyshortcuts', `${this.mnemonic}`);\n            }\n        }\n        this.check = append(this.item, $('span.menu-item-check' + ThemeIcon.asCSSSelector(Codicon.menuSelection)));\n        this.check.setAttribute('role', 'none');\n        this.label = append(this.item, $('span.action-label'));\n        if (this.options.label && this.options.keybinding) {\n            append(this.item, $('span.keybinding')).textContent = this.options.keybinding;\n        }\n        // Adds mouse up listener to actually run the action\n        this.runOnceToEnableMouseUp.schedule();\n        this.updateClass();\n        this.updateLabel();\n        this.updateTooltip();\n        this.updateEnabled();\n        this.updateChecked();\n        this.applyStyle();\n    }\n    blur() {\n        super.blur();\n        this.applyStyle();\n    }\n    focus() {\n        super.focus();\n        this.item?.focus();\n        this.applyStyle();\n    }\n    updatePositionInSet(pos, setSize) {\n        if (this.item) {\n            this.item.setAttribute('aria-posinset', `${pos}`);\n            this.item.setAttribute('aria-setsize', `${setSize}`);\n        }\n    }\n    updateLabel() {\n        if (!this.label) {\n            return;\n        }\n        if (this.options.label) {\n            clearNode(this.label);\n            let label = stripIcons(this.action.label);\n            if (label) {\n                const cleanLabel = cleanMnemonic(label);\n                if (!this.options.enableMnemonics) {\n                    label = cleanLabel;\n                }\n                this.label.setAttribute('aria-label', cleanLabel.replace(/&&/g, '&'));\n                const matches = MENU_MNEMONIC_REGEX.exec(label);\n                if (matches) {\n                    label = strings.escape(label);\n                    // This is global, reset it\n                    MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;\n                    let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);\n                    // We can't use negative lookbehind so if we match our negative and skip\n                    while (escMatch && escMatch[1]) {\n                        escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);\n                    }\n                    const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, '&amp;');\n                    if (escMatch) {\n                        this.label.append(strings.ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), ' '), $('u', { 'aria-hidden': 'true' }, escMatch[3]), strings.rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), ' '));\n                    }\n                    else {\n                        this.label.innerText = replaceDoubleEscapes(label).trim();\n                    }\n                    this.item?.setAttribute('aria-keyshortcuts', (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());\n                }\n                else {\n                    this.label.innerText = label.replace(/&&/g, '&').trim();\n                }\n            }\n        }\n    }\n    updateTooltip() {\n        // menus should function like native menus and they do not have tooltips\n    }\n    updateClass() {\n        if (this.cssClass && this.item) {\n            this.item.classList.remove(...this.cssClass.split(' '));\n        }\n        if (this.options.icon && this.label) {\n            this.cssClass = this.action.class || '';\n            this.label.classList.add('icon');\n            if (this.cssClass) {\n                this.label.classList.add(...this.cssClass.split(' '));\n            }\n            this.updateEnabled();\n        }\n        else if (this.label) {\n            this.label.classList.remove('icon');\n        }\n    }\n    updateEnabled() {\n        if (this.action.enabled) {\n            if (this.element) {\n                this.element.classList.remove('disabled');\n                this.element.removeAttribute('aria-disabled');\n            }\n            if (this.item) {\n                this.item.classList.remove('disabled');\n                this.item.removeAttribute('aria-disabled');\n                this.item.tabIndex = 0;\n            }\n        }\n        else {\n            if (this.element) {\n                this.element.classList.add('disabled');\n                this.element.setAttribute('aria-disabled', 'true');\n            }\n            if (this.item) {\n                this.item.classList.add('disabled');\n                this.item.setAttribute('aria-disabled', 'true');\n            }\n        }\n    }\n    updateChecked() {\n        if (!this.item) {\n            return;\n        }\n        const checked = this.action.checked;\n        this.item.classList.toggle('checked', !!checked);\n        if (checked !== undefined) {\n            this.item.setAttribute('role', 'menuitemcheckbox');\n            this.item.setAttribute('aria-checked', checked ? 'true' : 'false');\n        }\n        else {\n            this.item.setAttribute('role', 'menuitem');\n            this.item.setAttribute('aria-checked', '');\n        }\n    }\n    getMnemonic() {\n        return this.mnemonic;\n    }\n    applyStyle() {\n        const isSelected = this.element && this.element.classList.contains('focused');\n        const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n        const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : undefined;\n        const outline = isSelected && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : '';\n        const outlineOffset = isSelected && this.menuStyle.selectionBorderColor ? `-1px` : '';\n        if (this.item) {\n            this.item.style.color = fgColor ?? '';\n            this.item.style.backgroundColor = bgColor ?? '';\n            this.item.style.outline = outline;\n            this.item.style.outlineOffset = outlineOffset;\n        }\n        if (this.check) {\n            this.check.style.color = fgColor ?? '';\n        }\n    }\n}\nclass SubmenuMenuActionViewItem extends BaseMenuActionViewItem {\n    constructor(action, submenuActions, parentData, submenuOptions, menuStyles) {\n        super(action, action, submenuOptions, menuStyles);\n        this.submenuActions = submenuActions;\n        this.parentData = parentData;\n        this.submenuOptions = submenuOptions;\n        this.mysubmenu = null;\n        this.submenuDisposables = this._register(new DisposableStore());\n        this.mouseOver = false;\n        this.expandDirection = submenuOptions && submenuOptions.expandDirection !== undefined ? submenuOptions.expandDirection : { horizontal: HorizontalDirection.Right, vertical: VerticalDirection.Below };\n        this.showScheduler = new RunOnceScheduler(() => {\n            if (this.mouseOver) {\n                this.cleanupExistingSubmenu(false);\n                this.createSubmenu(false);\n            }\n        }, 250);\n        this.hideScheduler = new RunOnceScheduler(() => {\n            if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {\n                this.parentData.parent.focus(false);\n                this.cleanupExistingSubmenu(true);\n            }\n        }, 750);\n    }\n    render(container) {\n        super.render(container);\n        if (!this.element) {\n            return;\n        }\n        if (this.item) {\n            this.item.classList.add('monaco-submenu-item');\n            this.item.tabIndex = 0;\n            this.item.setAttribute('aria-haspopup', 'true');\n            this.updateAriaExpanded('false');\n            this.submenuIndicator = append(this.item, $('span.submenu-indicator' + ThemeIcon.asCSSSelector(Codicon.menuSubmenu)));\n            this.submenuIndicator.setAttribute('aria-hidden', 'true');\n        }\n        this._register(addDisposableListener(this.element, EventType.KEY_UP, e => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(17 /* KeyCode.RightArrow */) || event.equals(3 /* KeyCode.Enter */)) {\n                EventHelper.stop(e, true);\n                this.createSubmenu(true);\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.KEY_DOWN, e => {\n            const event = new StandardKeyboardEvent(e);\n            if (getActiveElement() === this.item) {\n                if (event.equals(17 /* KeyCode.RightArrow */) || event.equals(3 /* KeyCode.Enter */)) {\n                    EventHelper.stop(e, true);\n                }\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, e => {\n            if (!this.mouseOver) {\n                this.mouseOver = true;\n                this.showScheduler.schedule();\n            }\n        }));\n        this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, e => {\n            this.mouseOver = false;\n        }));\n        this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, e => {\n            if (this.element && !isAncestor(getActiveElement(), this.element)) {\n                this.hideScheduler.schedule();\n            }\n        }));\n        this._register(this.parentData.parent.onScroll(() => {\n            if (this.parentData.submenu === this.mysubmenu) {\n                this.parentData.parent.focus(false);\n                this.cleanupExistingSubmenu(true);\n            }\n        }));\n    }\n    updateEnabled() {\n        // override on submenu entry\n        // native menus do not observe enablement on sumbenus\n        // we mimic that behavior\n    }\n    onClick(e) {\n        // stop clicking from trying to run an action\n        EventHelper.stop(e, true);\n        this.cleanupExistingSubmenu(false);\n        this.createSubmenu(true);\n    }\n    cleanupExistingSubmenu(force) {\n        if (this.parentData.submenu && (force || (this.parentData.submenu !== this.mysubmenu))) {\n            // disposal may throw if the submenu has already been removed\n            try {\n                this.parentData.submenu.dispose();\n            }\n            catch { }\n            this.parentData.submenu = undefined;\n            this.updateAriaExpanded('false');\n            if (this.submenuContainer) {\n                this.submenuDisposables.clear();\n                this.submenuContainer = undefined;\n            }\n        }\n    }\n    calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {\n        const ret = { top: 0, left: 0 };\n        // Start with horizontal\n        ret.left = layout(windowDimensions.width, submenu.width, { position: expandDirection.horizontal === HorizontalDirection.Right ? 0 /* LayoutAnchorPosition.Before */ : 1 /* LayoutAnchorPosition.After */, offset: entry.left, size: entry.width });\n        // We don't have enough room to layout the menu fully, so we are overlapping the menu\n        if (ret.left >= entry.left && ret.left < entry.left + entry.width) {\n            if (entry.left + 10 + submenu.width <= windowDimensions.width) {\n                ret.left = entry.left + 10;\n            }\n            entry.top += 10;\n            entry.height = 0;\n        }\n        // Now that we have a horizontal position, try layout vertically\n        ret.top = layout(windowDimensions.height, submenu.height, { position: 0 /* LayoutAnchorPosition.Before */, offset: entry.top, size: 0 });\n        // We didn't have enough room below, but we did above, so we shift down to align the menu\n        if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {\n            ret.top += entry.height;\n        }\n        return ret;\n    }\n    createSubmenu(selectFirstItem = true) {\n        if (!this.element) {\n            return;\n        }\n        if (!this.parentData.submenu) {\n            this.updateAriaExpanded('true');\n            this.submenuContainer = append(this.element, $('div.monaco-submenu'));\n            this.submenuContainer.classList.add('menubar-menu-items-holder', 'context-view');\n            // Set the top value of the menu container before construction\n            // This allows the menu constructor to calculate the proper max height\n            const computedStyles = getWindow(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode);\n            const paddingTop = parseFloat(computedStyles.paddingTop || '0') || 0;\n            // this.submenuContainer.style.top = `${this.element.offsetTop - this.parentData.parent.scrollOffset - paddingTop}px`;\n            this.submenuContainer.style.zIndex = '1';\n            this.submenuContainer.style.position = 'fixed';\n            this.submenuContainer.style.top = '0';\n            this.submenuContainer.style.left = '0';\n            this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new EmptySubmenuAction()], this.submenuOptions, this.menuStyle);\n            // layout submenu\n            const entryBox = this.element.getBoundingClientRect();\n            const entryBoxUpdated = {\n                top: entryBox.top - paddingTop,\n                left: entryBox.left,\n                height: entryBox.height + 2 * paddingTop,\n                width: entryBox.width\n            };\n            const viewBox = this.submenuContainer.getBoundingClientRect();\n            const window = getWindow(this.element);\n            const { top, left } = this.calculateSubmenuMenuLayout(new Dimension(window.innerWidth, window.innerHeight), Dimension.lift(viewBox), entryBoxUpdated, this.expandDirection);\n            // subtract offsets caused by transform parent\n            this.submenuContainer.style.left = `${left - viewBox.left}px`;\n            this.submenuContainer.style.top = `${top - viewBox.top}px`;\n            this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                    EventHelper.stop(e, true);\n                    this.parentData.parent.focus();\n                    this.cleanupExistingSubmenu(true);\n                }\n            }));\n            this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, e => {\n                const event = new StandardKeyboardEvent(e);\n                if (event.equals(15 /* KeyCode.LeftArrow */)) {\n                    EventHelper.stop(e, true);\n                }\n            }));\n            this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {\n                this.parentData.parent.focus();\n                this.cleanupExistingSubmenu(true);\n            }));\n            this.parentData.submenu.focus(selectFirstItem);\n            this.mysubmenu = this.parentData.submenu;\n        }\n        else {\n            this.parentData.submenu.focus(false);\n        }\n    }\n    updateAriaExpanded(value) {\n        if (this.item) {\n            this.item?.setAttribute('aria-expanded', value);\n        }\n    }\n    applyStyle() {\n        super.applyStyle();\n        const isSelected = this.element && this.element.classList.contains('focused');\n        const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n        if (this.submenuIndicator) {\n            this.submenuIndicator.style.color = fgColor ?? '';\n        }\n    }\n    dispose() {\n        super.dispose();\n        this.hideScheduler.dispose();\n        if (this.mysubmenu) {\n            this.mysubmenu.dispose();\n            this.mysubmenu = null;\n        }\n        if (this.submenuContainer) {\n            this.submenuContainer = undefined;\n        }\n    }\n}\nclass MenuSeparatorActionViewItem extends ActionViewItem {\n    constructor(context, action, options, menuStyles) {\n        super(context, action, options);\n        this.menuStyles = menuStyles;\n    }\n    render(container) {\n        super.render(container);\n        if (this.label) {\n            this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : '';\n        }\n    }\n}\nexport function cleanMnemonic(label) {\n    const regex = MENU_MNEMONIC_REGEX;\n    const matches = regex.exec(label);\n    if (!matches) {\n        return label;\n    }\n    const mnemonicInText = !matches[1];\n    return label.replace(regex, mnemonicInText ? '$2$3' : '').trim();\n}\nexport function formatRule(c) {\n    const fontCharacter = getCodiconFontCharacters()[c.id];\n    return `.codicon-${c.id}:before { content: '\\\\${fontCharacter.toString(16)}'; }`;\n}\nfunction getMenuWidgetCSS(style, isForShadowDom) {\n    let result = /* css */ `\n.monaco-menu {\n\tfont-size: 13px;\n\tborder-radius: 5px;\n\tmin-width: 160px;\n}\n\n${formatRule(Codicon.menuSelection)}\n${formatRule(Codicon.menuSubmenu)}\n\n.monaco-menu .monaco-action-bar {\n\ttext-align: right;\n\toverflow: hidden;\n\twhite-space: nowrap;\n}\n\n.monaco-menu .monaco-action-bar .actions-container {\n\tdisplay: flex;\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 100%;\n\tjustify-content: flex-end;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar.reverse .actions-container {\n\tflex-direction: row-reverse;\n}\n\n.monaco-menu .monaco-action-bar .action-item {\n\tcursor: pointer;\n\tdisplay: inline-block;\n\ttransition: transform 50ms ease;\n\tposition: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled {\n\tcursor: default;\n}\n\n.monaco-menu .monaco-action-bar .action-item .icon,\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar .action-label {\n\tfont-size: 11px;\n\tmargin-right: 4px;\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label,\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {\n\tcolor: var(--vscode-disabledForeground);\n}\n\n/* Vertical actions */\n\n.monaco-menu .monaco-action-bar.vertical {\n\ttext-align: left;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tdisplay: block;\n\tborder-bottom: 1px solid var(--vscode-menu-separatorBackground);\n\tpadding-top: 1px;\n\tpadding: 30px;\n}\n\n.monaco-menu .secondary-actions .monaco-action-bar .action-label {\n\tmargin-left: 6px;\n}\n\n/* Action Items */\n.monaco-menu .monaco-action-bar .action-item.select-container {\n\toverflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */\n\tflex: 1;\n\tmax-width: 170px;\n\tmin-width: 60px;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tmargin-right: 10px;\n}\n\n.monaco-menu .monaco-action-bar.vertical {\n\tmargin-left: 0;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tpadding: 0;\n\ttransform: none;\n\tdisplay: flex;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.active {\n\ttransform: none;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\tflex: 1 1 auto;\n\tdisplay: flex;\n\theight: 2em;\n\talign-items: center;\n\tposition: relative;\n\tmargin: 0 4px;\n\tborder-radius: 4px;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,\n.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {\n\topacity: unset;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label {\n\tflex: 1 1 auto;\n\ttext-decoration: none;\n\tpadding: 0 1em;\n\tbackground: none;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .keybinding,\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tdisplay: inline-block;\n\tflex: 2 1 auto;\n\tpadding: 0 1em;\n\ttext-align: right;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {\n\tfont-size: 16px !important;\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {\n\tmargin-left: auto;\n\tmargin-right: -20px;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {\n\topacity: 0.4;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tmargin: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tposition: static;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {\n\tposition: absolute;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\twidth: 100%;\n\theight: 0px !important;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {\n\tpadding: 0.7em 1em 0.1em 1em;\n\tfont-weight: bold;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:hover {\n\tcolor: inherit;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tposition: absolute;\n\tvisibility: hidden;\n\twidth: 1em;\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {\n\tvisibility: visible;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Context Menu */\n\n.context-view.monaco-menu-container {\n\toutline: 0;\n\tborder: none;\n\tanimation: fadeIn 0.083s linear;\n\t-webkit-app-region: no-drag;\n}\n\n.context-view.monaco-menu-container :focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {\n\toutline: 0;\n}\n\n.hc-black .context-view.monaco-menu-container,\n.hc-light .context-view.monaco-menu-container,\n:host-context(.hc-black) .context-view.monaco-menu-container,\n:host-context(.hc-light) .context-view.monaco-menu-container {\n\tbox-shadow: none;\n}\n\n.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,\n:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground: none;\n}\n\n/* Vertical Action Bar Styles */\n\n.monaco-menu .monaco-action-bar.vertical {\n\tpadding: 4px 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\theight: 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),\n.monaco-menu .monaco-action-bar.vertical .keybinding {\n\tfont-size: inherit;\n\tpadding: 0 2em;\n\tmax-height: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tfont-size: inherit;\n\twidth: 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tfont-size: inherit;\n\tmargin: 5px 0 !important;\n\tpadding: 0;\n\tborder-radius: 0;\n}\n\n.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tmargin-left: 0;\n\tmargin-right: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tfont-size: 60%;\n\tpadding: 0 1.8em;\n}\n\n.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n\tmask-size: 10px 10px;\n\t-webkit-mask-size: 10px 10px;\n}\n\n.monaco-menu .action-item {\n\tcursor: default;\n}`;\n    if (isForShadowDom) {\n        // Only define scrollbar styles when used inside shadow dom,\n        // otherwise leave their styling to the global workbench styling.\n        result += `\n\t\t\t/* Arrows */\n\t\t\t.monaco-scrollable-element > .scrollbar > .scra {\n\t\t\t\tcursor: pointer;\n\t\t\t\tfont-size: 11px !important;\n\t\t\t}\n\n\t\t\t.monaco-scrollable-element > .visible {\n\t\t\t\topacity: 1;\n\n\t\t\t\t/* Background rule added for IE9 - to allow clicks on dom node */\n\t\t\t\tbackground:rgba(0,0,0,0);\n\n\t\t\t\ttransition: opacity 100ms linear;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible {\n\t\t\t\topacity: 0;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible.fade {\n\t\t\t\ttransition: opacity 800ms linear;\n\t\t\t}\n\n\t\t\t/* Scrollable Content Inset Shadow */\n\t\t\t.monaco-scrollable-element > .shadow {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 3px;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 3px;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 100%;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top-left-corner {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t`;\n        // Scrollbars\n        const scrollbarShadowColor = style.scrollbarShadow;\n        if (scrollbarShadowColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.top.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderBackgroundColor = style.scrollbarSliderBackground;\n        if (scrollbarSliderBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider {\n\t\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderHoverBackgroundColor = style.scrollbarSliderHoverBackground;\n        if (scrollbarSliderHoverBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider:hover {\n\t\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderActiveBackgroundColor = style.scrollbarSliderActiveBackground;\n        if (scrollbarSliderActiveBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider.active {\n\t\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, addDisposableListener, EventType, getActiveElement, getWindow, isAncestor, isHTMLElement } from '../../../base/browser/dom.js';\nimport { StandardMouseEvent } from '../../../base/browser/mouseEvent.js';\nimport { Menu } from '../../../base/browser/ui/menu/menu.js';\nimport { ActionRunner } from '../../../base/common/actions.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { combinedDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { defaultMenuStyles } from '../../theme/browser/defaultStyles.js';\nexport class ContextMenuHandler {\n    constructor(contextViewService, telemetryService, notificationService, keybindingService) {\n        this.contextViewService = contextViewService;\n        this.telemetryService = telemetryService;\n        this.notificationService = notificationService;\n        this.keybindingService = keybindingService;\n        this.focusToReturn = null;\n        this.lastContainer = null;\n        this.block = null;\n        this.blockDisposable = null;\n        this.options = { blockMouse: true };\n    }\n    configure(options) {\n        this.options = options;\n    }\n    showContextMenu(delegate) {\n        const actions = delegate.getActions();\n        if (!actions.length) {\n            return; // Don't render an empty context menu\n        }\n        this.focusToReturn = getActiveElement();\n        let menu;\n        const shadowRootElement = isHTMLElement(delegate.domForShadowRoot) ? delegate.domForShadowRoot : undefined;\n        this.contextViewService.showContextView({\n            getAnchor: () => delegate.getAnchor(),\n            canRelayout: false,\n            anchorAlignment: delegate.anchorAlignment,\n            anchorAxisAlignment: delegate.anchorAxisAlignment,\n            render: (container) => {\n                this.lastContainer = container;\n                const className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';\n                if (className) {\n                    container.className += ' ' + className;\n                }\n                // Render invisible div to block mouse interaction in the rest of the UI\n                if (this.options.blockMouse) {\n                    this.block = container.appendChild($('.context-view-block'));\n                    this.block.style.position = 'fixed';\n                    this.block.style.cursor = 'initial';\n                    this.block.style.left = '0';\n                    this.block.style.top = '0';\n                    this.block.style.width = '100%';\n                    this.block.style.height = '100%';\n                    this.block.style.zIndex = '-1';\n                    this.blockDisposable?.dispose();\n                    this.blockDisposable = addDisposableListener(this.block, EventType.MOUSE_DOWN, e => e.stopPropagation());\n                }\n                const menuDisposables = new DisposableStore();\n                const actionRunner = delegate.actionRunner || new ActionRunner();\n                actionRunner.onWillRun(evt => this.onActionRun(evt, !delegate.skipTelemetry), this, menuDisposables);\n                actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);\n                menu = new Menu(container, actions, {\n                    actionViewItemProvider: delegate.getActionViewItem,\n                    context: delegate.getActionsContext ? delegate.getActionsContext() : null,\n                    actionRunner,\n                    getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : action => this.keybindingService.lookupKeybinding(action.id)\n                }, defaultMenuStyles);\n                menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);\n                menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);\n                const targetWindow = getWindow(container);\n                menuDisposables.add(addDisposableListener(targetWindow, EventType.BLUR, () => this.contextViewService.hideContextView(true)));\n                menuDisposables.add(addDisposableListener(targetWindow, EventType.MOUSE_DOWN, (e) => {\n                    if (e.defaultPrevented) {\n                        return;\n                    }\n                    const event = new StandardMouseEvent(targetWindow, e);\n                    let element = event.target;\n                    // Don't do anything as we are likely creating a context menu\n                    if (event.rightButton) {\n                        return;\n                    }\n                    while (element) {\n                        if (element === container) {\n                            return;\n                        }\n                        element = element.parentElement;\n                    }\n                    this.contextViewService.hideContextView(true);\n                }));\n                return combinedDisposable(menuDisposables, menu);\n            },\n            focus: () => {\n                menu?.focus(!!delegate.autoSelectFirstItem);\n            },\n            onHide: (didCancel) => {\n                delegate.onHide?.(!!didCancel);\n                if (this.block) {\n                    this.block.remove();\n                    this.block = null;\n                }\n                this.blockDisposable?.dispose();\n                this.blockDisposable = null;\n                if (!!this.lastContainer && (getActiveElement() === this.lastContainer || isAncestor(getActiveElement(), this.lastContainer))) {\n                    this.focusToReturn?.focus();\n                }\n                this.lastContainer = null;\n            }\n        }, shadowRootElement, !!shadowRootElement);\n    }\n    onActionRun(e, logTelemetry) {\n        if (logTelemetry) {\n            this.telemetryService.publicLog2('workbenchActionExecuted', { id: e.action.id, from: 'contextMenu' });\n        }\n        this.contextViewService.hideContextView(false);\n    }\n    onDidActionRun(e) {\n        if (e.error && !isCancellationError(e.error)) {\n            this.notificationService.error(e.error);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { Toggle } from '../../../base/browser/ui/toggle/toggle.js';\nimport { equals } from '../../../base/common/arrays.js';\nimport { TimeoutTimer } from '../../../base/common/async.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { Emitter, EventBufferer } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isIOS } from '../../../base/common/platform.js';\nimport Severity from '../../../base/common/severity.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport './media/quickInput.css';\nimport { localize } from '../../../nls.js';\nimport { ItemActivation, NO_KEY_MODS, QuickInputButtonLocation, QuickInputHideReason, QuickPickFocus } from '../common/quickInput.js';\nimport { quickInputButtonToAction, renderQuickInputDescription } from './quickInputUtils.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IHoverService, WorkbenchHoverDelegate } from '../../hover/browser/hover.js';\nimport { ContextKeyExpr, RawContextKey } from '../../contextkey/common/contextkey.js';\nexport const inQuickInputContextKeyValue = 'inQuickInput';\nexport const InQuickInputContextKey = new RawContextKey(inQuickInputContextKeyValue, false, localize('inQuickInput', \"Whether keyboard focus is inside the quick input control\"));\nexport const inQuickInputContext = ContextKeyExpr.has(inQuickInputContextKeyValue);\nexport const quickInputTypeContextKeyValue = 'quickInputType';\nexport const QuickInputTypeContextKey = new RawContextKey(quickInputTypeContextKeyValue, undefined, localize('quickInputType', \"The type of the currently visible quick input\"));\nexport const endOfQuickInputBoxContextKeyValue = 'cursorAtEndOfQuickInputBox';\nexport const EndOfQuickInputBoxContextKey = new RawContextKey(endOfQuickInputBoxContextKeyValue, false, localize('cursorAtEndOfQuickInputBox', \"Whether the cursor in the quick input is at the end of the input box\"));\nexport const endOfQuickInputBoxContext = ContextKeyExpr.has(endOfQuickInputBoxContextKeyValue);\nexport const backButton = {\n    iconClass: ThemeIcon.asClassName(Codicon.quickInputBack),\n    tooltip: localize('quickInput.back', \"Back\"),\n    handle: -1 // TODO\n};\nclass QuickInput extends Disposable {\n    static { this.noPromptMessage = localize('inputModeEntry', \"Press 'Enter' to confirm your input or 'Escape' to cancel\"); }\n    constructor(ui) {\n        super();\n        this.ui = ui;\n        this._widgetUpdated = false;\n        this.visible = false;\n        this._enabled = true;\n        this._busy = false;\n        this._ignoreFocusOut = false;\n        this._leftButtons = [];\n        this._rightButtons = [];\n        this._inlineButtons = [];\n        this.buttonsUpdated = false;\n        this._toggles = [];\n        this.togglesUpdated = false;\n        this.noValidationMessage = QuickInput.noPromptMessage;\n        this._severity = Severity.Ignore;\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.onDidHideEmitter = this._register(new Emitter());\n        this.onWillHideEmitter = this._register(new Emitter());\n        this.onDisposeEmitter = this._register(new Emitter());\n        this.visibleDisposables = this._register(new DisposableStore());\n        this.onDidHide = this.onDidHideEmitter.event;\n    }\n    get title() {\n        return this._title;\n    }\n    set title(title) {\n        this._title = title;\n        this.update();\n    }\n    get description() {\n        return this._description;\n    }\n    set description(description) {\n        this._description = description;\n        this.update();\n    }\n    get step() {\n        return this._steps;\n    }\n    set step(step) {\n        this._steps = step;\n        this.update();\n    }\n    get totalSteps() {\n        return this._totalSteps;\n    }\n    set totalSteps(totalSteps) {\n        this._totalSteps = totalSteps;\n        this.update();\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(enabled) {\n        this._enabled = enabled;\n        this.update();\n    }\n    get contextKey() {\n        return this._contextKey;\n    }\n    set contextKey(contextKey) {\n        this._contextKey = contextKey;\n        this.update();\n    }\n    get busy() {\n        return this._busy;\n    }\n    set busy(busy) {\n        this._busy = busy;\n        this.update();\n    }\n    get ignoreFocusOut() {\n        return this._ignoreFocusOut;\n    }\n    set ignoreFocusOut(ignoreFocusOut) {\n        const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;\n        this._ignoreFocusOut = ignoreFocusOut && !isIOS;\n        if (shouldUpdate) {\n            this.update();\n        }\n    }\n    get titleButtons() {\n        return this._leftButtons.length\n            ? [...this._leftButtons, this._rightButtons]\n            : this._rightButtons;\n    }\n    get buttons() {\n        return [\n            ...this._leftButtons,\n            ...this._rightButtons,\n            ...this._inlineButtons\n        ];\n    }\n    set buttons(buttons) {\n        this._leftButtons = buttons.filter(b => b === backButton);\n        this._rightButtons = buttons.filter(b => b !== backButton && b.location !== QuickInputButtonLocation.Inline);\n        this._inlineButtons = buttons.filter(b => b.location === QuickInputButtonLocation.Inline);\n        this.buttonsUpdated = true;\n        this.update();\n    }\n    get toggles() {\n        return this._toggles;\n    }\n    set toggles(toggles) {\n        this._toggles = toggles ?? [];\n        this.togglesUpdated = true;\n        this.update();\n    }\n    get validationMessage() {\n        return this._validationMessage;\n    }\n    set validationMessage(validationMessage) {\n        this._validationMessage = validationMessage;\n        this.update();\n    }\n    get severity() {\n        return this._severity;\n    }\n    set severity(severity) {\n        this._severity = severity;\n        this.update();\n    }\n    show() {\n        if (this.visible) {\n            return;\n        }\n        this.visibleDisposables.add(this.ui.onDidTriggerButton(button => {\n            if (this.buttons.indexOf(button) !== -1) {\n                this.onDidTriggerButtonEmitter.fire(button);\n            }\n        }));\n        this.ui.show(this);\n        // update properties in the controller that get reset in the ui.show() call\n        this.visible = true;\n        // This ensures the message/prompt gets rendered\n        this._lastValidationMessage = undefined;\n        // This ensures the input box has the right severity applied\n        this._lastSeverity = undefined;\n        if (this.buttons.length) {\n            // if there are buttons, the ui.show() clears them out of the UI so we should\n            // rerender them.\n            this.buttonsUpdated = true;\n        }\n        if (this.toggles.length) {\n            // if there are toggles, the ui.show() clears them out of the UI so we should\n            // rerender them.\n            this.togglesUpdated = true;\n        }\n        this.update();\n    }\n    hide() {\n        if (!this.visible) {\n            return;\n        }\n        this.ui.hide();\n    }\n    didHide(reason = QuickInputHideReason.Other) {\n        this.visible = false;\n        this.visibleDisposables.clear();\n        this.onDidHideEmitter.fire({ reason });\n    }\n    willHide(reason = QuickInputHideReason.Other) {\n        this.onWillHideEmitter.fire({ reason });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        const title = this.getTitle();\n        if (title && this.ui.title.textContent !== title) {\n            this.ui.title.textContent = title;\n        }\n        else if (!title && this.ui.title.innerHTML !== '&nbsp;') {\n            this.ui.title.innerText = '\\u00a0';\n        }\n        const description = this.getDescription();\n        if (this.ui.description1.textContent !== description) {\n            this.ui.description1.textContent = description;\n        }\n        if (this.ui.description2.textContent !== description) {\n            this.ui.description2.textContent = description;\n        }\n        if (this._widgetUpdated) {\n            this._widgetUpdated = false;\n            if (this._widget) {\n                dom.reset(this.ui.widget, this._widget);\n            }\n            else {\n                dom.reset(this.ui.widget);\n            }\n        }\n        if (this.busy && !this.busyDelay) {\n            this.busyDelay = new TimeoutTimer();\n            this.busyDelay.setIfNotSet(() => {\n                if (this.visible) {\n                    this.ui.progressBar.infinite();\n                }\n            }, 800);\n        }\n        if (!this.busy && this.busyDelay) {\n            this.ui.progressBar.stop();\n            this.busyDelay.cancel();\n            this.busyDelay = undefined;\n        }\n        if (this.buttonsUpdated) {\n            this.buttonsUpdated = false;\n            this.ui.leftActionBar.clear();\n            const leftButtons = this._leftButtons\n                .map((button, index) => quickInputButtonToAction(button, `id-${index}`, async () => this.onDidTriggerButtonEmitter.fire(button)));\n            this.ui.leftActionBar.push(leftButtons, { icon: true, label: false });\n            this.ui.rightActionBar.clear();\n            const rightButtons = this._rightButtons\n                .map((button, index) => quickInputButtonToAction(button, `id-${index}`, async () => this.onDidTriggerButtonEmitter.fire(button)));\n            this.ui.rightActionBar.push(rightButtons, { icon: true, label: false });\n            this.ui.inlineActionBar.clear();\n            const inlineButtons = this._inlineButtons\n                .map((button, index) => quickInputButtonToAction(button, `id-${index}`, async () => this.onDidTriggerButtonEmitter.fire(button)));\n            this.ui.inlineActionBar.push(inlineButtons, { icon: true, label: false });\n        }\n        if (this.togglesUpdated) {\n            this.togglesUpdated = false;\n            // HACK: Filter out toggles here that are not concrete Toggle objects. This is to workaround\n            // a layering issue as quick input's interface is in common but Toggle is in browser and\n            // it requires a HTMLElement on its interface\n            const concreteToggles = this.toggles?.filter(opts => opts instanceof Toggle) ?? [];\n            this.ui.inputBox.toggles = concreteToggles;\n        }\n        this.ui.ignoreFocusOut = this.ignoreFocusOut;\n        this.ui.setEnabled(this.enabled);\n        this.ui.setContextKey(this.contextKey);\n        const validationMessage = this.validationMessage || this.noValidationMessage;\n        if (this._lastValidationMessage !== validationMessage) {\n            this._lastValidationMessage = validationMessage;\n            dom.reset(this.ui.message);\n            renderQuickInputDescription(validationMessage, this.ui.message, {\n                callback: (content) => {\n                    this.ui.linkOpenerDelegate(content);\n                },\n                disposables: this.visibleDisposables,\n            });\n        }\n        if (this._lastSeverity !== this.severity) {\n            this._lastSeverity = this.severity;\n            this.showMessageDecoration(this.severity);\n        }\n    }\n    getTitle() {\n        if (this.title && this.step) {\n            return `${this.title} (${this.getSteps()})`;\n        }\n        if (this.title) {\n            return this.title;\n        }\n        if (this.step) {\n            return this.getSteps();\n        }\n        return '';\n    }\n    getDescription() {\n        return this.description || '';\n    }\n    getSteps() {\n        if (this.step && this.totalSteps) {\n            return localize('quickInput.steps', \"{0}/{1}\", this.step, this.totalSteps);\n        }\n        if (this.step) {\n            return String(this.step);\n        }\n        return '';\n    }\n    showMessageDecoration(severity) {\n        this.ui.inputBox.showDecoration(severity);\n        if (severity !== Severity.Ignore) {\n            const styles = this.ui.inputBox.stylesForType(severity);\n            this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : '';\n            this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : '';\n            this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : '';\n            this.ui.message.style.marginBottom = '-2px';\n        }\n        else {\n            this.ui.message.style.color = '';\n            this.ui.message.style.backgroundColor = '';\n            this.ui.message.style.border = '';\n            this.ui.message.style.marginBottom = '';\n        }\n    }\n    dispose() {\n        this.hide();\n        this.onDisposeEmitter.fire();\n        super.dispose();\n    }\n}\nexport class QuickPick extends QuickInput {\n    constructor() {\n        super(...arguments);\n        this._value = '';\n        this.onDidChangeValueEmitter = this._register(new Emitter());\n        this.onWillAcceptEmitter = this._register(new Emitter());\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this._items = [];\n        this.itemsUpdated = false;\n        this._canSelectMany = false;\n        this._canAcceptInBackground = false;\n        this._matchOnDescription = false;\n        this._matchOnDetail = false;\n        this._matchOnLabel = true;\n        this._matchOnLabelMode = 'fuzzy';\n        this._sortByLabel = true;\n        this._keepScrollPosition = false;\n        this._itemActivation = ItemActivation.FIRST;\n        this._activeItems = [];\n        this.activeItemsUpdated = false;\n        this.activeItemsToConfirm = [];\n        this.onDidChangeActiveEmitter = this._register(new Emitter());\n        this._selectedItems = [];\n        this.selectedItemsUpdated = false;\n        this.selectedItemsToConfirm = [];\n        this.onDidChangeSelectionEmitter = this._register(new Emitter());\n        this.onDidTriggerItemButtonEmitter = this._register(new Emitter());\n        this.onDidTriggerSeparatorButtonEmitter = this._register(new Emitter());\n        this.valueSelectionUpdated = true;\n        this._ok = 'default';\n        this._customButton = false;\n        this._focusEventBufferer = new EventBufferer();\n        this.type = \"quickPick\" /* QuickInputType.QuickPick */;\n        this.filterValue = (value) => value;\n        this.onDidChangeValue = this.onDidChangeValueEmitter.event;\n        this.onWillAccept = this.onWillAcceptEmitter.event;\n        this.onDidAccept = this.onDidAcceptEmitter.event;\n        this.onDidChangeActive = this.onDidChangeActiveEmitter.event;\n        this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;\n        this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;\n        this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;\n    }\n    static { this.DEFAULT_ARIA_LABEL = localize('quickInputBox.ariaLabel', \"Type to narrow down results.\"); }\n    get quickNavigate() {\n        return this._quickNavigate;\n    }\n    set quickNavigate(quickNavigate) {\n        this._quickNavigate = quickNavigate;\n        this.update();\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this.doSetValue(value);\n    }\n    doSetValue(value, skipUpdate) {\n        if (this._value !== value) {\n            this._value = value;\n            if (!skipUpdate) {\n                this.update();\n            }\n            if (this.visible) {\n                const didFilter = this.ui.list.filter(this.filterValue(this._value));\n                if (didFilter) {\n                    this.trySelectFirst();\n                }\n            }\n            this.onDidChangeValueEmitter.fire(this._value);\n        }\n    }\n    set ariaLabel(ariaLabel) {\n        this._ariaLabel = ariaLabel;\n        this.update();\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(placeholder) {\n        this._placeholder = placeholder;\n        this.update();\n    }\n    get items() {\n        return this._items;\n    }\n    get scrollTop() {\n        return this.ui.list.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.ui.list.scrollTop = scrollTop;\n    }\n    set items(items) {\n        this._items = items;\n        this.itemsUpdated = true;\n        this.update();\n    }\n    get canSelectMany() {\n        return this._canSelectMany;\n    }\n    set canSelectMany(canSelectMany) {\n        this._canSelectMany = canSelectMany;\n        this.update();\n    }\n    get canAcceptInBackground() {\n        return this._canAcceptInBackground;\n    }\n    set canAcceptInBackground(canAcceptInBackground) {\n        this._canAcceptInBackground = canAcceptInBackground;\n    }\n    get matchOnDescription() {\n        return this._matchOnDescription;\n    }\n    set matchOnDescription(matchOnDescription) {\n        this._matchOnDescription = matchOnDescription;\n        this.update();\n    }\n    get matchOnDetail() {\n        return this._matchOnDetail;\n    }\n    set matchOnDetail(matchOnDetail) {\n        this._matchOnDetail = matchOnDetail;\n        this.update();\n    }\n    get matchOnLabel() {\n        return this._matchOnLabel;\n    }\n    set matchOnLabel(matchOnLabel) {\n        this._matchOnLabel = matchOnLabel;\n        this.update();\n    }\n    get matchOnLabelMode() {\n        return this._matchOnLabelMode;\n    }\n    set matchOnLabelMode(matchOnLabelMode) {\n        this._matchOnLabelMode = matchOnLabelMode;\n        this.update();\n    }\n    get sortByLabel() {\n        return this._sortByLabel;\n    }\n    set sortByLabel(sortByLabel) {\n        this._sortByLabel = sortByLabel;\n        this.update();\n    }\n    get keepScrollPosition() {\n        return this._keepScrollPosition;\n    }\n    set keepScrollPosition(keepScrollPosition) {\n        this._keepScrollPosition = keepScrollPosition;\n    }\n    get itemActivation() {\n        return this._itemActivation;\n    }\n    set itemActivation(itemActivation) {\n        this._itemActivation = itemActivation;\n    }\n    get activeItems() {\n        return this._activeItems;\n    }\n    set activeItems(activeItems) {\n        this._activeItems = activeItems;\n        this.activeItemsUpdated = true;\n        this.update();\n    }\n    get selectedItems() {\n        return this._selectedItems;\n    }\n    set selectedItems(selectedItems) {\n        this._selectedItems = selectedItems;\n        this.selectedItemsUpdated = true;\n        this.update();\n    }\n    get keyMods() {\n        if (this._quickNavigate) {\n            // Disable keyMods when quick navigate is enabled\n            // because in this model the interaction is purely\n            // keyboard driven and Ctrl/Alt are typically\n            // pressed and hold during this interaction.\n            return NO_KEY_MODS;\n        }\n        return this.ui.keyMods;\n    }\n    get valueSelection() {\n        const selection = this.ui.inputBox.getSelection();\n        if (!selection) {\n            return undefined;\n        }\n        return [selection.start, selection.end];\n    }\n    set valueSelection(valueSelection) {\n        this._valueSelection = valueSelection;\n        this.valueSelectionUpdated = true;\n        this.update();\n    }\n    get customButton() {\n        return this._customButton;\n    }\n    set customButton(showCustomButton) {\n        this._customButton = showCustomButton;\n        this.update();\n    }\n    get customLabel() {\n        return this._customButtonLabel;\n    }\n    set customLabel(label) {\n        this._customButtonLabel = label;\n        this.update();\n    }\n    get customHover() {\n        return this._customButtonHover;\n    }\n    set customHover(hover) {\n        this._customButtonHover = hover;\n        this.update();\n    }\n    get ok() {\n        return this._ok;\n    }\n    set ok(showOkButton) {\n        this._ok = showOkButton;\n        this.update();\n    }\n    get hideInput() {\n        return !!this._hideInput;\n    }\n    set hideInput(hideInput) {\n        this._hideInput = hideInput;\n        this.update();\n    }\n    trySelectFirst() {\n        if (!this.canSelectMany) {\n            this.ui.list.focus(QuickPickFocus.First);\n        }\n    }\n    show() {\n        if (!this.visible) {\n            this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {\n                this.doSetValue(value, true /* skip update since this originates from the UI */);\n            }));\n            this.visibleDisposables.add(this.ui.onDidAccept(() => {\n                if (this.canSelectMany) {\n                    // if there are no checked elements, it means that an onDidChangeSelection never fired to overwrite\n                    // `_selectedItems`. In that case, we should emit one with an empty array to ensure that\n                    // `.selectedItems` is up to date.\n                    if (!this.ui.list.getCheckedElements().length) {\n                        this._selectedItems = [];\n                        this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    }\n                }\n                else if (this.activeItems[0]) {\n                    // For single-select, we set `selectedItems` to the item that was accepted.\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                }\n                this.handleAccept(false);\n            }));\n            this.visibleDisposables.add(this.ui.onDidCustom(() => {\n                this.onDidCustomEmitter.fire();\n            }));\n            this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(this.ui.list.onDidChangeFocus, \n            // Only fire the last event\n            (_, e) => e)(focusedItems => {\n                if (this.activeItemsUpdated) {\n                    return; // Expect another event.\n                }\n                if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._activeItems = focusedItems;\n                this.onDidChangeActiveEmitter.fire(focusedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {\n                if (this.canSelectMany) {\n                    if (selectedItems.length) {\n                        this.ui.list.setSelectedElements([]);\n                    }\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = selectedItems;\n                this.onDidChangeSelectionEmitter.fire(selectedItems);\n                if (selectedItems.length) {\n                    this.handleAccept(dom.isMouseEvent(event) && event.button === 1 /* mouse middle click */);\n                }\n            }));\n            this.visibleDisposables.add(this.ui.list.onChangedCheckedElements(checkedItems => {\n                if (!this.canSelectMany || !this.visible) {\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = checkedItems;\n                this.onDidChangeSelectionEmitter.fire(checkedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onButtonTriggered(event => this.onDidTriggerItemButtonEmitter.fire(event)));\n            this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered(event => this.onDidTriggerSeparatorButtonEmitter.fire(event)));\n            this.visibleDisposables.add(this.registerQuickNavigation());\n            this.valueSelectionUpdated = true;\n        }\n        super.show(); // TODO: Why have show() bubble up while update() trickles down?\n    }\n    handleAccept(inBackground) {\n        // Figure out veto via `onWillAccept` event\n        let veto = false;\n        this.onWillAcceptEmitter.fire({ veto: () => veto = true });\n        // Continue with `onDidAccept` if no veto\n        if (!veto) {\n            this.onDidAcceptEmitter.fire({ inBackground });\n        }\n    }\n    registerQuickNavigation() {\n        return dom.addDisposableListener(this.ui.container, dom.EventType.KEY_UP, e => {\n            if (this.canSelectMany || !this._quickNavigate) {\n                return;\n            }\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            const keyCode = keyboardEvent.keyCode;\n            // Select element when keys are pressed that signal it\n            const quickNavKeys = this._quickNavigate.keybindings;\n            const wasTriggerKeyPressed = quickNavKeys.some(k => {\n                const chords = k.getChords();\n                if (chords.length > 1) {\n                    return false;\n                }\n                if (chords[0].shiftKey && keyCode === 4 /* KeyCode.Shift */) {\n                    if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {\n                        return false; // this is an optimistic check for the shift key being used to navigate back in quick input\n                    }\n                    return true;\n                }\n                if (chords[0].altKey && keyCode === 6 /* KeyCode.Alt */) {\n                    return true;\n                }\n                if (chords[0].ctrlKey && keyCode === 5 /* KeyCode.Ctrl */) {\n                    return true;\n                }\n                if (chords[0].metaKey && keyCode === 57 /* KeyCode.Meta */) {\n                    return true;\n                }\n                return false;\n            });\n            if (wasTriggerKeyPressed) {\n                if (this.activeItems[0]) {\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    this.handleAccept(false);\n                }\n                // Unset quick navigate after press. It is only valid once\n                // and should not result in any behaviour change afterwards\n                // if the picker remains open because there was no active item\n                this._quickNavigate = undefined;\n            }\n        });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        // store the scrollTop before it is reset\n        const scrollTopBefore = this.keepScrollPosition ? this.scrollTop : 0;\n        const hasDescription = !!this.description;\n        const visibilities = {\n            title: !!this.title || !!this.step || !!this.titleButtons.length,\n            description: hasDescription,\n            checkAll: this.canSelectMany && !this._hideCheckAll,\n            checkBox: this.canSelectMany,\n            inputBox: !this._hideInput,\n            progressBar: !this._hideInput || hasDescription,\n            visibleCount: true,\n            count: this.canSelectMany && !this._hideCountBadge,\n            ok: this.ok === 'default' ? this.canSelectMany : this.ok,\n            list: true,\n            message: !!this.validationMessage,\n            customButton: this.customButton\n        };\n        this.ui.setVisibilities(visibilities);\n        super.update();\n        if (this.ui.inputBox.value !== this.value) {\n            this.ui.inputBox.value = this.value;\n        }\n        if (this.valueSelectionUpdated) {\n            this.valueSelectionUpdated = false;\n            this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });\n        }\n        if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {\n            this.ui.inputBox.placeholder = (this.placeholder || '');\n        }\n        let ariaLabel = this.ariaLabel;\n        // Only set aria label to the input box placeholder if we actually have an input box.\n        if (!ariaLabel && visibilities.inputBox) {\n            ariaLabel = this.placeholder || QuickPick.DEFAULT_ARIA_LABEL;\n            // If we have a title, include it in the aria label.\n            if (this.title) {\n                ariaLabel += ` - ${this.title}`;\n            }\n        }\n        if (this.ui.list.ariaLabel !== ariaLabel) {\n            this.ui.list.ariaLabel = ariaLabel ?? null;\n        }\n        this.ui.list.matchOnDescription = this.matchOnDescription;\n        this.ui.list.matchOnDetail = this.matchOnDetail;\n        this.ui.list.matchOnLabel = this.matchOnLabel;\n        this.ui.list.matchOnLabelMode = this.matchOnLabelMode;\n        this.ui.list.sortByLabel = this.sortByLabel;\n        if (this.itemsUpdated) {\n            this.itemsUpdated = false;\n            this._focusEventBufferer.bufferEvents(() => {\n                this.ui.list.setElements(this.items);\n                // We want focus to exist in the list if there are items so that space can be used to toggle\n                this.ui.list.shouldLoop = !this.canSelectMany;\n                this.ui.list.filter(this.filterValue(this.ui.inputBox.value));\n                switch (this._itemActivation) {\n                    case ItemActivation.NONE:\n                        this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                        break;\n                    case ItemActivation.SECOND:\n                        this.ui.list.focus(QuickPickFocus.Second);\n                        this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                        break;\n                    case ItemActivation.LAST:\n                        this.ui.list.focus(QuickPickFocus.Last);\n                        this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                        break;\n                    default:\n                        this.trySelectFirst();\n                        break;\n                }\n            });\n        }\n        if (this.ui.container.classList.contains('show-checkboxes') !== !!this.canSelectMany) {\n            if (this.canSelectMany) {\n                this.ui.list.clearFocus();\n            }\n            else {\n                this.trySelectFirst();\n            }\n        }\n        if (this.activeItemsUpdated) {\n            this.activeItemsUpdated = false;\n            this.activeItemsToConfirm = this._activeItems;\n            this.ui.list.setFocusedElements(this.activeItems);\n            if (this.activeItemsToConfirm === this._activeItems) {\n                this.activeItemsToConfirm = null;\n            }\n        }\n        if (this.selectedItemsUpdated) {\n            this.selectedItemsUpdated = false;\n            this.selectedItemsToConfirm = this._selectedItems;\n            if (this.canSelectMany) {\n                this.ui.list.setCheckedElements(this.selectedItems);\n            }\n            else {\n                this.ui.list.setSelectedElements(this.selectedItems);\n            }\n            if (this.selectedItemsToConfirm === this._selectedItems) {\n                this.selectedItemsToConfirm = null;\n            }\n        }\n        this.ui.customButton.label = this.customLabel || '';\n        this.ui.customButton.element.title = this.customHover || '';\n        if (!visibilities.inputBox) {\n            // we need to move focus into the tree to detect keybindings\n            // properly when the input box is not visible (quick nav)\n            this.ui.list.domFocus();\n            // Focus the first element in the list if multiselect is enabled\n            if (this.canSelectMany) {\n                this.ui.list.focus(QuickPickFocus.First);\n            }\n        }\n        // Set the scroll position to what it was before updating the items\n        if (this.keepScrollPosition) {\n            this.scrollTop = scrollTopBefore;\n        }\n    }\n    focus(focus) {\n        this.ui.list.focus(focus);\n        // To allow things like space to check/uncheck items\n        if (this.canSelectMany) {\n            this.ui.list.domFocus();\n        }\n    }\n    accept(inBackground) {\n        if (inBackground && !this._canAcceptInBackground) {\n            return; // needs to be enabled\n        }\n        if (this.activeItems[0]) {\n            this._selectedItems = [this.activeItems[0]];\n            this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n            this.handleAccept(inBackground ?? false);\n        }\n    }\n}\nexport class InputBox extends QuickInput {\n    constructor() {\n        super(...arguments);\n        this._value = '';\n        this.valueSelectionUpdated = true;\n        this._password = false;\n        this.onDidValueChangeEmitter = this._register(new Emitter());\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.type = \"inputBox\" /* QuickInputType.InputBox */;\n        this.onDidChangeValue = this.onDidValueChangeEmitter.event;\n        this.onDidAccept = this.onDidAcceptEmitter.event;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value || '';\n        this.update();\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(placeholder) {\n        this._placeholder = placeholder;\n        this.update();\n    }\n    get password() {\n        return this._password;\n    }\n    set password(password) {\n        this._password = password;\n        this.update();\n    }\n    show() {\n        if (!this.visible) {\n            this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {\n                if (value === this.value) {\n                    return;\n                }\n                this._value = value;\n                this.onDidValueChangeEmitter.fire(value);\n            }));\n            this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire()));\n            this.valueSelectionUpdated = true;\n        }\n        super.show();\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        this.ui.container.classList.remove('hidden-input');\n        const visibilities = {\n            title: !!this.title || !!this.step || !!this.titleButtons.length,\n            description: !!this.description || !!this.step,\n            inputBox: true,\n            message: true,\n            progressBar: true\n        };\n        this.ui.setVisibilities(visibilities);\n        super.update();\n        if (this.ui.inputBox.value !== this.value) {\n            this.ui.inputBox.value = this.value;\n        }\n        if (this.valueSelectionUpdated) {\n            this.valueSelectionUpdated = false;\n            this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });\n        }\n        if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {\n            this.ui.inputBox.placeholder = (this.placeholder || '');\n        }\n        if (this.ui.inputBox.password !== this.password) {\n            this.ui.inputBox.password = this.password;\n        }\n    }\n}\nlet QuickInputHoverDelegate = class QuickInputHoverDelegate extends WorkbenchHoverDelegate {\n    constructor(configurationService, hoverService) {\n        super('element', false, (options) => this.getOverrideOptions(options), configurationService, hoverService);\n    }\n    getOverrideOptions(options) {\n        // Only show the hover hint if the content is of a decent size\n        const showHoverHint = (dom.isHTMLElement(options.content)\n            ? options.content.textContent ?? ''\n            : typeof options.content === 'string'\n                ? options.content\n                : options.content.value).includes('\\n');\n        return {\n            persistence: {\n                hideOnKeyDown: false,\n            },\n            appearance: {\n                showHoverHint,\n                skipFadeInAnimation: true,\n            },\n        };\n    }\n};\nQuickInputHoverDelegate = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, IHoverService)\n], QuickInputHoverDelegate);\nexport { QuickInputHoverDelegate };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet } from '../../dom.js';\nimport { getBaseLayerHoverDelegate } from '../hover/hoverDelegate2.js';\nimport { getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { List, unthemedListStyles } from '../list/listWidget.js';\nimport { SplitView } from '../splitview/splitview.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable, DisposableStore } from '../../../common/lifecycle.js';\nimport './table.css';\nclass TableListRenderer {\n    static { this.TemplateId = 'row'; }\n    constructor(columns, renderers, getColumnSize) {\n        this.columns = columns;\n        this.getColumnSize = getColumnSize;\n        this.templateId = TableListRenderer.TemplateId;\n        this.renderedTemplates = new Set();\n        const rendererMap = new Map(renderers.map(r => [r.templateId, r]));\n        this.renderers = [];\n        for (const column of columns) {\n            const renderer = rendererMap.get(column.templateId);\n            if (!renderer) {\n                throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);\n            }\n            this.renderers.push(renderer);\n        }\n    }\n    renderTemplate(container) {\n        const rowContainer = append(container, $('.monaco-table-tr'));\n        const cellContainers = [];\n        const cellTemplateData = [];\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            const cellContainer = append(rowContainer, $('.monaco-table-td', { 'data-col-index': i }));\n            cellContainer.style.width = `${this.getColumnSize(i)}px`;\n            cellContainers.push(cellContainer);\n            cellTemplateData.push(renderer.renderTemplate(cellContainer));\n        }\n        const result = { container, cellContainers, cellTemplateData };\n        this.renderedTemplates.add(result);\n        return result;\n    }\n    renderElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const column = this.columns[i];\n            const cell = column.project(element);\n            const renderer = this.renderers[i];\n            renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            if (renderer.disposeElement) {\n                const column = this.columns[i];\n                const cell = column.project(element);\n                renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            renderer.disposeTemplate(templateData.cellTemplateData[i]);\n        }\n        clearNode(templateData.container);\n        this.renderedTemplates.delete(templateData);\n    }\n    layoutColumn(index, size) {\n        for (const { cellContainers } of this.renderedTemplates) {\n            cellContainers[index].style.width = `${size}px`;\n        }\n    }\n}\nfunction asListVirtualDelegate(delegate) {\n    return {\n        getHeight(row) { return delegate.getHeight(row); },\n        getTemplateId() { return TableListRenderer.TemplateId; },\n    };\n}\nclass ColumnHeader extends Disposable {\n    get minimumSize() { return this.column.minimumWidth ?? 120; }\n    get maximumSize() { return this.column.maximumWidth ?? Number.POSITIVE_INFINITY; }\n    get onDidChange() { return this.column.onDidChangeWidthConstraints ?? Event.None; }\n    constructor(column, index) {\n        super();\n        this.column = column;\n        this.index = index;\n        this._onDidLayout = new Emitter();\n        this.onDidLayout = this._onDidLayout.event;\n        this.element = $('.monaco-table-th', { 'data-col-index': index }, column.label);\n        if (column.tooltip) {\n            this._register(getBaseLayerHoverDelegate().setupManagedHover(getDefaultHoverDelegate('mouse'), this.element, column.tooltip));\n        }\n    }\n    layout(size) {\n        this._onDidLayout.fire([this.index, size]);\n    }\n}\nexport class Table {\n    static { this.InstanceCount = 0; }\n    get onDidChangeFocus() { return this.list.onDidChangeFocus; }\n    get onDidChangeSelection() { return this.list.onDidChangeSelection; }\n    get onDidScroll() { return this.list.onDidScroll; }\n    get onMouseDblClick() { return this.list.onMouseDblClick; }\n    get onPointer() { return this.list.onPointer; }\n    get onDidFocus() { return this.list.onDidFocus; }\n    get scrollTop() { return this.list.scrollTop; }\n    set scrollTop(scrollTop) { this.list.scrollTop = scrollTop; }\n    get scrollHeight() { return this.list.scrollHeight; }\n    get renderHeight() { return this.list.renderHeight; }\n    get onDidDispose() { return this.list.onDidDispose; }\n    constructor(user, container, virtualDelegate, columns, renderers, _options) {\n        this.virtualDelegate = virtualDelegate;\n        this.columns = columns;\n        this.domId = `table_id_${++Table.InstanceCount}`;\n        this.disposables = new DisposableStore();\n        this.cachedWidth = 0;\n        this.cachedHeight = 0;\n        this.domNode = append(container, $(`.monaco-table.${this.domId}`));\n        const headers = columns.map((c, i) => this.disposables.add(new ColumnHeader(c, i)));\n        const descriptor = {\n            size: headers.reduce((a, b) => a + b.column.weight, 0),\n            views: headers.map(view => ({ size: view.column.weight, view }))\n        };\n        this.splitview = this.disposables.add(new SplitView(this.domNode, {\n            orientation: 1 /* Orientation.HORIZONTAL */,\n            scrollbarVisibility: 2 /* ScrollbarVisibility.Hidden */,\n            getSashOrthogonalSize: () => this.cachedHeight,\n            descriptor\n        }));\n        this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;\n        this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;\n        const renderer = new TableListRenderer(columns, renderers, i => this.splitview.getViewSize(i));\n        this.list = this.disposables.add(new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options));\n        Event.any(...headers.map(h => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size), null, this.disposables);\n        this.splitview.onDidSashReset(index => {\n            const totalWeight = columns.reduce((r, c) => r + c.weight, 0);\n            const size = columns[index].weight / totalWeight * this.cachedWidth;\n            this.splitview.resizeView(index, size);\n        }, null, this.disposables);\n        this.styleElement = createStyleSheet(this.domNode);\n        this.style(unthemedListStyles);\n    }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    splice(start, deleteCount, elements = []) {\n        this.list.splice(start, deleteCount, elements);\n    }\n    getHTMLElement() {\n        return this.domNode;\n    }\n    style(styles) {\n        const content = [];\n        content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\ttop: ${this.virtualDelegate.headerRowHeight + 1}px;\n\t\t\theight: calc(100% - ${this.virtualDelegate.headerRowHeight}px);\n\t\t}`);\n        this.styleElement.textContent = content.join('\\n');\n        this.list.style(styles);\n    }\n    getSelectedElements() {\n        return this.list.getSelectedElements();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet, getWindow, h, hasParentWithClass, asCssValueWithDefault, isKeyboardEvent, addDisposableListener } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { FindInput } from '../findinput/findInput.js';\nimport { unthemedInboxStyles } from '../inputbox/inputBox.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isActionItem, isButton, isInputElement, isMonacoCustomToggle, isMonacoEditor, isStickyScrollContainer, isStickyScrollElement, List, MouseController } from '../list/listWidget.js';\nimport { Toggle, unthemedToggleStyles } from '../toggle/toggle.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { Action } from '../../../common/actions.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { Delayer, disposableTimeout, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { SetMap } from '../../../common/map.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isNumber } from '../../../common/types.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nimport { createInstantHoverDelegate, getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { autorun, constObservable } from '../../../common/observable.js';\nimport { alert } from '../aria/aria.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        this.dnd.onDragStart?.(asTreeDragAndDropData(data), originalEvent);\n    }\n    onDragOver(data, targetNode, targetIndex, targetSector, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500, this.disposables);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* TreeDragOverBubble.Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, targetSector, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return { ...result, feedback: range(start, start + length) };\n    }\n    drop(data, targetNode, targetIndex, targetSector, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        this.dnd.onDragEnd?.(originalEvent);\n    }\n    dispose() {\n        this.disposables.dispose();\n        this.dnd.dispose();\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && {\n        ...options,\n        identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        },\n        dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),\n        multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });\n            }\n        },\n        accessibilityProvider: options.accessibilityProvider && {\n            ...options.accessibilityProvider,\n            getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            },\n            isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined,\n            getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem',\n            getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            },\n            getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n            getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            },\n            getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            })\n        },\n        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            ...options.keyboardNavigationLabelProvider,\n            getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            }\n        }\n    };\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        this.delegate.setDynamicHeight?.(element.element, height);\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    get elements() {\n        return this._elements;\n    }\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.disposables = new DisposableStore();\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport class TreeRenderer {\n    static { this.DefaultIndent = 8; }\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides, options = {}) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedIndentGuides = renderedIndentGuides;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        renderer.onDidChangeTwistieState?.(this.onDidChangeTwistieState, this, this.disposables);\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            const indent = clamp(options.indent, 0, 40);\n            if (indent !== this.indent) {\n                this.indent = indent;\n                for (const [node, templateData] of this.renderedNodes) {\n                    this.renderTreeElement(node, templateData);\n                }\n            }\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                for (const [node, templateData] of this.renderedNodes) {\n                    this._renderIndentGuides(node, templateData);\n                }\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderedNodes.set(node, templateData);\n        this.renderedElements.set(node.element, node);\n        this.renderTreeElement(node, templateData);\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        templateData.indentGuidesDisposable.dispose();\n        this.renderer.disposeElement?.(node, index, templateData.templateData, height);\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const templateData = this.renderedNodes.get(node);\n        if (!templateData) {\n            return;\n        }\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderTreeElement(node, templateData);\n    }\n    renderTreeElement(node, templateData) {\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n        templateData.twistie.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        this._renderIndentGuides(node, templateData);\n    }\n    _renderIndentGuides(node, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nclass FindFilter {\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    filter(element, parentVisibility) {\n        let visibility = 1 /* TreeVisibility.Visible */;\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (!this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility };\n            }\n            let score;\n            if (this.tree.findMatchType === TreeFindMatchType.Contiguous) {\n                const index = labelStr.toLowerCase().indexOf(this._lowercasePattern);\n                if (index > -1) {\n                    score = [Number.MAX_SAFE_INTEGER, 0];\n                    for (let i = this._lowercasePattern.length; i > 0; i--) {\n                        score.push(index + i - 1);\n                    }\n                }\n            }\n            else {\n                score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n            }\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility } :\n                    { data: { label: labelStr, score: score }, visibility };\n            }\n        }\n        if (this.tree.findMode === TreeFindMode.Filter) {\n            if (typeof this.tree.options.defaultFindVisibility === 'number') {\n                return this.tree.options.defaultFindVisibility;\n            }\n            else if (this.tree.options.defaultFindVisibility) {\n                return this.tree.options.defaultFindVisibility(element);\n            }\n            else {\n                return 2 /* TreeVisibility.Recurse */;\n            }\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nexport class ModeToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.listFilter,\n            title: localize('filter', \"Filter\"),\n            isChecked: opts.isChecked ?? false,\n            hoverDelegate: opts.hoverDelegate ?? getDefaultHoverDelegate('element'),\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nexport class FuzzyToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.searchFuzzy,\n            title: localize('fuzzySearch', \"Fuzzy Match\"),\n            isChecked: opts.isChecked ?? false,\n            hoverDelegate: opts.hoverDelegate ?? getDefaultHoverDelegate('element'),\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nconst unthemedFindWidgetStyles = {\n    inputBoxStyles: unthemedInboxStyles,\n    toggleStyles: unthemedToggleStyles,\n    listFilterWidgetBackground: undefined,\n    listFilterWidgetNoMatchesOutline: undefined,\n    listFilterWidgetOutline: undefined,\n    listFilterWidgetShadow: undefined\n};\nexport var TreeFindMode;\n(function (TreeFindMode) {\n    TreeFindMode[TreeFindMode[\"Highlight\"] = 0] = \"Highlight\";\n    TreeFindMode[TreeFindMode[\"Filter\"] = 1] = \"Filter\";\n})(TreeFindMode || (TreeFindMode = {}));\nexport var TreeFindMatchType;\n(function (TreeFindMatchType) {\n    TreeFindMatchType[TreeFindMatchType[\"Fuzzy\"] = 0] = \"Fuzzy\";\n    TreeFindMatchType[TreeFindMatchType[\"Contiguous\"] = 1] = \"Contiguous\";\n})(TreeFindMatchType || (TreeFindMatchType = {}));\nclass FindWidget extends Disposable {\n    set mode(mode) {\n        this.modeToggle.checked = mode === TreeFindMode.Filter;\n        this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localize('type to filter', \"Type to filter\") : localize('type to search', \"Type to search\"));\n    }\n    set matchType(matchType) {\n        this.matchTypeToggle.checked = matchType === TreeFindMatchType.Fuzzy;\n    }\n    constructor(container, tree, contextViewProvider, mode, matchType, options) {\n        super();\n        this.tree = tree;\n        this.elements = h('.monaco-tree-type-filter', [\n            h('.monaco-tree-type-filter-grab.codicon.codicon-debug-gripper@grab', { tabIndex: 0 }),\n            h('.monaco-tree-type-filter-input@findInput'),\n            h('.monaco-tree-type-filter-actionbar@actionbar'),\n        ]);\n        this.width = 0;\n        this.right = 0;\n        this.top = 0;\n        this._onDidDisable = new Emitter();\n        container.appendChild(this.elements.root);\n        this._register(toDisposable(() => this.elements.root.remove()));\n        const styles = options?.styles ?? unthemedFindWidgetStyles;\n        if (styles.listFilterWidgetBackground) {\n            this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground;\n        }\n        if (styles.listFilterWidgetShadow) {\n            this.elements.root.style.boxShadow = `0 0 8px 2px ${styles.listFilterWidgetShadow}`;\n        }\n        const toggleHoverDelegate = this._register(createInstantHoverDelegate());\n        this.modeToggle = this._register(new ModeToggle({ ...styles.toggleStyles, isChecked: mode === TreeFindMode.Filter, hoverDelegate: toggleHoverDelegate }));\n        this.matchTypeToggle = this._register(new FuzzyToggle({ ...styles.toggleStyles, isChecked: matchType === TreeFindMatchType.Fuzzy, hoverDelegate: toggleHoverDelegate }));\n        this.onDidChangeMode = Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);\n        this.onDidChangeMatchType = Event.map(this.matchTypeToggle.onChange, () => this.matchTypeToggle.checked ? TreeFindMatchType.Fuzzy : TreeFindMatchType.Contiguous, this._store);\n        this.findInput = this._register(new FindInput(this.elements.findInput, contextViewProvider, {\n            label: localize('type to search', \"Type to search\"),\n            additionalToggles: [this.modeToggle, this.matchTypeToggle],\n            showCommonFindToggles: false,\n            inputBoxStyles: styles.inputBoxStyles,\n            toggleStyles: styles.toggleStyles,\n            history: options?.history\n        }));\n        this.actionbar = this._register(new ActionBar(this.elements.actionbar));\n        this.mode = mode;\n        const emitter = this._register(new DomEmitter(this.findInput.inputBox.inputElement, 'keydown'));\n        const onKeyDown = Event.chain(emitter.event, $ => $.map(e => new StandardKeyboardEvent(e)));\n        this._register(onKeyDown((e) => {\n            // Using equals() so we reserve modified keys for future use\n            if (e.equals(3 /* KeyCode.Enter */)) {\n                // This is the only keyboard way to return to the tree from a history item that isn't the last one\n                e.preventDefault();\n                e.stopPropagation();\n                this.findInput.inputBox.addToHistory();\n                this.tree.domFocus();\n                return;\n            }\n            if (e.equals(18 /* KeyCode.DownArrow */)) {\n                e.preventDefault();\n                e.stopPropagation();\n                if (this.findInput.inputBox.isAtLastInHistory() || this.findInput.inputBox.isNowhereInHistory()) {\n                    // Retain original pre-history DownArrow behavior\n                    this.findInput.inputBox.addToHistory();\n                    this.tree.domFocus();\n                }\n                else {\n                    // Downward through history\n                    this.findInput.inputBox.showNextValue();\n                }\n                return;\n            }\n            if (e.equals(16 /* KeyCode.UpArrow */)) {\n                e.preventDefault();\n                e.stopPropagation();\n                // Upward through history\n                this.findInput.inputBox.showPreviousValue();\n                return;\n            }\n        }));\n        const closeAction = this._register(new Action('close', localize('close', \"Close\"), 'codicon codicon-close', true, () => this.dispose()));\n        this.actionbar.push(closeAction, { icon: true, label: false });\n        const onGrabMouseDown = this._register(new DomEmitter(this.elements.grab, 'mousedown'));\n        this._register(onGrabMouseDown.event(e => {\n            const disposables = new DisposableStore();\n            const onWindowMouseMove = disposables.add(new DomEmitter(getWindow(e), 'mousemove'));\n            const onWindowMouseUp = disposables.add(new DomEmitter(getWindow(e), 'mouseup'));\n            const startRight = this.right;\n            const startX = e.pageX;\n            const startTop = this.top;\n            const startY = e.pageY;\n            this.elements.grab.classList.add('grabbing');\n            const transition = this.elements.root.style.transition;\n            this.elements.root.style.transition = 'unset';\n            const update = (e) => {\n                const deltaX = e.pageX - startX;\n                this.right = startRight - deltaX;\n                const deltaY = e.pageY - startY;\n                this.top = startTop + deltaY;\n                this.layout();\n            };\n            disposables.add(onWindowMouseMove.event(update));\n            disposables.add(onWindowMouseUp.event(e => {\n                update(e);\n                this.elements.grab.classList.remove('grabbing');\n                this.elements.root.style.transition = transition;\n                disposables.dispose();\n            }));\n        }));\n        const onGrabKeyDown = Event.chain(this._register(new DomEmitter(this.elements.grab, 'keydown')).event, $ => $.map(e => new StandardKeyboardEvent(e)));\n        this._register(onGrabKeyDown((e) => {\n            let right;\n            let top;\n            if (e.keyCode === 15 /* KeyCode.LeftArrow */) {\n                right = Number.POSITIVE_INFINITY;\n            }\n            else if (e.keyCode === 17 /* KeyCode.RightArrow */) {\n                right = 0;\n            }\n            else if (e.keyCode === 10 /* KeyCode.Space */) {\n                right = this.right === 0 ? Number.POSITIVE_INFINITY : 0;\n            }\n            if (e.keyCode === 16 /* KeyCode.UpArrow */) {\n                top = 0;\n            }\n            else if (e.keyCode === 18 /* KeyCode.DownArrow */) {\n                top = Number.POSITIVE_INFINITY;\n            }\n            if (right !== undefined) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.right = right;\n                this.layout();\n            }\n            if (top !== undefined) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.top = top;\n                const transition = this.elements.root.style.transition;\n                this.elements.root.style.transition = 'unset';\n                this.layout();\n                setTimeout(() => {\n                    this.elements.root.style.transition = transition;\n                }, 0);\n            }\n        }));\n        this.onDidChangeValue = this.findInput.onDidChange;\n    }\n    layout(width = this.width) {\n        this.width = width;\n        this.right = clamp(this.right, 0, Math.max(0, width - 212));\n        this.elements.root.style.right = `${this.right}px`;\n        this.top = clamp(this.top, 0, 24);\n        this.elements.root.style.top = `${this.top}px`;\n    }\n    showMessage(message) {\n        this.findInput.showMessage(message);\n    }\n    clearMessage() {\n        this.findInput.clearMessage();\n    }\n    async dispose() {\n        this._onDidDisable.fire();\n        this.elements.root.classList.add('disabled');\n        await timeout(300);\n        super.dispose();\n    }\n}\nclass FindController {\n    get pattern() { return this._pattern; }\n    get mode() { return this._mode; }\n    set mode(mode) {\n        if (mode === this._mode) {\n            return;\n        }\n        this._mode = mode;\n        if (this.widget) {\n            this.widget.mode = this._mode;\n        }\n        this.tree.refilter();\n        this.render();\n        this._onDidChangeMode.fire(mode);\n    }\n    get matchType() { return this._matchType; }\n    set matchType(matchType) {\n        if (matchType === this._matchType) {\n            return;\n        }\n        this._matchType = matchType;\n        if (this.widget) {\n            this.widget.matchType = this._matchType;\n        }\n        this.tree.refilter();\n        this.render();\n        this._onDidChangeMatchType.fire(matchType);\n    }\n    constructor(tree, model, view, filter, contextViewProvider, options = {}) {\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.contextViewProvider = contextViewProvider;\n        this.options = options;\n        this._pattern = '';\n        this.width = 0;\n        this._onDidChangeMode = new Emitter();\n        this.onDidChangeMode = this._onDidChangeMode.event;\n        this._onDidChangeMatchType = new Emitter();\n        this.onDidChangeMatchType = this._onDidChangeMatchType.event;\n        this._onDidChangePattern = new Emitter();\n        this._onDidChangeOpenState = new Emitter();\n        this.onDidChangeOpenState = this._onDidChangeOpenState.event;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this._mode = tree.options.defaultFindMode ?? TreeFindMode.Highlight;\n        this._matchType = tree.options.defaultFindMatchType ?? TreeFindMatchType.Fuzzy;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n    }\n    updateOptions(optionsUpdate = {}) {\n        if (optionsUpdate.defaultFindMode !== undefined) {\n            this.mode = optionsUpdate.defaultFindMode;\n        }\n        if (optionsUpdate.defaultFindMatchType !== undefined) {\n            this.matchType = optionsUpdate.defaultFindMatchType;\n        }\n    }\n    onDidSpliceModel() {\n        if (!this.widget || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    render() {\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && noMatches) {\n            alert(localize('replFindNoResults', \"No results\"));\n            if (this.tree.options.showNotFoundMessage ?? true) {\n                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */, content: localize('not found', \"No elements found.\") });\n            }\n            else {\n                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */ });\n            }\n        }\n        else {\n            this.widget?.clearMessage();\n            if (this.pattern) {\n                alert(localize('replFindResults', \"{0} results\", this.filter.matchCount));\n            }\n        }\n    }\n    shouldAllowFocus(node) {\n        if (!this.widget || !this.pattern) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    layout(width) {\n        this.width = width;\n        this.widget?.layout(width);\n    }\n    dispose() {\n        this._history = undefined;\n        this._onDidChangePattern.dispose();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nfunction stickyScrollNodeStateEquals(node1, node2) {\n    return node1.position === node2.position && stickyScrollNodeEquals(node1, node2);\n}\nfunction stickyScrollNodeEquals(node1, node2) {\n    return node1.node.element === node2.node.element &&\n        node1.startIndex === node2.startIndex &&\n        node1.height === node2.height &&\n        node1.endIndex === node2.endIndex;\n}\nclass StickyScrollState {\n    constructor(stickyNodes = []) {\n        this.stickyNodes = stickyNodes;\n    }\n    get count() { return this.stickyNodes.length; }\n    equal(state) {\n        return equals(this.stickyNodes, state.stickyNodes, stickyScrollNodeStateEquals);\n    }\n    lastNodePartiallyVisible() {\n        if (this.count === 0) {\n            return false;\n        }\n        const lastStickyNode = this.stickyNodes[this.count - 1];\n        if (this.count === 1) {\n            return lastStickyNode.position !== 0;\n        }\n        const secondLastStickyNode = this.stickyNodes[this.count - 2];\n        return secondLastStickyNode.position + secondLastStickyNode.height !== lastStickyNode.position;\n    }\n    animationStateChanged(previousState) {\n        if (!equals(this.stickyNodes, previousState.stickyNodes, stickyScrollNodeEquals)) {\n            return false;\n        }\n        if (this.count === 0) {\n            return false;\n        }\n        const lastStickyNode = this.stickyNodes[this.count - 1];\n        const previousLastStickyNode = previousState.stickyNodes[previousState.count - 1];\n        return lastStickyNode.position !== previousLastStickyNode.position;\n    }\n}\nclass DefaultStickyScrollDelegate {\n    constrainStickyScrollNodes(stickyNodes, stickyScrollMaxItemCount, maxWidgetHeight) {\n        for (let i = 0; i < stickyNodes.length; i++) {\n            const stickyNode = stickyNodes[i];\n            const stickyNodeBottom = stickyNode.position + stickyNode.height;\n            if (stickyNodeBottom > maxWidgetHeight || i >= stickyScrollMaxItemCount) {\n                return stickyNodes.slice(0, i);\n            }\n        }\n        return stickyNodes;\n    }\n}\nclass StickyScrollController extends Disposable {\n    constructor(tree, model, view, renderers, treeDelegate, options = {}) {\n        super();\n        this.tree = tree;\n        this.model = model;\n        this.view = view;\n        this.treeDelegate = treeDelegate;\n        this.maxWidgetViewRatio = 0.4;\n        const stickyScrollOptions = this.validateStickySettings(options);\n        this.stickyScrollMaxItemCount = stickyScrollOptions.stickyScrollMaxItemCount;\n        this.stickyScrollDelegate = options.stickyScrollDelegate ?? new DefaultStickyScrollDelegate();\n        this._widget = this._register(new StickyScrollWidget(view.getScrollableElement(), view, tree, renderers, treeDelegate, options.accessibilityProvider));\n        this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus;\n        this.onContextMenu = this._widget.onContextMenu;\n        this._register(view.onDidScroll(() => this.update()));\n        this._register(view.onDidChangeContentHeight(() => this.update()));\n        this._register(tree.onDidChangeCollapseState(() => this.update()));\n        this.update();\n    }\n    get height() {\n        return this._widget.height;\n    }\n    getNodeAtHeight(height) {\n        let index;\n        if (height === 0) {\n            index = this.view.firstVisibleIndex;\n        }\n        else {\n            index = this.view.indexAt(height + this.view.scrollTop);\n        }\n        if (index < 0 || index >= this.view.length) {\n            return undefined;\n        }\n        return this.view.element(index);\n    }\n    update() {\n        const firstVisibleNode = this.getNodeAtHeight(0);\n        // Don't render anything if there are no elements\n        if (!firstVisibleNode || this.tree.scrollTop === 0) {\n            this._widget.setState(undefined);\n            return;\n        }\n        const stickyState = this.findStickyState(firstVisibleNode);\n        this._widget.setState(stickyState);\n    }\n    findStickyState(firstVisibleNode) {\n        const stickyNodes = [];\n        let firstVisibleNodeUnderWidget = firstVisibleNode;\n        let stickyNodesHeight = 0;\n        let nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, undefined, stickyNodesHeight);\n        while (nextStickyNode) {\n            stickyNodes.push(nextStickyNode);\n            stickyNodesHeight += nextStickyNode.height;\n            if (stickyNodes.length <= this.stickyScrollMaxItemCount) {\n                firstVisibleNodeUnderWidget = this.getNextVisibleNode(nextStickyNode);\n                if (!firstVisibleNodeUnderWidget) {\n                    break;\n                }\n            }\n            nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, nextStickyNode.node, stickyNodesHeight);\n        }\n        const contrainedStickyNodes = this.constrainStickyNodes(stickyNodes);\n        return contrainedStickyNodes.length ? new StickyScrollState(contrainedStickyNodes) : undefined;\n    }\n    getNextVisibleNode(previousStickyNode) {\n        return this.getNodeAtHeight(previousStickyNode.position + previousStickyNode.height);\n    }\n    getNextStickyNode(firstVisibleNodeUnderWidget, previousStickyNode, stickyNodesHeight) {\n        const nextStickyNode = this.getAncestorUnderPrevious(firstVisibleNodeUnderWidget, previousStickyNode);\n        if (!nextStickyNode) {\n            return undefined;\n        }\n        if (nextStickyNode === firstVisibleNodeUnderWidget) {\n            if (!this.nodeIsUncollapsedParent(firstVisibleNodeUnderWidget)) {\n                return undefined;\n            }\n            if (this.nodeTopAlignsWithStickyNodesBottom(firstVisibleNodeUnderWidget, stickyNodesHeight)) {\n                return undefined;\n            }\n        }\n        return this.createStickyScrollNode(nextStickyNode, stickyNodesHeight);\n    }\n    nodeTopAlignsWithStickyNodesBottom(node, stickyNodesHeight) {\n        const nodeIndex = this.getNodeIndex(node);\n        const elementTop = this.view.getElementTop(nodeIndex);\n        const stickyPosition = stickyNodesHeight;\n        return this.view.scrollTop === elementTop - stickyPosition;\n    }\n    createStickyScrollNode(node, currentStickyNodesHeight) {\n        const height = this.treeDelegate.getHeight(node);\n        const { startIndex, endIndex } = this.getNodeRange(node);\n        const position = this.calculateStickyNodePosition(endIndex, currentStickyNodesHeight, height);\n        return { node, position, height, startIndex, endIndex };\n    }\n    getAncestorUnderPrevious(node, previousAncestor = undefined) {\n        let currentAncestor = node;\n        let parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n        while (parentOfcurrentAncestor) {\n            if (parentOfcurrentAncestor === previousAncestor) {\n                return currentAncestor;\n            }\n            currentAncestor = parentOfcurrentAncestor;\n            parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n        }\n        if (previousAncestor === undefined) {\n            return currentAncestor;\n        }\n        return undefined;\n    }\n    calculateStickyNodePosition(lastDescendantIndex, stickyRowPositionTop, stickyNodeHeight) {\n        let lastChildRelativeTop = this.view.getRelativeTop(lastDescendantIndex);\n        // If the last descendant is only partially visible at the top of the view, getRelativeTop() returns null\n        // In that case, utilize the next node's relative top to calculate the sticky node's position\n        if (lastChildRelativeTop === null && this.view.firstVisibleIndex === lastDescendantIndex && lastDescendantIndex + 1 < this.view.length) {\n            const nodeHeight = this.treeDelegate.getHeight(this.view.element(lastDescendantIndex));\n            const nextNodeRelativeTop = this.view.getRelativeTop(lastDescendantIndex + 1);\n            lastChildRelativeTop = nextNodeRelativeTop ? nextNodeRelativeTop - nodeHeight / this.view.renderHeight : null;\n        }\n        if (lastChildRelativeTop === null) {\n            return stickyRowPositionTop;\n        }\n        const lastChildNode = this.view.element(lastDescendantIndex);\n        const lastChildHeight = this.treeDelegate.getHeight(lastChildNode);\n        const topOfLastChild = lastChildRelativeTop * this.view.renderHeight;\n        const bottomOfLastChild = topOfLastChild + lastChildHeight;\n        if (stickyRowPositionTop + stickyNodeHeight > bottomOfLastChild && stickyRowPositionTop <= bottomOfLastChild) {\n            return bottomOfLastChild - stickyNodeHeight;\n        }\n        return stickyRowPositionTop;\n    }\n    constrainStickyNodes(stickyNodes) {\n        if (stickyNodes.length === 0) {\n            return [];\n        }\n        // Check if sticky nodes need to be constrained\n        const maximumStickyWidgetHeight = this.view.renderHeight * this.maxWidgetViewRatio;\n        const lastStickyNode = stickyNodes[stickyNodes.length - 1];\n        if (stickyNodes.length <= this.stickyScrollMaxItemCount && lastStickyNode.position + lastStickyNode.height <= maximumStickyWidgetHeight) {\n            return stickyNodes;\n        }\n        // constrain sticky nodes\n        const constrainedStickyNodes = this.stickyScrollDelegate.constrainStickyScrollNodes(stickyNodes, this.stickyScrollMaxItemCount, maximumStickyWidgetHeight);\n        if (!constrainedStickyNodes.length) {\n            return [];\n        }\n        // Validate constraints\n        const lastConstrainedStickyNode = constrainedStickyNodes[constrainedStickyNodes.length - 1];\n        if (constrainedStickyNodes.length > this.stickyScrollMaxItemCount || lastConstrainedStickyNode.position + lastConstrainedStickyNode.height > maximumStickyWidgetHeight) {\n            throw new Error('stickyScrollDelegate violates constraints');\n        }\n        return constrainedStickyNodes;\n    }\n    getParentNode(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const parentLocation = this.model.getParentNodeLocation(nodeLocation);\n        return parentLocation ? this.model.getNode(parentLocation) : undefined;\n    }\n    nodeIsUncollapsedParent(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        return this.model.getListRenderCount(nodeLocation) > 1;\n    }\n    getNodeIndex(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const nodeIndex = this.model.getListIndex(nodeLocation);\n        return nodeIndex;\n    }\n    getNodeRange(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const startIndex = this.model.getListIndex(nodeLocation);\n        if (startIndex < 0) {\n            throw new Error('Node not found in tree');\n        }\n        const renderCount = this.model.getListRenderCount(nodeLocation);\n        const endIndex = startIndex + renderCount - 1;\n        return { startIndex, endIndex };\n    }\n    nodePositionTopBelowWidget(node) {\n        const ancestors = [];\n        let currentAncestor = this.getParentNode(node);\n        while (currentAncestor) {\n            ancestors.push(currentAncestor);\n            currentAncestor = this.getParentNode(currentAncestor);\n        }\n        let widgetHeight = 0;\n        for (let i = 0; i < ancestors.length && i < this.stickyScrollMaxItemCount; i++) {\n            widgetHeight += this.treeDelegate.getHeight(ancestors[i]);\n        }\n        return widgetHeight;\n    }\n    domFocus() {\n        this._widget.domFocus();\n    }\n    // Whether sticky scroll was the last focused part in the tree or not\n    focusedLast() {\n        return this._widget.focusedLast();\n    }\n    updateOptions(optionsUpdate = {}) {\n        if (!optionsUpdate.stickyScrollMaxItemCount) {\n            return;\n        }\n        const validatedOptions = this.validateStickySettings(optionsUpdate);\n        if (this.stickyScrollMaxItemCount !== validatedOptions.stickyScrollMaxItemCount) {\n            this.stickyScrollMaxItemCount = validatedOptions.stickyScrollMaxItemCount;\n            this.update();\n        }\n    }\n    validateStickySettings(options) {\n        let stickyScrollMaxItemCount = 7;\n        if (typeof options.stickyScrollMaxItemCount === 'number') {\n            stickyScrollMaxItemCount = Math.max(options.stickyScrollMaxItemCount, 1);\n        }\n        return { stickyScrollMaxItemCount };\n    }\n}\nclass StickyScrollWidget {\n    constructor(container, view, tree, treeRenderers, treeDelegate, accessibilityProvider) {\n        this.view = view;\n        this.tree = tree;\n        this.treeRenderers = treeRenderers;\n        this.treeDelegate = treeDelegate;\n        this.accessibilityProvider = accessibilityProvider;\n        this._previousElements = [];\n        this._previousStateDisposables = new DisposableStore();\n        this._rootDomNode = $('.monaco-tree-sticky-container.empty');\n        container.appendChild(this._rootDomNode);\n        const shadow = $('.monaco-tree-sticky-container-shadow');\n        this._rootDomNode.appendChild(shadow);\n        this.stickyScrollFocus = new StickyScrollFocus(this._rootDomNode, view);\n        this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus;\n        this.onContextMenu = this.stickyScrollFocus.onContextMenu;\n    }\n    get height() {\n        if (!this._previousState) {\n            return 0;\n        }\n        const lastElement = this._previousState.stickyNodes[this._previousState.count - 1];\n        return lastElement.position + lastElement.height;\n    }\n    setState(state) {\n        const wasVisible = !!this._previousState && this._previousState.count > 0;\n        const isVisible = !!state && state.count > 0;\n        // If state has not changed, do nothing\n        if ((!wasVisible && !isVisible) || (wasVisible && isVisible && this._previousState.equal(state))) {\n            return;\n        }\n        // Update visibility of the widget if changed\n        if (wasVisible !== isVisible) {\n            this.setVisible(isVisible);\n        }\n        if (!isVisible) {\n            this._previousState = undefined;\n            this._previousElements = [];\n            this._previousStateDisposables.clear();\n            return;\n        }\n        const lastStickyNode = state.stickyNodes[state.count - 1];\n        // If the new state is only a change in the last node's position, update the position of the last element\n        if (this._previousState && state.animationStateChanged(this._previousState)) {\n            this._previousElements[this._previousState.count - 1].style.top = `${lastStickyNode.position}px`;\n        }\n        // create new dom elements\n        else {\n            this._previousStateDisposables.clear();\n            const elements = Array(state.count);\n            for (let stickyIndex = state.count - 1; stickyIndex >= 0; stickyIndex--) {\n                const stickyNode = state.stickyNodes[stickyIndex];\n                const { element, disposable } = this.createElement(stickyNode, stickyIndex, state.count);\n                elements[stickyIndex] = element;\n                this._rootDomNode.appendChild(element);\n                this._previousStateDisposables.add(disposable);\n            }\n            this.stickyScrollFocus.updateElements(elements, state);\n            this._previousElements = elements;\n        }\n        this._previousState = state;\n        // Set the height of the widget to the bottom of the last sticky node\n        this._rootDomNode.style.height = `${lastStickyNode.position + lastStickyNode.height}px`;\n    }\n    createElement(stickyNode, stickyIndex, stickyNodesTotal) {\n        const nodeIndex = stickyNode.startIndex;\n        // Sticky element container\n        const stickyElement = document.createElement('div');\n        stickyElement.style.top = `${stickyNode.position}px`;\n        if (this.tree.options.setRowHeight !== false) {\n            stickyElement.style.height = `${stickyNode.height}px`;\n        }\n        if (this.tree.options.setRowLineHeight !== false) {\n            stickyElement.style.lineHeight = `${stickyNode.height}px`;\n        }\n        stickyElement.classList.add('monaco-tree-sticky-row');\n        stickyElement.classList.add('monaco-list-row');\n        stickyElement.setAttribute('data-index', `${nodeIndex}`);\n        stickyElement.setAttribute('data-parity', nodeIndex % 2 === 0 ? 'even' : 'odd');\n        stickyElement.setAttribute('id', this.view.getElementID(nodeIndex));\n        const accessibilityDisposable = this.setAccessibilityAttributes(stickyElement, stickyNode.node.element, stickyIndex, stickyNodesTotal);\n        // Get the renderer for the node\n        const nodeTemplateId = this.treeDelegate.getTemplateId(stickyNode.node);\n        const renderer = this.treeRenderers.find((renderer) => renderer.templateId === nodeTemplateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for template id ${nodeTemplateId}`);\n        }\n        // To make sure we do not influence the original node, we create a copy of the node\n        // We need to check if it is already a unique instance of the node by the delegate\n        let nodeCopy = stickyNode.node;\n        if (nodeCopy === this.tree.getNode(this.tree.getNodeLocation(stickyNode.node))) {\n            nodeCopy = new Proxy(stickyNode.node, {});\n        }\n        // Render the element\n        const templateData = renderer.renderTemplate(stickyElement);\n        renderer.renderElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n        // Remove the element from the DOM when state is disposed\n        const disposable = toDisposable(() => {\n            accessibilityDisposable.dispose();\n            renderer.disposeElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n            renderer.disposeTemplate(templateData);\n            stickyElement.remove();\n        });\n        return { element: stickyElement, disposable };\n    }\n    setAccessibilityAttributes(container, element, stickyIndex, stickyNodesTotal) {\n        if (!this.accessibilityProvider) {\n            return Disposable.None;\n        }\n        if (this.accessibilityProvider.getSetSize) {\n            container.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(element, stickyIndex, stickyNodesTotal)));\n        }\n        if (this.accessibilityProvider.getPosInSet) {\n            container.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(element, stickyIndex)));\n        }\n        if (this.accessibilityProvider.getRole) {\n            container.setAttribute('role', this.accessibilityProvider.getRole(element) ?? 'treeitem');\n        }\n        const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n        const observable = (ariaLabel && typeof ariaLabel !== 'string') ? ariaLabel : constObservable(ariaLabel);\n        const result = autorun(reader => {\n            const value = reader.readObservable(observable);\n            if (value) {\n                container.setAttribute('aria-label', value);\n            }\n            else {\n                container.removeAttribute('aria-label');\n            }\n        });\n        if (typeof ariaLabel === 'string') {\n        }\n        else if (ariaLabel) {\n            container.setAttribute('aria-label', ariaLabel.get());\n        }\n        const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n        if (typeof ariaLevel === 'number') {\n            container.setAttribute('aria-level', `${ariaLevel}`);\n        }\n        // Sticky Scroll elements can not be selected\n        container.setAttribute('aria-selected', String(false));\n        return result;\n    }\n    setVisible(visible) {\n        this._rootDomNode.classList.toggle('empty', !visible);\n        if (!visible) {\n            this.stickyScrollFocus.updateElements([], undefined);\n        }\n    }\n    domFocus() {\n        this.stickyScrollFocus.domFocus();\n    }\n    focusedLast() {\n        return this.stickyScrollFocus.focusedLast();\n    }\n    dispose() {\n        this.stickyScrollFocus.dispose();\n        this._previousStateDisposables.dispose();\n        this._rootDomNode.remove();\n    }\n}\nclass StickyScrollFocus extends Disposable {\n    get domHasFocus() { return this._domHasFocus; }\n    set domHasFocus(hasFocus) {\n        if (hasFocus !== this._domHasFocus) {\n            this._onDidChangeHasFocus.fire(hasFocus);\n            this._domHasFocus = hasFocus;\n        }\n    }\n    constructor(container, view) {\n        super();\n        this.container = container;\n        this.view = view;\n        this.focusedIndex = -1;\n        this.elements = [];\n        this._onDidChangeHasFocus = new Emitter();\n        this.onDidChangeHasFocus = this._onDidChangeHasFocus.event;\n        this._onContextMenu = new Emitter();\n        this.onContextMenu = this._onContextMenu.event;\n        this._domHasFocus = false;\n        this._register(addDisposableListener(this.container, 'focus', () => this.onFocus()));\n        this._register(addDisposableListener(this.container, 'blur', () => this.onBlur()));\n        this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(false)));\n        this._register(this.view.onKeyDown((e) => this.onKeyDown(e)));\n        this._register(this.view.onMouseDown((e) => this.onMouseDown(e)));\n        this._register(this.view.onContextMenu((e) => this.handleContextMenu(e)));\n    }\n    handleContextMenu(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            if (this.focusedLast()) {\n                this.view.domFocus();\n            }\n            return;\n        }\n        // The list handles the context menu triggered by a mouse event\n        // In that case only set the focus of the element clicked and leave the rest to the list to handle\n        if (!isKeyboardEvent(e.browserEvent)) {\n            if (!this.state) {\n                throw new Error('Context menu should not be triggered when state is undefined');\n            }\n            const stickyIndex = this.state.stickyNodes.findIndex(stickyNode => stickyNode.node.element === e.element?.element);\n            if (stickyIndex === -1) {\n                throw new Error('Context menu should not be triggered when element is not in sticky scroll widget');\n            }\n            this.container.focus();\n            this.setFocus(stickyIndex);\n            return;\n        }\n        if (!this.state || this.focusedIndex < 0) {\n            throw new Error('Context menu key should not be triggered when focus is not in sticky scroll widget');\n        }\n        const stickyNode = this.state.stickyNodes[this.focusedIndex];\n        const element = stickyNode.node.element;\n        const anchor = this.elements[this.focusedIndex];\n        this._onContextMenu.fire({ element, anchor, browserEvent: e.browserEvent, isStickyScroll: true });\n    }\n    onKeyDown(e) {\n        // Sticky Scroll Navigation\n        if (this.domHasFocus && this.state) {\n            // Move up\n            if (e.key === 'ArrowUp') {\n                this.setFocusedElement(Math.max(0, this.focusedIndex - 1));\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            // Move down, if last sticky node is focused, move focus into first child of last sticky node\n            else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {\n                if (this.focusedIndex >= this.state.count - 1) {\n                    const nodeIndexToFocus = this.state.stickyNodes[this.state.count - 1].startIndex + 1;\n                    this.view.domFocus();\n                    this.view.setFocus([nodeIndexToFocus]);\n                    this.scrollNodeUnderWidget(nodeIndexToFocus, this.state);\n                }\n                else {\n                    this.setFocusedElement(this.focusedIndex + 1);\n                }\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    onMouseDown(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            return;\n        }\n        e.browserEvent.preventDefault();\n        e.browserEvent.stopPropagation();\n    }\n    updateElements(elements, state) {\n        if (state && state.count === 0) {\n            throw new Error('Sticky scroll state must be undefined when there are no sticky nodes');\n        }\n        if (state && state.count !== elements.length) {\n            throw new Error('Sticky scroll focus received illigel state');\n        }\n        const previousIndex = this.focusedIndex;\n        this.removeFocus();\n        this.elements = elements;\n        this.state = state;\n        if (state) {\n            const newFocusedIndex = clamp(previousIndex, 0, state.count - 1);\n            this.setFocus(newFocusedIndex);\n        }\n        else {\n            if (this.domHasFocus) {\n                this.view.domFocus();\n            }\n        }\n        // must come last as it calls blur()\n        this.container.tabIndex = state ? 0 : -1;\n    }\n    setFocusedElement(stickyIndex) {\n        // doesn't imply that the widget has (or will have) focus\n        const state = this.state;\n        if (!state) {\n            throw new Error('Cannot set focus when state is undefined');\n        }\n        this.setFocus(stickyIndex);\n        if (stickyIndex < state.count - 1) {\n            return;\n        }\n        // If the last sticky node is not fully visible, scroll it into view\n        if (state.lastNodePartiallyVisible()) {\n            const lastStickyNode = state.stickyNodes[stickyIndex];\n            this.scrollNodeUnderWidget(lastStickyNode.endIndex + 1, state);\n        }\n    }\n    scrollNodeUnderWidget(nodeIndex, state) {\n        const lastStickyNode = state.stickyNodes[state.count - 1];\n        const secondLastStickyNode = state.count > 1 ? state.stickyNodes[state.count - 2] : undefined;\n        const elementScrollTop = this.view.getElementTop(nodeIndex);\n        const elementTargetViewTop = secondLastStickyNode ? secondLastStickyNode.position + secondLastStickyNode.height + lastStickyNode.height : lastStickyNode.height;\n        this.view.scrollTop = elementScrollTop - elementTargetViewTop;\n    }\n    domFocus() {\n        if (!this.state) {\n            throw new Error('Cannot focus when state is undefined');\n        }\n        this.container.focus();\n    }\n    focusedLast() {\n        if (!this.state) {\n            return false;\n        }\n        return this.view.getHTMLElement().classList.contains('sticky-scroll-focused');\n    }\n    removeFocus() {\n        if (this.focusedIndex === -1) {\n            return;\n        }\n        this.toggleElementFocus(this.elements[this.focusedIndex], false);\n        this.focusedIndex = -1;\n    }\n    setFocus(newFocusIndex) {\n        if (0 > newFocusIndex) {\n            throw new Error('addFocus() can not remove focus');\n        }\n        if (!this.state && newFocusIndex >= 0) {\n            throw new Error('Cannot set focus index when state is undefined');\n        }\n        if (this.state && newFocusIndex >= this.state.count) {\n            throw new Error('Cannot set focus index to an index that does not exist');\n        }\n        const oldIndex = this.focusedIndex;\n        if (oldIndex >= 0) {\n            this.toggleElementFocus(this.elements[oldIndex], false);\n        }\n        if (newFocusIndex >= 0) {\n            this.toggleElementFocus(this.elements[newFocusIndex], true);\n        }\n        this.focusedIndex = newFocusIndex;\n    }\n    toggleElementFocus(element, focused) {\n        this.toggleElementActiveFocus(element, focused && this.domHasFocus);\n        this.toggleElementPassiveFocus(element, focused);\n    }\n    toggleCurrentElementActiveFocus(focused) {\n        if (this.focusedIndex === -1) {\n            return;\n        }\n        this.toggleElementActiveFocus(this.elements[this.focusedIndex], focused);\n    }\n    toggleElementActiveFocus(element, focused) {\n        // active focus is set when sticky scroll has focus\n        element.classList.toggle('focused', focused);\n    }\n    toggleElementPassiveFocus(element, focused) {\n        // passive focus allows to show focus when sticky scroll does not have focus\n        // for example when the context menu has focus\n        element.classList.toggle('passive-focused', focused);\n    }\n    toggleStickyScrollFocused(focused) {\n        // Weather the last focus in the view was sticky scroll and not the list\n        // Is only removed when the focus is back in the tree an no longer in sticky scroll\n        this.view.getHTMLElement().classList.toggle('sticky-scroll-focused', focused);\n    }\n    onFocus() {\n        if (!this.state || this.elements.length === 0) {\n            throw new Error('Cannot focus when state is undefined or elements are empty');\n        }\n        this.domHasFocus = true;\n        this.toggleStickyScrollFocused(true);\n        this.toggleCurrentElementActiveFocus(true);\n        if (this.focusedIndex === -1) {\n            this.setFocus(0);\n        }\n    }\n    onBlur() {\n        this.domHasFocus = false;\n        this.toggleCurrentElementActiveFocus(false);\n    }\n    dispose() {\n        this.toggleStickyScrollFocused(false);\n        this._onDidChangeHasFocus.fire(false);\n        super.dispose();\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tree-type-filter', 'monaco-list')) {\n        target = TreeMouseEventTarget.Filter;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction asTreeContextMenuEvent(event) {\n    const isStickyScroll = isStickyScrollContainer(event.browserEvent.target);\n    return {\n        element: event.element ? event.element.element : null,\n        browserEvent: event.browserEvent,\n        anchor: event.anchor,\n        isStickyScroll\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    constructor(getFirstViewElementWithTrait, identityProvider) {\n        this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    set(nodes, browserEvent) {\n        if (!browserEvent?.__forceEvent && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode && insertedNode.visible) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        if (this.nodes.length > 0 && nodes.length === 0) {\n            const node = this.getFirstViewElementWithTrait();\n            if (node) {\n                nodes.push(node);\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree, stickyScrollProvider) {\n        super(list);\n        this.tree = tree;\n        this.stickyScrollProvider = stickyScrollProvider;\n    }\n    onViewPointer(e) {\n        if (isButton(e.browserEvent.target) ||\n            isInputElement(e.browserEvent.target) ||\n            isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        const isStickyElement = isStickyScrollElement(e.browserEvent.target);\n        let expandOnlyOnTwistieClick = false;\n        if (isStickyElement) {\n            expandOnlyOnTwistieClick = true;\n        }\n        else if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (!isStickyElement) {\n            if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n                return super.onViewPointer(e);\n            }\n            if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n                return super.onViewPointer(e);\n            }\n        }\n        else {\n            this.handleStickyScrollMouseEvent(e, node);\n        }\n        if (node.collapsible && (!isStickyElement || onTwistie)) {\n            const location = this.tree.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            this.tree.toggleCollapsed(location, recursive);\n            if (onTwistie) {\n                // Do not set this before calling a handler on the super class, because it will reject it as handled\n                e.browserEvent.isHandledByList = true;\n                return;\n            }\n        }\n        if (!isStickyElement) {\n            super.onViewPointer(e);\n        }\n    }\n    handleStickyScrollMouseEvent(e, node) {\n        if (isMonacoCustomToggle(e.browserEvent.target) || isActionItem(e.browserEvent.target)) {\n            return;\n        }\n        const stickyScrollController = this.stickyScrollProvider();\n        if (!stickyScrollController) {\n            throw new Error('Sticky scroll controller not found');\n        }\n        const nodeIndex = this.list.indexOf(node);\n        const elementScrollTop = this.list.getElementTop(nodeIndex);\n        const elementTargetViewTop = stickyScrollController.nodePositionTopBelowWidget(node);\n        this.tree.scrollTop = elementScrollTop - elementTargetViewTop;\n        this.list.domFocus();\n        this.list.setFocus([nodeIndex]);\n        this.list.setSelection([nodeIndex]);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n    // to make sure dom focus is not stolen (for example with context menu)\n    onMouseDown(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            super.onMouseDown(e);\n            return;\n        }\n    }\n    onContextMenu(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            super.onContextMenu(e);\n            return;\n        }\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree, options.stickyScrollProvider);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    get onDidScroll() { return this.view.onDidScroll; }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter); }\n    get onMouseOver() { return Event.map(this.view.onMouseOver, asTreeMouseEvent); }\n    get onMouseOut() { return Event.map(this.view.onMouseOut, asTreeMouseEvent); }\n    get onContextMenu() { return Event.any(Event.filter(Event.map(this.view.onContextMenu, asTreeContextMenuEvent), e => !e.isStickyScroll), this.stickyScrollController?.onContextMenu ?? Event.None); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onKeyDown() { return this.view.onKeyDown; }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get findMode() { return this.findController?.mode ?? TreeFindMode.Highlight; }\n    set findMode(findMode) { if (this.findController) {\n        this.findController.mode = findMode;\n    } }\n    get findMatchType() { return this.findController?.matchType ?? TreeFindMatchType.Fuzzy; }\n    set findMatchType(findFuzzy) { if (this.findController) {\n        this.findController.matchType = findFuzzy;\n    } }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    constructor(_user, container, delegate, renderers, _options = {}) {\n        this._user = _user;\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.onDidChangeFindOpenState = Event.None;\n        this.onDidChangeStickyScrollFocused = Event.None;\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        this.treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));\n        const renderedIndentGuides = new SetMap();\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, renderedIndentGuides, _options));\n        for (const r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = { ..._options, filter: filter }; // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n        this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n        this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n        this.view = new TreeNodeList(_user, container, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...asListOptions(() => this.model, _options), tree: this, stickyScrollProvider: () => this.stickyScrollController });\n        this.model = this.createModel(_user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        }, this.disposables);\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        const activeNodesEmitter = this.disposables.add(new Emitter());\n        const activeNodesDebounce = this.disposables.add(new Delayer(0));\n        this.disposables.add(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)(() => {\n            activeNodesDebounce.trigger(() => {\n                const set = new Set();\n                for (const node of this.focus.getNodes()) {\n                    set.add(node);\n                }\n                for (const node of this.selection.getNodes()) {\n                    set.add(node);\n                }\n                activeNodesEmitter.fire([...set.values()]);\n            });\n        }));\n        onDidChangeActiveNodes.input = activeNodesEmitter.event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown, $ => $.filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e)));\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 15 /* KeyCode.LeftArrow */))(this.onLeftArrow, this, this.disposables);\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 17 /* KeyCode.RightArrow */))(this.onRightArrow, this, this.disposables);\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 10 /* KeyCode.Space */))(this.onSpace, this, this.disposables);\n        }\n        if ((_options.findWidgetEnabled ?? true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {\n            const opts = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : undefined;\n            this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, opts);\n            this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);\n            this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;\n            this.disposables.add(this.findController);\n            this.onDidChangeFindMode = this.findController.onDidChangeMode;\n            this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;\n        }\n        else {\n            this.onDidChangeFindMode = Event.None;\n            this.onDidChangeFindMatchType = Event.None;\n        }\n        if (_options.enableStickyScroll) {\n            this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, _options);\n            this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    updateOptions(optionsUpdate = {}) {\n        this._options = { ...this._options, ...optionsUpdate };\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions(this._options);\n        this.findController?.updateOptions(optionsUpdate);\n        this.updateStickyScroll(optionsUpdate);\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    updateStickyScroll(optionsUpdate) {\n        if (!this.stickyScrollController && this._options.enableStickyScroll) {\n            this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, this._options);\n            this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n        }\n        else if (this.stickyScrollController && !this._options.enableStickyScroll) {\n            this.onDidChangeStickyScrollFocused = Event.None;\n            this.stickyScrollController.dispose();\n            this.stickyScrollController = undefined;\n        }\n        this.stickyScrollController?.updateOptions(optionsUpdate);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    get scrollHeight() {\n        return this.view.scrollHeight;\n    }\n    get renderHeight() {\n        return this.view.renderHeight;\n    }\n    get ariaLabel() {\n        return this.view.ariaLabel;\n    }\n    set ariaLabel(value) {\n        this.view.ariaLabel = value;\n    }\n    domFocus() {\n        if (this.stickyScrollController?.focusedLast()) {\n            this.stickyScrollController.domFocus();\n        }\n        else {\n            this.view.domFocus();\n        }\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n        if (isNumber(width)) {\n            this.findController?.layout(width);\n        }\n    }\n    style(styles) {\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeInactiveIndentGuidesStroke}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        // Sticky Scroll Background\n        const stickyScrollBackground = styles.treeStickyScrollBackground ?? styles.listBackground;\n        if (stickyScrollBackground) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${stickyScrollBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${stickyScrollBackground}; }`);\n        }\n        // Sticky Scroll Border\n        if (styles.treeStickyScrollBorder) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${styles.treeStickyScrollBorder}; }`);\n        }\n        // Sticky Scroll Shadow\n        if (styles.treeStickyScrollShadow) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${styles.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`);\n        }\n        // Sticky Scroll Focus\n        if (styles.listFocusForeground) {\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`);\n        }\n        // Sticky Scroll Focus Outlines\n        const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, styles.listFocusOutline ?? ''));\n        if (focusAndSelectionOutline) { // default: listFocusOutline\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`);\n        }\n        if (styles.listFocusOutline) { // default: set\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        this.view.style(styles);\n    }\n    // Tree navigation\n    getParentElement(location) {\n        const parentRef = this.model.getParentNodeLocation(location);\n        const parentNode = this.model.getNode(parentRef);\n        return parentNode.element;\n    }\n    getFirstElementChild(location) {\n        return this.model.getFirstElementChild(location);\n    }\n    // Tree\n    getNode(location) {\n        return this.model.getNode(location);\n    }\n    getNodeLocation(node) {\n        return this.model.getNodeLocation(node);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    toggleCollapsed(location, recursive = false) {\n        return this.model.setCollapsed(location, undefined, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        this.eventBufferer.bufferEvents(() => {\n            const nodes = elements.map(e => this.model.getNode(e));\n            this.selection.set(nodes, browserEvent);\n            const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n            this.view.setSelection(indexes, browserEvent, true);\n        });\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        this.eventBufferer.bufferEvents(() => {\n            const nodes = elements.map(e => this.model.getNode(e));\n            this.focus.set(nodes, browserEvent);\n            const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n            this.view.setFocus(indexes, browserEvent, true);\n        });\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusNext(n, loop, browserEvent, filter);\n    }\n    focusPrevious(n = 1, loop = false, browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusPrevious(n, loop, browserEvent, filter);\n    }\n    focusNextPage(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        return this.view.focusNextPage(browserEvent, filter);\n    }\n    focusPreviousPage(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        return this.view.focusPreviousPage(browserEvent, filter, () => this.stickyScrollController?.height ?? 0);\n    }\n    focusLast(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusLast(browserEvent, filter);\n    }\n    focusFirst(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusFirst(browserEvent, filter);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        if (!this.stickyScrollController) {\n            this.view.reveal(index, relativeTop);\n        }\n        else {\n            const paddingTop = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(location));\n            this.view.reveal(index, relativeTop, paddingTop);\n        }\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.stickyScrollController?.dispose();\n        this.view.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { getBaseLayerHoverDelegate } from '../hover/hoverDelegate2.js';\nimport { getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { renderLabelWithIcons } from '../iconLabel/iconLabels.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport * as objects from '../../../common/objects.js';\n/**\n * A widget which can render a label with substring highlights, often\n * originating from a filter function like the fuzzy matcher.\n */\nexport class HighlightedLabel extends Disposable {\n    /**\n     * Create a new {@link HighlightedLabel}.\n     *\n     * @param container The parent container to append to.\n     */\n    constructor(container, options) {\n        super();\n        this.options = options;\n        this.text = '';\n        this.title = '';\n        this.highlights = [];\n        this.didEverRender = false;\n        this.supportIcons = options?.supportIcons ?? false;\n        this.domNode = dom.append(container, dom.$('span.monaco-highlighted-label'));\n    }\n    /**\n     * The label's DOM node.\n     */\n    get element() {\n        return this.domNode;\n    }\n    /**\n     * Set the label and highlights.\n     *\n     * @param text The label to display.\n     * @param highlights The ranges to highlight.\n     * @param title An optional title for the hover tooltip.\n     * @param escapeNewLines Whether to escape new lines.\n     * @returns\n     */\n    set(text, highlights = [], title = '', escapeNewLines) {\n        if (!text) {\n            text = '';\n        }\n        if (escapeNewLines) {\n            // adjusts highlights inplace\n            text = HighlightedLabel.escapeNewLines(text, highlights);\n        }\n        if (this.didEverRender && this.text === text && this.title === title && objects.equals(this.highlights, highlights)) {\n            return;\n        }\n        this.text = text;\n        this.title = title;\n        this.highlights = highlights;\n        this.render();\n    }\n    render() {\n        const children = [];\n        let pos = 0;\n        for (const highlight of this.highlights) {\n            if (highlight.end === highlight.start) {\n                continue;\n            }\n            if (pos < highlight.start) {\n                const substring = this.text.substring(pos, highlight.start);\n                if (this.supportIcons) {\n                    children.push(...renderLabelWithIcons(substring));\n                }\n                else {\n                    children.push(substring);\n                }\n                pos = highlight.start;\n            }\n            const substring = this.text.substring(pos, highlight.end);\n            const element = dom.$('span.highlight', undefined, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]);\n            if (highlight.extraClasses) {\n                element.classList.add(...highlight.extraClasses);\n            }\n            children.push(element);\n            pos = highlight.end;\n        }\n        if (pos < this.text.length) {\n            const substring = this.text.substring(pos);\n            if (this.supportIcons) {\n                children.push(...renderLabelWithIcons(substring));\n            }\n            else {\n                children.push(substring);\n            }\n        }\n        dom.reset(this.domNode, ...children);\n        if (this.options?.hoverDelegate?.showNativeHover) {\n            /* While custom hover is not inside custom hover */\n            this.domNode.title = this.title;\n        }\n        else {\n            if (!this.customHover && this.title !== '') {\n                const hoverDelegate = this.options?.hoverDelegate ?? getDefaultHoverDelegate('mouse');\n                this.customHover = this._register(getBaseLayerHoverDelegate().setupManagedHover(hoverDelegate, this.domNode, this.title));\n            }\n            else if (this.customHover) {\n                this.customHover.update(this.title);\n            }\n        }\n        this.didEverRender = true;\n    }\n    static escapeNewLines(text, highlights) {\n        let total = 0;\n        let extra = 0;\n        return text.replace(/\\r\\n|\\r|\\n/g, (match, offset) => {\n            extra = match === '\\r\\n' ? -1 : 0;\n            offset += total;\n            for (const highlight of highlights) {\n                if (highlight.end <= offset) {\n                    continue;\n                }\n                if (highlight.start >= offset) {\n                    highlight.start += extra;\n                }\n                if (highlight.end >= offset) {\n                    highlight.end += extra;\n                }\n            }\n            total += extra;\n            return '\\u23CE';\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar QuickInputController_1;\nimport * as dom from '../../../base/browser/dom.js';\nimport { ActionBar } from '../../../base/browser/ui/actionbar/actionbar.js';\nimport { Button } from '../../../base/browser/ui/button/button.js';\nimport { CountBadge } from '../../../base/browser/ui/countBadge/countBadge.js';\nimport { ProgressBar } from '../../../base/browser/ui/progressbar/progressbar.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose } from '../../../base/common/lifecycle.js';\nimport Severity from '../../../base/common/severity.js';\nimport { localize } from '../../../nls.js';\nimport { QuickInputHideReason } from '../common/quickInput.js';\nimport { QuickInputBox } from './quickInputBox.js';\nimport { QuickPick, backButton, InputBox, InQuickInputContextKey, QuickInputTypeContextKey, EndOfQuickInputBoxContextKey } from './quickInput.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { QuickInputTree } from './quickInputTree.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport './quickInputActions.js';\nconst $ = dom.$;\nlet QuickInputController = class QuickInputController extends Disposable {\n    static { QuickInputController_1 = this; }\n    static { this.MAX_WIDTH = 600; } // Max total width of quick input widget\n    get currentQuickInput() { return this.controller ?? undefined; }\n    get container() { return this._container; }\n    constructor(options, layoutService, instantiationService, contextKeyService) {\n        super();\n        this.options = options;\n        this.layoutService = layoutService;\n        this.instantiationService = instantiationService;\n        this.contextKeyService = contextKeyService;\n        this.enabled = true;\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.keyMods = { ctrlCmd: false, alt: false };\n        this.controller = null;\n        this.onShowEmitter = this._register(new Emitter());\n        this.onShow = this.onShowEmitter.event;\n        this.onHideEmitter = this._register(new Emitter());\n        this.onHide = this.onHideEmitter.event;\n        this.inQuickInputContext = InQuickInputContextKey.bindTo(this.contextKeyService);\n        this.quickInputTypeContext = QuickInputTypeContextKey.bindTo(this.contextKeyService);\n        this.endOfQuickInputBoxContext = EndOfQuickInputBoxContextKey.bindTo(this.contextKeyService);\n        this.idPrefix = options.idPrefix;\n        this._container = options.container;\n        this.styles = options.styles;\n        this._register(Event.runAndSubscribe(dom.onDidRegisterWindow, ({ window, disposables }) => this.registerKeyModsListeners(window, disposables), { window: mainWindow, disposables: this._store }));\n        this._register(dom.onWillUnregisterWindow(window => {\n            if (this.ui && dom.getWindow(this.ui.container) === window) {\n                // The window this quick input is contained in is about to\n                // close, so we have to make sure to reparent it back to an\n                // existing parent to not loose functionality.\n                // (https://github.com/microsoft/vscode/issues/195870)\n                this.reparentUI(this.layoutService.mainContainer);\n                this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop);\n            }\n        }));\n    }\n    registerKeyModsListeners(window, disposables) {\n        const listener = (e) => {\n            this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;\n            this.keyMods.alt = e.altKey;\n        };\n        for (const event of [dom.EventType.KEY_DOWN, dom.EventType.KEY_UP, dom.EventType.MOUSE_DOWN]) {\n            disposables.add(dom.addDisposableListener(window, event, listener, true));\n        }\n    }\n    getUI(showInActiveContainer) {\n        if (this.ui) {\n            // In order to support aux windows, re-parent the controller\n            // if the original event is from a different document\n            if (showInActiveContainer) {\n                if (dom.getWindow(this._container) !== dom.getWindow(this.layoutService.activeContainer)) {\n                    this.reparentUI(this.layoutService.activeContainer);\n                    this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop);\n                }\n            }\n            return this.ui;\n        }\n        const container = dom.append(this._container, $('.quick-input-widget.show-file-icons'));\n        container.tabIndex = -1;\n        container.style.display = 'none';\n        const styleSheet = dom.createStyleSheet(container);\n        const titleBar = dom.append(container, $('.quick-input-titlebar'));\n        const leftActionBar = this._register(new ActionBar(titleBar, { hoverDelegate: this.options.hoverDelegate }));\n        leftActionBar.domNode.classList.add('quick-input-left-action-bar');\n        const title = dom.append(titleBar, $('.quick-input-title'));\n        const rightActionBar = this._register(new ActionBar(titleBar, { hoverDelegate: this.options.hoverDelegate }));\n        rightActionBar.domNode.classList.add('quick-input-right-action-bar');\n        const headerContainer = dom.append(container, $('.quick-input-header'));\n        const checkAll = dom.append(headerContainer, $('input.quick-input-check-all'));\n        checkAll.type = 'checkbox';\n        checkAll.setAttribute('aria-label', localize('quickInput.checkAll', \"Toggle all checkboxes\"));\n        this._register(dom.addStandardDisposableListener(checkAll, dom.EventType.CHANGE, e => {\n            const checked = checkAll.checked;\n            list.setAllVisibleChecked(checked);\n        }));\n        this._register(dom.addDisposableListener(checkAll, dom.EventType.CLICK, e => {\n            if (e.x || e.y) { // Avoid 'click' triggered by 'space'...\n                inputBox.setFocus();\n            }\n        }));\n        const description2 = dom.append(headerContainer, $('.quick-input-description'));\n        const inputContainer = dom.append(headerContainer, $('.quick-input-and-message'));\n        const filterContainer = dom.append(inputContainer, $('.quick-input-filter'));\n        const inputBox = this._register(new QuickInputBox(filterContainer, this.styles.inputBox, this.styles.toggle));\n        inputBox.setAttribute('aria-describedby', `${this.idPrefix}message`);\n        const visibleCountContainer = dom.append(filterContainer, $('.quick-input-visible-count'));\n        visibleCountContainer.setAttribute('aria-live', 'polite');\n        visibleCountContainer.setAttribute('aria-atomic', 'true');\n        const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, \"{0} Results\") }, this.styles.countBadge);\n        const countContainer = dom.append(filterContainer, $('.quick-input-count'));\n        countContainer.setAttribute('aria-live', 'polite');\n        const count = new CountBadge(countContainer, { countFormat: localize({ key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, \"{0} Selected\") }, this.styles.countBadge);\n        const inlineActionBar = this._register(new ActionBar(headerContainer, { hoverDelegate: this.options.hoverDelegate }));\n        inlineActionBar.domNode.classList.add('quick-input-inline-action-bar');\n        const okContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const ok = this._register(new Button(okContainer, this.styles.button));\n        ok.label = localize('ok', \"OK\");\n        this._register(ok.onDidClick(e => {\n            this.onDidAcceptEmitter.fire();\n        }));\n        const customButtonContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const customButton = this._register(new Button(customButtonContainer, { ...this.styles.button, supportIcons: true }));\n        customButton.label = localize('custom', \"Custom\");\n        this._register(customButton.onDidClick(e => {\n            this.onDidCustomEmitter.fire();\n        }));\n        const message = dom.append(inputContainer, $(`#${this.idPrefix}message.quick-input-message`));\n        const progressBar = this._register(new ProgressBar(container, this.styles.progressBar));\n        progressBar.getContainer().classList.add('quick-input-progress');\n        const widget = dom.append(container, $('.quick-input-html-widget'));\n        widget.tabIndex = -1;\n        const description1 = dom.append(container, $('.quick-input-description'));\n        const listId = this.idPrefix + 'list';\n        const list = this._register(this.instantiationService.createInstance(QuickInputTree, container, this.options.hoverDelegate, this.options.linkOpenerDelegate, listId));\n        inputBox.setAttribute('aria-controls', listId);\n        this._register(list.onDidChangeFocus(() => {\n            inputBox.setAttribute('aria-activedescendant', list.getActiveDescendant() ?? '');\n        }));\n        this._register(list.onChangedAllVisibleChecked(checked => {\n            checkAll.checked = checked;\n        }));\n        this._register(list.onChangedVisibleCount(c => {\n            visibleCount.setCount(c);\n        }));\n        this._register(list.onChangedCheckedCount(c => {\n            count.setCount(c);\n        }));\n        this._register(list.onLeave(() => {\n            // Defer to avoid the input field reacting to the triggering key.\n            // TODO@TylerLeonhardt https://github.com/microsoft/vscode/issues/203675\n            setTimeout(() => {\n                if (!this.controller) {\n                    return;\n                }\n                inputBox.setFocus();\n                if (this.controller instanceof QuickPick && this.controller.canSelectMany) {\n                    list.clearFocus();\n                }\n            }, 0);\n        }));\n        const focusTracker = dom.trackFocus(container);\n        this._register(focusTracker);\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, e => {\n            const ui = this.getUI();\n            if (dom.isAncestor(e.relatedTarget, ui.inputContainer)) {\n                const value = ui.inputBox.isSelectionAtEnd();\n                if (this.endOfQuickInputBoxContext.get() !== value) {\n                    this.endOfQuickInputBoxContext.set(value);\n                }\n            }\n            // Ignore focus events within container\n            if (dom.isAncestor(e.relatedTarget, ui.container)) {\n                return;\n            }\n            this.inQuickInputContext.set(true);\n            this.previousFocusElement = dom.isHTMLElement(e.relatedTarget) ? e.relatedTarget : undefined;\n        }, true));\n        this._register(focusTracker.onDidBlur(() => {\n            if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {\n                this.hide(QuickInputHideReason.Blur);\n            }\n            this.inQuickInputContext.set(false);\n            this.endOfQuickInputBoxContext.set(false);\n            this.previousFocusElement = undefined;\n        }));\n        this._register(inputBox.onKeyDown(_ => {\n            const value = this.getUI().inputBox.isSelectionAtEnd();\n            if (this.endOfQuickInputBoxContext.get() !== value) {\n                this.endOfQuickInputBoxContext.set(value);\n            }\n        }));\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, (e) => {\n            inputBox.setFocus();\n        }));\n        // TODO: Turn into commands instead of handling KEY_DOWN\n        // Keybindings for the quickinput widget as a whole\n        this._register(dom.addStandardDisposableListener(container, dom.EventType.KEY_DOWN, (event) => {\n            if (dom.isAncestor(event.target, widget)) {\n                return; // Ignore event if target is inside widget to allow the widget to handle the event.\n            }\n            switch (event.keyCode) {\n                case 3 /* KeyCode.Enter */:\n                    dom.EventHelper.stop(event, true);\n                    if (this.enabled) {\n                        this.onDidAcceptEmitter.fire();\n                    }\n                    break;\n                case 9 /* KeyCode.Escape */:\n                    dom.EventHelper.stop(event, true);\n                    this.hide(QuickInputHideReason.Gesture);\n                    break;\n                case 2 /* KeyCode.Tab */:\n                    if (!event.altKey && !event.ctrlKey && !event.metaKey) {\n                        // detect only visible actions\n                        const selectors = [\n                            '.quick-input-list .monaco-action-bar .always-visible',\n                            '.quick-input-list-entry:hover .monaco-action-bar',\n                            '.monaco-list-row.focused .monaco-action-bar'\n                        ];\n                        if (container.classList.contains('show-checkboxes')) {\n                            selectors.push('input');\n                        }\n                        else {\n                            selectors.push('input[type=text]');\n                        }\n                        if (this.getUI().list.displayed) {\n                            selectors.push('.monaco-list');\n                        }\n                        // focus links if there are any\n                        if (this.getUI().message) {\n                            selectors.push('.quick-input-message a');\n                        }\n                        if (this.getUI().widget) {\n                            if (dom.isAncestor(event.target, this.getUI().widget)) {\n                                // let the widget control tab\n                                break;\n                            }\n                            selectors.push('.quick-input-html-widget');\n                        }\n                        const stops = container.querySelectorAll(selectors.join(', '));\n                        if (event.shiftKey && event.target === stops[0]) {\n                            // Clear the focus from the list in order to allow\n                            // screen readers to read operations in the input box.\n                            dom.EventHelper.stop(event, true);\n                            list.clearFocus();\n                        }\n                        else if (!event.shiftKey && dom.isAncestor(event.target, stops[stops.length - 1])) {\n                            dom.EventHelper.stop(event, true);\n                            stops[0].focus();\n                        }\n                    }\n                    break;\n                case 10 /* KeyCode.Space */:\n                    if (event.ctrlKey) {\n                        dom.EventHelper.stop(event, true);\n                        this.getUI().list.toggleHover();\n                    }\n                    break;\n            }\n        }));\n        this.ui = {\n            container,\n            styleSheet,\n            leftActionBar,\n            titleBar,\n            title,\n            description1,\n            description2,\n            widget,\n            rightActionBar,\n            inlineActionBar,\n            checkAll,\n            inputContainer,\n            filterContainer,\n            inputBox,\n            visibleCountContainer,\n            visibleCount,\n            countContainer,\n            count,\n            okContainer,\n            ok,\n            message,\n            customButtonContainer,\n            customButton,\n            list,\n            progressBar,\n            onDidAccept: this.onDidAcceptEmitter.event,\n            onDidCustom: this.onDidCustomEmitter.event,\n            onDidTriggerButton: this.onDidTriggerButtonEmitter.event,\n            ignoreFocusOut: false,\n            keyMods: this.keyMods,\n            show: controller => this.show(controller),\n            hide: () => this.hide(),\n            setVisibilities: visibilities => this.setVisibilities(visibilities),\n            setEnabled: enabled => this.setEnabled(enabled),\n            setContextKey: contextKey => this.options.setContextKey(contextKey),\n            linkOpenerDelegate: content => this.options.linkOpenerDelegate(content)\n        };\n        this.updateStyles();\n        return this.ui;\n    }\n    reparentUI(container) {\n        if (this.ui) {\n            this._container = container;\n            dom.append(this._container, this.ui.container);\n        }\n    }\n    pick(picks, options = {}, token = CancellationToken.None) {\n        return new Promise((doResolve, reject) => {\n            let resolve = (result) => {\n                resolve = doResolve;\n                options.onKeyMods?.(input.keyMods);\n                doResolve(result);\n            };\n            if (token.isCancellationRequested) {\n                resolve(undefined);\n                return;\n            }\n            const input = this.createQuickPick({ useSeparators: true });\n            let activeItem;\n            const disposables = [\n                input,\n                input.onDidAccept(() => {\n                    if (input.canSelectMany) {\n                        resolve(input.selectedItems.slice());\n                        input.hide();\n                    }\n                    else {\n                        const result = input.activeItems[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidChangeActive(items => {\n                    const focused = items[0];\n                    if (focused && options.onDidFocus) {\n                        options.onDidFocus(focused);\n                    }\n                }),\n                input.onDidChangeSelection(items => {\n                    if (!input.canSelectMany) {\n                        const result = items[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidTriggerItemButton(event => options.onDidTriggerItemButton && options.onDidTriggerItemButton({\n                    ...event,\n                    removeItem: () => {\n                        const index = input.items.indexOf(event.item);\n                        if (index !== -1) {\n                            const items = input.items.slice();\n                            const removed = items.splice(index, 1);\n                            const activeItems = input.activeItems.filter(activeItem => activeItem !== removed[0]);\n                            const keepScrollPositionBefore = input.keepScrollPosition;\n                            input.keepScrollPosition = true;\n                            input.items = items;\n                            if (activeItems) {\n                                input.activeItems = activeItems;\n                            }\n                            input.keepScrollPosition = keepScrollPositionBefore;\n                        }\n                    }\n                })),\n                input.onDidTriggerSeparatorButton(event => options.onDidTriggerSeparatorButton?.(event)),\n                input.onDidChangeValue(value => {\n                    if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {\n                        input.activeItems = [activeItem];\n                    }\n                }),\n                token.onCancellationRequested(() => {\n                    input.hide();\n                }),\n                input.onDidHide(() => {\n                    dispose(disposables);\n                    resolve(undefined);\n                }),\n            ];\n            input.title = options.title;\n            if (options.value) {\n                input.value = options.value;\n            }\n            input.canSelectMany = !!options.canPickMany;\n            input.placeholder = options.placeHolder;\n            input.ignoreFocusOut = !!options.ignoreFocusLost;\n            input.matchOnDescription = !!options.matchOnDescription;\n            input.matchOnDetail = !!options.matchOnDetail;\n            input.matchOnLabel = (options.matchOnLabel === undefined) || options.matchOnLabel; // default to true\n            input.quickNavigate = options.quickNavigate;\n            input.hideInput = !!options.hideInput;\n            input.contextKey = options.contextKey;\n            input.busy = true;\n            Promise.all([picks, options.activeItem])\n                .then(([items, _activeItem]) => {\n                activeItem = _activeItem;\n                input.busy = false;\n                input.items = items;\n                if (input.canSelectMany) {\n                    input.selectedItems = items.filter(item => item.type !== 'separator' && item.picked);\n                }\n                if (activeItem) {\n                    input.activeItems = [activeItem];\n                }\n            });\n            input.show();\n            Promise.resolve(picks).then(undefined, err => {\n                reject(err);\n                input.hide();\n            });\n        });\n    }\n    createQuickPick(options = { useSeparators: false }) {\n        const ui = this.getUI(true);\n        return new QuickPick(ui);\n    }\n    createInputBox() {\n        const ui = this.getUI(true);\n        return new InputBox(ui);\n    }\n    show(controller) {\n        const ui = this.getUI(true);\n        this.onShowEmitter.fire();\n        const oldController = this.controller;\n        this.controller = controller;\n        oldController?.didHide();\n        this.setEnabled(true);\n        ui.leftActionBar.clear();\n        ui.title.textContent = '';\n        ui.description1.textContent = '';\n        ui.description2.textContent = '';\n        dom.reset(ui.widget);\n        ui.rightActionBar.clear();\n        ui.inlineActionBar.clear();\n        ui.checkAll.checked = false;\n        // ui.inputBox.value = ''; Avoid triggering an event.\n        ui.inputBox.placeholder = '';\n        ui.inputBox.password = false;\n        ui.inputBox.showDecoration(Severity.Ignore);\n        ui.visibleCount.setCount(0);\n        ui.count.setCount(0);\n        dom.reset(ui.message);\n        ui.progressBar.stop();\n        ui.list.setElements([]);\n        ui.list.matchOnDescription = false;\n        ui.list.matchOnDetail = false;\n        ui.list.matchOnLabel = true;\n        ui.list.sortByLabel = true;\n        ui.ignoreFocusOut = false;\n        ui.inputBox.toggles = undefined;\n        const backKeybindingLabel = this.options.backKeybindingLabel();\n        backButton.tooltip = backKeybindingLabel ? localize('quickInput.backWithKeybinding', \"Back ({0})\", backKeybindingLabel) : localize('quickInput.back', \"Back\");\n        ui.container.style.display = '';\n        this.updateLayout();\n        ui.inputBox.setFocus();\n        this.quickInputTypeContext.set(controller.type);\n    }\n    isVisible() {\n        return !!this.ui && this.ui.container.style.display !== 'none';\n    }\n    setVisibilities(visibilities) {\n        const ui = this.getUI();\n        ui.title.style.display = visibilities.title ? '' : 'none';\n        ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.checkAll.style.display = visibilities.checkAll ? '' : 'none';\n        ui.inputContainer.style.display = visibilities.inputBox ? '' : 'none';\n        ui.filterContainer.style.display = visibilities.inputBox ? '' : 'none';\n        ui.visibleCountContainer.style.display = visibilities.visibleCount ? '' : 'none';\n        ui.countContainer.style.display = visibilities.count ? '' : 'none';\n        ui.okContainer.style.display = visibilities.ok ? '' : 'none';\n        ui.customButtonContainer.style.display = visibilities.customButton ? '' : 'none';\n        ui.message.style.display = visibilities.message ? '' : 'none';\n        ui.progressBar.getContainer().style.display = visibilities.progressBar ? '' : 'none';\n        ui.list.displayed = !!visibilities.list;\n        ui.container.classList.toggle('show-checkboxes', !!visibilities.checkBox);\n        ui.container.classList.toggle('hidden-input', !visibilities.inputBox && !visibilities.description);\n        this.updateLayout(); // TODO\n    }\n    setEnabled(enabled) {\n        if (enabled !== this.enabled) {\n            this.enabled = enabled;\n            for (const item of this.getUI().leftActionBar.viewItems) {\n                item.action.enabled = enabled;\n            }\n            for (const item of this.getUI().rightActionBar.viewItems) {\n                item.action.enabled = enabled;\n            }\n            this.getUI().checkAll.disabled = !enabled;\n            this.getUI().inputBox.enabled = enabled;\n            this.getUI().ok.enabled = enabled;\n            this.getUI().list.enabled = enabled;\n        }\n    }\n    hide(reason) {\n        const controller = this.controller;\n        if (!controller) {\n            return;\n        }\n        controller.willHide(reason);\n        const container = this.ui?.container;\n        const focusChanged = container && !dom.isAncestorOfActiveElement(container);\n        this.controller = null;\n        this.onHideEmitter.fire();\n        if (container) {\n            container.style.display = 'none';\n        }\n        if (!focusChanged) {\n            let currentElement = this.previousFocusElement;\n            while (currentElement && !currentElement.offsetParent) {\n                currentElement = currentElement.parentElement ?? undefined;\n            }\n            if (currentElement?.offsetParent) {\n                currentElement.focus();\n                this.previousFocusElement = undefined;\n            }\n            else {\n                this.options.returnFocus();\n            }\n        }\n        controller.didHide(reason);\n    }\n    layout(dimension, titleBarOffset) {\n        this.dimension = dimension;\n        this.titleBarOffset = titleBarOffset;\n        this.updateLayout();\n    }\n    updateLayout() {\n        if (this.ui && this.isVisible()) {\n            this.ui.container.style.top = `${this.titleBarOffset}px`;\n            const style = this.ui.container.style;\n            const width = Math.min(this.dimension.width * 0.62 /* golden cut */, QuickInputController_1.MAX_WIDTH);\n            style.width = width + 'px';\n            style.marginLeft = '-' + (width / 2) + 'px';\n            this.ui.inputBox.layout();\n            this.ui.list.layout(this.dimension && this.dimension.height * 0.4);\n        }\n    }\n    applyStyles(styles) {\n        this.styles = styles;\n        this.updateStyles();\n    }\n    updateStyles() {\n        if (this.ui) {\n            const { quickInputTitleBackground, quickInputBackground, quickInputForeground, widgetBorder, widgetShadow, } = this.styles.widget;\n            this.ui.titleBar.style.backgroundColor = quickInputTitleBackground ?? '';\n            this.ui.container.style.backgroundColor = quickInputBackground ?? '';\n            this.ui.container.style.color = quickInputForeground ?? '';\n            this.ui.container.style.border = widgetBorder ? `1px solid ${widgetBorder}` : '';\n            this.ui.container.style.boxShadow = widgetShadow ? `0 0 8px 2px ${widgetShadow}` : '';\n            this.ui.list.style(this.styles.list);\n            const content = [];\n            if (this.styles.pickerGroup.pickerGroupBorder) {\n                content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`);\n            }\n            if (this.styles.pickerGroup.pickerGroupForeground) {\n                content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`);\n            }\n            if (this.styles.pickerGroup.pickerGroupForeground) {\n                content.push(`.quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }`);\n            }\n            if (this.styles.keybindingLabel.keybindingLabelBackground ||\n                this.styles.keybindingLabel.keybindingLabelBorder ||\n                this.styles.keybindingLabel.keybindingLabelBottomBorder ||\n                this.styles.keybindingLabel.keybindingLabelShadow ||\n                this.styles.keybindingLabel.keybindingLabelForeground) {\n                content.push('.quick-input-list .monaco-keybinding > .monaco-keybinding-key {');\n                if (this.styles.keybindingLabel.keybindingLabelBackground) {\n                    content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBorder) {\n                    // Order matters here. `border-color` must come before `border-bottom-color`.\n                    content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {\n                    content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelShadow) {\n                    content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelForeground) {\n                    content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);\n                }\n                content.push('}');\n            }\n            const newStyles = content.join('\\n');\n            if (newStyles !== this.ui.styleSheet.textContent) {\n                this.ui.styleSheet.textContent = newStyles;\n            }\n        }\n    }\n};\nQuickInputController = QuickInputController_1 = __decorate([\n    __param(1, ILayoutService),\n    __param(2, IInstantiationService),\n    __param(3, IContextKeyService)\n], QuickInputController);\nexport { QuickInputController };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { editorActiveIndentGuide1, editorIndentGuide1 } from '../../common/core/editorColorRegistry.js';\nimport { editorBackground, editorForeground, editorInactiveSelection, editorSelectionHighlight } from '../../../platform/theme/common/colorRegistry.js';\n/* -------------------------------- Begin vs theme -------------------------------- */\nexport const vs = {\n    base: 'vs',\n    inherit: false,\n    rules: [\n        { token: '', foreground: '000000', background: 'fffffe' },\n        { token: 'invalid', foreground: 'cd3131' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '001188' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'constant', foreground: 'dd0000' },\n        { token: 'comment', foreground: '008000' },\n        { token: 'number', foreground: '098658' },\n        { token: 'number.hex', foreground: '3030c0' },\n        { token: 'regexp', foreground: '800000' },\n        { token: 'annotation', foreground: '808080' },\n        { token: 'type', foreground: '008080' },\n        { token: 'delimiter', foreground: '000000' },\n        { token: 'delimiter.html', foreground: '383838' },\n        { token: 'delimiter.xml', foreground: '0000FF' },\n        { token: 'tag', foreground: '800000' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: '800000' },\n        { token: 'metatag', foreground: 'e00000' },\n        { token: 'metatag.content.html', foreground: 'FF0000' },\n        { token: 'metatag.html', foreground: '808080' },\n        { token: 'metatag.xml', foreground: '808080' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '863B00' },\n        { token: 'string.key.json', foreground: 'A31515' },\n        { token: 'string.value.json', foreground: '0451A5' },\n        { token: 'attribute.name', foreground: 'FF0000' },\n        { token: 'attribute.value', foreground: '0451A5' },\n        { token: 'attribute.value.number', foreground: '098658' },\n        { token: 'attribute.value.unit', foreground: '098658' },\n        { token: 'attribute.value.html', foreground: '0000FF' },\n        { token: 'attribute.value.xml', foreground: '0000FF' },\n        { token: 'string', foreground: 'A31515' },\n        { token: 'string.html', foreground: '0000FF' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'string.yaml', foreground: '0451A5' },\n        { token: 'keyword', foreground: '0000FF' },\n        { token: 'keyword.json', foreground: '0451A5' },\n        { token: 'keyword.flow', foreground: 'AF00DB' },\n        { token: 'keyword.flow.scss', foreground: '0000FF' },\n        { token: 'operator.scss', foreground: '666666' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '666666' },\n        { token: 'predefined.sql', foreground: 'C700C7' },\n    ],\n    colors: {\n        [editorBackground]: '#FFFFFE',\n        [editorForeground]: '#000000',\n        [editorInactiveSelection]: '#E5EBF1',\n        [editorIndentGuide1]: '#D3D3D3',\n        [editorActiveIndentGuide1]: '#939393',\n        [editorSelectionHighlight]: '#ADD6FF4D'\n    }\n};\n/* -------------------------------- End vs theme -------------------------------- */\n/* -------------------------------- Begin vs-dark theme -------------------------------- */\nexport const vs_dark = {\n    base: 'vs-dark',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'D4D4D4', background: '1E1E1E' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '74B0DF' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'B5CEA8' },\n        { token: 'number.hex', foreground: '5BB498' },\n        { token: 'regexp', foreground: 'B46695' },\n        { token: 'annotation', foreground: 'cc6666' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'DCDCDC' },\n        { token: 'delimiter.html', foreground: '808080' },\n        { token: 'delimiter.xml', foreground: '808080' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: 'A79873' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: 'DD6A6F' },\n        { token: 'metatag.content.html', foreground: '9CDCFE' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key.json', foreground: '9CDCFE' },\n        { token: 'string.value.json', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '9CDCFE' },\n        { token: 'attribute.value', foreground: 'CE9178' },\n        { token: 'attribute.value.number.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.unit.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.hex.css', foreground: 'D4D4D4' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'keyword.json', foreground: 'CE9178' },\n        { token: 'keyword.flow.scss', foreground: '569CD6' },\n        { token: 'operator.scss', foreground: '909090' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#1E1E1E',\n        [editorForeground]: '#D4D4D4',\n        [editorInactiveSelection]: '#3A3D41',\n        [editorIndentGuide1]: '#404040',\n        [editorActiveIndentGuide1]: '#707070',\n        [editorSelectionHighlight]: '#ADD6FF26'\n    }\n};\n/* -------------------------------- End vs-dark theme -------------------------------- */\n/* -------------------------------- Begin hc-black theme -------------------------------- */\nexport const hc_black = {\n    base: 'hc-black',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'FFFFFF', background: '000000' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '1AEBFF' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'FFFFFF' },\n        { token: 'regexp', foreground: 'C0C0C0' },\n        { token: 'annotation', foreground: '569CD6' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'FFFF00' },\n        { token: 'delimiter.html', foreground: 'FFFF00' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta', foreground: 'D4D4D4' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: '569CD6' },\n        { token: 'metatag.content.html', foreground: '1AEBFF' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key', foreground: '9CDCFE' },\n        { token: 'string.value', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '569CD6' },\n        { token: 'attribute.value', foreground: '3FF23F' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#000000',\n        [editorForeground]: '#FFFFFF',\n        [editorIndentGuide1]: '#FFFFFF',\n        [editorActiveIndentGuide1]: '#FFFFFF',\n    }\n};\n/* -------------------------------- End hc-black theme -------------------------------- */\n/* -------------------------------- Begin hc-light theme -------------------------------- */\nexport const hc_light = {\n    base: 'hc-light',\n    inherit: false,\n    rules: [\n        { token: '', foreground: '292929', background: 'FFFFFF' },\n        { token: 'invalid', foreground: 'B5200D' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '264F70' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'constant', foreground: 'dd0000' },\n        { token: 'comment', foreground: '008000' },\n        { token: 'number', foreground: '098658' },\n        { token: 'number.hex', foreground: '3030c0' },\n        { token: 'regexp', foreground: '800000' },\n        { token: 'annotation', foreground: '808080' },\n        { token: 'type', foreground: '008080' },\n        { token: 'delimiter', foreground: '000000' },\n        { token: 'delimiter.html', foreground: '383838' },\n        { token: 'tag', foreground: '800000' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: '800000' },\n        { token: 'metatag', foreground: 'e00000' },\n        { token: 'metatag.content.html', foreground: 'B5200D' },\n        { token: 'metatag.html', foreground: '808080' },\n        { token: 'metatag.xml', foreground: '808080' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '863B00' },\n        { token: 'string.key.json', foreground: 'A31515' },\n        { token: 'string.value.json', foreground: '0451A5' },\n        { token: 'attribute.name', foreground: '264F78' },\n        { token: 'attribute.value', foreground: '0451A5' },\n        { token: 'string', foreground: 'A31515' },\n        { token: 'string.sql', foreground: 'B5200D' },\n        { token: 'keyword', foreground: '0000FF' },\n        { token: 'keyword.flow', foreground: 'AF00DB' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '666666' },\n        { token: 'predefined.sql', foreground: 'C700C7' },\n    ],\n    colors: {\n        [editorBackground]: '#FFFFFF',\n        [editorForeground]: '#292929',\n        [editorIndentGuide1]: '#292929',\n        [editorActiveIndentGuide1]: '#292929',\n    }\n};\n/* -------------------------------- End hc-light theme -------------------------------- */\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { getCodiconFontCharacters } from '../../../base/common/codiconsUtil.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\n//  ------ API types\n// icon registry\nexport const Extensions = {\n    IconContribution: 'base.contributions.icons'\n};\nexport var IconContribution;\n(function (IconContribution) {\n    function getDefinition(contribution, registry) {\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n    IconContribution.getDefinition = getDefinition;\n})(IconContribution || (IconContribution = {}));\nexport var IconFontDefinition;\n(function (IconFontDefinition) {\n    function toJSONObject(iconFont) {\n        return {\n            weight: iconFont.weight,\n            style: iconFont.style,\n            src: iconFont.src.map(s => ({ format: s.format, location: s.location.toString() }))\n        };\n    }\n    IconFontDefinition.toJSONObject = toJSONObject;\n    function fromJSONObject(json) {\n        const stringOrUndef = (s) => isString(s) ? s : undefined;\n        if (json && Array.isArray(json.src) && json.src.every((s) => isString(s.format) && isString(s.location))) {\n            return {\n                weight: stringOrUndef(json.weight),\n                style: stringOrUndef(json.style),\n                src: json.src.map((s) => ({ format: s.format, location: URI.parse(s.location) }))\n            };\n        }\n        return undefined;\n    }\n    IconFontDefinition.fromJSONObject = fromJSONObject;\n})(IconFontDefinition || (IconFontDefinition = {}));\nclass IconRegistry {\n    constructor() {\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this.iconSchema = {\n            definitions: {\n                icons: {\n                    type: 'object',\n                    properties: {\n                        fontId: { type: 'string', description: localize('iconDefinition.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },\n                        fontCharacter: { type: 'string', description: localize('iconDefinition.fontCharacter', 'The font character associated with the icon definition.') }\n                    },\n                    additionalProperties: false,\n                    defaultSnippets: [{ body: { fontCharacter: '\\\\\\\\e030' } }]\n                }\n            },\n            type: 'object',\n            properties: {}\n        };\n        this.iconReferenceSchema = { type: 'string', pattern: `^${ThemeIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };\n        this.iconsById = {};\n        this.iconFontsById = {};\n    }\n    registerIcon(id, defaults, description, deprecationMessage) {\n        const existing = this.iconsById[id];\n        if (existing) {\n            if (description && !existing.description) {\n                existing.description = description;\n                this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;\n                const enumIndex = this.iconReferenceSchema.enum.indexOf(id);\n                if (enumIndex !== -1) {\n                    this.iconReferenceSchema.enumDescriptions[enumIndex] = description;\n                }\n                this._onDidChange.fire();\n            }\n            return existing;\n        }\n        const iconContribution = { id, description, defaults, deprecationMessage };\n        this.iconsById[id] = iconContribution;\n        const propertySchema = { $ref: '#/definitions/icons' };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (description) {\n            propertySchema.markdownDescription = `${description}: $(${id})`;\n        }\n        this.iconSchema.properties[id] = propertySchema;\n        this.iconReferenceSchema.enum.push(id);\n        this.iconReferenceSchema.enumDescriptions.push(description || '');\n        this._onDidChange.fire();\n        return { id };\n    }\n    getIcons() {\n        return Object.keys(this.iconsById).map(id => this.iconsById[id]);\n    }\n    getIcon(id) {\n        return this.iconsById[id];\n    }\n    getIconSchema() {\n        return this.iconSchema;\n    }\n    toString() {\n        const sorter = (i1, i2) => {\n            return i1.id.localeCompare(i2.id);\n        };\n        const classNames = (i) => {\n            while (ThemeIcon.isThemeIcon(i.defaults)) {\n                i = this.iconsById[i.defaults.id];\n            }\n            return `codicon codicon-${i ? i.id : ''}`;\n        };\n        const reference = [];\n        reference.push(`| preview     | identifier                        | default codicon ID                | description`);\n        reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);\n        const contributions = Object.keys(this.iconsById).map(key => this.iconsById[key]);\n        for (const i of contributions.filter(i => !!i.description).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);\n        }\n        reference.push(`| preview     | identifier                        `);\n        reference.push(`| ----------- | --------------------------------- |`);\n        for (const i of contributions.filter(i => !ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|`);\n        }\n        return reference.join('\\n');\n    }\n}\nconst iconRegistry = new IconRegistry();\nplatform.Registry.add(Extensions.IconContribution, iconRegistry);\nexport function registerIcon(id, defaults, description, deprecationMessage) {\n    return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);\n}\nexport function getIconRegistry() {\n    return iconRegistry;\n}\nfunction initialize() {\n    const codiconFontCharacters = getCodiconFontCharacters();\n    for (const icon in codiconFontCharacters) {\n        const fontCharacter = '\\\\' + codiconFontCharacters[icon].toString(16);\n        iconRegistry.registerIcon(icon, { fontCharacter });\n    }\n}\ninitialize();\nexport const iconsSchemaId = 'vscode://schemas/icons';\nconst schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(iconsSchemaId), 200);\niconRegistry.onDidChange(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n//setTimeout(_ => console.log(iconRegistry.toString()), 5000);\n// common icons\nexport const widgetClose = registerIcon('widget-close', Codicon.close, localize('widgetClose', 'Icon for the close action in widgets.'));\nexport const gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, localize('previousChangeIcon', 'Icon for goto previous editor location.'));\nexport const gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, localize('nextChangeIcon', 'Icon for goto next editor location.'));\nexport const syncing = ThemeIcon.modify(Codicon.sync, 'spin');\nexport const spinningLoading = ThemeIcon.modify(Codicon.loading, 'spin');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asCSSPropertyValue, asCSSUrl } from '../../../base/browser/dom.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { getIconRegistry } from '../common/iconRegistry.js';\nexport function getIconsStyleSheet(themeService) {\n    const disposable = new DisposableStore();\n    const onDidChangeEmmiter = disposable.add(new Emitter());\n    const iconRegistry = getIconRegistry();\n    disposable.add(iconRegistry.onDidChange(() => onDidChangeEmmiter.fire()));\n    if (themeService) {\n        disposable.add(themeService.onDidProductIconThemeChange(() => onDidChangeEmmiter.fire()));\n    }\n    return {\n        dispose: () => disposable.dispose(),\n        onDidChange: onDidChangeEmmiter.event,\n        getCSS() {\n            const productIconTheme = themeService ? themeService.getProductIconTheme() : new UnthemedProductIconTheme();\n            const usedFontIds = {};\n            const rules = [];\n            const rootAttribs = [];\n            for (const contribution of iconRegistry.getIcons()) {\n                const definition = productIconTheme.getIcon(contribution);\n                if (!definition) {\n                    continue;\n                }\n                const fontContribution = definition.font;\n                const fontFamilyVar = `--vscode-icon-${contribution.id}-font-family`;\n                const contentVar = `--vscode-icon-${contribution.id}-content`;\n                if (fontContribution) {\n                    usedFontIds[fontContribution.id] = fontContribution.definition;\n                    rootAttribs.push(`${fontFamilyVar}: ${asCSSPropertyValue(fontContribution.id)};`, `${contentVar}: '${definition.fontCharacter}';`);\n                    rules.push(`.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontContribution.id)}; }`);\n                }\n                else {\n                    rootAttribs.push(`${contentVar}: '${definition.fontCharacter}'; ${fontFamilyVar}: 'codicon';`);\n                    rules.push(`.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`);\n                }\n            }\n            for (const id in usedFontIds) {\n                const definition = usedFontIds[id];\n                const fontWeight = definition.weight ? `font-weight: ${definition.weight};` : '';\n                const fontStyle = definition.style ? `font-style: ${definition.style};` : '';\n                const src = definition.src.map(l => `${asCSSUrl(l.location)} format('${l.format}')`).join(', ');\n                rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)};${fontWeight}${fontStyle} font-display: block; }`);\n            }\n            rules.push(`:root { ${rootAttribs.join(' ')} }`);\n            return rules.join('\\n');\n        }\n    };\n}\nexport class UnthemedProductIconTheme {\n    getIcon(contribution) {\n        const iconRegistry = getIconRegistry();\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport { addMatchMediaChangeListener } from '../../../base/browser/browser.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { TokenMetadata } from '../../common/encodedTokenAttributes.js';\nimport { TokenTheme, generateTokensCSSForColorMap } from '../../common/languages/supports/tokenization.js';\nimport { hc_black, hc_light, vs, vs_dark } from '../common/themes.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { asCssVariableName, Extensions } from '../../../platform/theme/common/colorRegistry.js';\nimport { Extensions as ThemingExtensions } from '../../../platform/theme/common/themeService.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ColorScheme, isDark, isHighContrast } from '../../../platform/theme/common/theme.js';\nimport { getIconsStyleSheet, UnthemedProductIconTheme } from '../../../platform/theme/browser/iconsStyleSheet.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nexport const VS_LIGHT_THEME_NAME = 'vs';\nexport const VS_DARK_THEME_NAME = 'vs-dark';\nexport const HC_BLACK_THEME_NAME = 'hc-black';\nexport const HC_LIGHT_THEME_NAME = 'hc-light';\nconst colorRegistry = Registry.as(Extensions.ColorContribution);\nconst themingRegistry = Registry.as(ThemingExtensions.ThemingContribution);\nclass StandaloneTheme {\n    constructor(name, standaloneThemeData) {\n        this.semanticHighlighting = false;\n        this.themeData = standaloneThemeData;\n        const base = standaloneThemeData.base;\n        if (name.length > 0) {\n            if (isBuiltinTheme(name)) {\n                this.id = name;\n            }\n            else {\n                this.id = base + ' ' + name;\n            }\n            this.themeName = name;\n        }\n        else {\n            this.id = base;\n            this.themeName = base;\n        }\n        this.colors = null;\n        this.defaultColors = Object.create(null);\n        this._tokenTheme = null;\n    }\n    get base() {\n        return this.themeData.base;\n    }\n    notifyBaseUpdated() {\n        if (this.themeData.inherit) {\n            this.colors = null;\n            this._tokenTheme = null;\n        }\n    }\n    getColors() {\n        if (!this.colors) {\n            const colors = new Map();\n            for (const id in this.themeData.colors) {\n                colors.set(id, Color.fromHex(this.themeData.colors[id]));\n            }\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                for (const id in baseData.colors) {\n                    if (!colors.has(id)) {\n                        colors.set(id, Color.fromHex(baseData.colors[id]));\n                    }\n                }\n            }\n            this.colors = colors;\n        }\n        return this.colors;\n    }\n    getColor(colorId, useDefault) {\n        const color = this.getColors().get(colorId);\n        if (color) {\n            return color;\n        }\n        if (useDefault !== false) {\n            return this.getDefault(colorId);\n        }\n        return undefined;\n    }\n    getDefault(colorId) {\n        let color = this.defaultColors[colorId];\n        if (color) {\n            return color;\n        }\n        color = colorRegistry.resolveDefaultColor(colorId, this);\n        this.defaultColors[colorId] = color;\n        return color;\n    }\n    defines(colorId) {\n        return this.getColors().has(colorId);\n    }\n    get type() {\n        switch (this.base) {\n            case VS_LIGHT_THEME_NAME: return ColorScheme.LIGHT;\n            case HC_BLACK_THEME_NAME: return ColorScheme.HIGH_CONTRAST_DARK;\n            case HC_LIGHT_THEME_NAME: return ColorScheme.HIGH_CONTRAST_LIGHT;\n            default: return ColorScheme.DARK;\n        }\n    }\n    get tokenTheme() {\n        if (!this._tokenTheme) {\n            let rules = [];\n            let encodedTokensColors = [];\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                rules = baseData.rules;\n                if (baseData.encodedTokensColors) {\n                    encodedTokensColors = baseData.encodedTokensColors;\n                }\n            }\n            // Pick up default colors from `editor.foreground` and `editor.background` if available\n            const editorForeground = this.themeData.colors['editor.foreground'];\n            const editorBackground = this.themeData.colors['editor.background'];\n            if (editorForeground || editorBackground) {\n                const rule = { token: '' };\n                if (editorForeground) {\n                    rule.foreground = editorForeground;\n                }\n                if (editorBackground) {\n                    rule.background = editorBackground;\n                }\n                rules.push(rule);\n            }\n            rules = rules.concat(this.themeData.rules);\n            if (this.themeData.encodedTokensColors) {\n                encodedTokensColors = this.themeData.encodedTokensColors;\n            }\n            this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);\n        }\n        return this._tokenTheme;\n    }\n    getTokenStyleMetadata(type, modifiers, modelLanguage) {\n        // use theme rules match\n        const style = this.tokenTheme._match([type].concat(modifiers).join('.'));\n        const metadata = style.metadata;\n        const foreground = TokenMetadata.getForeground(metadata);\n        const fontStyle = TokenMetadata.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */)\n        };\n    }\n}\nfunction isBuiltinTheme(themeName) {\n    return (themeName === VS_LIGHT_THEME_NAME\n        || themeName === VS_DARK_THEME_NAME\n        || themeName === HC_BLACK_THEME_NAME\n        || themeName === HC_LIGHT_THEME_NAME);\n}\nfunction getBuiltinRules(builtinTheme) {\n    switch (builtinTheme) {\n        case VS_LIGHT_THEME_NAME:\n            return vs;\n        case VS_DARK_THEME_NAME:\n            return vs_dark;\n        case HC_BLACK_THEME_NAME:\n            return hc_black;\n        case HC_LIGHT_THEME_NAME:\n            return hc_light;\n    }\n}\nfunction newBuiltInTheme(builtinTheme) {\n    const themeData = getBuiltinRules(builtinTheme);\n    return new StandaloneTheme(builtinTheme, themeData);\n}\nexport class StandaloneThemeService extends Disposable {\n    constructor() {\n        super();\n        this._onColorThemeChange = this._register(new Emitter());\n        this.onDidColorThemeChange = this._onColorThemeChange.event;\n        this._onProductIconThemeChange = this._register(new Emitter());\n        this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;\n        this._environment = Object.create(null);\n        this._builtInProductIconTheme = new UnthemedProductIconTheme();\n        this._autoDetectHighContrast = true;\n        this._knownThemes = new Map();\n        this._knownThemes.set(VS_LIGHT_THEME_NAME, newBuiltInTheme(VS_LIGHT_THEME_NAME));\n        this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));\n        this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));\n        this._knownThemes.set(HC_LIGHT_THEME_NAME, newBuiltInTheme(HC_LIGHT_THEME_NAME));\n        const iconsStyleSheet = this._register(getIconsStyleSheet(this));\n        this._codiconCSS = iconsStyleSheet.getCSS();\n        this._themeCSS = '';\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._globalStyleElement = null;\n        this._styleElements = [];\n        this._colorMapOverride = null;\n        this.setTheme(VS_LIGHT_THEME_NAME);\n        this._onOSSchemeChanged();\n        this._register(iconsStyleSheet.onDidChange(() => {\n            this._codiconCSS = iconsStyleSheet.getCSS();\n            this._updateCSS();\n        }));\n        addMatchMediaChangeListener(mainWindow, '(forced-colors: active)', () => {\n            this._onOSSchemeChanged();\n        });\n    }\n    registerEditorContainer(domNode) {\n        if (dom.isInShadowDOM(domNode)) {\n            return this._registerShadowDomContainer(domNode);\n        }\n        return this._registerRegularEditorContainer();\n    }\n    _registerRegularEditorContainer() {\n        if (!this._globalStyleElement) {\n            this._globalStyleElement = dom.createStyleSheet(undefined, style => {\n                style.className = 'monaco-colors';\n                style.textContent = this._allCSS;\n            });\n            this._styleElements.push(this._globalStyleElement);\n        }\n        return Disposable.None;\n    }\n    _registerShadowDomContainer(domNode) {\n        const styleElement = dom.createStyleSheet(domNode, style => {\n            style.className = 'monaco-colors';\n            style.textContent = this._allCSS;\n        });\n        this._styleElements.push(styleElement);\n        return {\n            dispose: () => {\n                for (let i = 0; i < this._styleElements.length; i++) {\n                    if (this._styleElements[i] === styleElement) {\n                        this._styleElements.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    defineTheme(themeName, themeData) {\n        if (!/^[a-z0-9\\-]+$/i.test(themeName)) {\n            throw new Error('Illegal theme name!');\n        }\n        if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {\n            throw new Error('Illegal theme base!');\n        }\n        // set or replace theme\n        this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));\n        if (isBuiltinTheme(themeName)) {\n            this._knownThemes.forEach(theme => {\n                if (theme.base === themeName) {\n                    theme.notifyBaseUpdated();\n                }\n            });\n        }\n        if (this._theme.themeName === themeName) {\n            this.setTheme(themeName); // refresh theme\n        }\n    }\n    getColorTheme() {\n        return this._theme;\n    }\n    setColorMapOverride(colorMapOverride) {\n        this._colorMapOverride = colorMapOverride;\n        this._updateThemeOrColorMap();\n    }\n    setTheme(themeName) {\n        let theme;\n        if (this._knownThemes.has(themeName)) {\n            theme = this._knownThemes.get(themeName);\n        }\n        else {\n            theme = this._knownThemes.get(VS_LIGHT_THEME_NAME);\n        }\n        this._updateActualTheme(theme);\n    }\n    _updateActualTheme(desiredTheme) {\n        if (!desiredTheme || this._theme === desiredTheme) {\n            // Nothing to do\n            return;\n        }\n        this._theme = desiredTheme;\n        this._updateThemeOrColorMap();\n    }\n    _onOSSchemeChanged() {\n        if (this._autoDetectHighContrast) {\n            const wantsHighContrast = mainWindow.matchMedia(`(forced-colors: active)`).matches;\n            if (wantsHighContrast !== isHighContrast(this._theme.type)) {\n                // switch to high contrast or non-high contrast but stick to dark or light\n                let newThemeName;\n                if (isDark(this._theme.type)) {\n                    newThemeName = wantsHighContrast ? HC_BLACK_THEME_NAME : VS_DARK_THEME_NAME;\n                }\n                else {\n                    newThemeName = wantsHighContrast ? HC_LIGHT_THEME_NAME : VS_LIGHT_THEME_NAME;\n                }\n                this._updateActualTheme(this._knownThemes.get(newThemeName));\n            }\n        }\n    }\n    setAutoDetectHighContrast(autoDetectHighContrast) {\n        this._autoDetectHighContrast = autoDetectHighContrast;\n        this._onOSSchemeChanged();\n    }\n    _updateThemeOrColorMap() {\n        const cssRules = [];\n        const hasRule = {};\n        const ruleCollector = {\n            addRule: (rule) => {\n                if (!hasRule[rule]) {\n                    cssRules.push(rule);\n                    hasRule[rule] = true;\n                }\n            }\n        };\n        themingRegistry.getThemingParticipants().forEach(p => p(this._theme, ruleCollector, this._environment));\n        const colorVariables = [];\n        for (const item of colorRegistry.getColors()) {\n            const color = this._theme.getColor(item.id, true);\n            if (color) {\n                colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);\n            }\n        }\n        ruleCollector.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${colorVariables.join('\\n')} }`);\n        const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();\n        ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));\n        this._themeCSS = cssRules.join('\\n');\n        this._updateCSS();\n        TokenizationRegistry.setColorMap(colorMap);\n        this._onColorThemeChange.fire(this._theme);\n    }\n    _updateCSS() {\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._styleElements.forEach(styleElement => styleElement.textContent = this._allCSS);\n    }\n    getFileIconTheme() {\n        return {\n            hasFileIcons: false,\n            hasFolderIcons: false,\n            hidesExplorerArrows: false\n        };\n    }\n    getProductIconTheme() {\n        return this._builtInProductIconTheme;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Node {\n    constructor(key, data) {\n        this.key = key;\n        this.data = data;\n        this.incoming = new Map();\n        this.outgoing = new Map();\n    }\n}\nexport class Graph {\n    constructor(_hashFn) {\n        this._hashFn = _hashFn;\n        this._nodes = new Map();\n        // empty\n    }\n    roots() {\n        const ret = [];\n        for (const node of this._nodes.values()) {\n            if (node.outgoing.size === 0) {\n                ret.push(node);\n            }\n        }\n        return ret;\n    }\n    insertEdge(from, to) {\n        const fromNode = this.lookupOrInsertNode(from);\n        const toNode = this.lookupOrInsertNode(to);\n        fromNode.outgoing.set(toNode.key, toNode);\n        toNode.incoming.set(fromNode.key, fromNode);\n    }\n    removeNode(data) {\n        const key = this._hashFn(data);\n        this._nodes.delete(key);\n        for (const node of this._nodes.values()) {\n            node.outgoing.delete(key);\n            node.incoming.delete(key);\n        }\n    }\n    lookupOrInsertNode(data) {\n        const key = this._hashFn(data);\n        let node = this._nodes.get(key);\n        if (!node) {\n            node = new Node(key, data);\n            this._nodes.set(key, node);\n        }\n        return node;\n    }\n    isEmpty() {\n        return this._nodes.size === 0;\n    }\n    toString() {\n        const data = [];\n        for (const [key, value] of this._nodes) {\n            data.push(`${key}\\n\\t(-> incoming)[${[...value.incoming.keys()].join(', ')}]\\n\\t(outgoing ->)[${[...value.outgoing.keys()].join(',')}]\\n`);\n        }\n        return data.join('\\n');\n    }\n    /**\n     * This is brute force and slow and **only** be used\n     * to trouble shoot.\n     */\n    findCycleSlow() {\n        for (const [id, node] of this._nodes) {\n            const seen = new Set([id]);\n            const res = this._findCycle(node, seen);\n            if (res) {\n                return res;\n            }\n        }\n        return undefined;\n    }\n    _findCycle(node, seen) {\n        for (const [id, outgoing] of node.outgoing) {\n            if (seen.has(id)) {\n                return [...seen, id].join(' -> ');\n            }\n            seen.add(id);\n            const value = this._findCycle(outgoing, seen);\n            if (value) {\n                return value;\n            }\n            seen.delete(id);\n        }\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { dispose, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n// TRACING\nconst _enableAllTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        super('cyclic dependency between services');\n        this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {\n        this._services = _services;\n        this._strict = _strict;\n        this._parent = _parent;\n        this._enableTracing = _enableTracing;\n        this._isDisposed = false;\n        this._servicesToMaybeDispose = new Set();\n        this._children = new Set();\n        this._activeInstantiations = new Set();\n        this._services.set(IInstantiationService, this);\n        this._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n    }\n    dispose() {\n        if (!this._isDisposed) {\n            this._isDisposed = true;\n            // dispose all child services\n            dispose(this._children);\n            this._children.clear();\n            // dispose all services created by this service\n            for (const candidate of this._servicesToMaybeDispose) {\n                if (isDisposable(candidate)) {\n                    candidate.dispose();\n                }\n            }\n            this._servicesToMaybeDispose.clear();\n        }\n    }\n    _throwIfDisposed() {\n        if (this._isDisposed) {\n            throw new Error('InstantiationService has been disposed');\n        }\n    }\n    createChild(services, store) {\n        this._throwIfDisposed();\n        const that = this;\n        const result = new class extends InstantiationService {\n            dispose() {\n                that._children.delete(result);\n                super.dispose();\n            }\n        }(services, this._strict, this, this._enableTracing);\n        this._children.add(result);\n        store?.add(result);\n        return result;\n    }\n    invokeFunction(fn, ...args) {\n        this._throwIfDisposed();\n        const _trace = Trace.traceInvocation(this._enableTracing, fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        this._throwIfDisposed();\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return Reflect.construct(ctor, args.concat(serviceArgs));\n    }\n    _setCreatedServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setCreatedServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        if (this._globalGraph && this._globalGraphImplicitDependency) {\n            this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n        }\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        const seen = new Set();\n        while (stack.length) {\n            const item = stack.pop();\n            if (seen.has(String(item.id))) {\n                continue;\n            }\n            seen.add(String(item.id));\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                // take note of all service dependencies\n                this._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setCreatedServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {\n        if (!supportsDelayedInstantiation) {\n            // eager instantiation\n            const result = this._createInstance(ctor, args, _trace);\n            disposeBucket.add(result);\n            return result;\n        }\n        else {\n            const child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n            child._globalGraphImplicitDependency = String(id);\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            // return \"empty events\" when the service isn't instantiated yet\n            const earlyListeners = new Map();\n            const idle = new GlobalIdleValue(() => {\n                const result = child._createInstance(ctor, args, _trace);\n                // early listeners that we kept are now being subscribed to\n                // the real service\n                for (const [key, values] of earlyListeners) {\n                    const candidate = result[key];\n                    if (typeof candidate === 'function') {\n                        for (const value of values) {\n                            value.disposable = candidate.apply(result, value.listener);\n                        }\n                    }\n                }\n                earlyListeners.clear();\n                disposeBucket.add(result);\n                return result;\n            });\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (!idle.isInitialized) {\n                        // looks like an event\n                        if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n                            let list = earlyListeners.get(key);\n                            if (!list) {\n                                list = new LinkedList();\n                                earlyListeners.set(key, list);\n                            }\n                            const event = (callback, thisArg, disposables) => {\n                                if (idle.isInitialized) {\n                                    return idle.value[key](callback, thisArg, disposables);\n                                }\n                                else {\n                                    const entry = { listener: [callback, thisArg, disposables], disposable: undefined };\n                                    const rm = list.push(entry);\n                                    const result = toDisposable(() => {\n                                        rm();\n                                        entry.disposable?.dispose();\n                                    });\n                                    return result;\n                                }\n                            };\n                            return event;\n                        }\n                    }\n                    // value already exists\n                    if (key in target) {\n                        return target[key];\n                    }\n                    // create value\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                },\n                getPrototypeOf(_target) {\n                    return ctor.prototype;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    static { this.all = new Set(); }\n    static { this._None = new class extends Trace {\n        constructor() { super(0 /* TraceType.None */, null); }\n        stop() { }\n        branch() { return this; }\n    }; }\n    static traceInvocation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(2 /* TraceType.Invocation */, ctor.name || new Error().stack.split('\\n').slice(3, 4).join('\\n'));\n    }\n    static traceCreation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Creation */, ctor.name);\n    }\n    static { this._totals = 0; }\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    branch(id, first) {\n        const child = new Trace(3 /* TraceType.Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 1 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            Trace.all.add(lines.join('\\n'));\n        }\n    }\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFalsyOrEmpty, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { DebounceEmitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MarkerSeverity } from './markers.js';\nexport const unsupportedSchemas = new Set([\n    Schemas.inMemory,\n    Schemas.vscodeSourceControl,\n    Schemas.walkThrough,\n    Schemas.walkThroughSnippet,\n    Schemas.vscodeChatCodeBlock,\n]);\nclass DoubleResourceMap {\n    constructor() {\n        this._byResource = new ResourceMap();\n        this._byOwner = new Map();\n    }\n    set(resource, owner, value) {\n        let ownerMap = this._byResource.get(resource);\n        if (!ownerMap) {\n            ownerMap = new Map();\n            this._byResource.set(resource, ownerMap);\n        }\n        ownerMap.set(owner, value);\n        let resourceMap = this._byOwner.get(owner);\n        if (!resourceMap) {\n            resourceMap = new ResourceMap();\n            this._byOwner.set(owner, resourceMap);\n        }\n        resourceMap.set(resource, value);\n    }\n    get(resource, owner) {\n        const ownerMap = this._byResource.get(resource);\n        return ownerMap?.get(owner);\n    }\n    delete(resource, owner) {\n        let removedA = false;\n        let removedB = false;\n        const ownerMap = this._byResource.get(resource);\n        if (ownerMap) {\n            removedA = ownerMap.delete(owner);\n        }\n        const resourceMap = this._byOwner.get(owner);\n        if (resourceMap) {\n            removedB = resourceMap.delete(resource);\n        }\n        if (removedA !== removedB) {\n            throw new Error('illegal state');\n        }\n        return removedA && removedB;\n    }\n    values(key) {\n        if (typeof key === 'string') {\n            return this._byOwner.get(key)?.values() ?? Iterable.empty();\n        }\n        if (URI.isUri(key)) {\n            return this._byResource.get(key)?.values() ?? Iterable.empty();\n        }\n        return Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);\n    }\n}\nclass MarkerStats {\n    constructor(service) {\n        this.errors = 0;\n        this.infos = 0;\n        this.warnings = 0;\n        this.unknowns = 0;\n        this._data = new ResourceMap();\n        this._service = service;\n        this._subscription = service.onMarkerChanged(this._update, this);\n    }\n    dispose() {\n        this._subscription.dispose();\n    }\n    _update(resources) {\n        for (const resource of resources) {\n            const oldStats = this._data.get(resource);\n            if (oldStats) {\n                this._substract(oldStats);\n            }\n            const newStats = this._resourceStats(resource);\n            this._add(newStats);\n            this._data.set(resource, newStats);\n        }\n    }\n    _resourceStats(resource) {\n        const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n        // TODO this is a hack\n        if (unsupportedSchemas.has(resource.scheme)) {\n            return result;\n        }\n        for (const { severity } of this._service.read({ resource })) {\n            if (severity === MarkerSeverity.Error) {\n                result.errors += 1;\n            }\n            else if (severity === MarkerSeverity.Warning) {\n                result.warnings += 1;\n            }\n            else if (severity === MarkerSeverity.Info) {\n                result.infos += 1;\n            }\n            else {\n                result.unknowns += 1;\n            }\n        }\n        return result;\n    }\n    _substract(op) {\n        this.errors -= op.errors;\n        this.warnings -= op.warnings;\n        this.infos -= op.infos;\n        this.unknowns -= op.unknowns;\n    }\n    _add(op) {\n        this.errors += op.errors;\n        this.warnings += op.warnings;\n        this.infos += op.infos;\n        this.unknowns += op.unknowns;\n    }\n}\nexport class MarkerService {\n    constructor() {\n        this._onMarkerChanged = new DebounceEmitter({\n            delay: 0,\n            merge: MarkerService._merge\n        });\n        this.onMarkerChanged = this._onMarkerChanged.event;\n        this._data = new DoubleResourceMap();\n        this._stats = new MarkerStats(this);\n    }\n    dispose() {\n        this._stats.dispose();\n        this._onMarkerChanged.dispose();\n    }\n    remove(owner, resources) {\n        for (const resource of resources || []) {\n            this.changeOne(owner, resource, []);\n        }\n    }\n    changeOne(owner, resource, markerData) {\n        if (isFalsyOrEmpty(markerData)) {\n            // remove marker for this (owner,resource)-tuple\n            const removed = this._data.delete(resource, owner);\n            if (removed) {\n                this._onMarkerChanged.fire([resource]);\n            }\n        }\n        else {\n            // insert marker for this (owner,resource)-tuple\n            const markers = [];\n            for (const data of markerData) {\n                const marker = MarkerService._toMarker(owner, resource, data);\n                if (marker) {\n                    markers.push(marker);\n                }\n            }\n            this._data.set(resource, owner, markers);\n            this._onMarkerChanged.fire([resource]);\n        }\n    }\n    static _toMarker(owner, resource, data) {\n        let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags, } = data;\n        if (!message) {\n            return undefined;\n        }\n        // santize data\n        startLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n        startColumn = startColumn > 0 ? startColumn : 1;\n        endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n        endColumn = endColumn > 0 ? endColumn : startColumn;\n        return {\n            resource,\n            owner,\n            code,\n            severity,\n            message,\n            source,\n            startLineNumber,\n            startColumn,\n            endLineNumber,\n            endColumn,\n            relatedInformation,\n            tags,\n        };\n    }\n    changeAll(owner, data) {\n        const changes = [];\n        // remove old marker\n        const existing = this._data.values(owner);\n        if (existing) {\n            for (const data of existing) {\n                const first = Iterable.first(data);\n                if (first) {\n                    changes.push(first.resource);\n                    this._data.delete(first.resource, owner);\n                }\n            }\n        }\n        // add new markers\n        if (isNonEmptyArray(data)) {\n            // group by resource\n            const groups = new ResourceMap();\n            for (const { resource, marker: markerData } of data) {\n                const marker = MarkerService._toMarker(owner, resource, markerData);\n                if (!marker) {\n                    // filter bad markers\n                    continue;\n                }\n                const array = groups.get(resource);\n                if (!array) {\n                    groups.set(resource, [marker]);\n                    changes.push(resource);\n                }\n                else {\n                    array.push(marker);\n                }\n            }\n            // insert all\n            for (const [resource, value] of groups) {\n                this._data.set(resource, owner, value);\n            }\n        }\n        if (changes.length > 0) {\n            this._onMarkerChanged.fire(changes);\n        }\n    }\n    read(filter = Object.create(null)) {\n        let { owner, resource, severities, take } = filter;\n        if (!take || take < 0) {\n            take = -1;\n        }\n        if (owner && resource) {\n            // exactly one owner AND resource\n            const data = this._data.get(resource, owner);\n            if (!data) {\n                return [];\n            }\n            else {\n                const result = [];\n                for (const marker of data) {\n                    if (MarkerService._accept(marker, severities)) {\n                        const newLen = result.push(marker);\n                        if (take > 0 && newLen === take) {\n                            break;\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        else if (!owner && !resource) {\n            // all\n            const result = [];\n            for (const markers of this._data.values()) {\n                for (const data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n        else {\n            // of one resource OR owner\n            const iterable = this._data.values(resource ?? owner);\n            const result = [];\n            for (const markers of iterable) {\n                for (const data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    static _accept(marker, severities) {\n        return severities === undefined || (severities & marker.severity) === marker.severity;\n    }\n    // --- event debounce logic\n    static _merge(all) {\n        const set = new ResourceMap();\n        for (const array of all) {\n            for (const item of array) {\n                set.set(item, true);\n            }\n        }\n        return Array.from(set.keys());\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './standaloneCodeEditorService.js';\nimport './standaloneLayoutService.js';\nimport '../../../platform/undoRedo/common/undoRedoService.js';\nimport '../../common/services/languageFeatureDebounce.js';\nimport '../../common/services/semanticTokensStylingService.js';\nimport '../../common/services/languageFeaturesService.js';\nimport '../../browser/services/hoverService/hoverService.js';\nimport * as strings from '../../../base/common/strings.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyCodeChord, decodeKeybinding } from '../../../base/common/keybindings.js';\nimport { ImmortalReference, toDisposable, DisposableStore, Disposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport { OS, isLinux, isMacintosh } from '../../../base/common/platform.js';\nimport Severity from '../../../base/common/severity.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IBulkEditService, ResourceEdit, ResourceTextEdit } from '../../browser/services/bulkEditService.js';\nimport { isDiffEditorConfigurationKey, isEditorConfigurationKey } from '../../common/config/editorConfigurationSchema.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position as Pos } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ITextModelService } from '../../common/services/resolverService.js';\nimport { ITextResourceConfigurationService, ITextResourcePropertiesService } from '../../common/services/textResourceConfiguration.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { Configuration, ConfigurationModel, ConfigurationChangeEvent } from '../../../platform/configuration/common/configurationModels.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IDialogService } from '../../../platform/dialogs/common/dialogs.js';\nimport { createDecorator, IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { AbstractKeybindingService } from '../../../platform/keybinding/common/abstractKeybindingService.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { KeybindingResolver } from '../../../platform/keybinding/common/keybindingResolver.js';\nimport { KeybindingsRegistry } from '../../../platform/keybinding/common/keybindingsRegistry.js';\nimport { ResolvedKeybindingItem } from '../../../platform/keybinding/common/resolvedKeybindingItem.js';\nimport { USLayoutResolvedKeybinding } from '../../../platform/keybinding/common/usLayoutResolvedKeybinding.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nimport { INotificationService, NoOpNotification } from '../../../platform/notification/common/notification.js';\nimport { IEditorProgressService, IProgressService } from '../../../platform/progress/common/progress.js';\nimport { ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { IWorkspaceContextService, WorkspaceFolder, STANDALONE_EDITOR_WORKSPACE_ID } from '../../../platform/workspace/common/workspace.js';\nimport { ILayoutService } from '../../../platform/layout/browser/layoutService.js';\nimport { StandaloneServicesNLS } from '../../common/standaloneStrings.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { ConsoleLogger, ILogService } from '../../../platform/log/common/log.js';\nimport { IWorkspaceTrustManagementService } from '../../../platform/workspace/common/workspaceTrust.js';\nimport { IContextMenuService, IContextViewService } from '../../../platform/contextview/browser/contextView.js';\nimport { ContextViewService } from '../../../platform/contextview/browser/contextViewService.js';\nimport { LanguageService } from '../../common/services/languageService.js';\nimport { ContextMenuService } from '../../../platform/contextview/browser/contextMenuService.js';\nimport { getSingletonServiceDescriptors, registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { OpenerService } from '../../browser/services/openerService.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { EditorWorkerService } from '../../browser/services/editorWorkerService.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { MarkerDecorationsService } from '../../common/services/markerDecorationsService.js';\nimport { IMarkerDecorationsService } from '../../common/services/markerDecorations.js';\nimport { ModelService } from '../../common/services/modelService.js';\nimport { StandaloneQuickInputService } from './quickInput/standaloneQuickInputService.js';\nimport { StandaloneThemeService } from './standaloneThemeService.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { AccessibilityService } from '../../../platform/accessibility/browser/accessibilityService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { IMenuService } from '../../../platform/actions/common/actions.js';\nimport { MenuService } from '../../../platform/actions/common/menuService.js';\nimport { BrowserClipboardService } from '../../../platform/clipboard/browser/clipboardService.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { ContextKeyService } from '../../../platform/contextkey/browser/contextKeyService.js';\nimport { SyncDescriptor } from '../../../platform/instantiation/common/descriptors.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IListService, ListService } from '../../../platform/list/browser/listService.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { MarkerService } from '../../../platform/markers/common/markerService.js';\nimport { IOpenerService } from '../../../platform/opener/common/opener.js';\nimport { IQuickInputService } from '../../../platform/quickinput/common/quickInput.js';\nimport { IStorageService, InMemoryStorageService } from '../../../platform/storage/common/storage.js';\nimport { DefaultConfiguration } from '../../../platform/configuration/common/configurations.js';\nimport { IAccessibilitySignalService } from '../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { LogService } from '../../../platform/log/common/logService.js';\nimport { getEditorFeatures } from '../../common/editorFeatures.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { IEnvironmentService } from '../../../platform/environment/common/environment.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { ITreeSitterParserService } from '../../common/services/treeSitterParserService.js';\nimport { StandaloneTreeSitterParserService } from './standaloneTreeSitterService.js';\nclass SimpleModel {\n    constructor(model) {\n        this.disposed = false;\n        this.model = model;\n        this._onWillDispose = new Emitter();\n    }\n    get textEditorModel() {\n        return this.model;\n    }\n    dispose() {\n        this.disposed = true;\n        this._onWillDispose.fire();\n    }\n}\nlet StandaloneTextModelService = class StandaloneTextModelService {\n    constructor(modelService) {\n        this.modelService = modelService;\n    }\n    createModelReference(resource) {\n        const model = this.modelService.getModel(resource);\n        if (!model) {\n            return Promise.reject(new Error(`Model not found`));\n        }\n        return Promise.resolve(new ImmortalReference(new SimpleModel(model)));\n    }\n};\nStandaloneTextModelService = __decorate([\n    __param(0, IModelService)\n], StandaloneTextModelService);\nclass StandaloneEditorProgressService {\n    static { this.NULL_PROGRESS_RUNNER = {\n        done: () => { },\n        total: () => { },\n        worked: () => { }\n    }; }\n    show() {\n        return StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;\n    }\n    async showWhile(promise, delay) {\n        await promise;\n    }\n}\nclass StandaloneProgressService {\n    withProgress(_options, task, onDidCancel) {\n        return task({\n            report: () => { },\n        });\n    }\n}\nclass StandaloneEnvironmentService {\n    constructor() {\n        this.isExtensionDevelopment = false;\n        this.isBuilt = false;\n    }\n}\nclass StandaloneDialogService {\n    async confirm(confirmation) {\n        const confirmed = this.doConfirm(confirmation.message, confirmation.detail);\n        return {\n            confirmed,\n            checkboxChecked: false // unsupported\n        };\n    }\n    doConfirm(message, detail) {\n        let messageText = message;\n        if (detail) {\n            messageText = messageText + '\\n\\n' + detail;\n        }\n        return mainWindow.confirm(messageText);\n    }\n    async prompt(prompt) {\n        let result = undefined;\n        const confirmed = this.doConfirm(prompt.message, prompt.detail);\n        if (confirmed) {\n            const promptButtons = [...(prompt.buttons ?? [])];\n            if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {\n                promptButtons.push(prompt.cancelButton);\n            }\n            result = await promptButtons[0]?.run({ checkboxChecked: false });\n        }\n        return { result };\n    }\n    async error(message, detail) {\n        await this.prompt({ type: Severity.Error, message, detail });\n    }\n}\nexport class StandaloneNotificationService {\n    static { this.NO_OP = new NoOpNotification(); }\n    info(message) {\n        return this.notify({ severity: Severity.Info, message });\n    }\n    warn(message) {\n        return this.notify({ severity: Severity.Warning, message });\n    }\n    error(error) {\n        return this.notify({ severity: Severity.Error, message: error });\n    }\n    notify(notification) {\n        switch (notification.severity) {\n            case Severity.Error:\n                console.error(notification.message);\n                break;\n            case Severity.Warning:\n                console.warn(notification.message);\n                break;\n            default:\n                console.log(notification.message);\n                break;\n        }\n        return StandaloneNotificationService.NO_OP;\n    }\n    prompt(severity, message, choices, options) {\n        return StandaloneNotificationService.NO_OP;\n    }\n    status(message, options) {\n        return Disposable.None;\n    }\n}\nlet StandaloneCommandService = class StandaloneCommandService {\n    constructor(instantiationService) {\n        this._onWillExecuteCommand = new Emitter();\n        this._onDidExecuteCommand = new Emitter();\n        this.onDidExecuteCommand = this._onDidExecuteCommand.event;\n        this._instantiationService = instantiationService;\n    }\n    executeCommand(id, ...args) {\n        const command = CommandsRegistry.getCommand(id);\n        if (!command) {\n            return Promise.reject(new Error(`command '${id}' not found`));\n        }\n        try {\n            this._onWillExecuteCommand.fire({ commandId: id, args });\n            const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);\n            this._onDidExecuteCommand.fire({ commandId: id, args });\n            return Promise.resolve(result);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n};\nStandaloneCommandService = __decorate([\n    __param(0, IInstantiationService)\n], StandaloneCommandService);\nexport { StandaloneCommandService };\nlet StandaloneKeybindingService = class StandaloneKeybindingService extends AbstractKeybindingService {\n    constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {\n        super(contextKeyService, commandService, telemetryService, notificationService, logService);\n        this._cachedResolver = null;\n        this._dynamicKeybindings = [];\n        this._domNodeListeners = [];\n        const addContainer = (domNode) => {\n            const disposables = new DisposableStore();\n            // for standard keybindings\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                    keyEvent.stopPropagation();\n                }\n            }));\n            // for single modifier chord keybindings (e.g. shift shift)\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                }\n            }));\n            this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));\n        };\n        const removeContainer = (domNode) => {\n            for (let i = 0; i < this._domNodeListeners.length; i++) {\n                const domNodeListeners = this._domNodeListeners[i];\n                if (domNodeListeners.domNode === domNode) {\n                    this._domNodeListeners.splice(i, 1);\n                    domNodeListeners.dispose();\n                }\n            }\n        };\n        const addCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(61 /* EditorOption.inDiffEditor */)) {\n                return;\n            }\n            addContainer(codeEditor.getContainerDomNode());\n        };\n        const removeCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(61 /* EditorOption.inDiffEditor */)) {\n                return;\n            }\n            removeContainer(codeEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));\n        this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));\n        codeEditorService.listCodeEditors().forEach(addCodeEditor);\n        const addDiffEditor = (diffEditor) => {\n            addContainer(diffEditor.getContainerDomNode());\n        };\n        const removeDiffEditor = (diffEditor) => {\n            removeContainer(diffEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));\n        this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));\n        codeEditorService.listDiffEditors().forEach(addDiffEditor);\n    }\n    addDynamicKeybinding(command, keybinding, handler, when) {\n        return combinedDisposable(CommandsRegistry.registerCommand(command, handler), this.addDynamicKeybindings([{\n                keybinding,\n                command,\n                when\n            }]));\n    }\n    addDynamicKeybindings(rules) {\n        const entries = rules.map((rule) => {\n            const keybinding = decodeKeybinding(rule.keybinding, OS);\n            return {\n                keybinding,\n                command: rule.command ?? null,\n                commandArgs: rule.commandArgs,\n                when: rule.when,\n                weight1: 1000,\n                weight2: 0,\n                extensionId: null,\n                isBuiltinExtension: false\n            };\n        });\n        this._dynamicKeybindings = this._dynamicKeybindings.concat(entries);\n        this.updateResolver();\n        return toDisposable(() => {\n            // Search the first entry and remove them all since they will be contiguous\n            for (let i = 0; i < this._dynamicKeybindings.length; i++) {\n                if (this._dynamicKeybindings[i] === entries[0]) {\n                    this._dynamicKeybindings.splice(i, entries.length);\n                    this.updateResolver();\n                    return;\n                }\n            }\n        });\n    }\n    updateResolver() {\n        this._cachedResolver = null;\n        this._onDidUpdateKeybindings.fire();\n    }\n    _getResolver() {\n        if (!this._cachedResolver) {\n            const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);\n            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);\n            this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));\n        }\n        return this._cachedResolver;\n    }\n    _documentHasFocus() {\n        return mainWindow.document.hasFocus();\n    }\n    _toNormalizedKeybindingItems(items, isDefault) {\n        const result = [];\n        let resultLen = 0;\n        for (const item of items) {\n            const when = item.when || undefined;\n            const keybinding = item.keybinding;\n            if (!keybinding) {\n                // This might be a removal keybinding item in user settings => accept it\n                result[resultLen++] = new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false);\n            }\n            else {\n                const resolvedKeybindings = USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);\n                for (const resolvedKeybinding of resolvedKeybindings) {\n                    result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);\n                }\n            }\n        }\n        return result;\n    }\n    resolveKeyboardEvent(keyboardEvent) {\n        const chord = new KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);\n        return new USLayoutResolvedKeybinding([chord], OS);\n    }\n};\nStandaloneKeybindingService = __decorate([\n    __param(0, IContextKeyService),\n    __param(1, ICommandService),\n    __param(2, ITelemetryService),\n    __param(3, INotificationService),\n    __param(4, ILogService),\n    __param(5, ICodeEditorService)\n], StandaloneKeybindingService);\nexport { StandaloneKeybindingService };\nclass DomNodeListeners extends Disposable {\n    constructor(domNode, disposables) {\n        super();\n        this.domNode = domNode;\n        this._register(disposables);\n    }\n}\nfunction isConfigurationOverrides(thing) {\n    return thing\n        && typeof thing === 'object'\n        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n        && (!thing.resource || thing.resource instanceof URI);\n}\nlet StandaloneConfigurationService = class StandaloneConfigurationService {\n    constructor(logService) {\n        this.logService = logService;\n        this._onDidChangeConfiguration = new Emitter();\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        const defaultConfiguration = new DefaultConfiguration(logService);\n        this._configuration = new Configuration(defaultConfiguration.reload(), ConfigurationModel.createEmptyModel(logService), ConfigurationModel.createEmptyModel(logService), ConfigurationModel.createEmptyModel(logService), ConfigurationModel.createEmptyModel(logService), ConfigurationModel.createEmptyModel(logService), new ResourceMap(), ConfigurationModel.createEmptyModel(logService), new ResourceMap(), logService);\n        defaultConfiguration.dispose();\n    }\n    getValue(arg1, arg2) {\n        const section = typeof arg1 === 'string' ? arg1 : undefined;\n        const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};\n        return this._configuration.getValue(section, overrides, undefined);\n    }\n    updateValues(values) {\n        const previous = { data: this._configuration.toData() };\n        const changedKeys = [];\n        for (const entry of values) {\n            const [key, value] = entry;\n            if (this.getValue(key) === value) {\n                continue;\n            }\n            this._configuration.updateValue(key, value);\n            changedKeys.push(key);\n        }\n        if (changedKeys.length > 0) {\n            const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration, undefined, this.logService);\n            configurationChangeEvent.source = 8 /* ConfigurationTarget.MEMORY */;\n            this._onDidChangeConfiguration.fire(configurationChangeEvent);\n        }\n        return Promise.resolve();\n    }\n    updateValue(key, value, arg3, arg4) {\n        return this.updateValues([[key, value]]);\n    }\n    inspect(key, options = {}) {\n        return this._configuration.inspect(key, options, undefined);\n    }\n};\nStandaloneConfigurationService = __decorate([\n    __param(0, ILogService)\n], StandaloneConfigurationService);\nexport { StandaloneConfigurationService };\nlet StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {\n    constructor(configurationService, modelService, languageService) {\n        this.configurationService = configurationService;\n        this.modelService = modelService;\n        this.languageService = languageService;\n        this._onDidChangeConfiguration = new Emitter();\n        this.configurationService.onDidChangeConfiguration((e) => {\n            this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });\n        });\n    }\n    getValue(resource, arg2, arg3) {\n        const position = Pos.isIPosition(arg2) ? arg2 : null;\n        const section = position ? (typeof arg3 === 'string' ? arg3 : undefined) : (typeof arg2 === 'string' ? arg2 : undefined);\n        const language = resource ? this.getLanguage(resource, position) : undefined;\n        if (typeof section === 'undefined') {\n            return this.configurationService.getValue({\n                resource,\n                overrideIdentifier: language\n            });\n        }\n        return this.configurationService.getValue(section, {\n            resource,\n            overrideIdentifier: language\n        });\n    }\n    getLanguage(resource, position) {\n        const model = this.modelService.getModel(resource);\n        if (model) {\n            return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();\n        }\n        return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);\n    }\n};\nStandaloneResourceConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, IModelService),\n    __param(2, ILanguageService)\n], StandaloneResourceConfigurationService);\nlet StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService {\n    constructor(configurationService) {\n        this.configurationService = configurationService;\n    }\n    getEOL(resource, language) {\n        const eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return (isLinux || isMacintosh) ? '\\n' : '\\r\\n';\n    }\n};\nStandaloneResourcePropertiesService = __decorate([\n    __param(0, IConfigurationService)\n], StandaloneResourcePropertiesService);\nclass StandaloneTelemetryService {\n    publicLog2() { }\n}\nclass StandaloneWorkspaceContextService {\n    static { this.SCHEME = 'inmemory'; }\n    constructor() {\n        const resource = URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });\n        this.workspace = { id: STANDALONE_EDITOR_WORKSPACE_ID, folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })] };\n    }\n    getWorkspace() {\n        return this.workspace;\n    }\n    getWorkspaceFolder(resource) {\n        return resource && resource.scheme === StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;\n    }\n}\nexport function updateConfigurationService(configurationService, source, isDiffEditor) {\n    if (!source) {\n        return;\n    }\n    if (!(configurationService instanceof StandaloneConfigurationService)) {\n        return;\n    }\n    const toUpdate = [];\n    Object.keys(source).forEach((key) => {\n        if (isEditorConfigurationKey(key)) {\n            toUpdate.push([`editor.${key}`, source[key]]);\n        }\n        if (isDiffEditor && isDiffEditorConfigurationKey(key)) {\n            toUpdate.push([`diffEditor.${key}`, source[key]]);\n        }\n    });\n    if (toUpdate.length > 0) {\n        configurationService.updateValues(toUpdate);\n    }\n}\nlet StandaloneBulkEditService = class StandaloneBulkEditService {\n    constructor(_modelService) {\n        this._modelService = _modelService;\n        //\n    }\n    hasPreviewHandler() {\n        return false;\n    }\n    async apply(editsIn, _options) {\n        const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);\n        const textEdits = new Map();\n        for (const edit of edits) {\n            if (!(edit instanceof ResourceTextEdit)) {\n                throw new Error('bad edit - only text edits are supported');\n            }\n            const model = this._modelService.getModel(edit.resource);\n            if (!model) {\n                throw new Error('bad edit - model not found');\n            }\n            if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {\n                throw new Error('bad state - model changed in the meantime');\n            }\n            let array = textEdits.get(model);\n            if (!array) {\n                array = [];\n                textEdits.set(model, array);\n            }\n            array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));\n        }\n        let totalEdits = 0;\n        let totalFiles = 0;\n        for (const [model, edits] of textEdits) {\n            model.pushStackElement();\n            model.pushEditOperations([], edits, () => []);\n            model.pushStackElement();\n            totalFiles += 1;\n            totalEdits += edits.length;\n        }\n        return {\n            ariaSummary: strings.format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),\n            isApplied: totalEdits > 0\n        };\n    }\n};\nStandaloneBulkEditService = __decorate([\n    __param(0, IModelService)\n], StandaloneBulkEditService);\nclass StandaloneUriLabelService {\n    getUriLabel(resource, options) {\n        if (resource.scheme === 'file') {\n            return resource.fsPath;\n        }\n        return resource.path;\n    }\n    getUriBasenameLabel(resource) {\n        return basename(resource);\n    }\n}\nlet StandaloneContextViewService = class StandaloneContextViewService extends ContextViewService {\n    constructor(layoutService, _codeEditorService) {\n        super(layoutService);\n        this._codeEditorService = _codeEditorService;\n    }\n    showContextView(delegate, container, shadowRoot) {\n        if (!container) {\n            const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();\n            if (codeEditor) {\n                container = codeEditor.getContainerDomNode();\n            }\n        }\n        return super.showContextView(delegate, container, shadowRoot);\n    }\n};\nStandaloneContextViewService = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ICodeEditorService)\n], StandaloneContextViewService);\nclass StandaloneWorkspaceTrustManagementService {\n    constructor() {\n        this._neverEmitter = new Emitter();\n        this.onDidChangeTrust = this._neverEmitter.event;\n    }\n    isWorkspaceTrusted() {\n        return true;\n    }\n}\nclass StandaloneLanguageService extends LanguageService {\n    constructor() {\n        super();\n    }\n}\nclass StandaloneLogService extends LogService {\n    constructor() {\n        super(new ConsoleLogger());\n    }\n}\nlet StandaloneContextMenuService = class StandaloneContextMenuService extends ContextMenuService {\n    constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {\n        super(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService);\n        this.configure({ blockMouse: false }); // we do not want that in the standalone editor\n    }\n};\nStandaloneContextMenuService = __decorate([\n    __param(0, ITelemetryService),\n    __param(1, INotificationService),\n    __param(2, IContextViewService),\n    __param(3, IKeybindingService),\n    __param(4, IMenuService),\n    __param(5, IContextKeyService)\n], StandaloneContextMenuService);\nexport const standaloneEditorWorkerDescriptor = {\n    amdModuleId: 'vs/editor/common/services/editorSimpleWorker',\n    esmModuleLocation: undefined,\n    label: 'editorWorkerService'\n};\nlet StandaloneEditorWorkerService = class StandaloneEditorWorkerService extends EditorWorkerService {\n    constructor(modelService, configurationService, logService, languageConfigurationService, languageFeaturesService) {\n        super(standaloneEditorWorkerDescriptor, modelService, configurationService, logService, languageConfigurationService, languageFeaturesService);\n    }\n};\nStandaloneEditorWorkerService = __decorate([\n    __param(0, IModelService),\n    __param(1, ITextResourceConfigurationService),\n    __param(2, ILogService),\n    __param(3, ILanguageConfigurationService),\n    __param(4, ILanguageFeaturesService)\n], StandaloneEditorWorkerService);\nclass StandaloneAccessbilitySignalService {\n    async playSignal(cue, options) {\n    }\n}\nregisterSingleton(ILogService, StandaloneLogService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IConfigurationService, StandaloneConfigurationService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ITextResourceConfigurationService, StandaloneResourceConfigurationService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ITextResourcePropertiesService, StandaloneResourcePropertiesService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IWorkspaceContextService, StandaloneWorkspaceContextService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ILabelService, StandaloneUriLabelService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ITelemetryService, StandaloneTelemetryService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IDialogService, StandaloneDialogService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IEnvironmentService, StandaloneEnvironmentService, 0 /* InstantiationType.Eager */);\nregisterSingleton(INotificationService, StandaloneNotificationService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IMarkerService, MarkerService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ILanguageService, StandaloneLanguageService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IStandaloneThemeService, StandaloneThemeService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IModelService, ModelService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IMarkerDecorationsService, MarkerDecorationsService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IContextKeyService, ContextKeyService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IProgressService, StandaloneProgressService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IEditorProgressService, StandaloneEditorProgressService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IStorageService, InMemoryStorageService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IEditorWorkerService, StandaloneEditorWorkerService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IBulkEditService, StandaloneBulkEditService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IWorkspaceTrustManagementService, StandaloneWorkspaceTrustManagementService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ITextModelService, StandaloneTextModelService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IAccessibilityService, AccessibilityService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IListService, ListService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ICommandService, StandaloneCommandService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IKeybindingService, StandaloneKeybindingService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IQuickInputService, StandaloneQuickInputService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IContextViewService, StandaloneContextViewService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IOpenerService, OpenerService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IClipboardService, BrowserClipboardService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IContextMenuService, StandaloneContextMenuService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IMenuService, MenuService, 0 /* InstantiationType.Eager */);\nregisterSingleton(IAccessibilitySignalService, StandaloneAccessbilitySignalService, 0 /* InstantiationType.Eager */);\nregisterSingleton(ITreeSitterParserService, StandaloneTreeSitterParserService, 0 /* InstantiationType.Eager */);\n/**\n * We don't want to eagerly instantiate services because embedders get a one time chance\n * to override services when they create the first editor.\n */\nexport var StandaloneServices;\n(function (StandaloneServices) {\n    const serviceCollection = new ServiceCollection();\n    for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n        serviceCollection.set(id, descriptor);\n    }\n    const instantiationService = new InstantiationService(serviceCollection, true);\n    serviceCollection.set(IInstantiationService, instantiationService);\n    function get(serviceId) {\n        if (!initialized) {\n            initialize({});\n        }\n        const r = serviceCollection.get(serviceId);\n        if (!r) {\n            throw new Error('Missing service ' + serviceId);\n        }\n        if (r instanceof SyncDescriptor) {\n            return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));\n        }\n        else {\n            return r;\n        }\n    }\n    StandaloneServices.get = get;\n    let initialized = false;\n    const onDidInitialize = new Emitter();\n    function initialize(overrides) {\n        if (initialized) {\n            return instantiationService;\n        }\n        initialized = true;\n        // Add singletons that were registered after this module loaded\n        for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n            if (!serviceCollection.get(id)) {\n                serviceCollection.set(id, descriptor);\n            }\n        }\n        // Initialize the service collection with the overrides, but only if the\n        // service was not instantiated in the meantime.\n        for (const serviceId in overrides) {\n            if (overrides.hasOwnProperty(serviceId)) {\n                const serviceIdentifier = createDecorator(serviceId);\n                const r = serviceCollection.get(serviceIdentifier);\n                if (r instanceof SyncDescriptor) {\n                    serviceCollection.set(serviceIdentifier, overrides[serviceId]);\n                }\n            }\n        }\n        // Instantiate all editor features\n        const editorFeatures = getEditorFeatures();\n        for (const feature of editorFeatures) {\n            try {\n                instantiationService.createInstance(feature);\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        onDidInitialize.fire();\n        return instantiationService;\n    }\n    StandaloneServices.initialize = initialize;\n    /**\n     * Executes callback once services are initialized.\n     */\n    function withServices(callback) {\n        if (initialized) {\n            return callback();\n        }\n        const disposable = new DisposableStore();\n        const listener = disposable.add(onDidInitialize.event(() => {\n            listener.dispose();\n            disposable.add(callback());\n        }));\n        return disposable;\n    }\n    StandaloneServices.withServices = withServices;\n})(StandaloneServices || (StandaloneServices = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar MonarchTokenizer_1;\n/**\n * Create a syntax highighter with a fully declarative JSON style lexer description\n * using regular expressions.\n */\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    static { this._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH); }\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedLanguageData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        const stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    static { this._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH); }\n    static create(stack, embeddedLanguageData) {\n        return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    create(stack, embeddedLanguageData) {\n        if (embeddedLanguageData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        const stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nclass MonarchLineState {\n    constructor(stack, embeddedLanguageData) {\n        this.stack = stack;\n        this.embeddedLanguageData = embeddedLanguageData;\n    }\n    clone() {\n        const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n        // save an object\n        if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n            return true;\n        }\n        if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n            return false;\n        }\n        return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterLanguage(languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (const token of nestedResult.tokens) {\n                this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n            }\n        }\n        else {\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n        }\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(languageService, theme) {\n        this._languageService = languageService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* LanguageId.Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterLanguage(languageId) {\n        this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        const metadata = this._theme.match(this._currentLanguageId, type) | 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */;\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        const aLen = (a !== null ? a.length : 0);\n        const bLen = b.length;\n        const cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        const result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n                nestedResult.tokens[i] += offsetDelta;\n            }\n        }\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nlet MonarchTokenizer = MonarchTokenizer_1 = class MonarchTokenizer extends Disposable {\n    constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._languageService = languageService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedLanguages = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._register(languages.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                const language = e.changedLanguages[i];\n                if (this._embeddedLanguages[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                languages.TokenizationRegistry.handleChange([this._languageId]);\n                emitting = false;\n            }\n        }));\n        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n            overrideIdentifier: this._languageId\n        });\n        this._register(this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n                this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n                    overrideIdentifier: this._languageId\n                });\n            }\n        }));\n    }\n    getLoadStatus() {\n        const promises = [];\n        for (const nestedLanguageId in this._embeddedLanguages) {\n            const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n            if (tokenizationSupport) {\n                // The nested language is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer_1) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n                // The nested language is in the process of being loaded\n                promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenize(this._languageId, lineState);\n        }\n        const tokensCollector = new MonarchClassicTokensCollector();\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenizeEncoded(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n        }\n        const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, collector) {\n        if (lineState.embeddedLanguageData) {\n            return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, 0, collector);\n        }\n    }\n    _findLeavingNestedLanguageOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.resolveRegex(state.stack.state);\n            const regexSource = regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            const result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested language\n            const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n        }\n        const nestedLanguageLine = line.substring(0, popOffset);\n        if (nestedLanguageLine.length > 0) {\n            // tokenize with the nested language\n            tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n        }\n        const restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterLanguage(this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedLanguageData = lineState.embeddedLanguageData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedLanguage = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                const restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.resolveRegex(state));\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded language?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedLanguageData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n                        }\n                        embeddedLanguageData = null;\n                    }\n                    else if (embeddedLanguageData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n                    }\n                    else {\n                        enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage) => {\n                // support language names, mime types, and language ids\n                const languageId = (this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage)\n                    || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage)\n                    || enteringEmbeddedLanguage);\n                const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n                if (pos < lineLength) {\n                    // there is content from the embedded language on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedLanguage !== null) {\n                        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    const rest = result.substr('@brackets'.length);\n                    const bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    const token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedLanguage !== null) {\n                return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n    _getNestedEmbeddedLanguageData(languageId) {\n        if (!this._languageService.isRegisteredLanguageId(languageId)) {\n            return new EmbeddedLanguageData(languageId, NullState);\n        }\n        if (languageId !== this._languageId) {\n            // Fire language loading event\n            this._languageService.requestBasicLanguageFeatures(languageId);\n            languages.TokenizationRegistry.getOrCreate(languageId);\n            this._embeddedLanguages[languageId] = true;\n        }\n        const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n        if (tokenizationSupport) {\n            return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n        }\n        return new EmbeddedLanguageData(languageId, NullState);\n    }\n};\nMonarchTokenizer = MonarchTokenizer_1 = __decorate([\n    __param(4, IConfigurationService)\n], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    const brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* monarchCommon.MonarchBracket.Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* monarchCommon.MonarchBracket.Close */ };\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../base/browser/dom.js';\nimport { GlobalPointerMoveMonitor } from '../../base/browser/globalPointerMoveMonitor.js';\nimport { StandardMouseEvent } from '../../base/browser/mouseEvent.js';\nimport { RunOnceScheduler } from '../../base/common/async.js';\nimport { Disposable, DisposableStore } from '../../base/common/lifecycle.js';\nimport { asCssVariable } from '../../platform/theme/common/colorRegistry.js';\n/**\n * Coordinates relative to the whole document (e.g. mouse event's pageX and pageY)\n */\nexport class PageCoordinates {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this._pageCoordinatesBrand = undefined;\n    }\n    toClientCoordinates(targetWindow) {\n        return new ClientCoordinates(this.x - targetWindow.scrollX, this.y - targetWindow.scrollY);\n    }\n}\n/**\n * Coordinates within the application's client area (i.e. origin is document's scroll position).\n *\n * For example, clicking in the top-left corner of the client area will\n * always result in a mouse event with a client.x value of 0, regardless\n * of whether the page is scrolled horizontally.\n */\nexport class ClientCoordinates {\n    constructor(clientX, clientY) {\n        this.clientX = clientX;\n        this.clientY = clientY;\n        this._clientCoordinatesBrand = undefined;\n    }\n    toPageCoordinates(targetWindow) {\n        return new PageCoordinates(this.clientX + targetWindow.scrollX, this.clientY + targetWindow.scrollY);\n    }\n}\n/**\n * The position of the editor in the page.\n */\nexport class EditorPagePosition {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this._editorPagePositionBrand = undefined;\n    }\n}\n/**\n * Coordinates relative to the the (top;left) of the editor that can be used safely with other internal editor metrics.\n * **NOTE**: This position is obtained by taking page coordinates and transforming them relative to the\n * editor's (top;left) position in a way in which scale transformations are taken into account.\n * **NOTE**: These coordinates could be negative if the mouse position is outside the editor.\n */\nexport class CoordinatesRelativeToEditor {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this._positionRelativeToEditorBrand = undefined;\n    }\n}\nexport function createEditorPagePosition(editorViewDomNode) {\n    const editorPos = dom.getDomNodePagePosition(editorViewDomNode);\n    return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);\n}\nexport function createCoordinatesRelativeToEditor(editorViewDomNode, editorPagePosition, pos) {\n    // The editor's page position is read from the DOM using getBoundingClientRect().\n    //\n    // getBoundingClientRect() returns the actual dimensions, while offsetWidth and offsetHeight\n    // reflect the unscaled size. We can use this difference to detect a transform:scale()\n    // and we will apply the transformation in inverse to get mouse coordinates that make sense inside the editor.\n    //\n    // This could be expanded to cover rotation as well maybe by walking the DOM up from `editorViewDomNode`\n    // and computing the effective transformation matrix using getComputedStyle(element).transform.\n    //\n    const scaleX = editorPagePosition.width / editorViewDomNode.offsetWidth;\n    const scaleY = editorPagePosition.height / editorViewDomNode.offsetHeight;\n    // Adjust mouse offsets if editor appears to be scaled via transforms\n    const relativeX = (pos.x - editorPagePosition.x) / scaleX;\n    const relativeY = (pos.y - editorPagePosition.y) / scaleY;\n    return new CoordinatesRelativeToEditor(relativeX, relativeY);\n}\nexport class EditorMouseEvent extends StandardMouseEvent {\n    constructor(e, isFromPointerCapture, editorViewDomNode) {\n        super(dom.getWindow(editorViewDomNode), e);\n        this._editorMouseEventBrand = undefined;\n        this.isFromPointerCapture = isFromPointerCapture;\n        this.pos = new PageCoordinates(this.posx, this.posy);\n        this.editorPos = createEditorPagePosition(editorViewDomNode);\n        this.relativePos = createCoordinatesRelativeToEditor(editorViewDomNode, this.editorPos, this.pos);\n    }\n}\nexport class EditorMouseEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, false, this._editorViewDomNode);\n    }\n    onContextMenu(target, callback) {\n        return dom.addDisposableListener(target, 'contextmenu', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseUp(target, callback) {\n        return dom.addDisposableListener(target, 'mouseup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.MOUSE_DOWN, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_DOWN, (e) => {\n            callback(this._create(e), e.pointerId);\n        });\n    }\n    onMouseLeave(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.MOUSE_LEAVE, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onMouseMove(target, callback) {\n        return dom.addDisposableListener(target, 'mousemove', (e) => callback(this._create(e)));\n    }\n}\nexport class EditorPointerEventFactory {\n    constructor(editorViewDomNode) {\n        this._editorViewDomNode = editorViewDomNode;\n    }\n    _create(e) {\n        return new EditorMouseEvent(e, false, this._editorViewDomNode);\n    }\n    onPointerUp(target, callback) {\n        return dom.addDisposableListener(target, 'pointerup', (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerDown(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_DOWN, (e) => {\n            callback(this._create(e), e.pointerId);\n        });\n    }\n    onPointerLeave(target, callback) {\n        return dom.addDisposableListener(target, dom.EventType.POINTER_LEAVE, (e) => {\n            callback(this._create(e));\n        });\n    }\n    onPointerMove(target, callback) {\n        return dom.addDisposableListener(target, 'pointermove', (e) => callback(this._create(e)));\n    }\n}\nexport class GlobalEditorPointerMoveMonitor extends Disposable {\n    constructor(editorViewDomNode) {\n        super();\n        this._editorViewDomNode = editorViewDomNode;\n        this._globalPointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());\n        this._keydownListener = null;\n    }\n    startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {\n        // Add a <<capture>> keydown event listener that will cancel the monitoring\n        // if something other than a modifier key is pressed\n        this._keydownListener = dom.addStandardDisposableListener(initialElement.ownerDocument, 'keydown', (e) => {\n            const chord = e.toKeyCodeChord();\n            if (chord.isModifierKey()) {\n                // Allow modifier keys\n                return;\n            }\n            this._globalPointerMoveMonitor.stopMonitoring(true, e.browserEvent);\n        }, true);\n        this._globalPointerMoveMonitor.startMonitoring(initialElement, pointerId, initialButtons, (e) => {\n            pointerMoveCallback(new EditorMouseEvent(e, true, this._editorViewDomNode));\n        }, (e) => {\n            this._keydownListener.dispose();\n            onStopCallback(e);\n        });\n    }\n    stopMonitoring() {\n        this._globalPointerMoveMonitor.stopMonitoring(true);\n    }\n}\n/**\n * A helper to create dynamic css rules, bound to a class name.\n * Rules are reused.\n * Reference counting and delayed garbage collection ensure that no rules leak.\n*/\nexport class DynamicCssRules {\n    static { this._idPool = 0; }\n    constructor(_editor) {\n        this._editor = _editor;\n        this._instanceId = ++DynamicCssRules._idPool;\n        this._counter = 0;\n        this._rules = new Map();\n        // We delay garbage collection so that hanging rules can be reused.\n        this._garbageCollectionScheduler = new RunOnceScheduler(() => this.garbageCollect(), 1000);\n    }\n    createClassNameRef(options) {\n        const rule = this.getOrCreateRule(options);\n        rule.increaseRefCount();\n        return {\n            className: rule.className,\n            dispose: () => {\n                rule.decreaseRefCount();\n                this._garbageCollectionScheduler.schedule();\n            }\n        };\n    }\n    getOrCreateRule(properties) {\n        const key = this.computeUniqueKey(properties);\n        let existingRule = this._rules.get(key);\n        if (!existingRule) {\n            const counter = this._counter++;\n            existingRule = new RefCountedCssRule(key, `dyn-rule-${this._instanceId}-${counter}`, dom.isInShadowDOM(this._editor.getContainerDomNode())\n                ? this._editor.getContainerDomNode()\n                : undefined, properties);\n            this._rules.set(key, existingRule);\n        }\n        return existingRule;\n    }\n    computeUniqueKey(properties) {\n        return JSON.stringify(properties);\n    }\n    garbageCollect() {\n        for (const rule of this._rules.values()) {\n            if (!rule.hasReferences()) {\n                this._rules.delete(rule.key);\n                rule.dispose();\n            }\n        }\n    }\n}\nclass RefCountedCssRule {\n    constructor(key, className, _containerElement, properties) {\n        this.key = key;\n        this.className = className;\n        this.properties = properties;\n        this._referenceCount = 0;\n        this._styleElementDisposables = new DisposableStore();\n        this._styleElement = dom.createStyleSheet(_containerElement, undefined, this._styleElementDisposables);\n        this._styleElement.textContent = this.getCssText(this.className, this.properties);\n    }\n    getCssText(className, properties) {\n        let str = `.${className} {`;\n        for (const prop in properties) {\n            const value = properties[prop];\n            let cssValue;\n            if (typeof value === 'object') {\n                cssValue = asCssVariable(value.id);\n            }\n            else {\n                cssValue = value;\n            }\n            const cssPropName = camelToDashes(prop);\n            str += `\\n\\t${cssPropName}: ${cssValue};`;\n        }\n        str += `\\n}`;\n        return str;\n    }\n    dispose() {\n        this._styleElementDisposables.dispose();\n        this._styleElement = undefined;\n    }\n    increaseRefCount() {\n        this._referenceCount++;\n    }\n    decreaseRefCount() {\n        this._referenceCount--;\n    }\n    hasReferences() {\n        return this._referenceCount > 0;\n    }\n}\nfunction camelToDashes(str) {\n    return str.replace(/(^[A-Z])/, ([first]) => first.toLowerCase())\n        .replace(/([A-Z])/g, ([letter]) => `-${letter.toLowerCase()}`);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nclass UnknownHitTestResult {\n    constructor(hitTarget = null) {\n        this.hitTarget = hitTarget;\n        this.type = 0 /* HitTestResultType.Unknown */;\n    }\n}\nclass ContentHitTestResult {\n    get hitTarget() { return this.spanNode; }\n    constructor(position, spanNode, injectedText) {\n        this.position = position;\n        this.spanNode = spanNode;\n        this.injectedText = injectedText;\n        this.type = 1 /* HitTestResultType.Content */;\n    }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n    function createFromDOMInfo(ctx, spanNode, offset) {\n        const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n        if (position) {\n            return new ContentHitTestResult(position, spanNode, null);\n        }\n        return new UnknownHitTestResult(spanNode);\n    }\n    HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    static _deduceRage(position, range = null) {\n        if (!range && position) {\n            return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        return range ?? null;\n    }\n    static createUnknown(element, mouseColumn, position) {\n        return { type: 0 /* MouseTargetType.UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createTextarea(element, mouseColumn) {\n        return { type: 1 /* MouseTargetType.TEXTAREA */, element, mouseColumn, position: null, range: null };\n    }\n    static createMargin(type, element, mouseColumn, position, range, detail) {\n        return { type, element, mouseColumn, position, range, detail };\n    }\n    static createViewZone(type, element, mouseColumn, position, detail) {\n        return { type, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentText(element, mouseColumn, position, range, detail) {\n        return { type: 6 /* MouseTargetType.CONTENT_TEXT */, element, mouseColumn, position, range: this._deduceRage(position, range), detail };\n    }\n    static createContentEmpty(element, mouseColumn, position, detail) {\n        return { type: 7 /* MouseTargetType.CONTENT_EMPTY */, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentWidget(element, mouseColumn, detail) {\n        return { type: 9 /* MouseTargetType.CONTENT_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createScrollbar(element, mouseColumn, position) {\n        return { type: 11 /* MouseTargetType.SCROLLBAR */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createOverlayWidget(element, mouseColumn, detail) {\n        return { type: 12 /* MouseTargetType.OVERLAY_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {\n        return { type: 13 /* MouseTargetType.OUTSIDE_EDITOR */, element: null, mouseColumn, position, range: this._deduceRage(position), outsidePosition, outsideDistance };\n    }\n    static _typeToString(type) {\n        if (type === 1 /* MouseTargetType.TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 7 /* PartFingerprint.TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 6 /* PartFingerprint.ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 9 /* PartFingerprint.Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 1 /* PartFingerprint.ContentWidgets */);\n    }\n    static isChildOfOverflowGuard(path) {\n        return (path.length >= 1\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 4 /* PartFingerprint.OverlayWidgets */);\n    }\n    static isChildOfOverflowingOverlayWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 5 /* PartFingerprint.OverflowingOverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.viewModel = context.viewModel;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.stickyTabStops = options.get(117 /* EditorOption.stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.viewModel.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.viewModel.getLineCount();\n            const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== element.ownerDocument.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.relativePos = relativePos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    get target() {\n        if (this._useHitTestTarget) {\n            return this.hitTestResult.value.hitTarget;\n        }\n        return this._eventTarget;\n    }\n    get targetPath() {\n        if (this._targetPathCacheElement !== this.target) {\n            this._targetPathCacheElement = this.target;\n            this._targetPathCacheValue = PartFingerprints.collect(this.target, this._ctx.viewDomNode);\n        }\n        return this._targetPathCacheValue;\n    }\n    constructor(ctx, editorPos, pos, relativePos, eventTarget) {\n        super(ctx, editorPos, pos, relativePos);\n        this.hitTestResult = new Lazy(() => MouseTargetFactory.doHitTest(this._ctx, this));\n        this._targetPathCacheElement = null;\n        this._targetPathCacheValue = new Uint8Array(0);\n        this._ctx = ctx;\n        this._eventTarget = eventTarget;\n        // If no event target is passed in, we will use the hit test target\n        const hasEventTarget = Boolean(this._eventTarget);\n        this._useHitTestTarget = !hasEventTarget;\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    get wouldBenefitFromHitTestTargetSwitch() {\n        return (!this._useHitTestTarget\n            && this.hitTestResult.value.hitTarget !== null\n            && this.target !== this.hitTestResult.value.hitTarget);\n    }\n    switchToHitTestTarget() {\n        this._useHitTestTarget = true;\n    }\n    _getMouseColumn(position = null) {\n        if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n        }\n        return this.mouseColumn;\n    }\n    fulfillUnknown(position = null) {\n        return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillTextarea() {\n        return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n    fulfillMargin(type, position, range, detail) {\n        return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillViewZone(type, position, detail) {\n        return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentText(position, range, detail) {\n        return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillContentEmpty(position, detail) {\n        return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentWidget(detail) {\n        return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n    fulfillScrollbar(position) {\n        return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillOverlayWidget(detail) {\n        return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path) || ElementPath.isChildOfOverflowingOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request);\n            if (r.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n                // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n                if (ctx.stickyTabStops && r.position !== null) {\n                    const position = MouseTargetFactory._snapToSoftTabBoundary(r.position, ctx.viewModel);\n                    const range = EditorRange.fromPositions(position, position).plusRange(r.range);\n                    return request.fulfillContentText(position, range, r.detail);\n                }\n            }\n            // console.log(MouseTarget.toString(r));\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfillUnknown();\n        }\n    }\n    static _createMouseTarget(ctx, request) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        if (request.target === null) {\n            // No target\n            return request.fulfillUnknown();\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        if (!ElementPath.isChildOfOverflowGuard(request.targetPath) && !ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) && !ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            // We only render dom nodes inside the overflow guard or in the overflowing content widgets\n            result = result || request.fulfillUnknown();\n        }\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfillUnknown());\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillContentWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath) || ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillOverlayWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */);\n            return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: false, injectedText: null });\n            }\n            return request.fulfillTextarea();\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.relativePos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                const modelCoordinate = ctx.viewModel.coordinatesConverter.convertViewPositionToModelPosition(res.range.getStartPosition());\n                const lanes = ctx.viewModel.glyphLanes.getLanesAtLine(modelCoordinate.lineNumber);\n                detail.glyphMarginLane = lanes[Math.floor(offset / ctx.lineHeight)];\n                return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.viewModel.getLineCount();\n            const maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n            return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n        // See https://github.com/microsoft/vscode/issues/46942\n        if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n            const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n            }\n            const lineWidth = ctx.getLineWidth(lineNumber);\n            if (request.mouseContentHorizontalOffset >= lineWidth) {\n                // TODO: This is wrong for RTL\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                const pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n                return request.fulfillContentEmpty(pos, detail);\n            }\n        }\n        // Do the hit test (if not already done)\n        const hitTestResult = request.hitTestResult.value;\n        if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n        }\n        // We didn't hit content...\n        if (request.wouldBenefitFromHitTestTargetSwitch) {\n            // We actually hit something different... Give it one last change by trying again with this new target\n            request.switchToHitTestTarget();\n            return this._createMouseTarget(ctx, request);\n        }\n        // We have tried everything...\n        return request.fulfillUnknown();\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(relativePos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n        const lineNumber = pos.lineNumber;\n        const column = pos.column;\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfillContentEmpty(pos, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfillUnknown(pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (Math.abs(request.mouseContentHorizontalOffset - columnHorizontalOffset) < 1) {\n            return request.fulfillContentText(pos, null, { mightBeForeignElement: !!injectedText, injectedText });\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        const mouseCoordinates = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));\n        const spanNodeClientRect = spanNode.getBoundingClientRect();\n        const mouseIsOverSpanNode = (spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right);\n        let rng = null;\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                // See https://github.com/microsoft/vscode/issues/152819\n                // Due to the use of zwj, the browser's hit test result is skewed towards the left\n                // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n                const prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n                const nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n                pos = (prevDelta < nextDelta\n                    ? new Position(lineNumber, prev.column)\n                    : new Position(lineNumber, curr.column));\n                break;\n            }\n        }\n        return request.fulfillContentText(pos, rng, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;\n        const isBelowLastLine = (lineNumber === ctx.viewModel.getLineCount()\n            && request.mouseVerticalOffset > lineEndVerticalOffset);\n        if (!isBelowLastLine) {\n            const lineCenteredVerticalOffset = Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2);\n            let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n            if (adjustedPageY <= request.editorPos.y) {\n                adjustedPageY = request.editorPos.y + 1;\n            }\n            if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n                adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n            }\n            const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n            const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n            if (r.type === 1 /* HitTestResultType.Content */) {\n                return r;\n            }\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return new UnknownHitTestResult();\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer.parentNode);\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer);\n            }\n        }\n        return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n            }\n            else {\n                return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n            }\n        }\n        return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.model.getOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static doHitTest(ctx, request) {\n        let result = new UnknownHitTestResult();\n        if (typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (ctx.viewDomNode.ownerDocument.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n        }\n        if (result.type === 1 /* HitTestResultType.Content */) {\n            const injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n            const normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n            if (injectedText || !normalizedPosition.equals(result.position)) {\n                result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n            }\n        }\n        return result;\n    }\n}\nfunction shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font (the computed shorthand font property might be empty, see #3217)\n        const elWindow = dom.getWindow(el);\n        const fontStyle = elWindow.getComputedStyle(el, null).getPropertyValue('font-style');\n        const fontVariant = elWindow.getComputedStyle(el, null).getPropertyValue('font-variant');\n        const fontWeight = elWindow.getComputedStyle(el, null).getPropertyValue('font-weight');\n        const fontSize = elWindow.getComputedStyle(el, null).getPropertyValue('font-size');\n        const lineHeight = elWindow.getComputedStyle(el, null).getPropertyValue('line-height');\n        const fontFamily = elWindow.getComputedStyle(el, null).getPropertyValue('font-family');\n        const font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    static { this._INSTANCE = null; }\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    static { this.EMPTY = new TextAreaState('', 0, 0, null, undefined); }\n    constructor(value, \n    /** the offset where selection starts inside `value` */\n    selectionStart, \n    /** the offset where selection ends inside `value` */\n    selectionEnd, \n    /** the editor range in the view coordinate system that matches the selection inside `value` */\n    selection, \n    /** the visible line count (wrapped, not necessarily matching \\n characters) for the text in `value` before `selectionStart` */\n    newlineCountBeforeSelection) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selection = selection;\n        this.newlineCountBeforeSelection = newlineCountBeforeSelection;\n    }\n    toString() {\n        return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;\n    }\n    static readFromTextArea(textArea, previousState) {\n        const value = textArea.getValue();\n        const selectionStart = textArea.getSelectionStart();\n        const selectionEnd = textArea.getSelectionEnd();\n        let newlineCountBeforeSelection = undefined;\n        if (previousState) {\n            const valueBeforeSelectionStart = value.substring(0, selectionStart);\n            const previousValueBeforeSelectionStart = previousState.value.substring(0, previousState.selectionStart);\n            if (valueBeforeSelectionStart === previousValueBeforeSelectionStart) {\n                newlineCountBeforeSelection = previousState.newlineCountBeforeSelection;\n            }\n        }\n        return new TextAreaState(value, selectionStart, selectionEnd, null, newlineCountBeforeSelection);\n    }\n    collapseSelection() {\n        if (this.selectionStart === this.value.length) {\n            return this;\n        }\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, undefined);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log(`writeToTextArea ${reason}: ${this.toString()}`);\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // no current selection\n            const replacePreviousCharacters = (previousState.selectionStart - prefixLength);\n            if (_debugComposition) {\n                console.log(`REMOVE PREVIOUS: ${replacePreviousCharacters} chars`);\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(model, selection, linesPerPage, trimLongText) {\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        const LIMIT_CHARS = 500;\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        let pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        if (trimLongText && model.getValueLengthInRange(pretextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n            const pretextStart = model.modifyPosition(pretextRange.getEndPosition(), -LIMIT_CHARS);\n            pretextRange = Range.fromPositions(pretextStart, pretextRange.getEndPosition());\n        }\n        const pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        let posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        if (trimLongText && model.getValueLengthInRange(posttextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n            const posttextEnd = model.modifyPosition(posttextRange.getStartPosition(), LIMIT_CHARS);\n            posttextRange = Range.fromPositions(posttextRange.getStartPosition(), posttextEnd);\n        }\n        const posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */));\n        }\n        if (trimLongText && text.length > 2 * LIMIT_CHARS) {\n            text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, selection, pretextRange.endLineNumber - pretextRange.startLineNumber);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    static { this.INSTANCE = new InMemoryClipboardMetadataManager(); }\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nlet TextAreaInput = class TextAreaInput extends Disposable {\n    get textAreaState() {\n        return this._textAreaState;\n    }\n    constructor(_host, _textArea, _OS, _browser, _accessibilityService, _logService) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._accessibilityService = _accessibilityService;\n        this._logService = _logService;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new MutableDisposable());\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        if (this._accessibilityService.isScreenReaderOptimized()) {\n            this.writeNativeTextAreaContent('ctor');\n        }\n        this._register(Event.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {\n            if (this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value) {\n                this._asyncFocusGainWriteScreenReaderContent.value = this._register(new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0));\n            }\n            else {\n                this._asyncFocusGainWriteScreenReaderContent.clear();\n            }\n        }));\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n                // one character was typed\n                if (strings.isHighSurrogate(typeInput.text.charCodeAt(0))\n                    || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n                    // Ignore invalid input but keep it around for next time\n                    return;\n                }\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                if (!this._asyncFocusGainWriteScreenReaderContent.value) {\n                    this._asyncFocusGainWriteScreenReaderContent.value = new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0);\n                }\n                this._asyncFocusGainWriteScreenReaderContent.value.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', (e) => {\n            inputLatency.onSelectionChange();\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selection) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeNativeTextAreaContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeNativeTextAreaContent(reason) {\n        if ((!this._accessibilityService.isScreenReaderOptimized() && reason === 'render') || this._currentComposition) {\n            // Do not write to the text on render unless a screen reader is being used #192278\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._logService.trace(`writeTextAreaState(reason: ${reason})`);\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n};\nTextAreaInput = __decorate([\n    __param(4, IAccessibilityService),\n    __param(5, ILogService)\n], TextAreaInput);\nexport { TextAreaInput };\nexport const ClipboardEventUtils = {\n    getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    },\n    setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n};\nexport class TextAreaWrapper extends Disposable {\n    get ownerDocument() {\n        return this._actual.ownerDocument;\n    }\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n        this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n        this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n        this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n        this._register(this.onInput(() => inputLatency.onInput()));\n        this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (this._actual.isConnected) {\n            return dom.getActiveElement() === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = dom.getActiveElement();\n        }\n        const activeWindow = dom.getWindow(activeElement);\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nclass VisibleTextAreaData {\n    constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n        this._context = _context;\n        this.modelLineNumber = modelLineNumber;\n        this.distanceToModelLineStart = distanceToModelLineStart;\n        this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n        this.distanceToModelLineEnd = distanceToModelLineEnd;\n        this._visibleTextAreaBrand = undefined;\n        this.startPosition = null;\n        this.endPosition = null;\n        this.visibleTextareaStart = null;\n        this.visibleTextareaEnd = null;\n        /**\n         * When doing composition, the currently composed text might be split up into\n         * multiple tokens, then merged again into a single token, etc. Here we attempt\n         * to keep the presentation of the <textarea> stable by using the previous used\n         * style if multiple tokens come into play. This avoids flickering.\n         */\n        this._previousPresentation = null;\n    }\n    prepareRender(visibleRangeProvider) {\n        const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n        const endModelPosition = new Position(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n        this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n        this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n        if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n            this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n            this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n        }\n        else {\n            // TODO: what if the view positions are not on the same line?\n            this.visibleTextareaStart = null;\n            this.visibleTextareaEnd = null;\n        }\n    }\n    definePresentation(tokenPresentation) {\n        if (!this._previousPresentation) {\n            // To avoid flickering, once set, always reuse a presentation throughout the entire IME session\n            if (tokenPresentation) {\n                this._previousPresentation = tokenPresentation;\n            }\n            else {\n                this._previousPresentation = {\n                    foreground: 1 /* ColorId.DefaultForeground */,\n                    italic: false,\n                    bold: false,\n                    underline: false,\n                    strikethrough: false,\n                };\n            }\n        }\n        return this._previousPresentation;\n    }\n}\nconst canUseZeroSizeTextarea = (browser.isFirefox);\nlet TextAreaHandler = class TextAreaHandler extends ViewPart {\n    constructor(context, viewController, visibleRangeProvider, _keybindingService, _instantiationService) {\n        super(context);\n        this._keybindingService = _keybindingService;\n        this._instantiationService = _instantiationService;\n        this._primaryCursorPosition = new Position(1, 1);\n        this._primaryCursorVisibleRange = null;\n        this._viewController = viewController;\n        this._visibleRangeProvider = visibleRangeProvider;\n        this._scrollLeft = 0;\n        this._scrollTop = 0;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this._visibleTextArea = null;\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._modelSelections = [new Selection(1, 1, 1, 1)];\n        this._lastRenderPosition = null;\n        // Text Area (The focus will always be in the textarea when the cursor is blinking)\n        this.textArea = createFastDomNode(document.createElement('textarea'));\n        PartFingerprints.write(this.textArea, 7 /* PartFingerprint.TextArea */);\n        this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n        const { tabSize } = this._context.viewModel.model.getOptions();\n        this.textArea.domNode.style.tabSize = `${tabSize * this._fontInfo.spaceWidth}px`;\n        this.textArea.setAttribute('autocorrect', 'off');\n        this.textArea.setAttribute('autocapitalize', 'off');\n        this.textArea.setAttribute('autocomplete', 'off');\n        this.textArea.setAttribute('spellcheck', 'false');\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n        this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n        this.textArea.setAttribute('role', 'textbox');\n        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n        this.textArea.setAttribute('aria-multiline', 'true');\n        this.textArea.setAttribute('aria-autocomplete', options.get(92 /* EditorOption.readOnly */) ? 'none' : 'both');\n        this._ensureReadOnlyAttribute();\n        this.textAreaCover = createFastDomNode(document.createElement('div'));\n        this.textAreaCover.setPosition('absolute');\n        const simpleModel = {\n            getLineCount: () => {\n                return this._context.viewModel.getLineCount();\n            },\n            getLineMaxColumn: (lineNumber) => {\n                return this._context.viewModel.getLineMaxColumn(lineNumber);\n            },\n            getValueInRange: (range, eol) => {\n                return this._context.viewModel.getValueInRange(range, eol);\n            },\n            getValueLengthInRange: (range, eol) => {\n                return this._context.viewModel.getValueLengthInRange(range, eol);\n            },\n            modifyPosition: (position, offset) => {\n                return this._context.viewModel.modifyPosition(position, offset);\n            }\n        };\n        const textAreaInputHost = {\n            getDataToCopy: () => {\n                const rawTextToCopy = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n                const newLineCharacter = this._context.viewModel.model.getEOL();\n                const isFromEmptySelection = (this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty());\n                const multicursorText = (Array.isArray(rawTextToCopy) ? rawTextToCopy : null);\n                const text = (Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy);\n                let html = undefined;\n                let mode = null;\n                if (CopyOptions.forceCopyWithSyntaxHighlighting || (this._copyWithSyntaxHighlighting && text.length < 65536)) {\n                    const richText = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n                    if (richText) {\n                        html = richText.html;\n                        mode = richText.mode;\n                    }\n                }\n                return {\n                    isFromEmptySelection,\n                    multicursorText,\n                    text,\n                    html,\n                    mode\n                };\n            },\n            getScreenReaderContent: () => {\n                if (this._accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n                    // We know for a fact that a screen reader is not attached\n                    // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n                    const selection = this._selections[0];\n                    if (platform.isMacintosh && selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        let textBefore = this._getWordBeforePosition(position);\n                        if (textBefore.length === 0) {\n                            textBefore = this._getCharacterBeforePosition(position);\n                        }\n                        if (textBefore.length > 0) {\n                            return new TextAreaState(textBefore, textBefore.length, textBefore.length, Range.fromPositions(position), 0);\n                        }\n                    }\n                    // on macOS, write current selection into textarea will allow system text services pick selected text,\n                    // but we still want to limit the amount of text given Chromium handles very poorly text even of a few\n                    // thousand chars\n                    // (https://github.com/microsoft/vscode/issues/27799)\n                    const LIMIT_CHARS = 500;\n                    if (platform.isMacintosh && !selection.isEmpty() && simpleModel.getValueLengthInRange(selection, 0 /* EndOfLinePreference.TextDefined */) < LIMIT_CHARS) {\n                        const text = simpleModel.getValueInRange(selection, 0 /* EndOfLinePreference.TextDefined */);\n                        return new TextAreaState(text, 0, text.length, selection, 0);\n                    }\n                    // on Safari, document.execCommand('cut') and document.execCommand('copy') will just not work\n                    // if the textarea has no content selected. So if there is an editor selection, ensure something\n                    // is selected in the textarea.\n                    if (browser.isSafari && !selection.isEmpty()) {\n                        const placeholderText = 'vscode-placeholder';\n                        return new TextAreaState(placeholderText, 0, placeholderText.length, null, undefined);\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                if (browser.isAndroid) {\n                    // when tapping in the editor on a word, Android enters composition mode.\n                    // in the `compositionstart` event we cannot clear the textarea, because\n                    // it then forgets to ever send a `compositionend`.\n                    // we therefore only write the current word in the textarea\n                    const selection = this._selections[0];\n                    if (selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n                        if (wordAtPosition.length > 0) {\n                            return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, Range.fromPositions(position), 0);\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                return PagedScreenReaderStrategy.fromEditorSelection(simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* AccessibilitySupport.Unknown */);\n            },\n            deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n                return this._context.viewModel.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n            }\n        };\n        const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n        this._textAreaInput = this._register(this._instantiationService.createInstance(TextAreaInput, textAreaInputHost, textAreaWrapper, platform.OS, {\n            isAndroid: browser.isAndroid,\n            isChrome: browser.isChrome,\n            isFirefox: browser.isFirefox,\n            isSafari: browser.isSafari,\n        }));\n        this._register(this._textAreaInput.onKeyDown((e) => {\n            this._viewController.emitKeyDown(e);\n        }));\n        this._register(this._textAreaInput.onKeyUp((e) => {\n            this._viewController.emitKeyUp(e);\n        }));\n        this._register(this._textAreaInput.onPaste((e) => {\n            let pasteOnNewLine = false;\n            let multicursorText = null;\n            let mode = null;\n            if (e.metadata) {\n                pasteOnNewLine = (this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection);\n                multicursorText = (typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null);\n                mode = e.metadata.mode;\n            }\n            this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n        }));\n        this._register(this._textAreaInput.onCut(() => {\n            this._viewController.cut();\n        }));\n        this._register(this._textAreaInput.onType((e) => {\n            if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n                // must be handled through the new command\n                if (_debugComposition) {\n                    console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n                }\n                this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n            }\n            else {\n                if (_debugComposition) {\n                    console.log(` => type: <<${e.text}>>`);\n                }\n                this._viewController.type(e.text);\n            }\n        }));\n        this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {\n            this._viewController.setSelection(modelSelection);\n        }));\n        this._register(this._textAreaInput.onCompositionStart((e) => {\n            // The textarea might contain some content when composition starts.\n            //\n            // When we make the textarea visible, it always has a height of 1 line,\n            // so we don't need to worry too much about content on lines above or below\n            // the selection.\n            //\n            // However, the text on the current line needs to be made visible because\n            // some IME methods allow to move to other glyphs on the current line\n            // (by pressing arrow keys).\n            //\n            // (1) The textarea might contain only some parts of the current line,\n            // like the word before the selection. Also, the content inside the textarea\n            // can grow or shrink as composition occurs. We therefore anchor the textarea\n            // in terms of distance to a certain line start and line end.\n            //\n            // (2) Also, we should not make \\t characters visible, because their rendering\n            // inside the <textarea> will not align nicely with our rendering. We therefore\n            // will hide (if necessary) some of the leading text on the current line.\n            const ta = this.textArea.domNode;\n            const modelSelection = this._modelSelections[0];\n            const { distanceToModelLineStart, widthOfHiddenTextBefore } = (() => {\n                // Find the text that is on the current line before the selection\n                const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n                const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1);\n                // We now search to see if we should hide some part of it (if it contains \\t)\n                const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n                const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n                const startModelPosition = modelSelection.getStartPosition();\n                const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n                const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n                const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n                const { tabSize } = this._context.viewModel.model.getOptions();\n                const widthOfHiddenTextBefore = measureText(this.textArea.domNode.ownerDocument, hiddenLineTextBefore, this._fontInfo, tabSize);\n                return { distanceToModelLineStart, widthOfHiddenTextBefore };\n            })();\n            const { distanceToModelLineEnd } = (() => {\n                // Find the text that is on the current line after the selection\n                const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n                const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n                const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n                const desiredVisibleAfterCharCount = (tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1);\n                const endModelPosition = modelSelection.getEndPosition();\n                const visibleAfterCharCount = Math.min(this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n                const distanceToModelLineEnd = this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n                return { distanceToModelLineEnd };\n            })();\n            // Scroll to reveal the location in the editor where composition occurs\n            this._context.viewModel.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0 /* viewEvents.VerticalRevealType.Simple */, 1 /* ScrollType.Immediate */);\n            this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n            // We turn off wrapping if the <textarea> becomes visible for composition\n            this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n            // Show the textarea\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n            this._viewController.compositionStart();\n            this._context.viewModel.onCompositionStart();\n        }));\n        this._register(this._textAreaInput.onCompositionUpdate((e) => {\n            if (!this._visibleTextArea) {\n                return;\n            }\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n        }));\n        this._register(this._textAreaInput.onCompositionEnd(() => {\n            this._visibleTextArea = null;\n            // We turn on wrapping as necessary if the <textarea> hides after composition\n            this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n            this._render();\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n            this._viewController.compositionEnd();\n            this._context.viewModel.onCompositionEnd();\n        }));\n        this._register(this._textAreaInput.onFocus(() => {\n            this._context.viewModel.setHasFocus(true);\n        }));\n        this._register(this._textAreaInput.onBlur(() => {\n            this._context.viewModel.setHasFocus(false);\n        }));\n        this._register(IME.onDidChange(() => {\n            this._ensureReadOnlyAttribute();\n        }));\n    }\n    writeScreenReaderContent(reason) {\n        this._textAreaInput.writeNativeTextAreaContent(reason);\n    }\n    dispose() {\n        super.dispose();\n    }\n    _getAndroidWordAtPosition(position) {\n        const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS, []);\n        let goingLeft = true;\n        let startColumn = position.column;\n        let goingRight = true;\n        let endColumn = position.column;\n        let distance = 0;\n        while (distance < 50 && (goingLeft || goingRight)) {\n            if (goingLeft && startColumn <= 1) {\n                goingLeft = false;\n            }\n            if (goingLeft) {\n                const charCode = lineContent.charCodeAt(startColumn - 2);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingLeft = false;\n                }\n                else {\n                    startColumn--;\n                }\n            }\n            if (goingRight && endColumn > lineContent.length) {\n                goingRight = false;\n            }\n            if (goingRight) {\n                const charCode = lineContent.charCodeAt(endColumn - 1);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingRight = false;\n                }\n                else {\n                    endColumn++;\n                }\n            }\n            distance++;\n        }\n        return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n    }\n    _getWordBeforePosition(position) {\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(132 /* EditorOption.wordSeparators */), []);\n        let column = position.column;\n        let distance = 0;\n        while (column > 1) {\n            const charCode = lineContent.charCodeAt(column - 2);\n            const charClass = wordSeparators.get(charCode);\n            if (charClass !== 0 /* WordCharacterClass.Regular */ || distance > 50) {\n                return lineContent.substring(column - 1, position.column - 1);\n            }\n            distance++;\n            column--;\n        }\n        return lineContent.substring(0, position.column - 1);\n    }\n    _getCharacterBeforePosition(position) {\n        if (position.column > 1) {\n            const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n            const charBefore = lineContent.charAt(position.column - 2);\n            if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n                return charBefore;\n            }\n        }\n        return '';\n    }\n    _getAriaLabel(options) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n            const toggleKeybindingLabel = this._keybindingService.lookupKeybinding('editor.action.toggleScreenReaderAccessibilityMode')?.getAriaLabel();\n            const runCommandKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.showCommands')?.getAriaLabel();\n            const keybindingEditorKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.openGlobalKeybindings')?.getAriaLabel();\n            const editorNotAccessibleMessage = nls.localize('accessibilityModeOff', \"The editor is not accessible at this time.\");\n            if (toggleKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabel', \"{0} To enable screen reader optimized mode, use {1}\", editorNotAccessibleMessage, toggleKeybindingLabel);\n            }\n            else if (runCommandKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabelNoKb', \"{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.\", editorNotAccessibleMessage, runCommandKeybindingLabel);\n            }\n            else if (keybindingEditorKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabelNoKbs', \"{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.\", editorNotAccessibleMessage, keybindingEditorKeybindingLabel);\n            }\n            else {\n                // SOS\n                return editorNotAccessibleMessage;\n            }\n        }\n        return options.get(4 /* EditorOption.ariaLabel */);\n    }\n    _setAccessibilityOptions(options) {\n        this._accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        const accessibilityPageSize = options.get(3 /* EditorOption.accessibilityPageSize */);\n        if (this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n            // If a screen reader is attached and the default value is not set we should automatically increase the page size to 500 for a better experience\n            this._accessibilityPageSize = 500;\n        }\n        else {\n            this._accessibilityPageSize = accessibilityPageSize;\n        }\n        // When wrapping is enabled and a screen reader might be attached,\n        // we will size the textarea to match the width used for wrapping points computation (see `domLineBreaksComputer.ts`).\n        // This is because screen readers will read the text in the textarea and we'd like that the\n        // wrapping points in the textarea match the wrapping points in the editor.\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const wrappingColumn = layoutInfo.wrappingColumn;\n        if (wrappingColumn !== -1 && this._accessibilitySupport !== 1 /* AccessibilitySupport.Disabled */) {\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            this._textAreaWrapping = true;\n            this._textAreaWidth = Math.round(wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth);\n        }\n        else {\n            this._textAreaWrapping = false;\n            this._textAreaWidth = (canUseZeroSizeTextarea ? 0 : 1);\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n        const { tabSize } = this._context.viewModel.model.getOptions();\n        this.textArea.domNode.style.tabSize = `${tabSize * this._fontInfo.spaceWidth}px`;\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n        this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n        if (e.hasChanged(34 /* EditorOption.domReadOnly */) || e.hasChanged(92 /* EditorOption.readOnly */)) {\n            this._ensureReadOnlyAttribute();\n        }\n        if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n            this._textAreaInput.writeNativeTextAreaContent('strategy changed');\n        }\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        this._modelSelections = e.modelSelections.slice(0);\n        // We must update the <textarea> synchronously, otherwise long press IME on macos breaks.\n        // See https://github.com/microsoft/vscode/issues/165821\n        this._textAreaInput.writeNativeTextAreaContent('selection changed');\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollLeft = e.scrollLeft;\n        this._scrollTop = e.scrollTop;\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin view API\n    isFocused() {\n        return this._textAreaInput.isFocused();\n    }\n    focusTextArea() {\n        this._textAreaInput.focusTextArea();\n    }\n    getLastRenderData() {\n        return this._lastRenderPosition;\n    }\n    setAriaOptions(options) {\n        if (options.activeDescendant) {\n            this.textArea.setAttribute('aria-haspopup', 'true');\n            this.textArea.setAttribute('aria-autocomplete', 'list');\n            this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n        }\n        else {\n            this.textArea.setAttribute('aria-haspopup', 'false');\n            this.textArea.setAttribute('aria-autocomplete', 'both');\n            this.textArea.removeAttribute('aria-activedescendant');\n        }\n        if (options.role) {\n            this.textArea.setAttribute('role', options.role);\n        }\n    }\n    // --- end view API\n    _ensureReadOnlyAttribute() {\n        const options = this._context.configuration.options;\n        // When someone requests to disable IME, we set the \"readonly\" attribute on the <textarea>.\n        // This will prevent composition.\n        const useReadOnly = !IME.enabled || (options.get(34 /* EditorOption.domReadOnly */) && options.get(92 /* EditorOption.readOnly */));\n        if (useReadOnly) {\n            this.textArea.setAttribute('readonly', 'true');\n        }\n        else {\n            this.textArea.removeAttribute('readonly');\n        }\n    }\n    prepareRender(ctx) {\n        this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n        this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n        this._visibleTextArea?.prepareRender(ctx);\n    }\n    render(ctx) {\n        this._textAreaInput.writeNativeTextAreaContent('render');\n        this._render();\n    }\n    _render() {\n        if (this._visibleTextArea) {\n            // The text area is visible for composition reasons\n            const visibleStart = this._visibleTextArea.visibleTextareaStart;\n            const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n            const startPosition = this._visibleTextArea.startPosition;\n            const endPosition = this._visibleTextArea.endPosition;\n            if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n                const top = (this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop);\n                const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n                let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n                let left = (this._contentLeft + visibleStart.left - this._scrollLeft);\n                // See https://github.com/microsoft/vscode/issues/141725#issuecomment-1050670841\n                // Here we are adding +1 to avoid flickering that might be caused by having a width that is too small.\n                // This could be caused by rounding errors that might only show up with certain font families.\n                // In other words, a pixel might be lost when doing something like\n                //      `Math.round(end) - Math.round(start)`\n                // vs\n                //      `Math.round(end - start)`\n                let width = visibleEnd.left - visibleStart.left + 1;\n                if (left < this._contentLeft) {\n                    // the textarea would be rendered on top of the margin,\n                    // so reduce its width. We use the same technique as\n                    // for hiding text before\n                    const delta = (this._contentLeft - left);\n                    left += delta;\n                    scrollLeft += delta;\n                    width -= delta;\n                }\n                if (width > this._contentWidth) {\n                    // the textarea would be wider than the content width,\n                    // so reduce its width.\n                    width = this._contentWidth;\n                }\n                // Try to render the textarea with the color/font style to match the text under it\n                const viewLineData = this._context.viewModel.getViewLineData(startPosition.lineNumber);\n                const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n                const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n                const textareaSpansSingleToken = (startTokenIndex === endTokenIndex);\n                const presentation = this._visibleTextArea.definePresentation((textareaSpansSingleToken ? viewLineData.tokens.getPresentation(startTokenIndex) : null));\n                this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n                this.textArea.domNode.scrollLeft = scrollLeft;\n                this._doRender({\n                    lastRenderPosition: null,\n                    top: top,\n                    left: left,\n                    width: width,\n                    height: this._lineHeight,\n                    useCover: false,\n                    color: (TokenizationRegistry.getColorMap() || [])[presentation.foreground],\n                    italic: presentation.italic,\n                    bold: presentation.bold,\n                    underline: presentation.underline,\n                    strikethrough: presentation.strikethrough\n                });\n            }\n            return;\n        }\n        if (!this._primaryCursorVisibleRange) {\n            // The primary cursor is outside the viewport => place textarea to the top left\n            this._renderAtTopLeft();\n            return;\n        }\n        const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n        if (top < 0 || top > this._contentHeight) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n        if (platform.isMacintosh || this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // For the popup emoji input, we will make the text area as high as the line height\n            // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n            this._doRender({\n                lastRenderPosition: this._primaryCursorPosition,\n                top,\n                left: this._textAreaWrapping ? this._contentLeft : left,\n                width: this._textAreaWidth,\n                height: this._lineHeight,\n                useCover: false\n            });\n            // In case the textarea contains a word, we're going to try to align the textarea's cursor\n            // with our cursor by scrolling the textarea as much as possible\n            this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n            const lineCount = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n            this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n            return;\n        }\n        this._doRender({\n            lastRenderPosition: this._primaryCursorPosition,\n            top: top,\n            left: this._textAreaWrapping ? this._contentLeft : left,\n            width: this._textAreaWidth,\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: false\n        });\n    }\n    _newlinecount(text) {\n        let result = 0;\n        let startIndex = -1;\n        do {\n            startIndex = text.indexOf('\\n', startIndex + 1);\n            if (startIndex === -1) {\n                break;\n            }\n            result++;\n        } while (true);\n        return result;\n    }\n    _renderAtTopLeft() {\n        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n        // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n        this._doRender({\n            lastRenderPosition: null,\n            top: 0,\n            left: 0,\n            width: this._textAreaWidth,\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: true\n        });\n    }\n    _doRender(renderData) {\n        this._lastRenderPosition = renderData.lastRenderPosition;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        applyFontInfo(ta, this._fontInfo);\n        ta.setTop(renderData.top);\n        ta.setLeft(renderData.left);\n        ta.setWidth(renderData.width);\n        ta.setHeight(renderData.height);\n        ta.setColor(renderData.color ? Color.Format.CSS.formatHex(renderData.color) : '');\n        ta.setFontStyle(renderData.italic ? 'italic' : '');\n        if (renderData.bold) {\n            // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n            ta.setFontWeight('bold');\n        }\n        ta.setTextDecoration(`${renderData.underline ? ' underline' : ''}${renderData.strikethrough ? ' line-through' : ''}`);\n        tac.setTop(renderData.useCover ? renderData.top : 0);\n        tac.setLeft(renderData.useCover ? renderData.left : 0);\n        tac.setWidth(renderData.useCover ? renderData.width : 0);\n        tac.setHeight(renderData.useCover ? renderData.height : 0);\n        const options = this._context.configuration.options;\n        if (options.get(57 /* EditorOption.glyphMargin */)) {\n            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n        }\n        else {\n            if (options.get(68 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */) {\n                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n            }\n            else {\n                tac.setClassName('monaco-editor-background textAreaCover');\n            }\n        }\n    }\n};\nTextAreaHandler = __decorate([\n    __param(3, IKeybindingService),\n    __param(4, IInstantiationService)\n], TextAreaHandler);\nexport { TextAreaHandler };\nfunction measureText(targetDocument, text, fontInfo, tabSize) {\n    if (text.length === 0) {\n        return 0;\n    }\n    const container = targetDocument.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '-50000px';\n    container.style.width = '50000px';\n    const regularDomNode = targetDocument.createElement('span');\n    applyFontInfo(regularDomNode, fontInfo);\n    regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n    regularDomNode.style.tabSize = `${tabSize * fontInfo.spaceWidth}px`; // just like the textarea\n    regularDomNode.append(text);\n    container.appendChild(regularDomNode);\n    targetDocument.body.appendChild(container);\n    const res = regularDomNode.offsetWidth;\n    container.remove();\n    return res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.metadata = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class AutoIndentOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const indentationForSelections = [];\n            for (const selection of selections) {\n                const indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n                if (indentation === null) {\n                    // Auto indentation failed\n                    return;\n                }\n                indentationForSelections.push({ selection, indentation });\n            }\n            const autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n            return this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n        }\n        return;\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _findActualIndentationForSelection(config, model, selection, ch) {\n        const actualIndentation = getIndentActionForType(config, model, selection, ch, {\n            shiftIndent: (indentation) => {\n                return shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        const currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n        if (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n            return null;\n        }\n        return actualIndentation;\n    }\n    static _getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose) {\n        const commands = indentationForSelections.map(({ selection, indentation }) => {\n            if (autoClosingPairClose !== null) {\n                // Apply both auto closing pair edits and auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n                return new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n            }\n            else {\n                // Apply only auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n                return typeCommand(indentationEdit.range, indentationEdit.text, false);\n            }\n        });\n        const editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, editOptions);\n    }\n    static _getEditFromIndentationAndSelection(config, model, indentation, selection, ch, includeChInEdit = true) {\n        const startLineNumber = selection.startLineNumber;\n        const firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n        let text = config.normalizeIndentation(indentation);\n        if (firstNonWhitespaceColumn !== 0) {\n            const startLine = model.getLineContent(startLineNumber);\n            text += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n        }\n        text += includeChInEdit ? ch : '';\n        const range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n        return { range, text };\n    }\n}\nexport class AutoClosingOvertypeOperation {\n    static getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n        }\n        return;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n    static getEdits(config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        return;\n    }\n}\nexport class AutoClosingOpenCharTypeOperation {\n    static getEdits(config, model, selections, ch, chIsAlreadyTyped, isDoingComposition) {\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n            if (autoClosingPairClose !== null) {\n                return this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n            }\n        }\n        return;\n    }\n    static _runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n}\nexport class SurroundSelectionOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(config, selections, ch);\n        }\n        return;\n    }\n    static _runSurroundSelectionType(config, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexport class InterceptorElectricCharOperation {\n    static getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition) {\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        return;\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n}\nexport class SimpleCharacterTypeOperation {\n    static getEdits(prevEditOperationType, selections, ch) {\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class EnterOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        return;\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = unshiftIndent(config, r.indentation);\n                return typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class PasteOperation {\n    static getEdits(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substring(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substring(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\nexport class CompositionOperation {\n    static getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n}\nexport class TypeWithoutInterceptorsOperation {\n    static getEdits(prevEditOperationType, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class TabOperation {\n    static getCommands(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n}\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter) {\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    _computeCursorStateWithRange(model, range, helper) {\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        const text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = -closeCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(autoIndentationEdit, selection, openCharacter, closeCharacter) {\n        const text = openCharacter + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = openCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n        this._autoIndentationEdit = autoIndentationEdit;\n        this._autoClosingEdit = { range: selection, text };\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n        builder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length !== 2) {\n            throw new Error('There should be two inverse edit operations!');\n        }\n        const range1 = inverseEditOperations[0].range;\n        const range2 = inverseEditOperations[1].range;\n        const range = range1.plusRange(range2);\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\nfunction isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n        return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        if (!selection.isEmpty()) {\n            return false;\n        }\n        const position = selection.getPosition();\n        const lineText = model.getLineContent(position.lineNumber);\n        const afterCharacter = lineText.charAt(position.column - 1);\n        if (afterCharacter !== ch) {\n            return false;\n        }\n        // Do not over-type quotes after a backslash\n        const chIsQuote = isQuote(ch);\n        const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n        if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n            return false;\n        }\n        // Must over-type a closing character typed by the editor\n        if (config.autoClosingOvertype === 'auto') {\n            let found = false;\n            for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                const autoClosedCharacter = autoClosedCharacters[j];\n                if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    }\n    else {\n        return new ReplaceCommand(range, text, true);\n    }\n}\nexport function shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n        return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n    }\n    else {\n        // Character is a bracket\n        return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations } from './cursorTypeOperations.js';\nimport { BaseTypeWithAutoClosingCommand } from './cursorTypeEditOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof BaseTypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nimport { GlyphMarginLanesModel } from './glyphLanesModel.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView, _transactionalTarget) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this._transactionalTarget = _transactionalTarget;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        this.glyphLanes = new GlyphMarginLanesModel(0);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(92 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        if (e.hasChanged(99 /* EditorOption.renderValidationDecorations */)) {\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            const firstModelLineInViewPort = stableViewport.viewportStartModelPosition?.lineNumber;\n            const firstModelLineIsHidden = firstModelLineInViewPort && mergedRanges.some(range => range.startLineNumber <= firstModelLineInViewPort && firstModelLineInViewPort <= range.endLineNumber);\n            if (!firstModelLineIsHidden) {\n                stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(146 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(67 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1?.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2?.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        const resultModelPosition = this.model.modifyPosition(modelPosition, offset);\n        return this.coordinatesConverter.convertModelPositionToViewPosition(resultModelPosition);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealAllCursors(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealAll(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        return this._transactionalTarget.batchChanges(() => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                return callback(eventsCollector);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        });\n    }\n    batchEvents(callback) {\n        this._withViewEventsCollector(() => { callback(); });\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar CodeEditorWidget_1;\nimport '../../services/markerDecorations.js';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter, createEventDeliveryQueue } from '../../../../base/common/event.js';\nimport { Disposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport './editor.css';\nimport { applyFontInfo } from '../../config/domFontInfo.js';\nimport { EditorConfiguration } from '../../config/editorConfiguration.js';\nimport { TabFocus } from '../../config/tabFocus.js';\nimport { EditorExtensionsRegistry } from '../../editorExtensions.js';\nimport { ICodeEditorService } from '../../services/codeEditorService.js';\nimport { View } from '../../view.js';\nimport { DOMLineBreaksComputerFactory } from '../../view/domLineBreaksComputer.js';\nimport { ViewUserInputEvents } from '../../view/viewUserInputEvents.js';\nimport { CodeEditorContributions } from './codeEditorContributions.js';\nimport { filterValidationDecorations } from '../../../common/config/editorOptions.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { editorUnnecessaryCodeOpacity } from '../../../common/core/editorColorRegistry.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { WordOperations } from '../../../common/cursor/cursorWordOperations.js';\nimport { InternalEditorAction } from '../../../common/editorAction.js';\nimport * as editorCommon from '../../../common/editorCommon.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { MonospaceLineBreaksComputerFactory } from '../../../common/viewModel/monospaceLineBreaksComputer.js';\nimport { ViewModel } from '../../../common/viewModel/viewModelImpl.js';\nimport * as nls from '../../../../nls.js';\nimport { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ServiceCollection } from '../../../../platform/instantiation/common/serviceCollection.js';\nimport { INotificationService, Severity } from '../../../../platform/notification/common/notification.js';\nimport { editorErrorForeground, editorHintForeground, editorInfoForeground, editorWarningForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { IThemeService, registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nlet CodeEditorWidget = class CodeEditorWidget extends Disposable {\n    static { CodeEditorWidget_1 = this; }\n    static { this.dropIntoEditorDecorationOptions = ModelDecorationOptions.register({\n        description: 'workbench-dnd-target',\n        className: 'dnd-target'\n    }); }\n    //#endregion\n    get isSimpleWidget() {\n        return this._configuration.isSimpleWidget;\n    }\n    get contextMenuId() {\n        return this._configuration.contextMenuId;\n    }\n    constructor(domElement, _options, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        //#region Eventing\n        this._deliveryQueue = createEventDeliveryQueue();\n        this._contributions = this._register(new CodeEditorContributions());\n        this._onDidDispose = this._register(new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._onDidChangeModelContent = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelContent = this._onDidChangeModelContent.event;\n        this._onDidChangeModelLanguage = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event;\n        this._onDidChangeModelLanguageConfiguration = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event;\n        this._onDidChangeModelOptions = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelOptions = this._onDidChangeModelOptions.event;\n        this._onDidChangeModelDecorations = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event;\n        this._onDidChangeModelTokens = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModelTokens = this._onDidChangeModelTokens.event;\n        this._onDidChangeConfiguration = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this._onWillChangeModel = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onWillChangeModel = this._onWillChangeModel.event;\n        this._onDidChangeModel = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeModel = this._onDidChangeModel.event;\n        this._onDidChangeCursorPosition = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event;\n        this._onDidChangeCursorSelection = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event;\n        this._onDidAttemptReadOnlyEdit = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event;\n        this._onDidLayoutChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidLayoutChange = this._onDidLayoutChange.event;\n        this._editorTextFocus = this._register(new BooleanEventEmitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue;\n        this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse;\n        this._editorWidgetFocus = this._register(new BooleanEventEmitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue;\n        this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse;\n        this._onWillType = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onWillType = this._onWillType.event;\n        this._onDidType = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDidType = this._onDidType.event;\n        this._onDidCompositionStart = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDidCompositionStart = this._onDidCompositionStart.event;\n        this._onDidCompositionEnd = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDidCompositionEnd = this._onDidCompositionEnd.event;\n        this._onDidPaste = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDidPaste = this._onDidPaste.event;\n        this._onMouseUp = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseUp = this._onMouseUp.event;\n        this._onMouseDown = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseDown = this._onMouseDown.event;\n        this._onMouseDrag = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseDrag = this._onMouseDrag.event;\n        this._onMouseDrop = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseDrop = this._onMouseDrop.event;\n        this._onMouseDropCanceled = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseDropCanceled = this._onMouseDropCanceled.event;\n        this._onDropIntoEditor = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onDropIntoEditor = this._onDropIntoEditor.event;\n        this._onContextMenu = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onContextMenu = this._onContextMenu.event;\n        this._onMouseMove = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseMove = this._onMouseMove.event;\n        this._onMouseLeave = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseLeave = this._onMouseLeave.event;\n        this._onMouseWheel = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onMouseWheel = this._onMouseWheel.event;\n        this._onKeyUp = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onKeyUp = this._onKeyUp.event;\n        this._onKeyDown = this._register(new InteractionEmitter(this._contributions, this._deliveryQueue));\n        this.onKeyDown = this._onKeyDown.event;\n        this._onDidContentSizeChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._onDidScrollChange = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidScrollChange = this._onDidScrollChange.event;\n        this._onDidChangeViewZones = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeViewZones = this._onDidChangeViewZones.event;\n        this._onDidChangeHiddenAreas = this._register(new Emitter({ deliveryQueue: this._deliveryQueue }));\n        this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event;\n        this._updateCounter = 0;\n        this._onBeginUpdate = this._register(new Emitter());\n        this.onBeginUpdate = this._onBeginUpdate.event;\n        this._onEndUpdate = this._register(new Emitter());\n        this.onEndUpdate = this._onEndUpdate.event;\n        this._actions = new Map();\n        this._bannerDomNode = null;\n        this._dropIntoEditorDecorations = this.createDecorationsCollection();\n        codeEditorService.willCreateCodeEditor();\n        const options = { ..._options };\n        this._domElement = domElement;\n        this._overflowWidgetsDomNode = options.overflowWidgetsDomNode;\n        delete options.overflowWidgetsDomNode;\n        this._id = (++EDITOR_ID);\n        this._decorationTypeKeysToIds = {};\n        this._decorationTypeSubtypes = {};\n        this._telemetryData = codeEditorWidgetOptions.telemetryData;\n        this._configuration = this._register(this._createConfiguration(codeEditorWidgetOptions.isSimpleWidget || false, codeEditorWidgetOptions.contextMenuId ?? (codeEditorWidgetOptions.isSimpleWidget ? MenuId.SimpleEditorContext : MenuId.EditorContext), options, accessibilityService));\n        this._register(this._configuration.onDidChange((e) => {\n            this._onDidChangeConfiguration.fire(e);\n            const options = this._configuration.options;\n            if (e.hasChanged(146 /* EditorOption.layoutInfo */)) {\n                const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n                this._onDidLayoutChange.fire(layoutInfo);\n            }\n        }));\n        this._contextKeyService = this._register(contextKeyService.createScoped(this._domElement));\n        this._notificationService = notificationService;\n        this._codeEditorService = codeEditorService;\n        this._commandService = commandService;\n        this._themeService = themeService;\n        this._register(new EditorContextKeysManager(this, this._contextKeyService));\n        this._register(new EditorModeContext(this, this._contextKeyService, languageFeaturesService));\n        this._instantiationService = this._register(instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService])));\n        this._modelData = null;\n        this._focusTracker = new CodeEditorWidgetFocusTracker(domElement, this._overflowWidgetsDomNode);\n        this._register(this._focusTracker.onChange(() => {\n            this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());\n        }));\n        this._contentWidgets = {};\n        this._overlayWidgets = {};\n        this._glyphMarginWidgets = {};\n        let contributions;\n        if (Array.isArray(codeEditorWidgetOptions.contributions)) {\n            contributions = codeEditorWidgetOptions.contributions;\n        }\n        else {\n            contributions = EditorExtensionsRegistry.getEditorContributions();\n        }\n        this._contributions.initialize(this, contributions, this._instantiationService);\n        for (const action of EditorExtensionsRegistry.getEditorActions()) {\n            if (this._actions.has(action.id)) {\n                onUnexpectedError(new Error(`Cannot have two actions with the same id ${action.id}`));\n                continue;\n            }\n            const internalAction = new InternalEditorAction(action.id, action.label, action.alias, action.metadata, action.precondition ?? undefined, (args) => {\n                return this._instantiationService.invokeFunction((accessor) => {\n                    return Promise.resolve(action.runEditorCommand(accessor, this, args));\n                });\n            }, this._contextKeyService);\n            this._actions.set(internalAction.id, internalAction);\n        }\n        const isDropIntoEnabled = () => {\n            return !this._configuration.options.get(92 /* EditorOption.readOnly */)\n                && this._configuration.options.get(36 /* EditorOption.dropIntoEditor */).enabled;\n        };\n        this._register(new dom.DragAndDropObserver(this._domElement, {\n            onDragOver: e => {\n                if (!isDropIntoEnabled()) {\n                    return;\n                }\n                const target = this.getTargetAtClientPoint(e.clientX, e.clientY);\n                if (target?.position) {\n                    this.showDropIndicatorAt(target.position);\n                }\n            },\n            onDrop: async (e) => {\n                if (!isDropIntoEnabled()) {\n                    return;\n                }\n                this.removeDropIndicator();\n                if (!e.dataTransfer) {\n                    return;\n                }\n                const target = this.getTargetAtClientPoint(e.clientX, e.clientY);\n                if (target?.position) {\n                    this._onDropIntoEditor.fire({ position: target.position, event: e });\n                }\n            },\n            onDragLeave: () => {\n                this.removeDropIndicator();\n            },\n            onDragEnd: () => {\n                this.removeDropIndicator();\n            },\n        }));\n        this._codeEditorService.addCodeEditor(this);\n    }\n    writeScreenReaderContent(reason) {\n        this._modelData?.view.writeScreenReaderContent(reason);\n    }\n    _createConfiguration(isSimpleWidget, contextMenuId, options, accessibilityService) {\n        return new EditorConfiguration(isSimpleWidget, contextMenuId, options, this._domElement, accessibilityService);\n    }\n    getId() {\n        return this.getEditorType() + ':' + this._id;\n    }\n    getEditorType() {\n        return editorCommon.EditorType.ICodeEditor;\n    }\n    dispose() {\n        this._codeEditorService.removeCodeEditor(this);\n        this._focusTracker.dispose();\n        this._actions.clear();\n        this._contentWidgets = {};\n        this._overlayWidgets = {};\n        this._removeDecorationTypes();\n        this._postDetachModelCleanup(this._detachModel());\n        this._onDidDispose.fire();\n        super.dispose();\n    }\n    invokeWithinContext(fn) {\n        return this._instantiationService.invokeFunction(fn);\n    }\n    updateOptions(newOptions) {\n        this._configuration.updateOptions(newOptions || {});\n    }\n    getOptions() {\n        return this._configuration.options;\n    }\n    getOption(id) {\n        return this._configuration.options.get(id);\n    }\n    getRawOptions() {\n        return this._configuration.getRawOptions();\n    }\n    getOverflowWidgetsDomNode() {\n        return this._overflowWidgetsDomNode;\n    }\n    getConfiguredWordAtPosition(position) {\n        if (!this._modelData) {\n            return null;\n        }\n        return WordOperations.getWordAtPosition(this._modelData.model, this._configuration.options.get(132 /* EditorOption.wordSeparators */), this._configuration.options.get(131 /* EditorOption.wordSegmenterLocales */), position);\n    }\n    getValue(options = null) {\n        if (!this._modelData) {\n            return '';\n        }\n        const preserveBOM = (options && options.preserveBOM) ? true : false;\n        let eolPreference = 0 /* EndOfLinePreference.TextDefined */;\n        if (options && options.lineEnding && options.lineEnding === '\\n') {\n            eolPreference = 1 /* EndOfLinePreference.LF */;\n        }\n        else if (options && options.lineEnding && options.lineEnding === '\\r\\n') {\n            eolPreference = 2 /* EndOfLinePreference.CRLF */;\n        }\n        return this._modelData.model.getValue(eolPreference, preserveBOM);\n    }\n    setValue(newValue) {\n        try {\n            this._beginUpdate();\n            if (!this._modelData) {\n                return;\n            }\n            this._modelData.model.setValue(newValue);\n        }\n        finally {\n            this._endUpdate();\n        }\n    }\n    getModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model;\n    }\n    setModel(_model = null) {\n        try {\n            this._beginUpdate();\n            const model = _model;\n            if (this._modelData === null && model === null) {\n                // Current model is the new model\n                return;\n            }\n            if (this._modelData && this._modelData.model === model) {\n                // Current model is the new model\n                return;\n            }\n            const e = {\n                oldModelUrl: this._modelData?.model.uri || null,\n                newModelUrl: model?.uri || null\n            };\n            this._onWillChangeModel.fire(e);\n            const hasTextFocus = this.hasTextFocus();\n            const detachedModel = this._detachModel();\n            this._attachModel(model);\n            if (hasTextFocus && this.hasModel()) {\n                this.focus();\n            }\n            this._removeDecorationTypes();\n            this._onDidChangeModel.fire(e);\n            this._postDetachModelCleanup(detachedModel);\n            this._contributionsDisposable = this._contributions.onAfterModelAttached();\n        }\n        finally {\n            this._endUpdate();\n        }\n    }\n    _removeDecorationTypes() {\n        this._decorationTypeKeysToIds = {};\n        if (this._decorationTypeSubtypes) {\n            for (const decorationType in this._decorationTypeSubtypes) {\n                const subTypes = this._decorationTypeSubtypes[decorationType];\n                for (const subType in subTypes) {\n                    this._removeDecorationType(decorationType + '-' + subType);\n                }\n            }\n            this._decorationTypeSubtypes = {};\n        }\n    }\n    getVisibleRanges() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRanges();\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow();\n    }\n    getWhitespaces() {\n        if (!this._modelData) {\n            return [];\n        }\n        return this._modelData.viewModel.viewLayout.getWhitespaces();\n    }\n    static _getVerticalOffsetAfterPosition(modelData, modelLineNumber, modelColumn, includeViewZones) {\n        const modelPosition = modelData.model.validatePosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        return modelData.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(viewPosition.lineNumber, includeViewZones);\n    }\n    getTopForLineNumber(lineNumber, includeViewZones = false) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget_1._getVerticalOffsetForPosition(this._modelData, lineNumber, 1, includeViewZones);\n    }\n    getTopForPosition(lineNumber, column) {\n        if (!this._modelData) {\n            return -1;\n        }\n        return CodeEditorWidget_1._getVerticalOffsetForPosition(this._modelData, lineNumber, column, false);\n    }\n    static _getVerticalOffsetForPosition(modelData, modelLineNumber, modelColumn, includeViewZones = false) {\n        const modelPosition = modelData.model.validatePosition({\n            lineNumber: modelLineNumber,\n            column: modelColumn\n        });\n        const viewPosition = modelData.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        return modelData.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber, includeViewZones);\n    }\n    getBottomForLineNumber(lineNumber, includeViewZones = false) {\n        if (!this._modelData) {\n            return -1;\n        }\n        const maxCol = this._modelData.model.getLineMaxColumn(lineNumber);\n        return CodeEditorWidget_1._getVerticalOffsetAfterPosition(this._modelData, lineNumber, maxCol, includeViewZones);\n    }\n    setHiddenAreas(ranges, source) {\n        this._modelData?.viewModel.setHiddenAreas(ranges.map(r => Range.lift(r)), source);\n    }\n    getVisibleColumnFromPosition(rawPosition) {\n        if (!this._modelData) {\n            return rawPosition.column;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const tabSize = this._modelData.model.getOptions().tabSize;\n        return CursorColumns.visibleColumnFromColumn(this._modelData.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;\n    }\n    getPosition() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getPosition();\n    }\n    setPosition(position, source = 'api') {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.setSelections(source, [{\n                selectionStartLineNumber: position.lineNumber,\n                selectionStartColumn: position.column,\n                positionLineNumber: position.lineNumber,\n                positionColumn: position.column\n            }]);\n    }\n    _sendRevealRange(modelRange, verticalType, revealHorizontal, scrollType) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!Range.isIRange(modelRange)) {\n            throw new Error('Invalid arguments');\n        }\n        const validatedModelRange = this._modelData.model.validateRange(modelRange);\n        const viewRange = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(validatedModelRange);\n        this._modelData.viewModel.revealRange('api', revealHorizontal, viewRange, verticalType, scrollType);\n    }\n    revealLine(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 0 /* VerticalRevealType.Simple */, scrollType);\n    }\n    revealLineInCenter(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 1 /* VerticalRevealType.Center */, scrollType);\n    }\n    revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 2 /* VerticalRevealType.CenterIfOutsideViewport */, scrollType);\n    }\n    revealLineNearTop(lineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLine(lineNumber, 5 /* VerticalRevealType.NearTop */, scrollType);\n    }\n    _revealLine(lineNumber, revealType, scrollType) {\n        if (typeof lineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(lineNumber, 1, lineNumber, 1), revealType, false, scrollType);\n    }\n    revealPosition(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 0 /* VerticalRevealType.Simple */, true, scrollType);\n    }\n    revealPositionInCenter(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 1 /* VerticalRevealType.Center */, true, scrollType);\n    }\n    revealPositionInCenterIfOutsideViewport(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 2 /* VerticalRevealType.CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealPositionNearTop(position, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealPosition(position, 5 /* VerticalRevealType.NearTop */, true, scrollType);\n    }\n    _revealPosition(position, verticalType, revealHorizontal, scrollType) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal, scrollType);\n    }\n    getSelection() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelection();\n    }\n    getSelections() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel.getSelections();\n    }\n    setSelection(something, source = 'api') {\n        const isSelection = Selection.isISelection(something);\n        const isRange = Range.isIRange(something);\n        if (!isSelection && !isRange) {\n            throw new Error('Invalid arguments');\n        }\n        if (isSelection) {\n            this._setSelectionImpl(something, source);\n        }\n        else if (isRange) {\n            // act as if it was an IRange\n            const selection = {\n                selectionStartLineNumber: something.startLineNumber,\n                selectionStartColumn: something.startColumn,\n                positionLineNumber: something.endLineNumber,\n                positionColumn: something.endColumn\n            };\n            this._setSelectionImpl(selection, source);\n        }\n    }\n    _setSelectionImpl(sel, source) {\n        if (!this._modelData) {\n            return;\n        }\n        const selection = new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n        this._modelData.viewModel.setSelections(source, [selection]);\n    }\n    revealLines(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 0 /* VerticalRevealType.Simple */, scrollType);\n    }\n    revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 1 /* VerticalRevealType.Center */, scrollType);\n    }\n    revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 2 /* VerticalRevealType.CenterIfOutsideViewport */, scrollType);\n    }\n    revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealLines(startLineNumber, endLineNumber, 5 /* VerticalRevealType.NearTop */, scrollType);\n    }\n    _revealLines(startLineNumber, endLineNumber, verticalType, scrollType) {\n        if (typeof startLineNumber !== 'number' || typeof endLineNumber !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(new Range(startLineNumber, 1, endLineNumber, 1), verticalType, false, scrollType);\n    }\n    revealRange(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */, revealVerticalInCenter = false, revealHorizontal = true) {\n        this._revealRange(range, revealVerticalInCenter ? 1 /* VerticalRevealType.Center */ : 0 /* VerticalRevealType.Simple */, revealHorizontal, scrollType);\n    }\n    revealRangeInCenter(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 1 /* VerticalRevealType.Center */, true, scrollType);\n    }\n    revealRangeInCenterIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 2 /* VerticalRevealType.CenterIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeNearTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 5 /* VerticalRevealType.NearTop */, true, scrollType);\n    }\n    revealRangeNearTopIfOutsideViewport(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 6 /* VerticalRevealType.NearTopIfOutsideViewport */, true, scrollType);\n    }\n    revealRangeAtTop(range, scrollType = 0 /* editorCommon.ScrollType.Smooth */) {\n        this._revealRange(range, 3 /* VerticalRevealType.Top */, true, scrollType);\n    }\n    _revealRange(range, verticalType, revealHorizontal, scrollType) {\n        if (!Range.isIRange(range)) {\n            throw new Error('Invalid arguments');\n        }\n        this._sendRevealRange(Range.lift(range), verticalType, revealHorizontal, scrollType);\n    }\n    setSelections(ranges, source = 'api', reason = 0 /* CursorChangeReason.NotSet */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (!ranges || ranges.length === 0) {\n            throw new Error('Invalid arguments');\n        }\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            if (!Selection.isISelection(ranges[i])) {\n                throw new Error('Invalid arguments');\n            }\n        }\n        this._modelData.viewModel.setSelections(source, ranges, reason);\n    }\n    getContentWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentWidth();\n    }\n    getScrollWidth() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollWidth();\n    }\n    getScrollLeft() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollLeft();\n    }\n    getContentHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getContentHeight();\n    }\n    getScrollHeight() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getScrollHeight();\n    }\n    getScrollTop() {\n        if (!this._modelData) {\n            return -1;\n        }\n        return this._modelData.viewModel.viewLayout.getCurrentScrollTop();\n    }\n    setScrollLeft(newScrollLeft, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollLeft !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition({\n            scrollLeft: newScrollLeft\n        }, scrollType);\n    }\n    setScrollTop(newScrollTop, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        if (typeof newScrollTop !== 'number') {\n            throw new Error('Invalid arguments');\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition({\n            scrollTop: newScrollTop\n        }, scrollType);\n    }\n    setScrollPosition(position, scrollType = 1 /* editorCommon.ScrollType.Immediate */) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.viewLayout.setScrollPosition(position, scrollType);\n    }\n    hasPendingScrollAnimation() {\n        if (!this._modelData) {\n            return false;\n        }\n        return this._modelData.viewModel.viewLayout.hasPendingScrollAnimation();\n    }\n    saveViewState() {\n        if (!this._modelData) {\n            return null;\n        }\n        const contributionsState = this._contributions.saveViewState();\n        const cursorState = this._modelData.viewModel.saveCursorState();\n        const viewState = this._modelData.viewModel.saveState();\n        return {\n            cursorState: cursorState,\n            viewState: viewState,\n            contributionsState: contributionsState\n        };\n    }\n    restoreViewState(s) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        const codeEditorState = s;\n        if (codeEditorState && codeEditorState.cursorState && codeEditorState.viewState) {\n            const cursorState = codeEditorState.cursorState;\n            if (Array.isArray(cursorState)) {\n                if (cursorState.length > 0) {\n                    this._modelData.viewModel.restoreCursorState(cursorState);\n                }\n            }\n            else {\n                // Backwards compatibility\n                this._modelData.viewModel.restoreCursorState([cursorState]);\n            }\n            this._contributions.restoreViewState(codeEditorState.contributionsState || {});\n            const reducedState = this._modelData.viewModel.reduceRestoreState(codeEditorState.viewState);\n            this._modelData.view.restoreState(reducedState);\n        }\n    }\n    handleInitialized() {\n        this._getViewModel()?.visibleLinesStabilized();\n    }\n    getContribution(id) {\n        return this._contributions.get(id);\n    }\n    getActions() {\n        return Array.from(this._actions.values());\n    }\n    getSupportedActions() {\n        let result = this.getActions();\n        result = result.filter(action => action.isSupported());\n        return result;\n    }\n    getAction(id) {\n        return this._actions.get(id) || null;\n    }\n    trigger(source, handlerId, payload) {\n        payload = payload || {};\n        try {\n            this._beginUpdate();\n            switch (handlerId) {\n                case \"compositionStart\" /* editorCommon.Handler.CompositionStart */:\n                    this._startComposition();\n                    return;\n                case \"compositionEnd\" /* editorCommon.Handler.CompositionEnd */:\n                    this._endComposition(source);\n                    return;\n                case \"type\" /* editorCommon.Handler.Type */: {\n                    const args = payload;\n                    this._type(source, args.text || '');\n                    return;\n                }\n                case \"replacePreviousChar\" /* editorCommon.Handler.ReplacePreviousChar */: {\n                    const args = payload;\n                    this._compositionType(source, args.text || '', args.replaceCharCnt || 0, 0, 0);\n                    return;\n                }\n                case \"compositionType\" /* editorCommon.Handler.CompositionType */: {\n                    const args = payload;\n                    this._compositionType(source, args.text || '', args.replacePrevCharCnt || 0, args.replaceNextCharCnt || 0, args.positionDelta || 0);\n                    return;\n                }\n                case \"paste\" /* editorCommon.Handler.Paste */: {\n                    const args = payload;\n                    this._paste(source, args.text || '', args.pasteOnNewLine || false, args.multicursorText || null, args.mode || null, args.clipboardEvent);\n                    return;\n                }\n                case \"cut\" /* editorCommon.Handler.Cut */:\n                    this._cut(source);\n                    return;\n            }\n            const action = this.getAction(handlerId);\n            if (action) {\n                Promise.resolve(action.run(payload)).then(undefined, onUnexpectedError);\n                return;\n            }\n            if (!this._modelData) {\n                return;\n            }\n            if (this._triggerEditorCommand(source, handlerId, payload)) {\n                return;\n            }\n            this._triggerCommand(handlerId, payload);\n        }\n        finally {\n            this._endUpdate();\n        }\n    }\n    _triggerCommand(handlerId, payload) {\n        this._commandService.executeCommand(handlerId, payload);\n    }\n    _startComposition() {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.startComposition();\n        this._onDidCompositionStart.fire();\n    }\n    _endComposition(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.endComposition(source);\n        this._onDidCompositionEnd.fire();\n    }\n    _type(source, text) {\n        if (!this._modelData || text.length === 0) {\n            return;\n        }\n        if (source === 'keyboard') {\n            this._onWillType.fire(text);\n        }\n        this._modelData.viewModel.type(text, source);\n        if (source === 'keyboard') {\n            this._onDidType.fire(text);\n        }\n    }\n    _compositionType(source, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source);\n    }\n    _paste(source, text, pasteOnNewLine, multicursorText, mode, clipboardEvent) {\n        if (!this._modelData) {\n            return;\n        }\n        const viewModel = this._modelData.viewModel;\n        const startPosition = viewModel.getSelection().getStartPosition();\n        viewModel.paste(text, pasteOnNewLine, multicursorText, source);\n        const endPosition = viewModel.getSelection().getStartPosition();\n        if (source === 'keyboard') {\n            this._onDidPaste.fire({\n                clipboardEvent,\n                range: new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),\n                languageId: mode\n            });\n        }\n    }\n    _cut(source) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.cut(source);\n    }\n    _triggerEditorCommand(source, handlerId, payload) {\n        const command = EditorExtensionsRegistry.getEditorCommand(handlerId);\n        if (command) {\n            payload = payload || {};\n            payload.source = source;\n            this._instantiationService.invokeFunction((accessor) => {\n                Promise.resolve(command.runEditorCommand(accessor, this, payload)).then(undefined, onUnexpectedError);\n            });\n            return true;\n        }\n        return false;\n    }\n    _getViewModel() {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.viewModel;\n    }\n    pushUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(92 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.pushStackElement();\n        return true;\n    }\n    popUndoStop() {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(92 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        this._modelData.model.popStackElement();\n        return true;\n    }\n    executeEdits(source, edits, endCursorState) {\n        if (!this._modelData) {\n            return false;\n        }\n        if (this._configuration.options.get(92 /* EditorOption.readOnly */)) {\n            // read only editor => sorry!\n            return false;\n        }\n        let cursorStateComputer;\n        if (!endCursorState) {\n            cursorStateComputer = () => null;\n        }\n        else if (Array.isArray(endCursorState)) {\n            cursorStateComputer = () => endCursorState;\n        }\n        else {\n            cursorStateComputer = endCursorState;\n        }\n        this._modelData.viewModel.executeEdits(source, edits, cursorStateComputer);\n        return true;\n    }\n    executeCommand(source, command) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommand(command, source);\n    }\n    executeCommands(source, commands) {\n        if (!this._modelData) {\n            return;\n        }\n        this._modelData.viewModel.executeCommands(commands, source);\n    }\n    createDecorationsCollection(decorations) {\n        return new EditorDecorationsCollection(this, decorations);\n    }\n    changeDecorations(callback) {\n        if (!this._modelData) {\n            // callback will not be called\n            return null;\n        }\n        return this._modelData.model.changeDecorations(callback, this._id);\n    }\n    getLineDecorations(lineNumber) {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model.getLineDecorations(lineNumber, this._id, filterValidationDecorations(this._configuration.options));\n    }\n    getDecorationsInRange(range) {\n        if (!this._modelData) {\n            return null;\n        }\n        return this._modelData.model.getDecorationsInRange(range, this._id, filterValidationDecorations(this._configuration.options));\n    }\n    /**\n     * @deprecated\n     */\n    deltaDecorations(oldDecorations, newDecorations) {\n        if (!this._modelData) {\n            return [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            return oldDecorations;\n        }\n        return this._modelData.model.deltaDecorations(oldDecorations, newDecorations, this._id);\n    }\n    removeDecorations(decorationIds) {\n        if (!this._modelData || decorationIds.length === 0) {\n            return;\n        }\n        this._modelData.model.changeDecorations((changeAccessor) => {\n            changeAccessor.deltaDecorations(decorationIds, []);\n        });\n    }\n    removeDecorationsByType(decorationTypeKey) {\n        // remove decorations for type and sub type\n        const oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];\n        if (oldDecorationsIds) {\n            this.changeDecorations(accessor => accessor.deltaDecorations(oldDecorationsIds, []));\n        }\n        if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeKeysToIds[decorationTypeKey];\n        }\n        if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {\n            delete this._decorationTypeSubtypes[decorationTypeKey];\n        }\n    }\n    getLayoutInfo() {\n        const options = this._configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        return layoutInfo;\n    }\n    createOverviewRuler(cssClassName) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.createOverviewRuler(cssClassName);\n    }\n    getContainerDomNode() {\n        return this._domElement;\n    }\n    getDomNode() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.domNode.domNode;\n    }\n    delegateVerticalScrollbarPointerDown(browserEvent) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.delegateVerticalScrollbarPointerDown(browserEvent);\n    }\n    delegateScrollFromMouseWheelEvent(browserEvent) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.delegateScrollFromMouseWheelEvent(browserEvent);\n    }\n    layout(dimension, postponeRendering = false) {\n        this._configuration.observeContainer(dimension);\n        if (!postponeRendering) {\n            this.render();\n        }\n    }\n    focus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.focus();\n    }\n    hasTextFocus() {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return false;\n        }\n        return this._modelData.view.isFocused();\n    }\n    hasWidgetFocus() {\n        return this._focusTracker && this._focusTracker.hasFocus();\n    }\n    addContentWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._contentWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting a content widget with the same id:' + widget.getId());\n        }\n        this._contentWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addContentWidget(widgetData);\n        }\n    }\n    layoutContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutContentWidget(widgetData);\n            }\n        }\n    }\n    removeContentWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._contentWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._contentWidgets[widgetId];\n            delete this._contentWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeContentWidget(widgetData);\n            }\n        }\n    }\n    addOverlayWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._overlayWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting an overlay widget with the same id.');\n        }\n        this._overlayWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addOverlayWidget(widgetData);\n        }\n    }\n    layoutOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutOverlayWidget(widgetData);\n            }\n        }\n    }\n    removeOverlayWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._overlayWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._overlayWidgets[widgetId];\n            delete this._overlayWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeOverlayWidget(widgetData);\n            }\n        }\n    }\n    addGlyphMarginWidget(widget) {\n        const widgetData = {\n            widget: widget,\n            position: widget.getPosition()\n        };\n        if (this._glyphMarginWidgets.hasOwnProperty(widget.getId())) {\n            console.warn('Overwriting a glyph margin widget with the same id.');\n        }\n        this._glyphMarginWidgets[widget.getId()] = widgetData;\n        if (this._modelData && this._modelData.hasRealView) {\n            this._modelData.view.addGlyphMarginWidget(widgetData);\n        }\n    }\n    layoutGlyphMarginWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._glyphMarginWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._glyphMarginWidgets[widgetId];\n            widgetData.position = widget.getPosition();\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.layoutGlyphMarginWidget(widgetData);\n            }\n        }\n    }\n    removeGlyphMarginWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._glyphMarginWidgets.hasOwnProperty(widgetId)) {\n            const widgetData = this._glyphMarginWidgets[widgetId];\n            delete this._glyphMarginWidgets[widgetId];\n            if (this._modelData && this._modelData.hasRealView) {\n                this._modelData.view.removeGlyphMarginWidget(widgetData);\n            }\n        }\n    }\n    changeViewZones(callback) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.change(callback);\n    }\n    getTargetAtClientPoint(clientX, clientY) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        return this._modelData.view.getTargetAtClientPoint(clientX, clientY);\n    }\n    getScrolledVisiblePosition(rawPosition) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return null;\n        }\n        const position = this._modelData.model.validatePosition(rawPosition);\n        const options = this._configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const top = CodeEditorWidget_1._getVerticalOffsetForPosition(this._modelData, position.lineNumber, position.column) - this.getScrollTop();\n        const left = this._modelData.view.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - this.getScrollLeft();\n        return {\n            top: top,\n            left: left,\n            height: options.get(67 /* EditorOption.lineHeight */)\n        };\n    }\n    getOffsetForColumn(lineNumber, column) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return -1;\n        }\n        return this._modelData.view.getOffsetForColumn(lineNumber, column);\n    }\n    render(forceRedraw = false) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.viewModel.batchEvents(() => {\n            this._modelData.view.render(true, forceRedraw);\n        });\n    }\n    setAriaOptions(options) {\n        if (!this._modelData || !this._modelData.hasRealView) {\n            return;\n        }\n        this._modelData.view.setAriaOptions(options);\n    }\n    applyFontInfo(target) {\n        applyFontInfo(target, this._configuration.options.get(50 /* EditorOption.fontInfo */));\n    }\n    setBanner(domNode, domNodeHeight) {\n        if (this._bannerDomNode && this._domElement.contains(this._bannerDomNode)) {\n            this._bannerDomNode.remove();\n        }\n        this._bannerDomNode = domNode;\n        this._configuration.setReservedHeight(domNode ? domNodeHeight : 0);\n        if (this._bannerDomNode) {\n            this._domElement.prepend(this._bannerDomNode);\n        }\n    }\n    _attachModel(model) {\n        if (!model) {\n            this._modelData = null;\n            return;\n        }\n        const listenersToRemove = [];\n        this._domElement.setAttribute('data-mode-id', model.getLanguageId());\n        this._configuration.setIsDominatedByLongLines(model.isDominatedByLongLines());\n        this._configuration.setModelLineCount(model.getLineCount());\n        const attachedView = model.onBeforeAttached();\n        const viewModel = new ViewModel(this._id, this._configuration, model, DOMLineBreaksComputerFactory.create(dom.getWindow(this._domElement)), MonospaceLineBreaksComputerFactory.create(this._configuration.options), (callback) => dom.scheduleAtNextAnimationFrame(dom.getWindow(this._domElement), callback), this.languageConfigurationService, this._themeService, attachedView, {\n            batchChanges: (cb) => {\n                try {\n                    this._beginUpdate();\n                    return cb();\n                }\n                finally {\n                    this._endUpdate();\n                }\n            },\n        });\n        // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model\n        listenersToRemove.push(model.onWillDispose(() => this.setModel(null)));\n        listenersToRemove.push(viewModel.onEvent((e) => {\n            switch (e.kind) {\n                case 0 /* OutgoingViewModelEventKind.ContentSizeChanged */:\n                    this._onDidContentSizeChange.fire(e);\n                    break;\n                case 1 /* OutgoingViewModelEventKind.FocusChanged */:\n                    this._editorTextFocus.setValue(e.hasFocus);\n                    break;\n                case 2 /* OutgoingViewModelEventKind.ScrollChanged */:\n                    this._onDidScrollChange.fire(e);\n                    break;\n                case 3 /* OutgoingViewModelEventKind.ViewZonesChanged */:\n                    this._onDidChangeViewZones.fire();\n                    break;\n                case 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */:\n                    this._onDidChangeHiddenAreas.fire();\n                    break;\n                case 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */:\n                    this._onDidAttemptReadOnlyEdit.fire();\n                    break;\n                case 6 /* OutgoingViewModelEventKind.CursorStateChanged */: {\n                    if (e.reachedMaxCursorCount) {\n                        const multiCursorLimit = this.getOption(80 /* EditorOption.multiCursorLimit */);\n                        const message = nls.localize('cursors.maximum', \"The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.\", multiCursorLimit);\n                        this._notificationService.prompt(Severity.Warning, message, [\n                            {\n                                label: 'Find and Replace',\n                                run: () => {\n                                    this._commandService.executeCommand('editor.action.startFindReplaceAction');\n                                }\n                            },\n                            {\n                                label: nls.localize('goToSetting', 'Increase Multi Cursor Limit'),\n                                run: () => {\n                                    this._commandService.executeCommand('workbench.action.openSettings2', {\n                                        query: 'editor.multiCursorLimit'\n                                    });\n                                }\n                            }\n                        ]);\n                    }\n                    const positions = [];\n                    for (let i = 0, len = e.selections.length; i < len; i++) {\n                        positions[i] = e.selections[i].getPosition();\n                    }\n                    const e1 = {\n                        position: positions[0],\n                        secondaryPositions: positions.slice(1),\n                        reason: e.reason,\n                        source: e.source\n                    };\n                    this._onDidChangeCursorPosition.fire(e1);\n                    const e2 = {\n                        selection: e.selections[0],\n                        secondarySelections: e.selections.slice(1),\n                        modelVersionId: e.modelVersionId,\n                        oldSelections: e.oldSelections,\n                        oldModelVersionId: e.oldModelVersionId,\n                        source: e.source,\n                        reason: e.reason\n                    };\n                    this._onDidChangeCursorSelection.fire(e2);\n                    break;\n                }\n                case 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */:\n                    this._onDidChangeModelDecorations.fire(e.event);\n                    break;\n                case 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */:\n                    this._domElement.setAttribute('data-mode-id', model.getLanguageId());\n                    this._onDidChangeModelLanguage.fire(e.event);\n                    break;\n                case 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */:\n                    this._onDidChangeModelLanguageConfiguration.fire(e.event);\n                    break;\n                case 10 /* OutgoingViewModelEventKind.ModelContentChanged */:\n                    this._onDidChangeModelContent.fire(e.event);\n                    break;\n                case 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */:\n                    this._onDidChangeModelOptions.fire(e.event);\n                    break;\n                case 12 /* OutgoingViewModelEventKind.ModelTokensChanged */:\n                    this._onDidChangeModelTokens.fire(e.event);\n                    break;\n            }\n        }));\n        const [view, hasRealView] = this._createView(viewModel);\n        if (hasRealView) {\n            this._domElement.appendChild(view.domNode.domNode);\n            let keys = Object.keys(this._contentWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addContentWidget(this._contentWidgets[widgetId]);\n            }\n            keys = Object.keys(this._overlayWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addOverlayWidget(this._overlayWidgets[widgetId]);\n            }\n            keys = Object.keys(this._glyphMarginWidgets);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const widgetId = keys[i];\n                view.addGlyphMarginWidget(this._glyphMarginWidgets[widgetId]);\n            }\n            view.render(false, true);\n            view.domNode.domNode.setAttribute('data-uri', model.uri.toString());\n        }\n        this._modelData = new ModelData(model, viewModel, view, hasRealView, listenersToRemove, attachedView);\n    }\n    _createView(viewModel) {\n        let commandDelegate;\n        if (this.isSimpleWidget) {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    this._paste('keyboard', text, pasteOnNewLine, multicursorText, mode);\n                },\n                type: (text) => {\n                    this._type('keyboard', text);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    this._compositionType('keyboard', text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n                },\n                startComposition: () => {\n                    this._startComposition();\n                },\n                endComposition: () => {\n                    this._endComposition('keyboard');\n                },\n                cut: () => {\n                    this._cut('keyboard');\n                }\n            };\n        }\n        else {\n            commandDelegate = {\n                paste: (text, pasteOnNewLine, multicursorText, mode) => {\n                    const payload = { text, pasteOnNewLine, multicursorText, mode };\n                    this._commandService.executeCommand(\"paste\" /* editorCommon.Handler.Paste */, payload);\n                },\n                type: (text) => {\n                    const payload = { text };\n                    this._commandService.executeCommand(\"type\" /* editorCommon.Handler.Type */, payload);\n                },\n                compositionType: (text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) => {\n                    // Try if possible to go through the existing `replacePreviousChar` command\n                    if (replaceNextCharCnt || positionDelta) {\n                        // must be handled through the new command\n                        const payload = { text, replacePrevCharCnt, replaceNextCharCnt, positionDelta };\n                        this._commandService.executeCommand(\"compositionType\" /* editorCommon.Handler.CompositionType */, payload);\n                    }\n                    else {\n                        const payload = { text, replaceCharCnt: replacePrevCharCnt };\n                        this._commandService.executeCommand(\"replacePreviousChar\" /* editorCommon.Handler.ReplacePreviousChar */, payload);\n                    }\n                },\n                startComposition: () => {\n                    this._commandService.executeCommand(\"compositionStart\" /* editorCommon.Handler.CompositionStart */, {});\n                },\n                endComposition: () => {\n                    this._commandService.executeCommand(\"compositionEnd\" /* editorCommon.Handler.CompositionEnd */, {});\n                },\n                cut: () => {\n                    this._commandService.executeCommand(\"cut\" /* editorCommon.Handler.Cut */, {});\n                }\n            };\n        }\n        const viewUserInputEvents = new ViewUserInputEvents(viewModel.coordinatesConverter);\n        viewUserInputEvents.onKeyDown = (e) => this._onKeyDown.fire(e);\n        viewUserInputEvents.onKeyUp = (e) => this._onKeyUp.fire(e);\n        viewUserInputEvents.onContextMenu = (e) => this._onContextMenu.fire(e);\n        viewUserInputEvents.onMouseMove = (e) => this._onMouseMove.fire(e);\n        viewUserInputEvents.onMouseLeave = (e) => this._onMouseLeave.fire(e);\n        viewUserInputEvents.onMouseDown = (e) => this._onMouseDown.fire(e);\n        viewUserInputEvents.onMouseUp = (e) => this._onMouseUp.fire(e);\n        viewUserInputEvents.onMouseDrag = (e) => this._onMouseDrag.fire(e);\n        viewUserInputEvents.onMouseDrop = (e) => this._onMouseDrop.fire(e);\n        viewUserInputEvents.onMouseDropCanceled = (e) => this._onMouseDropCanceled.fire(e);\n        viewUserInputEvents.onMouseWheel = (e) => this._onMouseWheel.fire(e);\n        const view = new View(commandDelegate, this._configuration, this._themeService.getColorTheme(), viewModel, viewUserInputEvents, this._overflowWidgetsDomNode, this._instantiationService);\n        return [view, true];\n    }\n    _postDetachModelCleanup(detachedModel) {\n        detachedModel?.removeAllDecorationsWithOwnerId(this._id);\n    }\n    _detachModel() {\n        this._contributionsDisposable?.dispose();\n        this._contributionsDisposable = undefined;\n        if (!this._modelData) {\n            return null;\n        }\n        const model = this._modelData.model;\n        const removeDomNode = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;\n        this._modelData.dispose();\n        this._modelData = null;\n        this._domElement.removeAttribute('data-mode-id');\n        if (removeDomNode && this._domElement.contains(removeDomNode)) {\n            removeDomNode.remove();\n        }\n        if (this._bannerDomNode && this._domElement.contains(this._bannerDomNode)) {\n            this._bannerDomNode.remove();\n        }\n        return model;\n    }\n    _removeDecorationType(key) {\n        this._codeEditorService.removeDecorationType(key);\n    }\n    hasModel() {\n        return (this._modelData !== null);\n    }\n    showDropIndicatorAt(position) {\n        const newDecorations = [{\n                range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n                options: CodeEditorWidget_1.dropIntoEditorDecorationOptions\n            }];\n        this._dropIntoEditorDecorations.set(newDecorations);\n        this.revealPosition(position, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    removeDropIndicator() {\n        this._dropIntoEditorDecorations.clear();\n    }\n    setContextValue(key, value) {\n        this._contextKeyService.createKey(key, value);\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            this._onBeginUpdate.fire();\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._onEndUpdate.fire();\n        }\n    }\n};\nCodeEditorWidget = CodeEditorWidget_1 = __decorate([\n    __param(3, IInstantiationService),\n    __param(4, ICodeEditorService),\n    __param(5, ICommandService),\n    __param(6, IContextKeyService),\n    __param(7, IThemeService),\n    __param(8, INotificationService),\n    __param(9, IAccessibilityService),\n    __param(10, ILanguageConfigurationService),\n    __param(11, ILanguageFeaturesService)\n], CodeEditorWidget);\nexport { CodeEditorWidget };\nlet EDITOR_ID = 0;\nclass ModelData {\n    constructor(model, viewModel, view, hasRealView, listenersToRemove, attachedView) {\n        this.model = model;\n        this.viewModel = viewModel;\n        this.view = view;\n        this.hasRealView = hasRealView;\n        this.listenersToRemove = listenersToRemove;\n        this.attachedView = attachedView;\n    }\n    dispose() {\n        dispose(this.listenersToRemove);\n        this.model.onBeforeDetached(this.attachedView);\n        if (this.hasRealView) {\n            this.view.dispose();\n        }\n        this.viewModel.dispose();\n    }\n}\nexport class BooleanEventEmitter extends Disposable {\n    constructor(_emitterOptions) {\n        super();\n        this._emitterOptions = _emitterOptions;\n        this._onDidChangeToTrue = this._register(new Emitter(this._emitterOptions));\n        this.onDidChangeToTrue = this._onDidChangeToTrue.event;\n        this._onDidChangeToFalse = this._register(new Emitter(this._emitterOptions));\n        this.onDidChangeToFalse = this._onDidChangeToFalse.event;\n        this._value = 0 /* BooleanEventValue.NotSet */;\n    }\n    setValue(_value) {\n        const value = (_value ? 2 /* BooleanEventValue.True */ : 1 /* BooleanEventValue.False */);\n        if (this._value === value) {\n            return;\n        }\n        this._value = value;\n        if (this._value === 2 /* BooleanEventValue.True */) {\n            this._onDidChangeToTrue.fire();\n        }\n        else if (this._value === 1 /* BooleanEventValue.False */) {\n            this._onDidChangeToFalse.fire();\n        }\n    }\n}\n/**\n * A regular event emitter that also makes sure contributions are instantiated if necessary\n */\nclass InteractionEmitter extends Emitter {\n    constructor(_contributions, deliveryQueue) {\n        super({ deliveryQueue });\n        this._contributions = _contributions;\n    }\n    fire(event) {\n        this._contributions.onBeforeInteractionEvent();\n        super.fire(event);\n    }\n}\nclass EditorContextKeysManager extends Disposable {\n    constructor(editor, contextKeyService) {\n        super();\n        this._editor = editor;\n        contextKeyService.createKey('editorId', editor.getId());\n        this._editorSimpleInput = EditorContextKeys.editorSimpleInput.bindTo(contextKeyService);\n        this._editorFocus = EditorContextKeys.focus.bindTo(contextKeyService);\n        this._textInputFocus = EditorContextKeys.textInputFocus.bindTo(contextKeyService);\n        this._editorTextFocus = EditorContextKeys.editorTextFocus.bindTo(contextKeyService);\n        this._tabMovesFocus = EditorContextKeys.tabMovesFocus.bindTo(contextKeyService);\n        this._editorReadonly = EditorContextKeys.readOnly.bindTo(contextKeyService);\n        this._inDiffEditor = EditorContextKeys.inDiffEditor.bindTo(contextKeyService);\n        this._editorColumnSelection = EditorContextKeys.columnSelection.bindTo(contextKeyService);\n        this._hasMultipleSelections = EditorContextKeys.hasMultipleSelections.bindTo(contextKeyService);\n        this._hasNonEmptySelection = EditorContextKeys.hasNonEmptySelection.bindTo(contextKeyService);\n        this._canUndo = EditorContextKeys.canUndo.bindTo(contextKeyService);\n        this._canRedo = EditorContextKeys.canRedo.bindTo(contextKeyService);\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig()));\n        this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection()));\n        this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus()));\n        this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus()));\n        this._register(this._editor.onDidChangeModel(() => this._updateFromModel()));\n        this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel()));\n        this._register(TabFocus.onDidChangeTabFocus((tabFocusMode) => this._tabMovesFocus.set(tabFocusMode)));\n        this._updateFromConfig();\n        this._updateFromSelection();\n        this._updateFromFocus();\n        this._updateFromModel();\n        this._editorSimpleInput.set(this._editor.isSimpleWidget);\n    }\n    _updateFromConfig() {\n        const options = this._editor.getOptions();\n        this._tabMovesFocus.set(TabFocus.getTabFocusMode());\n        this._editorReadonly.set(options.get(92 /* EditorOption.readOnly */));\n        this._inDiffEditor.set(options.get(61 /* EditorOption.inDiffEditor */));\n        this._editorColumnSelection.set(options.get(22 /* EditorOption.columnSelection */));\n    }\n    _updateFromSelection() {\n        const selections = this._editor.getSelections();\n        if (!selections) {\n            this._hasMultipleSelections.reset();\n            this._hasNonEmptySelection.reset();\n        }\n        else {\n            this._hasMultipleSelections.set(selections.length > 1);\n            this._hasNonEmptySelection.set(selections.some(s => !s.isEmpty()));\n        }\n    }\n    _updateFromFocus() {\n        this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget);\n        this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget);\n        this._textInputFocus.set(this._editor.hasTextFocus());\n    }\n    _updateFromModel() {\n        const model = this._editor.getModel();\n        this._canUndo.set(Boolean(model && model.canUndo()));\n        this._canRedo.set(Boolean(model && model.canRedo()));\n    }\n}\nexport class EditorModeContext extends Disposable {\n    constructor(_editor, _contextKeyService, _languageFeaturesService) {\n        super();\n        this._editor = _editor;\n        this._contextKeyService = _contextKeyService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._langId = EditorContextKeys.languageId.bindTo(_contextKeyService);\n        this._hasCompletionItemProvider = EditorContextKeys.hasCompletionItemProvider.bindTo(_contextKeyService);\n        this._hasCodeActionsProvider = EditorContextKeys.hasCodeActionsProvider.bindTo(_contextKeyService);\n        this._hasCodeLensProvider = EditorContextKeys.hasCodeLensProvider.bindTo(_contextKeyService);\n        this._hasDefinitionProvider = EditorContextKeys.hasDefinitionProvider.bindTo(_contextKeyService);\n        this._hasDeclarationProvider = EditorContextKeys.hasDeclarationProvider.bindTo(_contextKeyService);\n        this._hasImplementationProvider = EditorContextKeys.hasImplementationProvider.bindTo(_contextKeyService);\n        this._hasTypeDefinitionProvider = EditorContextKeys.hasTypeDefinitionProvider.bindTo(_contextKeyService);\n        this._hasHoverProvider = EditorContextKeys.hasHoverProvider.bindTo(_contextKeyService);\n        this._hasDocumentHighlightProvider = EditorContextKeys.hasDocumentHighlightProvider.bindTo(_contextKeyService);\n        this._hasDocumentSymbolProvider = EditorContextKeys.hasDocumentSymbolProvider.bindTo(_contextKeyService);\n        this._hasReferenceProvider = EditorContextKeys.hasReferenceProvider.bindTo(_contextKeyService);\n        this._hasRenameProvider = EditorContextKeys.hasRenameProvider.bindTo(_contextKeyService);\n        this._hasSignatureHelpProvider = EditorContextKeys.hasSignatureHelpProvider.bindTo(_contextKeyService);\n        this._hasInlayHintsProvider = EditorContextKeys.hasInlayHintsProvider.bindTo(_contextKeyService);\n        this._hasDocumentFormattingProvider = EditorContextKeys.hasDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasDocumentSelectionFormattingProvider = EditorContextKeys.hasDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentFormattingProvider = EditorContextKeys.hasMultipleDocumentFormattingProvider.bindTo(_contextKeyService);\n        this._hasMultipleDocumentSelectionFormattingProvider = EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider.bindTo(_contextKeyService);\n        this._isInEmbeddedEditor = EditorContextKeys.isInEmbeddedEditor.bindTo(_contextKeyService);\n        const update = () => this._update();\n        // update when model/mode changes\n        this._register(_editor.onDidChangeModel(update));\n        this._register(_editor.onDidChangeModelLanguage(update));\n        // update when registries change\n        this._register(_languageFeaturesService.completionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.codeActionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.codeLensProvider.onDidChange(update));\n        this._register(_languageFeaturesService.definitionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.declarationProvider.onDidChange(update));\n        this._register(_languageFeaturesService.implementationProvider.onDidChange(update));\n        this._register(_languageFeaturesService.typeDefinitionProvider.onDidChange(update));\n        this._register(_languageFeaturesService.hoverProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentHighlightProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentSymbolProvider.onDidChange(update));\n        this._register(_languageFeaturesService.referenceProvider.onDidChange(update));\n        this._register(_languageFeaturesService.renameProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentFormattingEditProvider.onDidChange(update));\n        this._register(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(update));\n        this._register(_languageFeaturesService.signatureHelpProvider.onDidChange(update));\n        this._register(_languageFeaturesService.inlayHintsProvider.onDidChange(update));\n        update();\n    }\n    dispose() {\n        super.dispose();\n    }\n    reset() {\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.reset();\n            this._hasCompletionItemProvider.reset();\n            this._hasCodeActionsProvider.reset();\n            this._hasCodeLensProvider.reset();\n            this._hasDefinitionProvider.reset();\n            this._hasDeclarationProvider.reset();\n            this._hasImplementationProvider.reset();\n            this._hasTypeDefinitionProvider.reset();\n            this._hasHoverProvider.reset();\n            this._hasDocumentHighlightProvider.reset();\n            this._hasDocumentSymbolProvider.reset();\n            this._hasReferenceProvider.reset();\n            this._hasRenameProvider.reset();\n            this._hasDocumentFormattingProvider.reset();\n            this._hasDocumentSelectionFormattingProvider.reset();\n            this._hasSignatureHelpProvider.reset();\n            this._isInEmbeddedEditor.reset();\n        });\n    }\n    _update() {\n        const model = this._editor.getModel();\n        if (!model) {\n            this.reset();\n            return;\n        }\n        this._contextKeyService.bufferChangeEvents(() => {\n            this._langId.set(model.getLanguageId());\n            this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(model));\n            this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(model));\n            this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(model));\n            this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(model));\n            this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(model));\n            this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(model));\n            this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(model));\n            this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(model));\n            this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(model));\n            this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(model));\n            this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(model));\n            this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(model));\n            this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(model));\n            this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(model));\n            this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(model) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(model));\n            this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(model));\n            this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(model).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(model).length > 1);\n            this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(model).length > 1);\n            this._isInEmbeddedEditor.set(model.uri.scheme === Schemas.walkThroughSnippet || model.uri.scheme === Schemas.vscodeChatCodeBlock);\n        });\n    }\n}\nclass CodeEditorWidgetFocusTracker extends Disposable {\n    constructor(domElement, overflowWidgetsDomNode) {\n        super();\n        this._onChange = this._register(new Emitter());\n        this.onChange = this._onChange.event;\n        this._hadFocus = undefined;\n        this._hasDomElementFocus = false;\n        this._domFocusTracker = this._register(dom.trackFocus(domElement));\n        this._overflowWidgetsDomNodeHasFocus = false;\n        this._register(this._domFocusTracker.onDidFocus(() => {\n            this._hasDomElementFocus = true;\n            this._update();\n        }));\n        this._register(this._domFocusTracker.onDidBlur(() => {\n            this._hasDomElementFocus = false;\n            this._update();\n        }));\n        if (overflowWidgetsDomNode) {\n            this._overflowWidgetsDomNode = this._register(dom.trackFocus(overflowWidgetsDomNode));\n            this._register(this._overflowWidgetsDomNode.onDidFocus(() => {\n                this._overflowWidgetsDomNodeHasFocus = true;\n                this._update();\n            }));\n            this._register(this._overflowWidgetsDomNode.onDidBlur(() => {\n                this._overflowWidgetsDomNodeHasFocus = false;\n                this._update();\n            }));\n        }\n    }\n    _update() {\n        const focused = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;\n        if (this._hadFocus !== focused) {\n            this._hadFocus = focused;\n            this._onChange.fire(undefined);\n        }\n    }\n    hasFocus() {\n        return this._hadFocus ?? false;\n    }\n}\nclass EditorDecorationsCollection {\n    get length() {\n        return this._decorationIds.length;\n    }\n    constructor(_editor, decorations) {\n        this._editor = _editor;\n        this._decorationIds = [];\n        this._isChangingDecorations = false;\n        if (Array.isArray(decorations) && decorations.length > 0) {\n            this.set(decorations);\n        }\n    }\n    onDidChange(listener, thisArgs, disposables) {\n        return this._editor.onDidChangeModelDecorations((e) => {\n            if (this._isChangingDecorations) {\n                return;\n            }\n            listener.call(thisArgs, e);\n        }, disposables);\n    }\n    getRange(index) {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (index >= this._decorationIds.length) {\n            return null;\n        }\n        return this._editor.getModel().getDecorationRange(this._decorationIds[index]);\n    }\n    getRanges() {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        const model = this._editor.getModel();\n        const result = [];\n        for (const decorationId of this._decorationIds) {\n            const range = model.getDecorationRange(decorationId);\n            if (range) {\n                result.push(range);\n            }\n        }\n        return result;\n    }\n    has(decoration) {\n        return this._decorationIds.includes(decoration.id);\n    }\n    clear() {\n        if (this._decorationIds.length === 0) {\n            // nothing to do\n            return;\n        }\n        this.set([]);\n    }\n    set(newDecorations) {\n        try {\n            this._isChangingDecorations = true;\n            this._editor.changeDecorations((accessor) => {\n                this._decorationIds = accessor.deltaDecorations(this._decorationIds, newDecorations);\n            });\n        }\n        finally {\n            this._isChangingDecorations = false;\n        }\n        return this._decorationIds;\n    }\n    append(newDecorations) {\n        let newDecorationIds = [];\n        try {\n            this._isChangingDecorations = true;\n            this._editor.changeDecorations((accessor) => {\n                newDecorationIds = accessor.deltaDecorations([], newDecorations);\n                this._decorationIds = this._decorationIds.concat(newDecorationIds);\n            });\n        }\n        finally {\n            this._isChangingDecorations = false;\n        }\n        return newDecorationIds;\n    }\n}\nconst squigglyStart = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='`);\nconst squigglyEnd = encodeURIComponent(`'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>`);\nfunction getSquigglySVGData(color) {\n    return squigglyStart + encodeURIComponent(color.toString()) + squigglyEnd;\n}\nconst dotdotdotStart = encodeURIComponent(`<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"3\" width=\"12\"><g fill=\"`);\nconst dotdotdotEnd = encodeURIComponent(`\"><circle cx=\"1\" cy=\"1\" r=\"1\"/><circle cx=\"5\" cy=\"1\" r=\"1\"/><circle cx=\"9\" cy=\"1\" r=\"1\"/></g></svg>`);\nfunction getDotDotDotSVGData(color) {\n    return dotdotdotStart + encodeURIComponent(color.toString()) + dotdotdotEnd;\n}\nregisterThemingParticipant((theme, collector) => {\n    const errorForeground = theme.getColor(editorErrorForeground);\n    if (errorForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-error\" /* ClassName.EditorErrorDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(errorForeground)}\") repeat-x bottom left; }`);\n    }\n    const warningForeground = theme.getColor(editorWarningForeground);\n    if (warningForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-warning\" /* ClassName.EditorWarningDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(warningForeground)}\") repeat-x bottom left; }`);\n    }\n    const infoForeground = theme.getColor(editorInfoForeground);\n    if (infoForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-info\" /* ClassName.EditorInfoDecoration */} { background: url(\"data:image/svg+xml,${getSquigglySVGData(infoForeground)}\") repeat-x bottom left; }`);\n    }\n    const hintForeground = theme.getColor(editorHintForeground);\n    if (hintForeground) {\n        collector.addRule(`.monaco-editor .${\"squiggly-hint\" /* ClassName.EditorHintDecoration */} { background: url(\"data:image/svg+xml,${getDotDotDotSVGData(hintForeground)}\") no-repeat bottom left; }`);\n    }\n    const unnecessaryForeground = theme.getColor(editorUnnecessaryCodeOpacity);\n    if (unnecessaryForeground) {\n        collector.addRule(`.monaco-editor.showUnused .${\"squiggly-inline-unnecessary\" /* ClassName.EditorUnnecessaryInlineDecoration */} { opacity: ${unnecessaryForeground.rgba.a}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { addStandardDisposableListener, getDomNodePagePosition } from '../../../../../../base/browser/dom.js';\nimport { Action } from '../../../../../../base/common/actions.js';\nimport { Codicon } from '../../../../../../base/common/codicons.js';\nimport { Disposable } from '../../../../../../base/common/lifecycle.js';\nimport { isIOS } from '../../../../../../base/common/platform.js';\nimport { ThemeIcon } from '../../../../../../base/common/themables.js';\nimport { localize } from '../../../../../../nls.js';\nexport class InlineDiffDeletedCodeMargin extends Disposable {\n    get visibility() {\n        return this._visibility;\n    }\n    set visibility(_visibility) {\n        if (this._visibility !== _visibility) {\n            this._visibility = _visibility;\n            this._diffActions.style.visibility = _visibility ? 'visible' : 'hidden';\n        }\n    }\n    constructor(_getViewZoneId, _marginDomNode, _modifiedEditor, _diff, _editor, _viewLineCounts, _originalTextModel, _contextMenuService, _clipboardService) {\n        super();\n        this._getViewZoneId = _getViewZoneId;\n        this._marginDomNode = _marginDomNode;\n        this._modifiedEditor = _modifiedEditor;\n        this._diff = _diff;\n        this._editor = _editor;\n        this._viewLineCounts = _viewLineCounts;\n        this._originalTextModel = _originalTextModel;\n        this._contextMenuService = _contextMenuService;\n        this._clipboardService = _clipboardService;\n        this._visibility = false;\n        // make sure the diff margin shows above overlay.\n        this._marginDomNode.style.zIndex = '10';\n        this._diffActions = document.createElement('div');\n        this._diffActions.className = ThemeIcon.asClassName(Codicon.lightBulb) + ' lightbulb-glyph';\n        this._diffActions.style.position = 'absolute';\n        const lineHeight = this._modifiedEditor.getOption(67 /* EditorOption.lineHeight */);\n        this._diffActions.style.right = '0px';\n        this._diffActions.style.visibility = 'hidden';\n        this._diffActions.style.height = `${lineHeight}px`;\n        this._diffActions.style.lineHeight = `${lineHeight}px`;\n        this._marginDomNode.appendChild(this._diffActions);\n        let currentLineNumberOffset = 0;\n        const useShadowDOM = _modifiedEditor.getOption(128 /* EditorOption.useShadowDOM */) && !isIOS; // Do not use shadow dom on IOS #122035\n        const showContextMenu = (x, y) => {\n            this._contextMenuService.showContextMenu({\n                domForShadowRoot: useShadowDOM ? _modifiedEditor.getDomNode() ?? undefined : undefined,\n                getAnchor: () => ({ x, y }),\n                getActions: () => {\n                    const actions = [];\n                    const isDeletion = _diff.modified.isEmpty;\n                    // default action\n                    actions.push(new Action('diff.clipboard.copyDeletedContent', isDeletion\n                        ? (_diff.original.length > 1\n                            ? localize('diff.clipboard.copyDeletedLinesContent.label', \"Copy deleted lines\")\n                            : localize('diff.clipboard.copyDeletedLinesContent.single.label', \"Copy deleted line\"))\n                        : (_diff.original.length > 1\n                            ? localize('diff.clipboard.copyChangedLinesContent.label', \"Copy changed lines\")\n                            : localize('diff.clipboard.copyChangedLinesContent.single.label', \"Copy changed line\")), undefined, true, async () => {\n                        const originalText = this._originalTextModel.getValueInRange(_diff.original.toExclusiveRange());\n                        await this._clipboardService.writeText(originalText);\n                    }));\n                    if (_diff.original.length > 1) {\n                        actions.push(new Action('diff.clipboard.copyDeletedLineContent', isDeletion\n                            ? localize('diff.clipboard.copyDeletedLineContent.label', \"Copy deleted line ({0})\", _diff.original.startLineNumber + currentLineNumberOffset)\n                            : localize('diff.clipboard.copyChangedLineContent.label', \"Copy changed line ({0})\", _diff.original.startLineNumber + currentLineNumberOffset), undefined, true, async () => {\n                            let lineContent = this._originalTextModel.getLineContent(_diff.original.startLineNumber + currentLineNumberOffset);\n                            if (lineContent === '') {\n                                // empty line -> new line\n                                const eof = this._originalTextModel.getEndOfLineSequence();\n                                lineContent = eof === 0 /* EndOfLineSequence.LF */ ? '\\n' : '\\r\\n';\n                            }\n                            await this._clipboardService.writeText(lineContent);\n                        }));\n                    }\n                    const readOnly = _modifiedEditor.getOption(92 /* EditorOption.readOnly */);\n                    if (!readOnly) {\n                        actions.push(new Action('diff.inline.revertChange', localize('diff.inline.revertChange.label', \"Revert this change\"), undefined, true, async () => {\n                            this._editor.revert(this._diff);\n                        }));\n                    }\n                    return actions;\n                },\n                autoSelectFirstItem: true\n            });\n        };\n        this._register(addStandardDisposableListener(this._diffActions, 'mousedown', e => {\n            if (!e.leftButton) {\n                return;\n            }\n            const { top, height } = getDomNodePagePosition(this._diffActions);\n            const pad = Math.floor(lineHeight / 3);\n            e.preventDefault();\n            showContextMenu(e.posx, top + height + pad);\n        }));\n        this._register(_modifiedEditor.onMouseMove((e) => {\n            if ((e.target.type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ || e.target.type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) && e.target.detail.viewZoneId === this._getViewZoneId()) {\n                currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                this.visibility = true;\n            }\n            else {\n                this.visibility = false;\n            }\n        }));\n        this._register(_modifiedEditor.onMouseDown((e) => {\n            if (!e.event.leftButton) {\n                return;\n            }\n            if (e.target.type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ || e.target.type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n                const viewZoneId = e.target.detail.viewZoneId;\n                if (viewZoneId === this._getViewZoneId()) {\n                    e.event.preventDefault();\n                    currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);\n                    showContextMenu(e.event.posx, e.event.posy + lineHeight);\n                }\n            }\n        }));\n    }\n    _updateLightBulbPosition(marginDomNode, y, lineHeight) {\n        const { top } = getDomNodePagePosition(marginDomNode);\n        const offset = y - top;\n        const lineNumberOffset = Math.floor(offset / lineHeight);\n        const newTop = lineNumberOffset * lineHeight;\n        this._diffActions.style.top = `${newTop}px`;\n        if (this._viewLineCounts) {\n            let acc = 0;\n            for (let i = 0; i < this._viewLineCounts.length; i++) {\n                acc += this._viewLineCounts[i];\n                if (lineNumberOffset < acc) {\n                    return i;\n                }\n            }\n        }\n        return lineNumberOffset;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as aria from '../../../base/browser/ui/aria/aria.js';\nimport { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { CodeEditorWidget } from '../../browser/widget/codeEditor/codeEditorWidget.js';\nimport { InternalEditorAction } from '../../common/editorAction.js';\nimport { StandaloneKeybindingService, updateConfigurationService } from './standaloneServices.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { MenuId, MenuRegistry } from '../../../platform/actions/common/actions.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { StandaloneCodeEditorNLS } from '../../common/standaloneStrings.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { StandaloneCodeEditorService } from './standaloneCodeEditorService.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../../common/languages/modesRegistry.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nimport { DiffEditorWidget } from '../../browser/widget/diffEditor/diffEditorWidget.js';\nimport { IAccessibilitySignalService } from '../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { setHoverDelegateFactory } from '../../../base/browser/ui/hover/hoverDelegateFactory.js';\nimport { IHoverService, WorkbenchHoverDelegate } from '../../../platform/hover/browser/hover.js';\nimport { setBaseLayerHoverDelegate } from '../../../base/browser/ui/hover/hoverDelegate2.js';\nlet LAST_GENERATED_COMMAND_ID = 0;\nlet ariaDomNodeCreated = false;\n/**\n * Create ARIA dom node inside parent,\n * or only for the first editor instantiation inside document.body.\n * @param parent container element for ARIA dom node\n */\nfunction createAriaDomNode(parent) {\n    if (!parent) {\n        if (ariaDomNodeCreated) {\n            return;\n        }\n        ariaDomNodeCreated = true;\n    }\n    aria.setARIAContainer(parent || mainWindow.document.body);\n}\n/**\n * A code editor to be used both by the standalone editor and the standalone diff editor.\n */\nlet StandaloneCodeEditor = class StandaloneCodeEditor extends CodeEditorWidget {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {\n        const options = { ..._options };\n        options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;\n        super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        if (keybindingService instanceof StandaloneKeybindingService) {\n            this._standaloneKeybindingService = keybindingService;\n        }\n        else {\n            this._standaloneKeybindingService = null;\n        }\n        createAriaDomNode(options.ariaContainerElement);\n        setHoverDelegateFactory((placement, enableInstantHover) => instantiationService.createInstance(WorkbenchHoverDelegate, placement, enableInstantHover, {}));\n        setBaseLayerHoverDelegate(hoverService);\n    }\n    addCommand(keybinding, handler, context) {\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');\n            return null;\n        }\n        const commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);\n        const whenExpression = ContextKeyExpr.deserialize(context);\n        this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);\n        return commandId;\n    }\n    createContextKey(key, defaultValue) {\n        return this._contextKeyService.createKey(key, defaultValue);\n    }\n    addAction(_descriptor) {\n        if ((typeof _descriptor.id !== 'string') || (typeof _descriptor.label !== 'string') || (typeof _descriptor.run !== 'function')) {\n            throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');\n        }\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');\n            return Disposable.None;\n        }\n        // Read descriptor options\n        const id = _descriptor.id;\n        const label = _descriptor.label;\n        const precondition = ContextKeyExpr.and(ContextKeyExpr.equals('editorId', this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));\n        const keybindings = _descriptor.keybindings;\n        const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));\n        const contextMenuGroupId = _descriptor.contextMenuGroupId || null;\n        const contextMenuOrder = _descriptor.contextMenuOrder || 0;\n        const run = (_accessor, ...args) => {\n            return Promise.resolve(_descriptor.run(this, ...args));\n        };\n        const toDispose = new DisposableStore();\n        // Generate a unique id to allow the same descriptor.id across multiple editor instances\n        const uniqueId = this.getId() + ':' + id;\n        // Register the command\n        toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));\n        // Register the context menu item\n        if (contextMenuGroupId) {\n            const menuItem = {\n                command: {\n                    id: uniqueId,\n                    title: label\n                },\n                when: precondition,\n                group: contextMenuGroupId,\n                order: contextMenuOrder\n            };\n            toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));\n        }\n        // Register the keybindings\n        if (Array.isArray(keybindings)) {\n            for (const kb of keybindings) {\n                toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));\n            }\n        }\n        // Finally, register an internal editor action\n        const internalAction = new InternalEditorAction(uniqueId, label, label, undefined, precondition, (...args) => Promise.resolve(_descriptor.run(this, ...args)), this._contextKeyService);\n        // Store it under the original id, such that trigger with the original id will work\n        this._actions.set(id, internalAction);\n        toDispose.add(toDisposable(() => {\n            this._actions.delete(id);\n        }));\n        return toDispose;\n    }\n    _triggerCommand(handlerId, payload) {\n        if (this._codeEditorService instanceof StandaloneCodeEditorService) {\n            // Help commands find this editor as the active editor\n            try {\n                this._codeEditorService.setActiveCodeEditor(this);\n                super._triggerCommand(handlerId, payload);\n            }\n            finally {\n                this._codeEditorService.setActiveCodeEditor(null);\n            }\n        }\n        else {\n            super._triggerCommand(handlerId, payload);\n        }\n    }\n};\nStandaloneCodeEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IHoverService),\n    __param(7, IKeybindingService),\n    __param(8, IThemeService),\n    __param(9, INotificationService),\n    __param(10, IAccessibilityService),\n    __param(11, ILanguageConfigurationService),\n    __param(12, ILanguageFeaturesService)\n], StandaloneCodeEditor);\nexport { StandaloneCodeEditor };\nlet StandaloneEditor = class StandaloneEditor extends StandaloneCodeEditor {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {\n        const options = { ..._options };\n        updateConfigurationService(configurationService, options, false);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        const _model = options.model;\n        delete options.model;\n        super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, hoverService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n        let model;\n        if (typeof _model === 'undefined') {\n            const languageId = languageService.getLanguageIdByMimeType(options.language) || options.language || PLAINTEXT_LANGUAGE_ID;\n            model = createTextModel(modelService, languageService, options.value || '', languageId, undefined);\n            this._ownsModel = true;\n        }\n        else {\n            model = _model;\n            this._ownsModel = false;\n        }\n        this._attachModel(model);\n        if (model) {\n            const e = {\n                oldModelUrl: null,\n                newModelUrl: model.uri\n            };\n            this._onDidChangeModel.fire(e);\n        }\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, false);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _postDetachModelCleanup(detachedModel) {\n        super._postDetachModelCleanup(detachedModel);\n        if (detachedModel && this._ownsModel) {\n            detachedModel.dispose();\n            this._ownsModel = false;\n        }\n    }\n};\nStandaloneEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IHoverService),\n    __param(7, IKeybindingService),\n    __param(8, IStandaloneThemeService),\n    __param(9, INotificationService),\n    __param(10, IConfigurationService),\n    __param(11, IAccessibilityService),\n    __param(12, IModelService),\n    __param(13, ILanguageService),\n    __param(14, ILanguageConfigurationService),\n    __param(15, ILanguageFeaturesService)\n], StandaloneEditor);\nexport { StandaloneEditor };\nlet StandaloneDiffEditor2 = class StandaloneDiffEditor2 extends DiffEditorWidget {\n    constructor(domElement, _options, instantiationService, contextKeyService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService, accessibilitySignalService) {\n        const options = { ..._options };\n        updateConfigurationService(configurationService, options, true);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        super(domElement, options, {}, contextKeyService, instantiationService, codeEditorService, accessibilitySignalService, editorProgressService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, true);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _createInnerEditor(instantiationService, container, options) {\n        return instantiationService.createInstance(StandaloneCodeEditor, container, options);\n    }\n    getOriginalEditor() {\n        return super.getOriginalEditor();\n    }\n    getModifiedEditor() {\n        return super.getModifiedEditor();\n    }\n    addCommand(keybinding, handler, context) {\n        return this.getModifiedEditor().addCommand(keybinding, handler, context);\n    }\n    createContextKey(key, defaultValue) {\n        return this.getModifiedEditor().createContextKey(key, defaultValue);\n    }\n    addAction(descriptor) {\n        return this.getModifiedEditor().addAction(descriptor);\n    }\n};\nStandaloneDiffEditor2 = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, IContextKeyService),\n    __param(4, ICodeEditorService),\n    __param(5, IStandaloneThemeService),\n    __param(6, INotificationService),\n    __param(7, IConfigurationService),\n    __param(8, IContextMenuService),\n    __param(9, IEditorProgressService),\n    __param(10, IClipboardService),\n    __param(11, IAccessibilitySignalService)\n], StandaloneDiffEditor2);\nexport { StandaloneDiffEditor2 };\n/**\n * @internal\n */\nexport function createTextModel(modelService, languageService, value, languageId, uri) {\n    value = value || '';\n    if (!languageId) {\n        const firstLF = value.indexOf('\\n');\n        let firstLine = value;\n        if (firstLF !== -1) {\n            firstLine = value.substring(0, firstLF);\n        }\n        return doCreateModel(modelService, value, languageService.createByFilepathOrFirstLine(uri || null, firstLine), uri);\n    }\n    return doCreateModel(modelService, value, languageService.createById(languageId), uri);\n}\n/**\n * @internal\n */\nfunction doCreateModel(modelService, value, languageSelection, uri) {\n    return modelService.createModel(value, languageSelection, uri);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*\n * This module only exports 'compile' which compiles a JSON language definition\n * into a typed and checked ILexer definition.\n */\nimport * as monarchCommon from './monarchCommon.js';\n/*\n * Type helpers\n *\n * Note: this is just for sanity checks on the JSON description which is\n * helpful for the programmer. No checks are done anymore once the lexer is\n * already 'compiled and checked'.\n *\n */\nfunction isArrayOf(elemType, obj) {\n    if (!obj) {\n        return false;\n    }\n    if (!(Array.isArray(obj))) {\n        return false;\n    }\n    for (const el of obj) {\n        if (!(elemType(el))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction bool(prop, defValue) {\n    if (typeof prop === 'boolean') {\n        return prop;\n    }\n    return defValue;\n}\nfunction string(prop, defValue) {\n    if (typeof (prop) === 'string') {\n        return prop;\n    }\n    return defValue;\n}\nfunction arrayToHash(array) {\n    const result = {};\n    for (const e of array) {\n        result[e] = true;\n    }\n    return result;\n}\nfunction createKeywordMatcher(arr, caseInsensitive = false) {\n    if (caseInsensitive) {\n        arr = arr.map(function (x) { return x.toLowerCase(); });\n    }\n    const hash = arrayToHash(arr);\n    if (caseInsensitive) {\n        return function (word) {\n            return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n        };\n    }\n    else {\n        return function (word) {\n            return hash[word] !== undefined && hash.hasOwnProperty(word);\n        };\n    }\n}\nfunction compileRegExp(lexer, str, handleSn) {\n    // @@ must be interpreted as a literal @, so we replace all occurences of @@ with a placeholder character\n    str = str.replace(/@@/g, `\\x01`);\n    let n = 0;\n    let hadExpansion;\n    do {\n        hadExpansion = false;\n        str = str.replace(/@(\\w+)/g, function (s, attr) {\n            hadExpansion = true;\n            let sub = '';\n            if (typeof (lexer[attr]) === 'string') {\n                sub = lexer[attr];\n            }\n            else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n                sub = lexer[attr].source;\n            }\n            else {\n                if (lexer[attr] === undefined) {\n                    throw monarchCommon.createError(lexer, 'language definition does not contain attribute \\'' + attr + '\\', used at: ' + str);\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'attribute reference \\'' + attr + '\\' must be a string, used at: ' + str);\n                }\n            }\n            return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');\n        });\n        n++;\n    } while (hadExpansion && n < 5);\n    // handle escaped @@\n    str = str.replace(/\\x01/g, '@');\n    const flags = (lexer.ignoreCase ? 'i' : '') + (lexer.unicode ? 'u' : '');\n    // handle $Sn\n    if (handleSn) {\n        const match = str.match(/\\$[sS](\\d\\d?)/g);\n        if (match) {\n            let lastState = null;\n            let lastRegEx = null;\n            return (state) => {\n                if (lastRegEx && lastState === state) {\n                    return lastRegEx;\n                }\n                lastState = state;\n                lastRegEx = new RegExp(monarchCommon.substituteMatchesRe(lexer, str, state), flags);\n                return lastRegEx;\n            };\n        }\n    }\n    return new RegExp(str, flags);\n}\n/**\n * Compiles guard functions for case matches.\n * This compiles 'cases' attributes into efficient match functions.\n *\n */\nfunction selectScrutinee(id, matches, state, num) {\n    if (num < 0) {\n        return id;\n    }\n    if (num < matches.length) {\n        return matches[num];\n    }\n    if (num >= 100) {\n        num = num - 100;\n        const parts = state.split('.');\n        parts.unshift(state);\n        if (num < parts.length) {\n            return parts[num];\n        }\n    }\n    return null;\n}\nfunction createGuard(lexer, ruleName, tkey, val) {\n    // get the scrutinee and pattern\n    let scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn\n    let oppat = tkey;\n    let matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n    if (matches) {\n        if (matches[3]) { // if digits\n            scrut = parseInt(matches[3]);\n            if (matches[2]) {\n                scrut = scrut + 100; // if [sS] present\n            }\n        }\n        oppat = matches[4];\n    }\n    // get operator\n    let op = '~';\n    let pat = oppat;\n    if (!oppat || oppat.length === 0) {\n        op = '!=';\n        pat = '';\n    }\n    else if (/^\\w*$/.test(pat)) { // just a word\n        op = '==';\n    }\n    else {\n        matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n        if (matches) {\n            op = matches[1];\n            pat = matches[2];\n        }\n    }\n    // set the tester function\n    let tester;\n    // special case a regexp that matches just words\n    if ((op === '~' || op === '!~') && /^(\\w|\\|)*$/.test(pat)) {\n        const inWords = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);\n        tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '@' || op === '!@') {\n        const words = lexer[pat];\n        if (!words) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' is not defined, in rule: ' + ruleName);\n        }\n        if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' must be an array of strings, in rule: ' + ruleName);\n        }\n        const inWords = createKeywordMatcher(words, lexer.ignoreCase);\n        tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '~' || op === '!~') {\n        if (pat.indexOf('$') < 0) {\n            // precompile regular expression\n            const re = compileRegExp(lexer, '^' + pat + '$', false);\n            tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };\n        }\n        else {\n            tester = function (s, id, matches, state) {\n                const re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$', false);\n                return re.test(s);\n            };\n        }\n    }\n    else { // if (op==='==' || op==='!=') {\n        if (pat.indexOf('$') < 0) {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s) { return (op === '==' ? s === patx : s !== patx); };\n        }\n        else {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s, id, matches, state, eos) {\n                const patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);\n                return (op === '==' ? s === patexp : s !== patexp);\n            };\n        }\n    }\n    // return the branch object\n    if (scrut === -1) {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                return tester(id, id, matches, state, eos);\n            }\n        };\n    }\n    else {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                const scrutinee = selectScrutinee(id, matches, state, scrut);\n                return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);\n            }\n        };\n    }\n}\n/**\n * Compiles an action: i.e. optimize regular expressions and case matches\n * and do many sanity checks.\n *\n * This is called only during compilation but if the lexer definition\n * contains user functions as actions (which is usually not allowed), then this\n * may be called during lexing. It is important therefore to compile common cases efficiently\n */\nfunction compileAction(lexer, ruleName, action) {\n    if (!action) {\n        return { token: '' };\n    }\n    else if (typeof (action) === 'string') {\n        return action; // { token: action };\n    }\n    else if (action.token || action.token === '') {\n        if (typeof (action.token) !== 'string') {\n            throw monarchCommon.createError(lexer, 'a \\'token\\' attribute must be of type string, in rule: ' + ruleName);\n        }\n        else {\n            // only copy specific typed fields (only happens once during compile Lexer)\n            const newAction = { token: action.token };\n            if (action.token.indexOf('$') >= 0) {\n                newAction.tokenSubst = true;\n            }\n            if (typeof (action.bracket) === 'string') {\n                if (action.bracket === '@open') {\n                    newAction.bracket = 1 /* monarchCommon.MonarchBracket.Open */;\n                }\n                else if (action.bracket === '@close') {\n                    newAction.bracket = -1 /* monarchCommon.MonarchBracket.Close */;\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'a \\'bracket\\' attribute must be either \\'@open\\' or \\'@close\\', in rule: ' + ruleName);\n                }\n            }\n            if (action.next) {\n                if (typeof (action.next) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'the next state must be a string value in rule: ' + ruleName);\n                }\n                else {\n                    let next = action.next;\n                    if (!/^(@pop|@push|@popall)$/.test(next)) {\n                        if (next[0] === '@') {\n                            next = next.substr(1); // peel off starting @ sign\n                        }\n                        if (next.indexOf('$') < 0) { // no dollar substitution, we can check if the state exists\n                            if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {\n                                throw monarchCommon.createError(lexer, 'the next state \\'' + action.next + '\\' is not defined in rule: ' + ruleName);\n                            }\n                        }\n                    }\n                    newAction.next = next;\n                }\n            }\n            if (typeof (action.goBack) === 'number') {\n                newAction.goBack = action.goBack;\n            }\n            if (typeof (action.switchTo) === 'string') {\n                newAction.switchTo = action.switchTo;\n            }\n            if (typeof (action.log) === 'string') {\n                newAction.log = action.log;\n            }\n            if (typeof (action.nextEmbedded) === 'string') {\n                newAction.nextEmbedded = action.nextEmbedded;\n                lexer.usesEmbedded = true;\n            }\n            return newAction;\n        }\n    }\n    else if (Array.isArray(action)) {\n        const results = [];\n        for (let i = 0, len = action.length; i < len; i++) {\n            results[i] = compileAction(lexer, ruleName, action[i]);\n        }\n        return { group: results };\n    }\n    else if (action.cases) {\n        // build an array of test cases\n        const cases = [];\n        // for each case, push a test function and result value\n        for (const tkey in action.cases) {\n            if (action.cases.hasOwnProperty(tkey)) {\n                const val = compileAction(lexer, ruleName, action.cases[tkey]);\n                // what kind of case\n                if (tkey === '@default' || tkey === '@' || tkey === '') {\n                    cases.push({ test: undefined, value: val, name: tkey });\n                }\n                else if (tkey === '@eos') {\n                    cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });\n                }\n                else {\n                    cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture\n                }\n            }\n        }\n        // create a matching function\n        const def = lexer.defaultToken;\n        return {\n            test: function (id, matches, state, eos) {\n                for (const _case of cases) {\n                    const didmatch = (!_case.test || _case.test(id, matches, state, eos));\n                    if (didmatch) {\n                        return _case.value;\n                    }\n                }\n                return def;\n            }\n        };\n    }\n    else {\n        throw monarchCommon.createError(lexer, 'an action must be a string, an object with a \\'token\\' or \\'cases\\' attribute, or an array of actions; in rule: ' + ruleName);\n    }\n}\n/**\n * Helper class for creating matching rules\n */\nclass Rule {\n    constructor(name) {\n        this.regex = new RegExp('');\n        this.action = { token: '' };\n        this.matchOnlyAtLineStart = false;\n        this.name = '';\n        this.name = name;\n    }\n    setRegex(lexer, re) {\n        let sregex;\n        if (typeof (re) === 'string') {\n            sregex = re;\n        }\n        else if (re instanceof RegExp) {\n            sregex = re.source;\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'rules must start with a match string or regular expression: ' + this.name);\n        }\n        this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');\n        this.name = this.name + ': ' + sregex;\n        this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')', true);\n    }\n    setAction(lexer, act) {\n        this.action = compileAction(lexer, this.name, act);\n    }\n    resolveRegex(state) {\n        if (this.regex instanceof RegExp) {\n            return this.regex;\n        }\n        else {\n            return this.regex(state);\n        }\n    }\n}\n/**\n * Compiles a json description function into json where all regular expressions,\n * case matches etc, are compiled and all include rules are expanded.\n * We also compile the bracket definitions, supply defaults, and do many sanity checks.\n * If the 'jsonStrict' parameter is 'false', we allow at certain locations\n * regular expression objects and functions that get called during lexing.\n * (Currently we have no samples that need this so perhaps we should always have\n * jsonStrict to true).\n */\nexport function compile(languageId, json) {\n    if (!json || typeof (json) !== 'object') {\n        throw new Error('Monarch: expecting a language definition object');\n    }\n    // Create our lexer\n    const lexer = {\n        languageId: languageId,\n        includeLF: bool(json.includeLF, false),\n        noThrow: false, // raise exceptions during compilation\n        maxStack: 100,\n        start: (typeof json.start === 'string' ? json.start : null),\n        ignoreCase: bool(json.ignoreCase, false),\n        unicode: bool(json.unicode, false),\n        tokenPostfix: string(json.tokenPostfix, '.' + languageId),\n        defaultToken: string(json.defaultToken, 'source'),\n        usesEmbedded: false, // becomes true if we find a nextEmbedded action\n        stateNames: {},\n        tokenizer: {},\n        brackets: []\n    };\n    // For calling compileAction later on\n    const lexerMin = json;\n    lexerMin.languageId = languageId;\n    lexerMin.includeLF = lexer.includeLF;\n    lexerMin.ignoreCase = lexer.ignoreCase;\n    lexerMin.unicode = lexer.unicode;\n    lexerMin.noThrow = lexer.noThrow;\n    lexerMin.usesEmbedded = lexer.usesEmbedded;\n    lexerMin.stateNames = json.tokenizer;\n    lexerMin.defaultToken = lexer.defaultToken;\n    // Compile an array of rules into newrules where RegExp objects are created.\n    function addRules(state, newrules, rules) {\n        for (const rule of rules) {\n            let include = rule.include;\n            if (include) {\n                if (typeof (include) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'an \\'include\\' attribute must be a string at: ' + state);\n                }\n                if (include[0] === '@') {\n                    include = include.substr(1); // peel off starting @\n                }\n                if (!json.tokenizer[include]) {\n                    throw monarchCommon.createError(lexer, 'include target \\'' + include + '\\' is not defined at: ' + state);\n                }\n                addRules(state + '.' + include, newrules, json.tokenizer[include]);\n            }\n            else {\n                const newrule = new Rule(state);\n                // Set up new rule attributes\n                if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n                    newrule.setRegex(lexerMin, rule[0]);\n                    if (rule.length >= 3) {\n                        if (typeof (rule[1]) === 'string') {\n                            newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });\n                        }\n                        else if (typeof (rule[1]) === 'object') {\n                            const rule1 = rule[1];\n                            rule1.next = rule[2];\n                            newrule.setAction(lexerMin, rule1);\n                        }\n                        else {\n                            throw monarchCommon.createError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);\n                        }\n                    }\n                    else {\n                        newrule.setAction(lexerMin, rule[1]);\n                    }\n                }\n                else {\n                    if (!rule.regex) {\n                        throw monarchCommon.createError(lexer, 'a rule must either be an array, or an object with a \\'regex\\' or \\'include\\' field at: ' + state);\n                    }\n                    if (rule.name) {\n                        if (typeof rule.name === 'string') {\n                            newrule.name = rule.name;\n                        }\n                    }\n                    if (rule.matchOnlyAtStart) {\n                        newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n                    }\n                    newrule.setRegex(lexerMin, rule.regex);\n                    newrule.setAction(lexerMin, rule.action);\n                }\n                newrules.push(newrule);\n            }\n        }\n    }\n    // compile the tokenizer rules\n    if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {\n        throw monarchCommon.createError(lexer, 'a language definition must define the \\'tokenizer\\' attribute as an object');\n    }\n    lexer.tokenizer = [];\n    for (const key in json.tokenizer) {\n        if (json.tokenizer.hasOwnProperty(key)) {\n            if (!lexer.start) {\n                lexer.start = key;\n            }\n            const rules = json.tokenizer[key];\n            lexer.tokenizer[key] = new Array();\n            addRules('tokenizer.' + key, lexer.tokenizer[key], rules);\n        }\n    }\n    lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction\n    // Set simple brackets\n    if (json.brackets) {\n        if (!(Array.isArray(json.brackets))) {\n            throw monarchCommon.createError(lexer, 'the \\'brackets\\' attribute must be defined as an array');\n        }\n    }\n    else {\n        json.brackets = [\n            { open: '{', close: '}', token: 'delimiter.curly' },\n            { open: '[', close: ']', token: 'delimiter.square' },\n            { open: '(', close: ')', token: 'delimiter.parenthesis' },\n            { open: '<', close: '>', token: 'delimiter.angle' }\n        ];\n    }\n    const brackets = [];\n    for (const el of json.brackets) {\n        let desc = el;\n        if (desc && Array.isArray(desc) && desc.length === 3) {\n            desc = { token: desc[2], open: desc[0], close: desc[1] };\n        }\n        if (desc.open === desc.close) {\n            throw monarchCommon.createError(lexer, 'open and close brackets in a \\'brackets\\' attribute must be different: ' + desc.open +\n                '\\n hint: use the \\'bracket\\' attribute if matching on equal brackets is required.');\n        }\n        if (typeof desc.open === 'string' && typeof desc.token === 'string' && typeof desc.close === 'string') {\n            brackets.push({\n                token: desc.token + lexer.tokenPostfix,\n                open: monarchCommon.fixCase(lexer, desc.open),\n                close: monarchCommon.fixCase(lexer, desc.close)\n            });\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'every element in the \\'brackets\\' array must be a \\'{open,close,token}\\' object or array');\n        }\n    }\n    lexer.brackets = brackets;\n    // Disable throw so the syntax highlighter goes, no matter what\n    lexer.noThrow = true;\n    return lexer;\n}\n","/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../editor/editor.api.js\";\n\n// src/basic-languages/_.contribution.ts\nvar languageDefinitions = {};\nvar lazyLanguageLoaders = {};\nvar LazyLanguageLoader = class _LazyLanguageLoader {\n  static getOrCreate(languageId) {\n    if (!lazyLanguageLoaders[languageId]) {\n      lazyLanguageLoaders[languageId] = new _LazyLanguageLoader(languageId);\n    }\n    return lazyLanguageLoaders[languageId];\n  }\n  constructor(languageId) {\n    this._languageId = languageId;\n    this._loadingTriggered = false;\n    this._lazyLoadPromise = new Promise((resolve, reject) => {\n      this._lazyLoadPromiseResolve = resolve;\n      this._lazyLoadPromiseReject = reject;\n    });\n  }\n  load() {\n    if (!this._loadingTriggered) {\n      this._loadingTriggered = true;\n      languageDefinitions[this._languageId].loader().then(\n        (mod) => this._lazyLoadPromiseResolve(mod),\n        (err) => this._lazyLoadPromiseReject(err)\n      );\n    }\n    return this._lazyLoadPromise;\n  }\n};\nasync function loadLanguage(languageId) {\n  await LazyLanguageLoader.getOrCreate(languageId).load();\n  const model = monaco_editor_core_exports.editor.createModel(\"\", languageId);\n  model.dispose();\n}\nfunction registerLanguage(def) {\n  const languageId = def.id;\n  languageDefinitions[languageId] = def;\n  monaco_editor_core_exports.languages.register(def);\n  const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);\n  monaco_editor_core_exports.languages.registerTokensProviderFactory(languageId, {\n    create: async () => {\n      const mod = await lazyLanguageLoader.load();\n      return mod.language;\n    }\n  });\n  monaco_editor_core_exports.languages.onLanguageEncountered(languageId, async () => {\n    const mod = await lazyLanguageLoader.load();\n    monaco_editor_core_exports.languages.setLanguageConfiguration(languageId, mod.conf);\n  });\n}\nexport {\n  loadLanguage,\n  registerLanguage\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/css/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  constructor(languageId, options, modeConfiguration) {\n    this._onDidChange = new monaco_editor_core_exports.Emitter();\n    this._languageId = languageId;\n    this.setOptions(options);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  get diagnosticsOptions() {\n    return this.options;\n  }\n  get options() {\n    return this._options;\n  }\n  setOptions(options) {\n    this._options = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setDiagnosticsOptions(options) {\n    this.setOptions(options);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar optionsDefault = {\n  validate: true,\n  lint: {\n    compatibleVendorPrefixes: \"ignore\",\n    vendorPrefix: \"warning\",\n    duplicateProperties: \"warning\",\n    emptyRules: \"warning\",\n    importStatement: \"ignore\",\n    boxModel: \"ignore\",\n    universalSelector: \"ignore\",\n    zeroUnits: \"ignore\",\n    fontFaceProperties: \"warning\",\n    hexColorLength: \"error\",\n    argumentsInColorFunction: \"error\",\n    unknownProperties: \"warning\",\n    ieHack: \"ignore\",\n    unknownVendorSpecificProperties: \"ignore\",\n    propertyIgnoredDueToDisplay: \"warning\",\n    important: \"ignore\",\n    float: \"ignore\",\n    idSelector: \"ignore\"\n  },\n  data: { useDefaultDataProvider: true },\n  format: {\n    newlineBetweenSelectors: true,\n    newlineBetweenRules: true,\n    spaceAroundSelectorSeparator: false,\n    braceStyle: \"collapse\",\n    maxPreserveNewLines: void 0,\n    preserveNewLines: true\n  }\n};\nvar modeConfigurationDefault = {\n  completionItems: true,\n  hovers: true,\n  documentSymbols: true,\n  definitions: true,\n  references: true,\n  documentHighlights: true,\n  rename: true,\n  colors: true,\n  foldingRanges: true,\n  diagnostics: true,\n  selectionRanges: true,\n  documentFormattingEdits: true,\n  documentRangeFormattingEdits: true\n};\nvar cssDefaults = new LanguageServiceDefaultsImpl(\n  \"css\",\n  optionsDefault,\n  modeConfigurationDefault\n);\nvar scssDefaults = new LanguageServiceDefaultsImpl(\n  \"scss\",\n  optionsDefault,\n  modeConfigurationDefault\n);\nvar lessDefaults = new LanguageServiceDefaultsImpl(\n  \"less\",\n  optionsDefault,\n  modeConfigurationDefault\n);\nmonaco_editor_core_exports.languages.css = { cssDefaults, lessDefaults, scssDefaults };\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/css/cssMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./cssMode.js\");\n  }\n}\nmonaco_editor_core_exports.languages.onLanguage(\"less\", () => {\n  getMode().then((mode) => mode.setupMode(lessDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"scss\", () => {\n  getMode().then((mode) => mode.setupMode(scssDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"css\", () => {\n  getMode().then((mode) => mode.setupMode(cssDefaults));\n});\nexport {\n  cssDefaults,\n  lessDefaults,\n  scssDefaults\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/html/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  constructor(languageId, options, modeConfiguration) {\n    this._onDidChange = new monaco_editor_core_exports.Emitter();\n    this._languageId = languageId;\n    this.setOptions(options);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get options() {\n    return this._options;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  setOptions(options) {\n    this._options = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar formatDefaults = {\n  tabSize: 4,\n  insertSpaces: false,\n  wrapLineLength: 120,\n  unformatted: 'default\": \"a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',\n  contentUnformatted: \"pre\",\n  indentInnerHtml: false,\n  preserveNewLines: true,\n  maxPreserveNewLines: void 0,\n  indentHandlebars: false,\n  endWithNewline: false,\n  extraLiners: \"head, body, /html\",\n  wrapAttributes: \"auto\"\n};\nvar optionsDefault = {\n  format: formatDefaults,\n  suggest: {},\n  data: { useDefaultDataProvider: true }\n};\nfunction getConfigurationDefault(languageId) {\n  return {\n    completionItems: true,\n    hovers: true,\n    documentSymbols: true,\n    links: true,\n    documentHighlights: true,\n    rename: true,\n    colors: true,\n    foldingRanges: true,\n    selectionRanges: true,\n    diagnostics: languageId === htmlLanguageId,\n    // turned off for Razor and Handlebar\n    documentFormattingEdits: languageId === htmlLanguageId,\n    // turned off for Razor and Handlebar\n    documentRangeFormattingEdits: languageId === htmlLanguageId\n    // turned off for Razor and Handlebar\n  };\n}\nvar htmlLanguageId = \"html\";\nvar handlebarsLanguageId = \"handlebars\";\nvar razorLanguageId = \"razor\";\nvar htmlLanguageService = registerHTMLLanguageService(\n  htmlLanguageId,\n  optionsDefault,\n  getConfigurationDefault(htmlLanguageId)\n);\nvar htmlDefaults = htmlLanguageService.defaults;\nvar handlebarLanguageService = registerHTMLLanguageService(\n  handlebarsLanguageId,\n  optionsDefault,\n  getConfigurationDefault(handlebarsLanguageId)\n);\nvar handlebarDefaults = handlebarLanguageService.defaults;\nvar razorLanguageService = registerHTMLLanguageService(\n  razorLanguageId,\n  optionsDefault,\n  getConfigurationDefault(razorLanguageId)\n);\nvar razorDefaults = razorLanguageService.defaults;\nmonaco_editor_core_exports.languages.html = {\n  htmlDefaults,\n  razorDefaults,\n  handlebarDefaults,\n  htmlLanguageService,\n  handlebarLanguageService,\n  razorLanguageService,\n  registerHTMLLanguageService\n};\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/html/htmlMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./htmlMode.js\");\n  }\n}\nfunction registerHTMLLanguageService(languageId, options = optionsDefault, modeConfiguration = getConfigurationDefault(languageId)) {\n  const defaults = new LanguageServiceDefaultsImpl(languageId, options, modeConfiguration);\n  let mode;\n  const onLanguageListener = monaco_editor_core_exports.languages.onLanguage(languageId, async () => {\n    mode = (await getMode()).setupMode(defaults);\n  });\n  return {\n    defaults,\n    dispose() {\n      onLanguageListener.dispose();\n      mode?.dispose();\n      mode = void 0;\n    }\n  };\n}\nexport {\n  handlebarDefaults,\n  handlebarLanguageService,\n  htmlDefaults,\n  htmlLanguageService,\n  razorDefaults,\n  razorLanguageService,\n  registerHTMLLanguageService\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/json/monaco.contribution.ts\nvar LanguageServiceDefaultsImpl = class {\n  constructor(languageId, diagnosticsOptions, modeConfiguration) {\n    this._onDidChange = new monaco_editor_core_exports.Emitter();\n    this._languageId = languageId;\n    this.setDiagnosticsOptions(diagnosticsOptions);\n    this.setModeConfiguration(modeConfiguration);\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  get diagnosticsOptions() {\n    return this._diagnosticsOptions;\n  }\n  setDiagnosticsOptions(options) {\n    this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(this);\n  }\n};\nvar diagnosticDefault = {\n  validate: true,\n  allowComments: true,\n  schemas: [],\n  enableSchemaRequest: false,\n  schemaRequest: \"warning\",\n  schemaValidation: \"warning\",\n  comments: \"error\",\n  trailingCommas: \"error\"\n};\nvar modeConfigurationDefault = {\n  documentFormattingEdits: true,\n  documentRangeFormattingEdits: true,\n  completionItems: true,\n  hovers: true,\n  documentSymbols: true,\n  tokens: true,\n  colors: true,\n  foldingRanges: true,\n  diagnostics: true,\n  selectionRanges: true\n};\nvar jsonDefaults = new LanguageServiceDefaultsImpl(\n  \"json\",\n  diagnosticDefault,\n  modeConfigurationDefault\n);\nvar getWorker = () => getMode().then((mode) => mode.getWorker());\nmonaco_editor_core_exports.languages.json = { jsonDefaults, getWorker };\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/json/jsonMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./jsonMode.js\");\n  }\n}\nmonaco_editor_core_exports.languages.register({\n  id: \"json\",\n  extensions: [\".json\", \".bowerrc\", \".jshintrc\", \".jscsrc\", \".eslintrc\", \".babelrc\", \".har\"],\n  aliases: [\"JSON\", \"json\"],\n  mimetypes: [\"application/json\"]\n});\nmonaco_editor_core_exports.languages.onLanguage(\"json\", () => {\n  getMode().then((mode) => mode.setupMode(jsonDefaults));\n});\nexport {\n  getWorker,\n  jsonDefaults\n};\n","import '../../editor/editor.api.js';\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/language/typescript/lib/typescriptServicesMetadata.ts\nvar typescriptVersion = \"5.4.5\";\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/language/typescript/monaco.contribution.ts\nvar ModuleKind = /* @__PURE__ */ ((ModuleKind2) => {\n  ModuleKind2[ModuleKind2[\"None\"] = 0] = \"None\";\n  ModuleKind2[ModuleKind2[\"CommonJS\"] = 1] = \"CommonJS\";\n  ModuleKind2[ModuleKind2[\"AMD\"] = 2] = \"AMD\";\n  ModuleKind2[ModuleKind2[\"UMD\"] = 3] = \"UMD\";\n  ModuleKind2[ModuleKind2[\"System\"] = 4] = \"System\";\n  ModuleKind2[ModuleKind2[\"ES2015\"] = 5] = \"ES2015\";\n  ModuleKind2[ModuleKind2[\"ESNext\"] = 99] = \"ESNext\";\n  return ModuleKind2;\n})(ModuleKind || {});\nvar JsxEmit = /* @__PURE__ */ ((JsxEmit2) => {\n  JsxEmit2[JsxEmit2[\"None\"] = 0] = \"None\";\n  JsxEmit2[JsxEmit2[\"Preserve\"] = 1] = \"Preserve\";\n  JsxEmit2[JsxEmit2[\"React\"] = 2] = \"React\";\n  JsxEmit2[JsxEmit2[\"ReactNative\"] = 3] = \"ReactNative\";\n  JsxEmit2[JsxEmit2[\"ReactJSX\"] = 4] = \"ReactJSX\";\n  JsxEmit2[JsxEmit2[\"ReactJSXDev\"] = 5] = \"ReactJSXDev\";\n  return JsxEmit2;\n})(JsxEmit || {});\nvar NewLineKind = /* @__PURE__ */ ((NewLineKind2) => {\n  NewLineKind2[NewLineKind2[\"CarriageReturnLineFeed\"] = 0] = \"CarriageReturnLineFeed\";\n  NewLineKind2[NewLineKind2[\"LineFeed\"] = 1] = \"LineFeed\";\n  return NewLineKind2;\n})(NewLineKind || {});\nvar ScriptTarget = /* @__PURE__ */ ((ScriptTarget2) => {\n  ScriptTarget2[ScriptTarget2[\"ES3\"] = 0] = \"ES3\";\n  ScriptTarget2[ScriptTarget2[\"ES5\"] = 1] = \"ES5\";\n  ScriptTarget2[ScriptTarget2[\"ES2015\"] = 2] = \"ES2015\";\n  ScriptTarget2[ScriptTarget2[\"ES2016\"] = 3] = \"ES2016\";\n  ScriptTarget2[ScriptTarget2[\"ES2017\"] = 4] = \"ES2017\";\n  ScriptTarget2[ScriptTarget2[\"ES2018\"] = 5] = \"ES2018\";\n  ScriptTarget2[ScriptTarget2[\"ES2019\"] = 6] = \"ES2019\";\n  ScriptTarget2[ScriptTarget2[\"ES2020\"] = 7] = \"ES2020\";\n  ScriptTarget2[ScriptTarget2[\"ESNext\"] = 99] = \"ESNext\";\n  ScriptTarget2[ScriptTarget2[\"JSON\"] = 100] = \"JSON\";\n  ScriptTarget2[ScriptTarget2[\"Latest\"] = 99 /* ESNext */] = \"Latest\";\n  return ScriptTarget2;\n})(ScriptTarget || {});\nvar ModuleResolutionKind = /* @__PURE__ */ ((ModuleResolutionKind2) => {\n  ModuleResolutionKind2[ModuleResolutionKind2[\"Classic\"] = 1] = \"Classic\";\n  ModuleResolutionKind2[ModuleResolutionKind2[\"NodeJs\"] = 2] = \"NodeJs\";\n  return ModuleResolutionKind2;\n})(ModuleResolutionKind || {});\nvar LanguageServiceDefaultsImpl = class {\n  constructor(compilerOptions, diagnosticsOptions, workerOptions, inlayHintsOptions, modeConfiguration) {\n    this._onDidChange = new monaco_editor_core_exports.Emitter();\n    this._onDidExtraLibsChange = new monaco_editor_core_exports.Emitter();\n    this._extraLibs = /* @__PURE__ */ Object.create(null);\n    this._removedExtraLibs = /* @__PURE__ */ Object.create(null);\n    this._eagerModelSync = false;\n    this.setCompilerOptions(compilerOptions);\n    this.setDiagnosticsOptions(diagnosticsOptions);\n    this.setWorkerOptions(workerOptions);\n    this.setInlayHintsOptions(inlayHintsOptions);\n    this.setModeConfiguration(modeConfiguration);\n    this._onDidExtraLibsChangeTimeout = -1;\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  get onDidExtraLibsChange() {\n    return this._onDidExtraLibsChange.event;\n  }\n  get modeConfiguration() {\n    return this._modeConfiguration;\n  }\n  get workerOptions() {\n    return this._workerOptions;\n  }\n  get inlayHintsOptions() {\n    return this._inlayHintsOptions;\n  }\n  getExtraLibs() {\n    return this._extraLibs;\n  }\n  addExtraLib(content, _filePath) {\n    let filePath;\n    if (typeof _filePath === \"undefined\") {\n      filePath = `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;\n    } else {\n      filePath = _filePath;\n    }\n    if (this._extraLibs[filePath] && this._extraLibs[filePath].content === content) {\n      return {\n        dispose: () => {\n        }\n      };\n    }\n    let myVersion = 1;\n    if (this._removedExtraLibs[filePath]) {\n      myVersion = this._removedExtraLibs[filePath] + 1;\n    }\n    if (this._extraLibs[filePath]) {\n      myVersion = this._extraLibs[filePath].version + 1;\n    }\n    this._extraLibs[filePath] = {\n      content,\n      version: myVersion\n    };\n    this._fireOnDidExtraLibsChangeSoon();\n    return {\n      dispose: () => {\n        let extraLib = this._extraLibs[filePath];\n        if (!extraLib) {\n          return;\n        }\n        if (extraLib.version !== myVersion) {\n          return;\n        }\n        delete this._extraLibs[filePath];\n        this._removedExtraLibs[filePath] = myVersion;\n        this._fireOnDidExtraLibsChangeSoon();\n      }\n    };\n  }\n  setExtraLibs(libs) {\n    for (const filePath in this._extraLibs) {\n      this._removedExtraLibs[filePath] = this._extraLibs[filePath].version;\n    }\n    this._extraLibs = /* @__PURE__ */ Object.create(null);\n    if (libs && libs.length > 0) {\n      for (const lib of libs) {\n        const filePath = lib.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;\n        const content = lib.content;\n        let myVersion = 1;\n        if (this._removedExtraLibs[filePath]) {\n          myVersion = this._removedExtraLibs[filePath] + 1;\n        }\n        this._extraLibs[filePath] = {\n          content,\n          version: myVersion\n        };\n      }\n    }\n    this._fireOnDidExtraLibsChangeSoon();\n  }\n  _fireOnDidExtraLibsChangeSoon() {\n    if (this._onDidExtraLibsChangeTimeout !== -1) {\n      return;\n    }\n    this._onDidExtraLibsChangeTimeout = window.setTimeout(() => {\n      this._onDidExtraLibsChangeTimeout = -1;\n      this._onDidExtraLibsChange.fire(void 0);\n    }, 0);\n  }\n  getCompilerOptions() {\n    return this._compilerOptions;\n  }\n  setCompilerOptions(options) {\n    this._compilerOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  getDiagnosticsOptions() {\n    return this._diagnosticsOptions;\n  }\n  setDiagnosticsOptions(options) {\n    this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setWorkerOptions(options) {\n    this._workerOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setInlayHintsOptions(options) {\n    this._inlayHintsOptions = options || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n  setMaximumWorkerIdleTime(value) {\n  }\n  setEagerModelSync(value) {\n    this._eagerModelSync = value;\n  }\n  getEagerModelSync() {\n    return this._eagerModelSync;\n  }\n  setModeConfiguration(modeConfiguration) {\n    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);\n    this._onDidChange.fire(void 0);\n  }\n};\nvar typescriptVersion2 = typescriptVersion;\nvar modeConfigurationDefault = {\n  completionItems: true,\n  hovers: true,\n  documentSymbols: true,\n  definitions: true,\n  references: true,\n  documentHighlights: true,\n  rename: true,\n  diagnostics: true,\n  documentRangeFormattingEdits: true,\n  signatureHelp: true,\n  onTypeFormattingEdits: true,\n  codeActions: true,\n  inlayHints: true\n};\nvar typescriptDefaults = new LanguageServiceDefaultsImpl(\n  { allowNonTsExtensions: true, target: 99 /* Latest */ },\n  { noSemanticValidation: false, noSyntaxValidation: false, onlyVisible: false },\n  {},\n  {},\n  modeConfigurationDefault\n);\nvar javascriptDefaults = new LanguageServiceDefaultsImpl(\n  { allowNonTsExtensions: true, allowJs: true, target: 99 /* Latest */ },\n  { noSemanticValidation: true, noSyntaxValidation: false, onlyVisible: false },\n  {},\n  {},\n  modeConfigurationDefault\n);\nvar getTypeScriptWorker = () => {\n  return getMode().then((mode) => mode.getTypeScriptWorker());\n};\nvar getJavaScriptWorker = () => {\n  return getMode().then((mode) => mode.getJavaScriptWorker());\n};\nmonaco_editor_core_exports.languages.typescript = {\n  ModuleKind,\n  JsxEmit,\n  NewLineKind,\n  ScriptTarget,\n  ModuleResolutionKind,\n  typescriptVersion: typescriptVersion2,\n  typescriptDefaults,\n  javascriptDefaults,\n  getTypeScriptWorker,\n  getJavaScriptWorker\n};\nfunction getMode() {\n  if (false) {\n    return new Promise((resolve, reject) => {\n      __require([\"vs/language/typescript/tsMode\"], resolve, reject);\n    });\n  } else {\n    return import(\"./tsMode.js\");\n  }\n}\nmonaco_editor_core_exports.languages.onLanguage(\"typescript\", () => {\n  return getMode().then((mode) => mode.setupTypeScript(typescriptDefaults));\n});\nmonaco_editor_core_exports.languages.onLanguage(\"javascript\", () => {\n  return getMode().then((mode) => mode.setupJavaScript(javascriptDefaults));\n});\nexport {\n  JsxEmit,\n  ModuleKind,\n  ModuleResolutionKind,\n  NewLineKind,\n  ScriptTarget,\n  getJavaScriptWorker,\n  getTypeScriptWorker,\n  javascriptDefaults,\n  typescriptDefaults,\n  typescriptVersion2 as typescriptVersion\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nexport function createStringDataTransferItem(stringOrPromise) {\n    return {\n        asString: async () => stringOrPromise,\n        asFile: () => undefined,\n        value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n    };\n}\nexport function createFileDataTransferItem(fileName, uri, data) {\n    const file = { id: generateUuid(), name: fileName, uri, data };\n    return {\n        asString: async () => '',\n        asFile: () => file,\n        value: undefined,\n    };\n}\nexport class VSDataTransfer {\n    constructor() {\n        this._entries = new Map();\n    }\n    get size() {\n        let size = 0;\n        for (const _ of this._entries) {\n            size++;\n        }\n        return size;\n    }\n    has(mimeType) {\n        return this._entries.has(this.toKey(mimeType));\n    }\n    matches(pattern) {\n        const mimes = [...this._entries.keys()];\n        if (Iterable.some(this, ([_, item]) => item.asFile())) {\n            mimes.push('files');\n        }\n        return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n    }\n    get(mimeType) {\n        return this._entries.get(this.toKey(mimeType))?.[0];\n    }\n    /**\n     * Add a new entry to this data transfer.\n     *\n     * This does not replace existing entries for `mimeType`.\n     */\n    append(mimeType, value) {\n        const existing = this._entries.get(mimeType);\n        if (existing) {\n            existing.push(value);\n        }\n        else {\n            this._entries.set(this.toKey(mimeType), [value]);\n        }\n    }\n    /**\n     * Set the entry for a given mime type.\n     *\n     * This replaces all existing entries for `mimeType`.\n     */\n    replace(mimeType, value) {\n        this._entries.set(this.toKey(mimeType), [value]);\n    }\n    /**\n     * Remove all entries for `mimeType`.\n     */\n    delete(mimeType) {\n        this._entries.delete(this.toKey(mimeType));\n    }\n    /**\n     * Iterate over all `[mime, item]` pairs in this data transfer.\n     *\n     * There may be multiple entries for each mime type.\n     */\n    *[Symbol.iterator]() {\n        for (const [mine, items] of this._entries) {\n            for (const item of items) {\n                yield [mine, item];\n            }\n        }\n    }\n    toKey(mimeType) {\n        return normalizeMimeType(mimeType);\n    }\n}\nfunction normalizeMimeType(mimeType) {\n    return mimeType.toLowerCase();\n}\nexport function matchesMimeType(pattern, mimeTypes) {\n    return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n    // Anything wildcard\n    if (normalizedPattern === '*/*') {\n        return normalizedMimeTypes.length > 0;\n    }\n    // Exact match\n    if (normalizedMimeTypes.includes(normalizedPattern)) {\n        return true;\n    }\n    // Wildcard, such as `image/*`\n    const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n    if (!wildcard) {\n        return false;\n    }\n    const [_, type, subtype] = wildcard;\n    if (subtype === '*') {\n        return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n    }\n    return false;\n}\nexport const UriList = Object.freeze({\n    // http://amundsen.com/hypermedia/urilist/\n    create: (entries) => {\n        return distinct(entries.map(x => x.toString())).join('\\r\\n');\n    },\n    split: (str) => {\n        return str.split('\\r\\n');\n    },\n    parse: (str) => {\n        return UriList.split(str).filter(value => !value.startsWith('#'));\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as types from './types.js';\nimport * as nls from '../../nls.js';\nfunction exceptionToErrorMessage(exception, verbose) {\n    if (verbose && (exception.stack || exception.stacktrace)) {\n        return nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));\n    }\n    return detectSystemErrorMessage(exception);\n}\nfunction stackToString(stack) {\n    if (Array.isArray(stack)) {\n        return stack.join('\\n');\n    }\n    return stack;\n}\nfunction detectSystemErrorMessage(exception) {\n    // Custom node.js error from us\n    if (exception.code === 'ERR_UNC_HOST_NOT_ALLOWED') {\n        return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n    }\n    // See https://nodejs.org/api/errors.html#errors_class_system_error\n    if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n        return nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n    }\n    return exception.message || nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error = null, verbose = false) {\n    if (!error) {\n        return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n    }\n    if (Array.isArray(error)) {\n        const errors = arrays.coalesce(error);\n        const msg = toErrorMessage(errors[0], verbose);\n        if (errors.length > 1) {\n            return nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n        }\n        return msg;\n    }\n    if (types.isString(error)) {\n        return error;\n    }\n    if (error.detail) {\n        const detail = error.detail;\n        if (detail.error) {\n            return exceptionToErrorMessage(detail.error, verbose);\n        }\n        if (detail.exception) {\n            return exceptionToErrorMessage(detail.exception, verbose);\n        }\n    }\n    if (error.stack) {\n        return exceptionToErrorMessage(error, verbose);\n    }\n    if (error.message) {\n        return error.message;\n    }\n    return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar PostEditWidget_1;\nimport * as dom from '../../../../base/browser/dom.js';\nimport { Button } from '../../../../base/browser/ui/button/button.js';\nimport { toAction } from '../../../../base/common/actions.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './postEditWidget.css';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { createCombinedWorkspaceEdit } from './edit.js';\nimport { localize } from '../../../../nls.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../../../platform/contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nlet PostEditWidget = class PostEditWidget extends Disposable {\n    static { PostEditWidget_1 = this; }\n    static { this.baseId = 'editor.widget.postEditWidget'; }\n    constructor(typeId, editor, visibleContext, showCommand, range, edits, onSelectNewEdit, _contextMenuService, contextKeyService, _keybindingService) {\n        super();\n        this.typeId = typeId;\n        this.editor = editor;\n        this.showCommand = showCommand;\n        this.range = range;\n        this.edits = edits;\n        this.onSelectNewEdit = onSelectNewEdit;\n        this._contextMenuService = _contextMenuService;\n        this._keybindingService = _keybindingService;\n        this.allowEditorOverflow = true;\n        this.suppressMouseDown = true;\n        this.create();\n        this.visibleContext = visibleContext.bindTo(contextKeyService);\n        this.visibleContext.set(true);\n        this._register(toDisposable(() => this.visibleContext.reset()));\n        this.editor.addContentWidget(this);\n        this.editor.layoutContentWidget(this);\n        this._register(toDisposable((() => this.editor.removeContentWidget(this))));\n        this._register(this.editor.onDidChangeCursorPosition(e => {\n            if (!range.containsPosition(e.position)) {\n                this.dispose();\n            }\n        }));\n        this._register(Event.runAndSubscribe(_keybindingService.onDidUpdateKeybindings, () => {\n            this._updateButtonTitle();\n        }));\n    }\n    _updateButtonTitle() {\n        const binding = this._keybindingService.lookupKeybinding(this.showCommand.id)?.getLabel();\n        this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : '');\n    }\n    create() {\n        this.domNode = dom.$('.post-edit-widget');\n        this.button = this._register(new Button(this.domNode, {\n            supportIcons: true,\n        }));\n        this.button.label = '$(insert)';\n        this._register(dom.addDisposableListener(this.domNode, dom.EventType.CLICK, () => this.showSelector()));\n    }\n    getId() {\n        return PostEditWidget_1.baseId + '.' + this.typeId;\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    getPosition() {\n        return {\n            position: this.range.getEndPosition(),\n            preference: [2 /* ContentWidgetPositionPreference.BELOW */]\n        };\n    }\n    showSelector() {\n        this._contextMenuService.showContextMenu({\n            getAnchor: () => {\n                const pos = dom.getDomNodePagePosition(this.button.element);\n                return { x: pos.left + pos.width, y: pos.top + pos.height };\n            },\n            getActions: () => {\n                return this.edits.allEdits.map((edit, i) => toAction({\n                    id: '',\n                    label: edit.title,\n                    checked: i === this.edits.activeEditIndex,\n                    run: () => {\n                        if (i !== this.edits.activeEditIndex) {\n                            return this.onSelectNewEdit(i);\n                        }\n                    },\n                }));\n            }\n        });\n    }\n};\nPostEditWidget = PostEditWidget_1 = __decorate([\n    __param(7, IContextMenuService),\n    __param(8, IContextKeyService),\n    __param(9, IKeybindingService)\n], PostEditWidget);\nlet PostEditWidgetManager = class PostEditWidgetManager extends Disposable {\n    constructor(_id, _editor, _visibleContext, _showCommand, _instantiationService, _bulkEditService, _notificationService) {\n        super();\n        this._id = _id;\n        this._editor = _editor;\n        this._visibleContext = _visibleContext;\n        this._showCommand = _showCommand;\n        this._instantiationService = _instantiationService;\n        this._bulkEditService = _bulkEditService;\n        this._notificationService = _notificationService;\n        this._currentWidget = this._register(new MutableDisposable());\n        this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));\n    }\n    async applyEditAndShowIfNeeded(ranges, edits, canShowWidget, resolve, token) {\n        const model = this._editor.getModel();\n        if (!model || !ranges.length) {\n            return;\n        }\n        const edit = edits.allEdits.at(edits.activeEditIndex);\n        if (!edit) {\n            return;\n        }\n        const onDidSelectEdit = async (newEditIndex) => {\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            await model.undo();\n            this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, resolve, token);\n        };\n        const handleError = (e, message) => {\n            if (isCancellationError(e)) {\n                return;\n            }\n            this._notificationService.error(message);\n            if (canShowWidget) {\n                this.show(ranges[0], edits, onDidSelectEdit);\n            }\n        };\n        let resolvedEdit;\n        try {\n            resolvedEdit = await resolve(edit, token);\n        }\n        catch (e) {\n            return handleError(e, localize('resolveError', \"Error resolving edit '{0}':\\n{1}\", edit.title, toErrorMessage(e)));\n        }\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, ranges, resolvedEdit);\n        // Use a decoration to track edits around the trigger range\n        const primaryRange = ranges[0];\n        const editTrackingDecoration = model.deltaDecorations([], [{\n                range: primaryRange,\n                options: { description: 'paste-line-suffix', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }\n            }]);\n        this._editor.focus();\n        let editResult;\n        let editRange;\n        try {\n            editResult = await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });\n            editRange = model.getDecorationRange(editTrackingDecoration[0]);\n        }\n        catch (e) {\n            return handleError(e, localize('applyError', \"Error applying edit '{0}':\\n{1}\", edit.title, toErrorMessage(e)));\n        }\n        finally {\n            model.deltaDecorations(editTrackingDecoration, []);\n        }\n        if (token.isCancellationRequested) {\n            return;\n        }\n        if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {\n            this.show(editRange ?? primaryRange, edits, onDidSelectEdit);\n        }\n    }\n    show(range, edits, onDidSelectEdit) {\n        this.clear();\n        if (this._editor.hasModel()) {\n            this._currentWidget.value = this._instantiationService.createInstance((PostEditWidget), this._id, this._editor, this._visibleContext, this._showCommand, range, edits, onDidSelectEdit);\n        }\n    }\n    clear() {\n        this._currentWidget.clear();\n    }\n    tryShowSelector() {\n        this._currentWidget.value?.showSelector();\n    }\n};\nPostEditWidgetManager = __decorate([\n    __param(4, IInstantiationService),\n    __param(5, IBulkEditService),\n    __param(6, INotificationService)\n], PostEditWidgetManager);\nexport { PostEditWidgetManager };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(languageConfigurationService, selection, indentSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._indentSize = indentSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n        model.tokenization.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        const lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Type.Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* Type.ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Type.Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* Type.ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenization.tokenizeIfCheap(s.startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, indentSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (indentSize - (currentVisibleColumn % indentSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, indentSize) {\n        let minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { buildReplaceStringWithCasePreserved } from '../../../../base/common/search.js';\n/**\n * Assigned when the replace pattern is entirely static.\n */\nclass StaticValueReplacePattern {\n    constructor(staticValue) {\n        this.staticValue = staticValue;\n        this.kind = 0 /* ReplacePatternKind.StaticValue */;\n    }\n}\n/**\n * Assigned when the replace pattern has replacement patterns.\n */\nclass DynamicPiecesReplacePattern {\n    constructor(pieces) {\n        this.pieces = pieces;\n        this.kind = 1 /* ReplacePatternKind.DynamicPieces */;\n    }\n}\nexport class ReplacePattern {\n    static fromStaticValue(value) {\n        return new ReplacePattern([ReplacePiece.staticValue(value)]);\n    }\n    get hasReplacementPatterns() {\n        return (this._state.kind === 1 /* ReplacePatternKind.DynamicPieces */);\n    }\n    constructor(pieces) {\n        if (!pieces || pieces.length === 0) {\n            this._state = new StaticValueReplacePattern('');\n        }\n        else if (pieces.length === 1 && pieces[0].staticValue !== null) {\n            this._state = new StaticValueReplacePattern(pieces[0].staticValue);\n        }\n        else {\n            this._state = new DynamicPiecesReplacePattern(pieces);\n        }\n    }\n    buildReplaceString(matches, preserveCase) {\n        if (this._state.kind === 0 /* ReplacePatternKind.StaticValue */) {\n            if (preserveCase) {\n                return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);\n            }\n            else {\n                return this._state.staticValue;\n            }\n        }\n        let result = '';\n        for (let i = 0, len = this._state.pieces.length; i < len; i++) {\n            const piece = this._state.pieces[i];\n            if (piece.staticValue !== null) {\n                // static value ReplacePiece\n                result += piece.staticValue;\n                continue;\n            }\n            // match index ReplacePiece\n            let match = ReplacePattern._substitute(piece.matchIndex, matches);\n            if (piece.caseOps !== null && piece.caseOps.length > 0) {\n                const repl = [];\n                const lenOps = piece.caseOps.length;\n                let opIdx = 0;\n                for (let idx = 0, len = match.length; idx < len; idx++) {\n                    if (opIdx >= lenOps) {\n                        repl.push(match.slice(idx));\n                        break;\n                    }\n                    switch (piece.caseOps[opIdx]) {\n                        case 'U':\n                            repl.push(match[idx].toUpperCase());\n                            break;\n                        case 'u':\n                            repl.push(match[idx].toUpperCase());\n                            opIdx++;\n                            break;\n                        case 'L':\n                            repl.push(match[idx].toLowerCase());\n                            break;\n                        case 'l':\n                            repl.push(match[idx].toLowerCase());\n                            opIdx++;\n                            break;\n                        default:\n                            repl.push(match[idx]);\n                    }\n                }\n                match = repl.join('');\n            }\n            result += match;\n        }\n        return result;\n    }\n    static _substitute(matchIndex, matches) {\n        if (matches === null) {\n            return '';\n        }\n        if (matchIndex === 0) {\n            return matches[0];\n        }\n        let remainder = '';\n        while (matchIndex > 0) {\n            if (matchIndex < matches.length) {\n                // A match can be undefined\n                const match = (matches[matchIndex] || '');\n                return match + remainder;\n            }\n            remainder = String(matchIndex % 10) + remainder;\n            matchIndex = Math.floor(matchIndex / 10);\n        }\n        return '$' + remainder;\n    }\n}\n/**\n * A replace piece can either be a static string or an index to a specific match.\n */\nexport class ReplacePiece {\n    static staticValue(value) {\n        return new ReplacePiece(value, -1, null);\n    }\n    static caseOps(index, caseOps) {\n        return new ReplacePiece(null, index, caseOps);\n    }\n    constructor(staticValue, matchIndex, caseOps) {\n        this.staticValue = staticValue;\n        this.matchIndex = matchIndex;\n        if (!caseOps || caseOps.length === 0) {\n            this.caseOps = null;\n        }\n        else {\n            this.caseOps = caseOps.slice(0);\n        }\n    }\n}\nclass ReplacePieceBuilder {\n    constructor(source) {\n        this._source = source;\n        this._lastCharIndex = 0;\n        this._result = [];\n        this._resultLen = 0;\n        this._currentStaticPiece = '';\n    }\n    emitUnchanged(toCharIndex) {\n        this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));\n        this._lastCharIndex = toCharIndex;\n    }\n    emitStatic(value, toCharIndex) {\n        this._emitStatic(value);\n        this._lastCharIndex = toCharIndex;\n    }\n    _emitStatic(value) {\n        if (value.length === 0) {\n            return;\n        }\n        this._currentStaticPiece += value;\n    }\n    emitMatchIndex(index, toCharIndex, caseOps) {\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);\n        this._lastCharIndex = toCharIndex;\n    }\n    finalize() {\n        this.emitUnchanged(this._source.length);\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        return new ReplacePattern(this._result);\n    }\n}\n/**\n * \\n\t\t\t=> inserts a LF\n * \\t\t\t\t=> inserts a TAB\n * \\\\\t\t\t=> inserts a \"\\\".\n * \\u\t\t\t=> upper-cases one character in a match.\n * \\U\t\t\t=> upper-cases ALL remaining characters in a match.\n * \\l\t\t\t=> lower-cases one character in a match.\n * \\L\t\t\t=> lower-cases ALL remaining characters in a match.\n * $$\t\t\t=> inserts a \"$\".\n * $& and $0\t=> inserts the matched substring.\n * $n\t\t\t=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string\n * everything else stays untouched\n *\n * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\n */\nexport function parseReplaceString(replaceString) {\n    if (!replaceString || replaceString.length === 0) {\n        return new ReplacePattern(null);\n    }\n    const caseOps = [];\n    const result = new ReplacePieceBuilder(replaceString);\n    for (let i = 0, len = replaceString.length; i < len; i++) {\n        const chCode = replaceString.charCodeAt(i);\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = replaceString.charCodeAt(i);\n            // let replaceWithCharacter: string | null = null;\n            switch (nextChCode) {\n                case 92 /* CharCode.Backslash */:\n                    // \\\\ => inserts a \"\\\"\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\\\', i + 1);\n                    break;\n                case 110 /* CharCode.n */:\n                    // \\n => inserts a LF\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\n', i + 1);\n                    break;\n                case 116 /* CharCode.t */:\n                    // \\t => inserts a TAB\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\t', i + 1);\n                    break;\n                // Case modification of string replacements, patterned after Boost, but only applied\n                // to the replacement text, not subsequent content.\n                case 117 /* CharCode.u */:\n                // \\u => upper-cases one character.\n                case 85 /* CharCode.U */:\n                // \\U => upper-cases ALL following characters.\n                case 108 /* CharCode.l */:\n                // \\l => lower-cases one character.\n                case 76 /* CharCode.L */:\n                    // \\L => lower-cases ALL following characters.\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('', i + 1);\n                    caseOps.push(String.fromCharCode(nextChCode));\n                    break;\n            }\n            continue;\n        }\n        if (chCode === 36 /* CharCode.DollarSign */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a $\n                break;\n            }\n            const nextChCode = replaceString.charCodeAt(i);\n            if (nextChCode === 36 /* CharCode.DollarSign */) {\n                // $$ => inserts a \"$\"\n                result.emitUnchanged(i - 1);\n                result.emitStatic('$', i + 1);\n                continue;\n            }\n            if (nextChCode === 48 /* CharCode.Digit0 */ || nextChCode === 38 /* CharCode.Ampersand */) {\n                // $& and $0 => inserts the matched substring.\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(0, i + 1, caseOps);\n                caseOps.length = 0;\n                continue;\n            }\n            if (49 /* CharCode.Digit1 */ <= nextChCode && nextChCode <= 57 /* CharCode.Digit9 */) {\n                // $n\n                let matchIndex = nextChCode - 48 /* CharCode.Digit0 */;\n                // peek next char to probe for $nn\n                if (i + 1 < len) {\n                    const nextNextChCode = replaceString.charCodeAt(i + 1);\n                    if (48 /* CharCode.Digit0 */ <= nextNextChCode && nextNextChCode <= 57 /* CharCode.Digit9 */) {\n                        // $nn\n                        // move to next char\n                        i++;\n                        matchIndex = matchIndex * 10 + (nextNextChCode - 48 /* CharCode.Digit0 */);\n                        result.emitUnchanged(i - 2);\n                        result.emitMatchIndex(matchIndex, i + 1, caseOps);\n                        caseOps.length = 0;\n                        continue;\n                    }\n                }\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(matchIndex, i + 1, caseOps);\n                caseOps.length = 0;\n                continue;\n            }\n        }\n    }\n    return result.finalize();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { alert as alertFn } from '../../../../base/browser/ui/aria/aria.js';\nimport { Toggle } from '../../../../base/browser/ui/toggle/toggle.js';\nimport { Sash } from '../../../../base/browser/ui/sash/sash.js';\nimport { Widget } from '../../../../base/browser/ui/widget.js';\nimport { Delayer } from '../../../../base/common/async.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { toDisposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport './findWidget.css';\nimport { Range } from '../../../common/core/range.js';\nimport { CONTEXT_FIND_INPUT_FOCUSED, CONTEXT_REPLACE_INPUT_FOCUSED, FIND_IDS, MATCHES_LIMIT } from './findModel.js';\nimport * as nls from '../../../../nls.js';\nimport { ContextScopedFindInput, ContextScopedReplaceInput } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nimport { showHistoryKeybindingHint } from '../../../../platform/history/browser/historyWidgetKeybindingHint.js';\nimport { asCssVariable, contrastBorder, editorFindMatchForeground, editorFindMatchHighlightBorder, editorFindMatchHighlightForeground, editorFindRangeHighlightBorder, inputActiveOptionBackground, inputActiveOptionBorder, inputActiveOptionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerIcon, widgetClose } from '../../../../platform/theme/common/iconRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nimport { assertIsDefined } from '../../../../base/common/types.js';\nimport { defaultInputBoxStyles, defaultToggleStyles } from '../../../../platform/theme/browser/defaultStyles.js';\nimport { createInstantHoverDelegate, getDefaultHoverDelegate } from '../../../../base/browser/ui/hover/hoverDelegateFactory.js';\nconst findCollapsedIcon = registerIcon('find-collapsed', Codicon.chevronRight, nls.localize('findCollapsedIcon', 'Icon to indicate that the editor find widget is collapsed.'));\nconst findExpandedIcon = registerIcon('find-expanded', Codicon.chevronDown, nls.localize('findExpandedIcon', 'Icon to indicate that the editor find widget is expanded.'));\nexport const findSelectionIcon = registerIcon('find-selection', Codicon.selection, nls.localize('findSelectionIcon', 'Icon for \\'Find in Selection\\' in the editor find widget.'));\nexport const findReplaceIcon = registerIcon('find-replace', Codicon.replace, nls.localize('findReplaceIcon', 'Icon for \\'Replace\\' in the editor find widget.'));\nexport const findReplaceAllIcon = registerIcon('find-replace-all', Codicon.replaceAll, nls.localize('findReplaceAllIcon', 'Icon for \\'Replace All\\' in the editor find widget.'));\nexport const findPreviousMatchIcon = registerIcon('find-previous-match', Codicon.arrowUp, nls.localize('findPreviousMatchIcon', 'Icon for \\'Find Previous\\' in the editor find widget.'));\nexport const findNextMatchIcon = registerIcon('find-next-match', Codicon.arrowDown, nls.localize('findNextMatchIcon', 'Icon for \\'Find Next\\' in the editor find widget.'));\nconst NLS_FIND_DIALOG_LABEL = nls.localize('label.findDialog', \"Find / Replace\");\nconst NLS_FIND_INPUT_LABEL = nls.localize('label.find', \"Find\");\nconst NLS_FIND_INPUT_PLACEHOLDER = nls.localize('placeholder.find', \"Find\");\nconst NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize('label.previousMatchButton', \"Previous Match\");\nconst NLS_NEXT_MATCH_BTN_LABEL = nls.localize('label.nextMatchButton', \"Next Match\");\nconst NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize('label.toggleSelectionFind', \"Find in Selection\");\nconst NLS_CLOSE_BTN_LABEL = nls.localize('label.closeButton', \"Close\");\nconst NLS_REPLACE_INPUT_LABEL = nls.localize('label.replace', \"Replace\");\nconst NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize('placeholder.replace', \"Replace\");\nconst NLS_REPLACE_BTN_LABEL = nls.localize('label.replaceButton', \"Replace\");\nconst NLS_REPLACE_ALL_BTN_LABEL = nls.localize('label.replaceAllButton', \"Replace All\");\nconst NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize('label.toggleReplaceButton', \"Toggle Replace\");\nconst NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize('title.matchesCountLimit', \"Only the first {0} results are highlighted, but all find operations work on the entire text.\", MATCHES_LIMIT);\nexport const NLS_MATCHES_LOCATION = nls.localize('label.matchesLocation', \"{0} of {1}\");\nexport const NLS_NO_RESULTS = nls.localize('label.noResults', \"No results\");\nconst FIND_WIDGET_INITIAL_WIDTH = 419;\nconst PART_WIDTH = 275;\nconst FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;\nlet MAX_MATCHES_COUNT_WIDTH = 69;\n// let FIND_ALL_CONTROLS_WIDTH = 17/** Find Input margin-left */ + (MAX_MATCHES_COUNT_WIDTH + 3 + 1) /** Match Results */ + 23 /** Button */ * 4 + 2/** sash */;\nconst FIND_INPUT_AREA_HEIGHT = 33; // The height of Find Widget when Replace Input is not visible.\nconst ctrlEnterReplaceAllWarningPromptedKey = 'ctrlEnterReplaceAll.windows.donotask';\nconst ctrlKeyMod = (platform.isMacintosh ? 256 /* KeyMod.WinCtrl */ : 2048 /* KeyMod.CtrlCmd */);\nexport class FindWidgetViewZone {\n    constructor(afterLineNumber) {\n        this.afterLineNumber = afterLineNumber;\n        this.heightInPx = FIND_INPUT_AREA_HEIGHT;\n        this.suppressMouseDown = false;\n        this.domNode = document.createElement('div');\n        this.domNode.className = 'dock-find-viewzone';\n    }\n}\nfunction stopPropagationForMultiLineUpwards(event, value, textarea) {\n    const isMultiline = !!value.match(/\\n/);\n    if (textarea && isMultiline && textarea.selectionStart > 0) {\n        event.stopPropagation();\n        return;\n    }\n}\nfunction stopPropagationForMultiLineDownwards(event, value, textarea) {\n    const isMultiline = !!value.match(/\\n/);\n    if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {\n        event.stopPropagation();\n        return;\n    }\n}\nexport class FindWidget extends Widget {\n    static { this.ID = 'editor.contrib.findWidget'; }\n    constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService, _hoverService) {\n        super();\n        this._hoverService = _hoverService;\n        this._cachedHeight = null;\n        this._revealTimeouts = [];\n        this._codeEditor = codeEditor;\n        this._controller = controller;\n        this._state = state;\n        this._contextViewProvider = contextViewProvider;\n        this._keybindingService = keybindingService;\n        this._contextKeyService = contextKeyService;\n        this._storageService = storageService;\n        this._notificationService = notificationService;\n        this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0 /* StorageScope.PROFILE */);\n        this._isVisible = false;\n        this._isReplaceVisible = false;\n        this._ignoreChangeEvent = false;\n        this._updateHistoryDelayer = new Delayer(500);\n        this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));\n        this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this._buildDomNode();\n        this._updateButtons();\n        this._tryUpdateWidgetWidth();\n        this._findInput.inputBox.layout();\n        this._register(this._codeEditor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(92 /* EditorOption.readOnly */)) {\n                if (this._codeEditor.getOption(92 /* EditorOption.readOnly */)) {\n                    // Hide replace part if editor becomes read only\n                    this._state.change({ isReplaceRevealed: false }, false);\n                }\n                this._updateButtons();\n            }\n            if (e.hasChanged(146 /* EditorOption.layoutInfo */)) {\n                this._tryUpdateWidgetWidth();\n            }\n            if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n                this.updateAccessibilitySupport();\n            }\n            if (e.hasChanged(41 /* EditorOption.find */)) {\n                const supportLoop = this._codeEditor.getOption(41 /* EditorOption.find */).loop;\n                this._state.change({ loop: supportLoop }, false);\n                const addExtraSpaceOnTop = this._codeEditor.getOption(41 /* EditorOption.find */).addExtraSpaceOnTop;\n                if (addExtraSpaceOnTop && !this._viewZone) {\n                    this._viewZone = new FindWidgetViewZone(0);\n                    this._showViewZone();\n                }\n                if (!addExtraSpaceOnTop && this._viewZone) {\n                    this._removeViewZone();\n                }\n            }\n        }));\n        this.updateAccessibilitySupport();\n        this._register(this._codeEditor.onDidChangeCursorSelection(() => {\n            if (this._isVisible) {\n                this._updateToggleSelectionFindButton();\n            }\n        }));\n        this._register(this._codeEditor.onDidFocusEditorWidget(async () => {\n            if (this._isVisible) {\n                const globalBufferTerm = await this._controller.getGlobalBufferTerm();\n                if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {\n                    this._state.change({ searchString: globalBufferTerm }, false);\n                    this._findInput.select();\n                }\n            }\n        }));\n        this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);\n        this._findFocusTracker = this._register(dom.trackFocus(this._findInput.inputBox.inputElement));\n        this._register(this._findFocusTracker.onDidFocus(() => {\n            this._findInputFocused.set(true);\n            this._updateSearchScope();\n        }));\n        this._register(this._findFocusTracker.onDidBlur(() => {\n            this._findInputFocused.set(false);\n        }));\n        this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);\n        this._replaceFocusTracker = this._register(dom.trackFocus(this._replaceInput.inputBox.inputElement));\n        this._register(this._replaceFocusTracker.onDidFocus(() => {\n            this._replaceInputFocused.set(true);\n            this._updateSearchScope();\n        }));\n        this._register(this._replaceFocusTracker.onDidBlur(() => {\n            this._replaceInputFocused.set(false);\n        }));\n        this._codeEditor.addOverlayWidget(this);\n        if (this._codeEditor.getOption(41 /* EditorOption.find */).addExtraSpaceOnTop) {\n            this._viewZone = new FindWidgetViewZone(0); // Put it before the first line then users can scroll beyond the first line.\n        }\n        this._register(this._codeEditor.onDidChangeModel(() => {\n            if (!this._isVisible) {\n                return;\n            }\n            this._viewZoneId = undefined;\n        }));\n        this._register(this._codeEditor.onDidScrollChange((e) => {\n            if (e.scrollTopChanged) {\n                this._layoutViewZone();\n                return;\n            }\n            // for other scroll changes, layout the viewzone in next tick to avoid ruining current rendering.\n            setTimeout(() => {\n                this._layoutViewZone();\n            }, 0);\n        }));\n    }\n    // ----- IOverlayWidget API\n    getId() {\n        return FindWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        if (this._isVisible) {\n            return {\n                preference: 0 /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */\n            };\n        }\n        return null;\n    }\n    // ----- React to state changes\n    _onStateChanged(e) {\n        if (e.searchString) {\n            try {\n                this._ignoreChangeEvent = true;\n                this._findInput.setValue(this._state.searchString);\n            }\n            finally {\n                this._ignoreChangeEvent = false;\n            }\n            this._updateButtons();\n        }\n        if (e.replaceString) {\n            this._replaceInput.inputBox.value = this._state.replaceString;\n        }\n        if (e.isRevealed) {\n            if (this._state.isRevealed) {\n                this._reveal();\n            }\n            else {\n                this._hide(true);\n            }\n        }\n        if (e.isReplaceRevealed) {\n            if (this._state.isReplaceRevealed) {\n                if (!this._codeEditor.getOption(92 /* EditorOption.readOnly */) && !this._isReplaceVisible) {\n                    this._isReplaceVisible = true;\n                    this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                    this._updateButtons();\n                    this._replaceInput.inputBox.layout();\n                }\n            }\n            else {\n                if (this._isReplaceVisible) {\n                    this._isReplaceVisible = false;\n                    this._updateButtons();\n                }\n            }\n        }\n        if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {\n            if (this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }\n        if (e.isRegex) {\n            this._findInput.setRegex(this._state.isRegex);\n        }\n        if (e.wholeWord) {\n            this._findInput.setWholeWords(this._state.wholeWord);\n        }\n        if (e.matchCase) {\n            this._findInput.setCaseSensitive(this._state.matchCase);\n        }\n        if (e.preserveCase) {\n            this._replaceInput.setPreserveCase(this._state.preserveCase);\n        }\n        if (e.searchScope) {\n            if (this._state.searchScope) {\n                this._toggleSelectionFind.checked = true;\n            }\n            else {\n                this._toggleSelectionFind.checked = false;\n            }\n            this._updateToggleSelectionFindButton();\n        }\n        if (e.searchString || e.matchesCount || e.matchesPosition) {\n            const showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);\n            this._domNode.classList.toggle('no-results', showRedOutline);\n            this._updateMatchesCount();\n            this._updateButtons();\n        }\n        if (e.searchString || e.currentMatch) {\n            this._layoutViewZone();\n        }\n        if (e.updateHistory) {\n            this._delayedUpdateHistory();\n        }\n        if (e.loop) {\n            this._updateButtons();\n        }\n    }\n    _delayedUpdateHistory() {\n        this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(undefined, onUnexpectedError);\n    }\n    _updateHistory() {\n        if (this._state.searchString) {\n            this._findInput.inputBox.addToHistory();\n        }\n        if (this._state.replaceString) {\n            this._replaceInput.inputBox.addToHistory();\n        }\n    }\n    _updateMatchesCount() {\n        this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + 'px';\n        if (this._state.matchesCount >= MATCHES_LIMIT) {\n            this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;\n        }\n        else {\n            this._matchesCount.title = '';\n        }\n        // remove previous content\n        this._matchesCount.firstChild?.remove();\n        let label;\n        if (this._state.matchesCount > 0) {\n            let matchesCount = String(this._state.matchesCount);\n            if (this._state.matchesCount >= MATCHES_LIMIT) {\n                matchesCount += '+';\n            }\n            let matchesPosition = String(this._state.matchesPosition);\n            if (matchesPosition === '0') {\n                matchesPosition = '?';\n            }\n            label = strings.format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);\n        }\n        else {\n            label = NLS_NO_RESULTS;\n        }\n        this._matchesCount.appendChild(document.createTextNode(label));\n        alertFn(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));\n        MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);\n    }\n    // ----- actions\n    _getAriaLabel(label, currentMatch, searchString) {\n        if (label === NLS_NO_RESULTS) {\n            return searchString === ''\n                ? nls.localize('ariaSearchNoResultEmpty', \"{0} found\", label)\n                : nls.localize('ariaSearchNoResult', \"{0} found for '{1}'\", label, searchString);\n        }\n        if (currentMatch) {\n            const ariaLabel = nls.localize('ariaSearchNoResultWithLineNum', \"{0} found for '{1}', at {2}\", label, searchString, currentMatch.startLineNumber + ':' + currentMatch.startColumn);\n            const model = this._codeEditor.getModel();\n            if (model && (currentMatch.startLineNumber <= model.getLineCount()) && (currentMatch.startLineNumber >= 1)) {\n                const lineContent = model.getLineContent(currentMatch.startLineNumber);\n                return `${lineContent}, ${ariaLabel}`;\n            }\n            return ariaLabel;\n        }\n        return nls.localize('ariaSearchNoResultWithLineNumNoCurrentMatch', \"{0} found for '{1}'\", label, searchString);\n    }\n    /**\n     * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').\n     * If 'selection find' is OFF we enable the button only if there is a selection.\n     */\n    _updateToggleSelectionFindButton() {\n        const selection = this._codeEditor.getSelection();\n        const isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;\n        const isChecked = this._toggleSelectionFind.checked;\n        if (this._isVisible && (isChecked || isSelection)) {\n            this._toggleSelectionFind.enable();\n        }\n        else {\n            this._toggleSelectionFind.disable();\n        }\n    }\n    _updateButtons() {\n        this._findInput.setEnabled(this._isVisible);\n        this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);\n        this._updateToggleSelectionFindButton();\n        this._closeBtn.setEnabled(this._isVisible);\n        const findInputIsNonEmpty = (this._state.searchString.length > 0);\n        const matchesCount = this._state.matchesCount ? true : false;\n        this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());\n        this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());\n        this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n        this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n        this._domNode.classList.toggle('replaceToggled', this._isReplaceVisible);\n        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n        const canReplace = !this._codeEditor.getOption(92 /* EditorOption.readOnly */);\n        this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);\n    }\n    _reveal() {\n        this._revealTimeouts.forEach(e => {\n            clearTimeout(e);\n        });\n        this._revealTimeouts = [];\n        if (!this._isVisible) {\n            this._isVisible = true;\n            const selection = this._codeEditor.getSelection();\n            switch (this._codeEditor.getOption(41 /* EditorOption.find */).autoFindInSelection) {\n                case 'always':\n                    this._toggleSelectionFind.checked = true;\n                    break;\n                case 'never':\n                    this._toggleSelectionFind.checked = false;\n                    break;\n                case 'multiline': {\n                    const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;\n                    this._toggleSelectionFind.checked = isSelectionMultipleLine;\n                    break;\n                }\n                default:\n                    break;\n            }\n            this._tryUpdateWidgetWidth();\n            this._updateButtons();\n            this._revealTimeouts.push(setTimeout(() => {\n                this._domNode.classList.add('visible');\n                this._domNode.setAttribute('aria-hidden', 'false');\n            }, 0));\n            // validate query again as it's being dismissed when we hide the find widget.\n            this._revealTimeouts.push(setTimeout(() => {\n                this._findInput.validate();\n            }, 200));\n            this._codeEditor.layoutOverlayWidget(this);\n            let adjustEditorScrollTop = true;\n            if (this._codeEditor.getOption(41 /* EditorOption.find */).seedSearchStringFromSelection && selection) {\n                const domNode = this._codeEditor.getDomNode();\n                if (domNode) {\n                    const editorCoords = dom.getDomNodePagePosition(domNode);\n                    const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());\n                    const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);\n                    const startTop = startCoords ? startCoords.top : 0;\n                    if (this._viewZone && startTop < this._viewZone.heightInPx) {\n                        if (selection.endLineNumber > selection.startLineNumber) {\n                            adjustEditorScrollTop = false;\n                        }\n                        const leftOfFindWidget = dom.getTopLeftOffset(this._domNode).left;\n                        if (startLeft > leftOfFindWidget) {\n                            adjustEditorScrollTop = false;\n                        }\n                        const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());\n                        const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);\n                        if (endLeft > leftOfFindWidget) {\n                            adjustEditorScrollTop = false;\n                        }\n                    }\n                }\n            }\n            this._showViewZone(adjustEditorScrollTop);\n        }\n    }\n    _hide(focusTheEditor) {\n        this._revealTimeouts.forEach(e => {\n            clearTimeout(e);\n        });\n        this._revealTimeouts = [];\n        if (this._isVisible) {\n            this._isVisible = false;\n            this._updateButtons();\n            this._domNode.classList.remove('visible');\n            this._domNode.setAttribute('aria-hidden', 'true');\n            this._findInput.clearMessage();\n            if (focusTheEditor) {\n                this._codeEditor.focus();\n            }\n            this._codeEditor.layoutOverlayWidget(this);\n            this._removeViewZone();\n        }\n    }\n    _layoutViewZone(targetScrollTop) {\n        const addExtraSpaceOnTop = this._codeEditor.getOption(41 /* EditorOption.find */).addExtraSpaceOnTop;\n        if (!addExtraSpaceOnTop) {\n            this._removeViewZone();\n            return;\n        }\n        if (!this._isVisible) {\n            return;\n        }\n        const viewZone = this._viewZone;\n        if (this._viewZoneId !== undefined || !viewZone) {\n            return;\n        }\n        this._codeEditor.changeViewZones((accessor) => {\n            viewZone.heightInPx = this._getHeight();\n            this._viewZoneId = accessor.addZone(viewZone);\n            // scroll top adjust to make sure the editor doesn't scroll when adding viewzone at the beginning.\n            this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);\n        });\n    }\n    _showViewZone(adjustScroll = true) {\n        if (!this._isVisible) {\n            return;\n        }\n        const addExtraSpaceOnTop = this._codeEditor.getOption(41 /* EditorOption.find */).addExtraSpaceOnTop;\n        if (!addExtraSpaceOnTop) {\n            return;\n        }\n        if (this._viewZone === undefined) {\n            this._viewZone = new FindWidgetViewZone(0);\n        }\n        const viewZone = this._viewZone;\n        this._codeEditor.changeViewZones((accessor) => {\n            if (this._viewZoneId !== undefined) {\n                // the view zone already exists, we need to update the height\n                const newHeight = this._getHeight();\n                if (newHeight === viewZone.heightInPx) {\n                    return;\n                }\n                const scrollAdjustment = newHeight - viewZone.heightInPx;\n                viewZone.heightInPx = newHeight;\n                accessor.layoutZone(this._viewZoneId);\n                if (adjustScroll) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);\n                }\n                return;\n            }\n            else {\n                let scrollAdjustment = this._getHeight();\n                // if the editor has top padding, factor that into the zone height\n                scrollAdjustment -= this._codeEditor.getOption(84 /* EditorOption.padding */).top;\n                if (scrollAdjustment <= 0) {\n                    return;\n                }\n                viewZone.heightInPx = scrollAdjustment;\n                this._viewZoneId = accessor.addZone(viewZone);\n                if (adjustScroll) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);\n                }\n            }\n        });\n    }\n    _removeViewZone() {\n        this._codeEditor.changeViewZones((accessor) => {\n            if (this._viewZoneId !== undefined) {\n                accessor.removeZone(this._viewZoneId);\n                this._viewZoneId = undefined;\n                if (this._viewZone) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);\n                    this._viewZone = undefined;\n                }\n            }\n        });\n    }\n    _tryUpdateWidgetWidth() {\n        if (!this._isVisible) {\n            return;\n        }\n        if (!this._domNode.isConnected) {\n            // the widget is not in the DOM\n            return;\n        }\n        const layoutInfo = this._codeEditor.getLayoutInfo();\n        const editorContentWidth = layoutInfo.contentWidth;\n        if (editorContentWidth <= 0) {\n            // for example, diff view original editor\n            this._domNode.classList.add('hiddenEditor');\n            return;\n        }\n        else if (this._domNode.classList.contains('hiddenEditor')) {\n            this._domNode.classList.remove('hiddenEditor');\n        }\n        const editorWidth = layoutInfo.width;\n        const minimapWidth = layoutInfo.minimap.minimapWidth;\n        let collapsedFindWidget = false;\n        let reducedFindWidget = false;\n        let narrowFindWidget = false;\n        if (this._resized) {\n            const widgetWidth = dom.getTotalWidth(this._domNode);\n            if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {\n                // as the widget is resized by users, we may need to change the max width of the widget as the editor width changes.\n                this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                return;\n            }\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {\n            reducedFindWidget = true;\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {\n            narrowFindWidget = true;\n        }\n        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {\n            collapsedFindWidget = true;\n        }\n        this._domNode.classList.toggle('collapsed-find-widget', collapsedFindWidget);\n        this._domNode.classList.toggle('narrow-find-widget', narrowFindWidget);\n        this._domNode.classList.toggle('reduced-find-widget', reducedFindWidget);\n        if (!narrowFindWidget && !collapsedFindWidget) {\n            // the minimal left offset of findwidget is 15px.\n            this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n        }\n        this._findInput.layout({ collapsedFindWidget, narrowFindWidget, reducedFindWidget });\n        if (this._resized) {\n            const findInputWidth = this._findInput.inputBox.element.clientWidth;\n            if (findInputWidth > 0) {\n                this._replaceInput.width = findInputWidth;\n            }\n        }\n        else if (this._isReplaceVisible) {\n            this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n        }\n    }\n    _getHeight() {\n        let totalheight = 0;\n        // find input margin top\n        totalheight += 4;\n        // find input height\n        totalheight += this._findInput.inputBox.height + 2 /** input box border */;\n        if (this._isReplaceVisible) {\n            // replace input margin\n            totalheight += 4;\n            totalheight += this._replaceInput.inputBox.height + 2 /** input box border */;\n        }\n        // margin bottom\n        totalheight += 4;\n        return totalheight;\n    }\n    _tryUpdateHeight() {\n        const totalHeight = this._getHeight();\n        if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {\n            return false;\n        }\n        this._cachedHeight = totalHeight;\n        this._domNode.style.height = `${totalHeight}px`;\n        return true;\n    }\n    // ----- Public\n    focusFindInput() {\n        this._findInput.select();\n        // Edge browser requires focus() in addition to select()\n        this._findInput.focus();\n    }\n    focusReplaceInput() {\n        this._replaceInput.select();\n        // Edge browser requires focus() in addition to select()\n        this._replaceInput.focus();\n    }\n    highlightFindOptions() {\n        this._findInput.highlightFindOptions();\n    }\n    _updateSearchScope() {\n        if (!this._codeEditor.hasModel()) {\n            return;\n        }\n        if (this._toggleSelectionFind.checked) {\n            const selections = this._codeEditor.getSelections();\n            selections.map(selection => {\n                if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                    selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                }\n                const currentMatch = this._state.currentMatch;\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    if (!Range.equalsRange(selection, currentMatch)) {\n                        return selection;\n                    }\n                }\n                return null;\n            }).filter(element => !!element);\n            if (selections.length) {\n                this._state.change({ searchScope: selections }, true);\n            }\n        }\n    }\n    _onFindInputMouseDown(e) {\n        // on linux, middle key does pasting.\n        if (e.middleButton) {\n            e.stopPropagation();\n        }\n    }\n    _onFindInputKeyDown(e) {\n        if (e.equals(ctrlKeyMod | 3 /* KeyCode.Enter */)) {\n            if (this._keybindingService.dispatchEvent(e, e.target)) {\n                e.preventDefault();\n                return;\n            }\n            else {\n                this._findInput.inputBox.insertAtCursor('\\n');\n                e.preventDefault();\n                return;\n            }\n        }\n        if (e.equals(2 /* KeyCode.Tab */)) {\n            if (this._isReplaceVisible) {\n                this._replaceInput.focus();\n            }\n            else {\n                this._findInput.focusOnCaseSensitive();\n            }\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */)) {\n            this._codeEditor.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(16 /* KeyCode.UpArrow */)) {\n            return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector('textarea'));\n        }\n        if (e.equals(18 /* KeyCode.DownArrow */)) {\n            return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector('textarea'));\n        }\n    }\n    _onReplaceInputKeyDown(e) {\n        if (e.equals(ctrlKeyMod | 3 /* KeyCode.Enter */)) {\n            if (this._keybindingService.dispatchEvent(e, e.target)) {\n                e.preventDefault();\n                return;\n            }\n            else {\n                if (platform.isWindows && platform.isNative && !this._ctrlEnterReplaceAllWarningPrompted) {\n                    // this is the first time when users press Ctrl + Enter to replace all\n                    this._notificationService.info(nls.localize('ctrlEnter.keybindingChanged', 'Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.'));\n                    this._ctrlEnterReplaceAllWarningPrompted = true;\n                    this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n                }\n                this._replaceInput.inputBox.insertAtCursor('\\n');\n                e.preventDefault();\n                return;\n            }\n        }\n        if (e.equals(2 /* KeyCode.Tab */)) {\n            this._findInput.focusOnCaseSensitive();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n            this._findInput.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(2048 /* KeyMod.CtrlCmd */ | 18 /* KeyCode.DownArrow */)) {\n            this._codeEditor.focus();\n            e.preventDefault();\n            return;\n        }\n        if (e.equals(16 /* KeyCode.UpArrow */)) {\n            return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector('textarea'));\n        }\n        if (e.equals(18 /* KeyCode.DownArrow */)) {\n            return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector('textarea'));\n        }\n    }\n    // ----- sash\n    getVerticalSashLeft(_sash) {\n        return 0;\n    }\n    // ----- initialization\n    _keybindingLabelFor(actionId) {\n        const kb = this._keybindingService.lookupKeybinding(actionId);\n        if (!kb) {\n            return '';\n        }\n        return ` (${kb.getLabel()})`;\n    }\n    _buildDomNode() {\n        const flexibleHeight = true;\n        const flexibleWidth = true;\n        // Find input\n        this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {\n            width: FIND_INPUT_AREA_WIDTH,\n            label: NLS_FIND_INPUT_LABEL,\n            placeholder: NLS_FIND_INPUT_PLACEHOLDER,\n            appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),\n            appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),\n            appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),\n            validation: (value) => {\n                if (value.length === 0 || !this._findInput.getRegex()) {\n                    return null;\n                }\n                try {\n                    // use `g` and `u` which are also used by the TextModel search\n                    new RegExp(value, 'gu');\n                    return null;\n                }\n                catch (e) {\n                    return { content: e.message };\n                }\n            },\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight: 118,\n            showCommonFindToggles: true,\n            showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),\n            inputBoxStyles: defaultInputBoxStyles,\n            toggleStyles: defaultToggleStyles\n        }, this._contextKeyService));\n        this._findInput.setRegex(!!this._state.isRegex);\n        this._findInput.setCaseSensitive(!!this._state.matchCase);\n        this._findInput.setWholeWords(!!this._state.wholeWord);\n        this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));\n        this._register(this._findInput.inputBox.onDidChange(() => {\n            if (this._ignoreChangeEvent) {\n                return;\n            }\n            this._state.change({ searchString: this._findInput.getValue() }, true);\n        }));\n        this._register(this._findInput.onDidOptionChange(() => {\n            this._state.change({\n                isRegex: this._findInput.getRegex(),\n                wholeWord: this._findInput.getWholeWords(),\n                matchCase: this._findInput.getCaseSensitive()\n            }, true);\n        }));\n        this._register(this._findInput.onCaseSensitiveKeyDown((e) => {\n            if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n                if (this._isReplaceVisible) {\n                    this._replaceInput.focus();\n                    e.preventDefault();\n                }\n            }\n        }));\n        this._register(this._findInput.onRegexKeyDown((e) => {\n            if (e.equals(2 /* KeyCode.Tab */)) {\n                if (this._isReplaceVisible) {\n                    this._replaceInput.focusOnPreserve();\n                    e.preventDefault();\n                }\n            }\n        }));\n        this._register(this._findInput.inputBox.onDidHeightChange((e) => {\n            if (this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }));\n        if (platform.isLinux) {\n            this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));\n        }\n        this._matchesCount = document.createElement('div');\n        this._matchesCount.className = 'matchesCount';\n        this._updateMatchesCount();\n        // Create a scoped hover delegate for all find related buttons\n        const hoverDelegate = this._register(createInstantHoverDelegate());\n        // Previous button\n        this._prevBtn = this._register(new SimpleButton({\n            label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),\n            icon: findPreviousMatchIcon,\n            hoverDelegate,\n            onTrigger: () => {\n                assertIsDefined(this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction)).run().then(undefined, onUnexpectedError);\n            }\n        }, this._hoverService));\n        // Next button\n        this._nextBtn = this._register(new SimpleButton({\n            label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),\n            icon: findNextMatchIcon,\n            hoverDelegate,\n            onTrigger: () => {\n                assertIsDefined(this._codeEditor.getAction(FIND_IDS.NextMatchFindAction)).run().then(undefined, onUnexpectedError);\n            }\n        }, this._hoverService));\n        const findPart = document.createElement('div');\n        findPart.className = 'find-part';\n        findPart.appendChild(this._findInput.domNode);\n        const actionsContainer = document.createElement('div');\n        actionsContainer.className = 'find-actions';\n        findPart.appendChild(actionsContainer);\n        actionsContainer.appendChild(this._matchesCount);\n        actionsContainer.appendChild(this._prevBtn.domNode);\n        actionsContainer.appendChild(this._nextBtn.domNode);\n        // Toggle selection button\n        this._toggleSelectionFind = this._register(new Toggle({\n            icon: findSelectionIcon,\n            title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),\n            isChecked: false,\n            hoverDelegate: hoverDelegate,\n            inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground),\n            inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),\n            inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),\n        }));\n        this._register(this._toggleSelectionFind.onChange(() => {\n            if (this._toggleSelectionFind.checked) {\n                if (this._codeEditor.hasModel()) {\n                    let selections = this._codeEditor.getSelections();\n                    selections = selections.map(selection => {\n                        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                            selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                        }\n                        if (!selection.isEmpty()) {\n                            return selection;\n                        }\n                        return null;\n                    }).filter((element) => !!element);\n                    if (selections.length) {\n                        this._state.change({ searchScope: selections }, true);\n                    }\n                }\n            }\n            else {\n                this._state.change({ searchScope: null }, true);\n            }\n        }));\n        actionsContainer.appendChild(this._toggleSelectionFind.domNode);\n        // Close button\n        this._closeBtn = this._register(new SimpleButton({\n            label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),\n            icon: widgetClose,\n            hoverDelegate,\n            onTrigger: () => {\n                this._state.change({ isRevealed: false, searchScope: null }, false);\n            },\n            onKeyDown: (e) => {\n                if (e.equals(2 /* KeyCode.Tab */)) {\n                    if (this._isReplaceVisible) {\n                        if (this._replaceBtn.isEnabled()) {\n                            this._replaceBtn.focus();\n                        }\n                        else {\n                            this._codeEditor.focus();\n                        }\n                        e.preventDefault();\n                    }\n                }\n            }\n        }, this._hoverService));\n        // Replace input\n        this._replaceInput = this._register(new ContextScopedReplaceInput(null, undefined, {\n            label: NLS_REPLACE_INPUT_LABEL,\n            placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,\n            appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),\n            history: [],\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight: 118,\n            showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),\n            inputBoxStyles: defaultInputBoxStyles,\n            toggleStyles: defaultToggleStyles\n        }, this._contextKeyService, true));\n        this._replaceInput.setPreserveCase(!!this._state.preserveCase);\n        this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));\n        this._register(this._replaceInput.inputBox.onDidChange(() => {\n            this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);\n        }));\n        this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {\n            if (this._isReplaceVisible && this._tryUpdateHeight()) {\n                this._showViewZone();\n            }\n        }));\n        this._register(this._replaceInput.onDidOptionChange(() => {\n            this._state.change({\n                preserveCase: this._replaceInput.getPreserveCase()\n            }, true);\n        }));\n        this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {\n            if (e.equals(2 /* KeyCode.Tab */)) {\n                if (this._prevBtn.isEnabled()) {\n                    this._prevBtn.focus();\n                }\n                else if (this._nextBtn.isEnabled()) {\n                    this._nextBtn.focus();\n                }\n                else if (this._toggleSelectionFind.enabled) {\n                    this._toggleSelectionFind.focus();\n                }\n                else if (this._closeBtn.isEnabled()) {\n                    this._closeBtn.focus();\n                }\n                e.preventDefault();\n            }\n        }));\n        // Create scoped hover delegate for replace actions\n        const replaceHoverDelegate = this._register(createInstantHoverDelegate());\n        // Replace one button\n        this._replaceBtn = this._register(new SimpleButton({\n            label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),\n            icon: findReplaceIcon,\n            hoverDelegate: replaceHoverDelegate,\n            onTrigger: () => {\n                this._controller.replace();\n            },\n            onKeyDown: (e) => {\n                if (e.equals(1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */)) {\n                    this._closeBtn.focus();\n                    e.preventDefault();\n                }\n            }\n        }, this._hoverService));\n        // Replace all button\n        this._replaceAllBtn = this._register(new SimpleButton({\n            label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),\n            icon: findReplaceAllIcon,\n            hoverDelegate: replaceHoverDelegate,\n            onTrigger: () => {\n                this._controller.replaceAll();\n            }\n        }, this._hoverService));\n        const replacePart = document.createElement('div');\n        replacePart.className = 'replace-part';\n        replacePart.appendChild(this._replaceInput.domNode);\n        const replaceActionsContainer = document.createElement('div');\n        replaceActionsContainer.className = 'replace-actions';\n        replacePart.appendChild(replaceActionsContainer);\n        replaceActionsContainer.appendChild(this._replaceBtn.domNode);\n        replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);\n        // Toggle replace button\n        this._toggleReplaceBtn = this._register(new SimpleButton({\n            label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,\n            className: 'codicon toggle left',\n            onTrigger: () => {\n                this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);\n                if (this._isReplaceVisible) {\n                    this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n                    this._replaceInput.inputBox.layout();\n                }\n                this._showViewZone();\n            }\n        }, this._hoverService));\n        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n        // Widget\n        this._domNode = document.createElement('div');\n        this._domNode.className = 'editor-widget find-widget';\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._domNode.ariaLabel = NLS_FIND_DIALOG_LABEL;\n        this._domNode.role = 'dialog';\n        // We need to set this explicitly, otherwise on IE11, the width inheritence of flex doesn't work.\n        this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;\n        this._domNode.appendChild(this._toggleReplaceBtn.domNode);\n        this._domNode.appendChild(findPart);\n        this._domNode.appendChild(this._closeBtn.domNode);\n        this._domNode.appendChild(replacePart);\n        this._resizeSash = this._register(new Sash(this._domNode, this, { orientation: 0 /* Orientation.VERTICAL */, size: 2 }));\n        this._resized = false;\n        let originalWidth = FIND_WIDGET_INITIAL_WIDTH;\n        this._register(this._resizeSash.onDidStart(() => {\n            originalWidth = dom.getTotalWidth(this._domNode);\n        }));\n        this._register(this._resizeSash.onDidChange((evt) => {\n            this._resized = true;\n            const width = originalWidth + evt.startX - evt.currentX;\n            if (width < FIND_WIDGET_INITIAL_WIDTH) {\n                // narrow down the find widget should be handled by CSS.\n                return;\n            }\n            const maxWidth = parseFloat(dom.getComputedStyle(this._domNode).maxWidth) || 0;\n            if (width > maxWidth) {\n                return;\n            }\n            this._domNode.style.width = `${width}px`;\n            if (this._isReplaceVisible) {\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n            }\n            this._findInput.inputBox.layout();\n            this._tryUpdateHeight();\n        }));\n        this._register(this._resizeSash.onDidReset(() => {\n            // users double click on the sash\n            const currentWidth = dom.getTotalWidth(this._domNode);\n            if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {\n                // The editor is narrow and the width of the find widget is controlled fully by CSS.\n                return;\n            }\n            let width = FIND_WIDGET_INITIAL_WIDTH;\n            if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {\n                // 1. never resized before, double click should maximizes it\n                // 2. users resized it already but its width is the same as default\n                const layoutInfo = this._codeEditor.getLayoutInfo();\n                width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;\n                this._resized = true;\n            }\n            else {\n                /**\n                 * no op, the find widget should be shrinked to its default size.\n                 */\n            }\n            this._domNode.style.width = `${width}px`;\n            if (this._isReplaceVisible) {\n                this._replaceInput.width = dom.getTotalWidth(this._findInput.domNode);\n            }\n            this._findInput.inputBox.layout();\n        }));\n    }\n    updateAccessibilitySupport() {\n        const value = this._codeEditor.getOption(2 /* EditorOption.accessibilitySupport */);\n        this._findInput.setFocusInputOnOptionClick(value !== 2 /* AccessibilitySupport.Enabled */);\n    }\n}\nexport class SimpleButton extends Widget {\n    constructor(opts, hoverService) {\n        super();\n        this._opts = opts;\n        let className = 'button';\n        if (this._opts.className) {\n            className = className + ' ' + this._opts.className;\n        }\n        if (this._opts.icon) {\n            className = className + ' ' + ThemeIcon.asClassName(this._opts.icon);\n        }\n        this._domNode = document.createElement('div');\n        this._domNode.tabIndex = 0;\n        this._domNode.className = className;\n        this._domNode.setAttribute('role', 'button');\n        this._domNode.setAttribute('aria-label', this._opts.label);\n        this._register(hoverService.setupManagedHover(opts.hoverDelegate ?? getDefaultHoverDelegate('element'), this._domNode, this._opts.label));\n        this.onclick(this._domNode, (e) => {\n            this._opts.onTrigger();\n            e.preventDefault();\n        });\n        this.onkeydown(this._domNode, (e) => {\n            if (e.equals(10 /* KeyCode.Space */) || e.equals(3 /* KeyCode.Enter */)) {\n                this._opts.onTrigger();\n                e.preventDefault();\n                return;\n            }\n            this._opts.onKeyDown?.(e);\n        });\n    }\n    get domNode() {\n        return this._domNode;\n    }\n    isEnabled() {\n        return (this._domNode.tabIndex >= 0);\n    }\n    focus() {\n        this._domNode.focus();\n    }\n    setEnabled(enabled) {\n        this._domNode.classList.toggle('disabled', !enabled);\n        this._domNode.setAttribute('aria-disabled', String(!enabled));\n        this._domNode.tabIndex = enabled ? 0 : -1;\n    }\n    setExpanded(expanded) {\n        this._domNode.setAttribute('aria-expanded', String(!!expanded));\n        if (expanded) {\n            this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));\n            this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));\n        }\n        else {\n            this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));\n            this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));\n        }\n    }\n}\n// theming\nregisterThemingParticipant((theme, collector) => {\n    const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);\n    if (findMatchHighlightBorder) {\n        collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? 'dotted' : 'solid'} ${findMatchHighlightBorder}; box-sizing: border-box; }`);\n    }\n    const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);\n    if (findRangeHighlightBorder) {\n        collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? 'dashed' : 'solid'} ${findRangeHighlightBorder}; }`);\n    }\n    const hcBorder = theme.getColor(contrastBorder);\n    if (hcBorder) {\n        collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);\n    }\n    const findMatchForeground = theme.getColor(editorFindMatchForeground);\n    if (findMatchForeground) {\n        collector.addRule(`.monaco-editor .findMatchInline { color: ${findMatchForeground}; }`);\n    }\n    const findMatchHighlightForeground = theme.getColor(editorFindMatchHighlightForeground);\n    if (findMatchHighlightForeground) {\n        collector.addRule(`.monaco-editor .currentFindMatchInline { color: ${findMatchHighlightForeground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar FoldingController_1;\nimport { createCancelablePromise, Delayer, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { illegalArgument, onUnexpectedError } from '../../../../base/common/errors.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport './folding.css';\nimport { StableEditorScrollState } from '../../../browser/stableEditorScroll.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerInstantiatedEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { FoldingRangeKind } from '../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingModel, getNextFoldLine, getParentFoldLine as getParentFoldLine, getPreviousFoldLine, setCollapseStateAtLevel, setCollapseStateForMatchingLines, setCollapseStateForRest, setCollapseStateForType, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateUp, toggleCollapseState } from './foldingModel.js';\nimport { HiddenRangeModel } from './hiddenRangeModel.js';\nimport { IndentRangeProvider } from './indentRangeProvider.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { FoldingDecorationProvider } from './foldingDecorations.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { SyntaxRangeProvider } from './syntaxRangeProvider.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CONTEXT_FOLDING_ENABLED = new RawContextKey('foldingEnabled', false);\nlet FoldingController = class FoldingController extends Disposable {\n    static { FoldingController_1 = this; }\n    static { this.ID = 'editor.contrib.folding'; }\n    static get(editor) {\n        return editor.getContribution(FoldingController_1.ID);\n    }\n    static getFoldingRangeProviders(languageFeaturesService, model) {\n        const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);\n        return (FoldingController_1._foldingRangeSelector?.(foldingRangeProviders, model)) ?? foldingRangeProviders;\n    }\n    constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this.contextKeyService = contextKeyService;\n        this.languageConfigurationService = languageConfigurationService;\n        this.languageFeaturesService = languageFeaturesService;\n        this.localToDispose = this._register(new DisposableStore());\n        this.editor = editor;\n        this._foldingLimitReporter = new RangesLimitReporter(editor);\n        const options = this.editor.getOptions();\n        this._isEnabled = options.get(43 /* EditorOption.folding */);\n        this._useFoldingProviders = options.get(44 /* EditorOption.foldingStrategy */) !== 'indentation';\n        this._unfoldOnClickAfterEndOfLine = options.get(48 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n        this._restoringViewState = false;\n        this._currentModelHasFoldedImports = false;\n        this._foldingImportsByDefault = options.get(46 /* EditorOption.foldingImportsByDefault */);\n        this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, 'Folding', { min: 200 });\n        this.foldingModel = null;\n        this.hiddenRangeModel = null;\n        this.rangeProvider = null;\n        this.foldingRegionPromise = null;\n        this.foldingModelPromise = null;\n        this.updateScheduler = null;\n        this.cursorChangedScheduler = null;\n        this.mouseDownInfo = null;\n        this.foldingDecorationProvider = new FoldingDecorationProvider(editor);\n        this.foldingDecorationProvider.showFoldingControls = options.get(111 /* EditorOption.showFoldingControls */);\n        this.foldingDecorationProvider.showFoldingHighlights = options.get(45 /* EditorOption.foldingHighlight */);\n        this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);\n        this.foldingEnabled.set(this._isEnabled);\n        this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));\n        this._register(this.editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(43 /* EditorOption.folding */)) {\n                this._isEnabled = this.editor.getOptions().get(43 /* EditorOption.folding */);\n                this.foldingEnabled.set(this._isEnabled);\n                this.onModelChanged();\n            }\n            if (e.hasChanged(47 /* EditorOption.foldingMaximumRegions */)) {\n                this.onModelChanged();\n            }\n            if (e.hasChanged(111 /* EditorOption.showFoldingControls */) || e.hasChanged(45 /* EditorOption.foldingHighlight */)) {\n                const options = this.editor.getOptions();\n                this.foldingDecorationProvider.showFoldingControls = options.get(111 /* EditorOption.showFoldingControls */);\n                this.foldingDecorationProvider.showFoldingHighlights = options.get(45 /* EditorOption.foldingHighlight */);\n                this.triggerFoldingModelChanged();\n            }\n            if (e.hasChanged(44 /* EditorOption.foldingStrategy */)) {\n                this._useFoldingProviders = this.editor.getOptions().get(44 /* EditorOption.foldingStrategy */) !== 'indentation';\n                this.onFoldingStrategyChanged();\n            }\n            if (e.hasChanged(48 /* EditorOption.unfoldOnClickAfterEndOfLine */)) {\n                this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(48 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n            }\n            if (e.hasChanged(46 /* EditorOption.foldingImportsByDefault */)) {\n                this._foldingImportsByDefault = this.editor.getOptions().get(46 /* EditorOption.foldingImportsByDefault */);\n            }\n        }));\n        this.onModelChanged();\n    }\n    /**\n     * Store view state.\n     */\n    saveViewState() {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n            return {};\n        }\n        if (this.foldingModel) { // disposed ?\n            const collapsedRegions = this.foldingModel.getMemento();\n            const provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n            return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };\n        }\n        return undefined;\n    }\n    /**\n     * Restore view state.\n     */\n    restoreViewState(state) {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n            return;\n        }\n        if (!state) {\n            return;\n        }\n        this._currentModelHasFoldedImports = !!state.foldedImports;\n        if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {\n            this._restoringViewState = true;\n            try {\n                this.foldingModel.applyMemento(state.collapsedRegions);\n            }\n            finally {\n                this._restoringViewState = false;\n            }\n        }\n    }\n    onModelChanged() {\n        this.localToDispose.clear();\n        const model = this.editor.getModel();\n        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n            // huge files get no view model, so they cannot support hidden areas\n            return;\n        }\n        this._currentModelHasFoldedImports = false;\n        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);\n        this.localToDispose.add(this.foldingModel);\n        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);\n        this.localToDispose.add(this.hiddenRangeModel);\n        this.localToDispose.add(this.hiddenRangeModel.onDidChange(hr => this.onHiddenRangesChanges(hr)));\n        this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));\n        this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);\n        this.localToDispose.add(this.cursorChangedScheduler);\n        this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));\n        this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())); // covers model language changes as well\n        this.localToDispose.add(this.editor.onDidChangeModelContent(e => this.onDidChangeModelContent(e)));\n        this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));\n        this.localToDispose.add(this.editor.onMouseDown(e => this.onEditorMouseDown(e)));\n        this.localToDispose.add(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));\n        this.localToDispose.add({\n            dispose: () => {\n                if (this.foldingRegionPromise) {\n                    this.foldingRegionPromise.cancel();\n                    this.foldingRegionPromise = null;\n                }\n                this.updateScheduler?.cancel();\n                this.updateScheduler = null;\n                this.foldingModel = null;\n                this.foldingModelPromise = null;\n                this.hiddenRangeModel = null;\n                this.cursorChangedScheduler = null;\n                this.rangeProvider?.dispose();\n                this.rangeProvider = null;\n            }\n        });\n        this.triggerFoldingModelChanged();\n    }\n    onFoldingStrategyChanged() {\n        this.rangeProvider?.dispose();\n        this.rangeProvider = null;\n        this.triggerFoldingModelChanged();\n    }\n    getRangeProvider(editorModel) {\n        if (this.rangeProvider) {\n            return this.rangeProvider;\n        }\n        const indentRangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._foldingLimitReporter);\n        this.rangeProvider = indentRangeProvider; // fallback\n        if (this._useFoldingProviders && this.foldingModel) {\n            const selectedProviders = FoldingController_1.getFoldingRangeProviders(this.languageFeaturesService, editorModel);\n            if (selectedProviders.length > 0) {\n                this.rangeProvider = new SyntaxRangeProvider(editorModel, selectedProviders, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, indentRangeProvider);\n            }\n        }\n        return this.rangeProvider;\n    }\n    getFoldingModel() {\n        return this.foldingModelPromise;\n    }\n    onDidChangeModelContent(e) {\n        this.hiddenRangeModel?.notifyChangeModelContent(e);\n        this.triggerFoldingModelChanged();\n    }\n    triggerFoldingModelChanged() {\n        if (this.updateScheduler) {\n            if (this.foldingRegionPromise) {\n                this.foldingRegionPromise.cancel();\n                this.foldingRegionPromise = null;\n            }\n            this.foldingModelPromise = this.updateScheduler.trigger(() => {\n                const foldingModel = this.foldingModel;\n                if (!foldingModel) { // null if editor has been disposed, or folding turned off\n                    return null;\n                }\n                const sw = new StopWatch();\n                const provider = this.getRangeProvider(foldingModel.textModel);\n                const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise(token => provider.compute(token));\n                return foldingRegionPromise.then(foldingRanges => {\n                    if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) { // new request or cancelled in the meantime?\n                        let scrollState;\n                        if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {\n                            const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);\n                            if (hasChanges) {\n                                scrollState = StableEditorScrollState.capture(this.editor);\n                                this._currentModelHasFoldedImports = hasChanges;\n                            }\n                        }\n                        // some cursors might have moved into hidden regions, make sure they are in expanded regions\n                        const selections = this.editor.getSelections();\n                        foldingModel.update(foldingRanges, toSelectedLines(selections));\n                        scrollState?.restore(this.editor);\n                        // update debounce info\n                        const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());\n                        if (this.updateScheduler) {\n                            this.updateScheduler.defaultDelay = newValue;\n                        }\n                    }\n                    return foldingModel;\n                });\n            }).then(undefined, (err) => {\n                onUnexpectedError(err);\n                return null;\n            });\n        }\n    }\n    onHiddenRangesChanges(hiddenRanges) {\n        if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {\n            const selections = this.editor.getSelections();\n            if (selections) {\n                if (this.hiddenRangeModel.adjustSelections(selections)) {\n                    this.editor.setSelections(selections);\n                }\n            }\n        }\n        this.editor.setHiddenAreas(hiddenRanges, this);\n    }\n    onCursorPositionChanged() {\n        if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n            this.cursorChangedScheduler.schedule();\n        }\n    }\n    revealCursor() {\n        const foldingModel = this.getFoldingModel();\n        if (!foldingModel) {\n            return;\n        }\n        foldingModel.then(foldingModel => {\n            if (foldingModel) {\n                const selections = this.editor.getSelections();\n                if (selections && selections.length > 0) {\n                    const toToggle = [];\n                    for (const selection of selections) {\n                        const lineNumber = selection.selectionStartLineNumber;\n                        if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {\n                            toToggle.push(...foldingModel.getAllRegionsAtLine(lineNumber, r => r.isCollapsed && lineNumber > r.startLineNumber));\n                        }\n                    }\n                    if (toToggle.length) {\n                        foldingModel.toggleCollapseState(toToggle);\n                        this.reveal(selections[0].getPosition());\n                    }\n                }\n            }\n        }).then(undefined, onUnexpectedError);\n    }\n    onEditorMouseDown(e) {\n        this.mouseDownInfo = null;\n        if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n            return;\n        }\n        if (!e.event.leftButton && !e.event.middleButton) {\n            return;\n        }\n        const range = e.target.range;\n        let iconClicked = false;\n        switch (e.target.type) {\n            case 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */: {\n                const data = e.target.detail;\n                const offsetLeftInGutter = e.target.element.offsetLeft;\n                const gutterOffsetX = data.offsetX - offsetLeftInGutter;\n                // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n                // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n                if (gutterOffsetX < 4) { // the whitespace between the border and the real folding icon border is 4px\n                    return;\n                }\n                iconClicked = true;\n                break;\n            }\n            case 7 /* MouseTargetType.CONTENT_EMPTY */: {\n                if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {\n                    const data = e.target.detail;\n                    if (!data.isAfterLines) {\n                        break;\n                    }\n                }\n                return;\n            }\n            case 6 /* MouseTargetType.CONTENT_TEXT */: {\n                if (this.hiddenRangeModel.hasRanges()) {\n                    const model = this.editor.getModel();\n                    if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n                        break;\n                    }\n                }\n                return;\n            }\n            default:\n                return;\n        }\n        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };\n    }\n    onEditorMouseUp(e) {\n        const foldingModel = this.foldingModel;\n        if (!foldingModel || !this.mouseDownInfo || !e.target) {\n            return;\n        }\n        const lineNumber = this.mouseDownInfo.lineNumber;\n        const iconClicked = this.mouseDownInfo.iconClicked;\n        const range = e.target.range;\n        if (!range || range.startLineNumber !== lineNumber) {\n            return;\n        }\n        if (iconClicked) {\n            if (e.target.type !== 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n                return;\n            }\n        }\n        else {\n            const model = this.editor.getModel();\n            if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n                return;\n            }\n        }\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region && region.startLineNumber === lineNumber) {\n            const isCollapsed = region.isCollapsed;\n            if (iconClicked || isCollapsed) {\n                const surrounding = e.event.altKey;\n                let toToggle = [];\n                if (surrounding) {\n                    const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);\n                    const toMaybeToggle = foldingModel.getRegionsInside(null, filter);\n                    for (const r of toMaybeToggle) {\n                        if (r.isCollapsed) {\n                            toToggle.push(r);\n                        }\n                    }\n                    // if any surrounding regions are folded, unfold those. Otherwise, fold all surrounding\n                    if (toToggle.length === 0) {\n                        toToggle = toMaybeToggle;\n                    }\n                }\n                else {\n                    const recursive = e.event.middleButton || e.event.shiftKey;\n                    if (recursive) {\n                        for (const r of foldingModel.getRegionsInside(region)) {\n                            if (r.isCollapsed === isCollapsed) {\n                                toToggle.push(r);\n                            }\n                        }\n                    }\n                    // when recursive, first only collapse all children. If all are already folded or there are no children, also fold parent.\n                    if (isCollapsed || !recursive || toToggle.length === 0) {\n                        toToggle.push(region);\n                    }\n                }\n                foldingModel.toggleCollapseState(toToggle);\n                this.reveal({ lineNumber, column: 1 });\n            }\n        }\n    }\n    reveal(position) {\n        this.editor.revealPositionInCenterIfOutsideViewport(position, 0 /* ScrollType.Smooth */);\n    }\n};\nFoldingController = FoldingController_1 = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageConfigurationService),\n    __param(3, INotificationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], FoldingController);\nexport { FoldingController };\nexport class RangesLimitReporter {\n    constructor(editor) {\n        this.editor = editor;\n        this._onDidChange = new Emitter();\n        this._computed = 0;\n        this._limited = false;\n    }\n    get limit() {\n        return this.editor.getOptions().get(47 /* EditorOption.foldingMaximumRegions */);\n    }\n    update(computed, limited) {\n        if (computed !== this._computed || limited !== this._limited) {\n            this._computed = computed;\n            this._limited = limited;\n            this._onDidChange.fire();\n        }\n    }\n}\nclass FoldingAction extends EditorAction {\n    runEditorCommand(accessor, editor, args) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const foldingController = FoldingController.get(editor);\n        if (!foldingController) {\n            return;\n        }\n        const foldingModelPromise = foldingController.getFoldingModel();\n        if (foldingModelPromise) {\n            this.reportTelemetry(accessor, editor);\n            return foldingModelPromise.then(foldingModel => {\n                if (foldingModel) {\n                    this.invoke(foldingController, foldingModel, editor, args, languageConfigurationService);\n                    const selection = editor.getSelection();\n                    if (selection) {\n                        foldingController.reveal(selection.getStartPosition());\n                    }\n                }\n            });\n        }\n    }\n    getSelectedLines(editor) {\n        const selections = editor.getSelections();\n        return selections ? selections.map(s => s.startLineNumber) : [];\n    }\n    getLineNumbers(args, editor) {\n        if (args && args.selectionLines) {\n            return args.selectionLines.map(l => l + 1); // to 0-bases line numbers\n        }\n        return this.getSelectedLines(editor);\n    }\n    run(_accessor, _editor) {\n    }\n}\nexport function toSelectedLines(selections) {\n    if (!selections || selections.length === 0) {\n        return {\n            startsInside: () => false\n        };\n    }\n    return {\n        startsInside(startLine, endLine) {\n            for (const s of selections) {\n                const line = s.startLineNumber;\n                if (line >= startLine && line <= endLine) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n}\nfunction foldingArgumentsConstraint(args) {\n    if (!types.isUndefined(args)) {\n        if (!types.isObject(args)) {\n            return false;\n        }\n        const foldingArgs = args;\n        if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.selectionLines) && (!Array.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n            return false;\n        }\n    }\n    return true;\n}\nclass UnfoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfold',\n            label: nls.localize('unfoldAction.label', \"Unfold\"),\n            alias: 'Unfold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 94 /* KeyCode.BracketRight */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 94 /* KeyCode.BracketRight */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            metadata: {\n                description: 'Unfold the content in the editor',\n                args: [\n                    {\n                        name: 'Unfold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                    'default': 1\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                    'default': 'down'\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const levels = args && args.levels || 1;\n        const lineNumbers = this.getLineNumbers(args, editor);\n        if (args && args.direction === 'up') {\n            setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n        }\n        else {\n            setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n        }\n    }\n}\nclass UnFoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldRecursively',\n            label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n            alias: 'Unfold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 94 /* KeyCode.BracketRight */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, _args) {\n        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n    }\n}\nclass FoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.fold',\n            label: nls.localize('foldAction.label', \"Fold\"),\n            alias: 'Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 92 /* KeyCode.BracketLeft */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 92 /* KeyCode.BracketLeft */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            metadata: {\n                description: 'Fold the content in the editor',\n                args: [\n                    {\n                        name: 'Fold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t\tIf no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const lineNumbers = this.getLineNumbers(args, editor);\n        const levels = args && args.levels;\n        const direction = args && args.direction;\n        if (typeof levels !== 'number' && typeof direction !== 'string') {\n            // fold the region at the location or if already collapsed, the first uncollapsed parent instead.\n            setCollapseStateUp(foldingModel, true, lineNumbers);\n        }\n        else {\n            if (direction === 'up') {\n                setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);\n            }\n            else {\n                setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);\n            }\n        }\n    }\n}\nclass ToggleFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.toggleFold',\n            label: nls.localize('toggleFoldAction.label', \"Toggle Fold\"),\n            alias: 'Toggle Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 42 /* KeyCode.KeyL */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        toggleCollapseState(foldingModel, 1, selectedLines);\n    }\n}\nclass FoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldRecursively',\n            label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n            alias: 'Fold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 92 /* KeyCode.BracketLeft */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n    }\n}\nclass ToggleFoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.toggleFoldRecursively',\n            label: nls.localize('toggleFoldRecursivelyAction.label', \"Toggle Fold Recursively\"),\n            alias: 'Toggle Fold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 42 /* KeyCode.KeyL */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        toggleCollapseState(foldingModel, Number.MAX_VALUE, selectedLines);\n    }\n}\nclass FoldAllBlockCommentsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllBlockComments',\n            label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n            alias: 'Fold All Block Comments',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 90 /* KeyCode.Slash */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;\n            if (comments && comments.blockCommentStartToken) {\n                const regExp = new RegExp('^\\\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass FoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllMarkerRegions',\n            label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n            alias: 'Fold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 29 /* KeyCode.Digit8 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass UnfoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllMarkerRegions',\n            label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n            alias: 'Unfold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 30 /* KeyCode.Digit9 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, false);\n            }\n        }\n    }\n}\nclass FoldAllExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllExcept',\n            label: nls.localize('foldAllExcept.label', \"Fold All Except Selected\"),\n            alias: 'Fold All Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 88 /* KeyCode.Minus */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, true, selectedLines);\n    }\n}\nclass UnfoldAllExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllExcept',\n            label: nls.localize('unfoldAllExcept.label', \"Unfold All Except Selected\"),\n            alias: 'Unfold All Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 86 /* KeyCode.Equal */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, false, selectedLines);\n    }\n}\nclass FoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAll',\n            label: nls.localize('foldAllAction.label', \"Fold All\"),\n            alias: 'Fold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 21 /* KeyCode.Digit0 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, true);\n    }\n}\nclass UnfoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAll',\n            label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n            alias: 'Unfold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 40 /* KeyCode.KeyJ */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, false);\n    }\n}\nclass FoldLevelAction extends FoldingAction {\n    static { this.ID_PREFIX = 'editor.foldLevel'; }\n    static { this.ID = (level) => FoldLevelAction.ID_PREFIX + level; }\n    getFoldingLevel() {\n        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n    }\n}\n/** Action to go to the parent fold of current line */\nclass GotoParentFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoParentFold',\n            label: nls.localize('gotoParentFold.label', \"Go to Parent Fold\"),\n            alias: 'Go to Parent Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the previous fold of current line */\nclass GotoPreviousFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoPreviousFold',\n            label: nls.localize('gotoPreviousFold.label', \"Go to Previous Folding Range\"),\n            alias: 'Go to Previous Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the next fold of current line */\nclass GotoNextFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoNextFold',\n            label: nls.localize('gotoNextFold.label', \"Go to Next Folding Range\"),\n            alias: 'Go to Next Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\nclass FoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.createFoldingRangeFromSelection',\n            label: nls.localize('createManualFoldRange.label', \"Create Folding Range from Selection\"),\n            alias: 'Create Folding Range from Selection',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 87 /* KeyCode.Comma */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const collapseRanges = [];\n        const selections = editor.getSelections();\n        if (selections) {\n            for (const selection of selections) {\n                let endLineNumber = selection.endLineNumber;\n                if (selection.endColumn === 1) {\n                    --endLineNumber;\n                }\n                if (endLineNumber > selection.startLineNumber) {\n                    collapseRanges.push({\n                        startLineNumber: selection.startLineNumber,\n                        endLineNumber: endLineNumber,\n                        type: undefined,\n                        isCollapsed: true,\n                        source: 1 /* FoldSource.userDefined */\n                    });\n                    editor.setSelection({\n                        startLineNumber: selection.startLineNumber,\n                        startColumn: 1,\n                        endLineNumber: selection.startLineNumber,\n                        endColumn: 1\n                    });\n                }\n            }\n            if (collapseRanges.length > 0) {\n                collapseRanges.sort((a, b) => {\n                    return a.startLineNumber - b.startLineNumber;\n                });\n                const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, editor.getModel()?.getLineCount());\n                foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n            }\n        }\n    }\n}\nclass RemoveFoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.removeManualFoldingRanges',\n            label: nls.localize('removeManualFoldingRanges.label', \"Remove Manual Folding Ranges\"),\n            alias: 'Remove Manual Folding Ranges',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 89 /* KeyCode.Period */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(foldingController, foldingModel, editor) {\n        const selections = editor.getSelections();\n        if (selections) {\n            const ranges = [];\n            for (const selection of selections) {\n                const { startLineNumber, endLineNumber } = selection;\n                ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });\n            }\n            foldingModel.removeManualRanges(ranges);\n            foldingController.triggerFoldingModelChanged();\n        }\n    }\n}\nregisterEditorContribution(FoldingController.ID, FoldingController, 0 /* EditorContributionInstantiation.Eager */); // eager because it uses `saveViewState`/`restoreViewState`\nregisterEditorAction(UnfoldAction);\nregisterEditorAction(UnFoldRecursivelyAction);\nregisterEditorAction(FoldAction);\nregisterEditorAction(FoldRecursivelyAction);\nregisterEditorAction(ToggleFoldRecursivelyAction);\nregisterEditorAction(FoldAllAction);\nregisterEditorAction(UnfoldAllAction);\nregisterEditorAction(FoldAllBlockCommentsAction);\nregisterEditorAction(FoldAllRegionsAction);\nregisterEditorAction(UnfoldAllRegionsAction);\nregisterEditorAction(FoldAllExceptAction);\nregisterEditorAction(UnfoldAllExceptAction);\nregisterEditorAction(ToggleFoldAction);\nregisterEditorAction(GotoParentFoldAction);\nregisterEditorAction(GotoPreviousFoldAction);\nregisterEditorAction(GotoNextFoldAction);\nregisterEditorAction(FoldRangeFromSelectionAction);\nregisterEditorAction(RemoveFoldRangeFromSelectionAction);\nfor (let i = 1; i <= 7; i++) {\n    registerInstantiatedEditorAction(new FoldLevelAction({\n        id: FoldLevelAction.ID(i),\n        label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n        alias: `Fold Level ${i}`,\n        precondition: CONTEXT_FOLDING_ENABLED,\n        kbOpts: {\n            kbExpr: EditorContextKeys.editorTextFocus,\n            primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | (21 /* KeyCode.Digit0 */ + i)),\n            weight: 100 /* KeybindingWeight.EditorContrib */\n        }\n    }));\n}\nCommandsRegistry.registerCommand('_executeFoldingRangeProvider', async function (accessor, ...args) {\n    const [resource] = args;\n    if (!(resource instanceof URI)) {\n        throw illegalArgument();\n    }\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = accessor.get(IModelService).getModel(resource);\n    if (!model) {\n        throw illegalArgument();\n    }\n    const configurationService = accessor.get(IConfigurationService);\n    if (!configurationService.getValue('editor.folding', { resource })) {\n        return [];\n    }\n    const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n    const strategy = configurationService.getValue('editor.foldingStrategy', { resource });\n    const foldingLimitReporter = {\n        get limit() {\n            return configurationService.getValue('editor.foldingMaximumRegions', { resource });\n        },\n        update: (computed, limited) => { }\n    };\n    const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);\n    let rangeProvider = indentRangeProvider;\n    if (strategy !== 'indentation') {\n        const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);\n        if (providers.length) {\n            rangeProvider = new SyntaxRangeProvider(model, providers, () => { }, foldingLimitReporter, indentRangeProvider);\n        }\n    }\n    const ranges = await rangeProvider.compute(CancellationToken.None);\n    const result = [];\n    try {\n        if (ranges) {\n            for (let i = 0; i < ranges.length; i++) {\n                const type = ranges.getType(i);\n                result.push({ start: ranges.getStartLineNumber(i), end: ranges.getEndLineNumber(i), kind: type ? FoldingRangeKind.fromValue(type) : undefined });\n            }\n        }\n        return result;\n    }\n    finally {\n        rangeProvider.dispose();\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../../../base/common/arrays.js';\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { SingleTextEdit, TextEdit } from '../../../../common/core/textEdit.js';\nexport class GhostText {\n    constructor(lineNumber, parts) {\n        this.lineNumber = lineNumber;\n        this.parts = parts;\n    }\n    equals(other) {\n        return this.lineNumber === other.lineNumber &&\n            this.parts.length === other.parts.length &&\n            this.parts.every((part, index) => part.equals(other.parts[index]));\n    }\n    renderForScreenReader(lineText) {\n        if (this.parts.length === 0) {\n            return '';\n        }\n        const lastPart = this.parts[this.parts.length - 1];\n        const cappedLineText = lineText.substr(0, lastPart.column - 1);\n        const text = new TextEdit([\n            ...this.parts.map(p => new SingleTextEdit(Range.fromPositions(new Position(1, p.column)), p.lines.join('\\n'))),\n        ]).applyToString(cappedLineText);\n        return text.substring(this.parts[0].column - 1);\n    }\n    isEmpty() {\n        return this.parts.every(p => p.lines.length === 0);\n    }\n    get lineCount() {\n        return 1 + this.parts.reduce((r, p) => r + p.lines.length - 1, 0);\n    }\n}\nexport class GhostTextPart {\n    constructor(column, text, \n    /**\n     * Indicates if this part is a preview of an inline suggestion when a suggestion is previewed.\n    */\n    preview) {\n        this.column = column;\n        this.text = text;\n        this.preview = preview;\n        this.lines = splitLines(this.text);\n    }\n    equals(other) {\n        return this.column === other.column &&\n            this.lines.length === other.lines.length &&\n            this.lines.every((line, index) => line === other.lines[index]);\n    }\n}\nexport class GhostTextReplacement {\n    constructor(lineNumber, columnRange, text, additionalReservedLineCount = 0) {\n        this.lineNumber = lineNumber;\n        this.columnRange = columnRange;\n        this.text = text;\n        this.additionalReservedLineCount = additionalReservedLineCount;\n        this.parts = [\n            new GhostTextPart(this.columnRange.endColumnExclusive, this.text, false),\n        ];\n        this.newLines = splitLines(this.text);\n    }\n    renderForScreenReader(_lineText) {\n        return this.newLines.join('\\n');\n    }\n    get lineCount() {\n        return this.newLines.length;\n    }\n    isEmpty() {\n        return this.parts.every(p => p.lines.length === 0);\n    }\n    equals(other) {\n        return this.lineNumber === other.lineNumber &&\n            this.columnRange.equals(other.columnRange) &&\n            this.newLines.length === other.newLines.length &&\n            this.newLines.every((line, index) => line === other.newLines[index]) &&\n            this.additionalReservedLineCount === other.additionalReservedLineCount;\n    }\n}\nexport function ghostTextsOrReplacementsEqual(a, b) {\n    return equals(a, b, ghostTextOrReplacementEquals);\n}\nexport function ghostTextOrReplacementEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!a || !b) {\n        return false;\n    }\n    if (a instanceof GhostText && b instanceof GhostText) {\n        return a.equals(b);\n    }\n    if (a instanceof GhostTextReplacement && b instanceof GhostTextReplacement) {\n        return a.equals(b);\n    }\n    return false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../../base/common/errors.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { SingleTextEdit } from '../../../../common/core/textEdit.js';\nimport { getReadonlyEmptyArray } from '../utils.js';\nimport { SnippetParser, Text } from '../../../snippet/browser/snippetParser.js';\nexport async function provideInlineCompletions(registry, positionOrRange, model, context, token = CancellationToken.None, languageConfigurationService) {\n    // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n    const defaultReplaceRange = positionOrRange instanceof Position ? getDefaultRange(positionOrRange, model) : positionOrRange;\n    const providers = registry.all(model);\n    const multiMap = new SetMap();\n    for (const provider of providers) {\n        if (provider.groupId) {\n            multiMap.add(provider.groupId, provider);\n        }\n    }\n    function getPreferredProviders(provider) {\n        if (!provider.yieldsToGroupIds) {\n            return [];\n        }\n        const result = [];\n        for (const groupId of provider.yieldsToGroupIds || []) {\n            const providers = multiMap.get(groupId);\n            for (const p of providers) {\n                result.push(p);\n            }\n        }\n        return result;\n    }\n    const states = new Map();\n    const seen = new Set();\n    function findPreferredProviderCircle(provider, stack) {\n        stack = [...stack, provider];\n        if (seen.has(provider)) {\n            return stack;\n        }\n        seen.add(provider);\n        try {\n            const preferred = getPreferredProviders(provider);\n            for (const p of preferred) {\n                const c = findPreferredProviderCircle(p, stack);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n        finally {\n            seen.delete(provider);\n        }\n        return undefined;\n    }\n    function processProvider(provider) {\n        const state = states.get(provider);\n        if (state) {\n            return state;\n        }\n        const circle = findPreferredProviderCircle(provider, []);\n        if (circle) {\n            onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n        }\n        const deferredPromise = new DeferredPromise();\n        states.set(provider, deferredPromise.p);\n        (async () => {\n            if (!circle) {\n                const preferred = getPreferredProviders(provider);\n                for (const p of preferred) {\n                    const result = await processProvider(p);\n                    if (result && result.items.length > 0) {\n                        // Skip provider\n                        return undefined;\n                    }\n                }\n            }\n            try {\n                if (positionOrRange instanceof Position) {\n                    const completions = await provider.provideInlineCompletions(model, positionOrRange, context, token);\n                    return completions;\n                }\n                else {\n                    const completions = await provider.provideInlineEdits?.(model, positionOrRange, context, token);\n                    return completions;\n                }\n            }\n            catch (e) {\n                onUnexpectedExternalError(e);\n                return undefined;\n            }\n        })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n        return deferredPromise.p;\n    }\n    const providerResults = await Promise.all(providers.map(async (provider) => ({ provider, completions: await processProvider(provider) })));\n    const itemsByHash = new Map();\n    const lists = [];\n    for (const result of providerResults) {\n        const completions = result.completions;\n        if (!completions) {\n            continue;\n        }\n        const list = new InlineCompletionList(completions, result.provider);\n        lists.push(list);\n        for (const item of completions.items) {\n            const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n            itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n        }\n    }\n    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\nexport class InlineCompletionProviderResult {\n    constructor(\n    /**\n     * Free of duplicates.\n     */\n    completions, hashs, providerResults) {\n        this.completions = completions;\n        this.hashs = hashs;\n        this.providerResults = providerResults;\n    }\n    has(item) {\n        return this.hashs.has(item.hash());\n    }\n    dispose() {\n        for (const result of this.providerResults) {\n            result.removeRef();\n        }\n    }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n    constructor(inlineCompletions, provider) {\n        this.inlineCompletions = inlineCompletions;\n        this.provider = provider;\n        this.refCount = 1;\n    }\n    addRef() {\n        this.refCount++;\n    }\n    removeRef() {\n        this.refCount--;\n        if (this.refCount === 0) {\n            this.provider.freeInlineCompletions(this.inlineCompletions);\n        }\n    }\n}\nexport class InlineCompletionItem {\n    static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n        let insertText;\n        let snippetInfo;\n        let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n        if (typeof inlineCompletion.insertText === 'string') {\n            insertText = inlineCompletion.insertText;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = insertText.length - inlineCompletion.insertText.length;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            snippetInfo = undefined;\n        }\n        else if ('snippet' in inlineCompletion.insertText) {\n            const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n            if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n                insertText = snippet.children[0].value;\n                snippetInfo = undefined;\n            }\n            else {\n                insertText = snippet.toString();\n                snippetInfo = {\n                    snippet: inlineCompletion.insertText.snippet,\n                    range: range\n                };\n            }\n        }\n        else {\n            assertNever(inlineCompletion.insertText);\n        }\n        return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n    }\n    constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits, \n    /**\n     * A reference to the original inline completion this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    sourceInlineCompletion, \n    /**\n     * A reference to the original inline completion list this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    source) {\n        this.filterText = filterText;\n        this.command = command;\n        this.range = range;\n        this.insertText = insertText;\n        this.snippetInfo = snippetInfo;\n        this.additionalTextEdits = additionalTextEdits;\n        this.sourceInlineCompletion = sourceInlineCompletion;\n        this.source = source;\n        filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n        insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    }\n    withRange(updatedRange) {\n        return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n    }\n    hash() {\n        return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n    }\n    toSingleTextEdit() {\n        return new SingleTextEdit(this.range, this.insertText);\n    }\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n    const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n    const newLine = lineStart + text;\n    const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n    const slicedTokens = newTokens?.sliceAndInflate(position.column - 1, newLine.length, 0);\n    if (!slicedTokens) {\n        return text;\n    }\n    const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n    return newText;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { compareBy, Permutation } from '../../../../../base/common/arrays.js';\nimport { mapFindFirst } from '../../../../../base/common/arraysFind.js';\nimport { itemsEquals } from '../../../../../base/common/equals.js';\nimport { BugIndicatingError, onUnexpectedError, onUnexpectedExternalError } from '../../../../../base/common/errors.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { autorun, derived, derivedHandleChanges, derivedOpts, observableSignal, observableValue, recomputeInitiallyAndOnChange, subtransaction, transaction } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, splitLinesIncludeSeparators } from '../../../../../base/common/strings.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { EditOperation } from '../../../../common/core/editOperation.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { Selection } from '../../../../common/core/selection.js';\nimport { SingleTextEdit, TextEdit } from '../../../../common/core/textEdit.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { InlineCompletionTriggerKind } from '../../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';\nimport { GhostText, ghostTextOrReplacementEquals, ghostTextsOrReplacementsEqual } from './ghostText.js';\nimport { InlineCompletionsSource } from './inlineCompletionsSource.js';\nimport { computeGhostText, singleTextEditAugments, singleTextRemoveCommonPrefix } from './singleTextEdit.js';\nimport { addPositions, subtractPositions } from '../utils.js';\nimport { SnippetController2 } from '../../../snippet/browser/snippetController2.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n    get isAcceptingPartially() { return this._isAcceptingPartially; }\n    constructor(textModel, selectedSuggestItem, _textModelVersionId, _positions, _debounceValue, _suggestPreviewEnabled, _suggestPreviewMode, _inlineSuggestMode, _enabled, _instantiationService, _commandService, _languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.selectedSuggestItem = selectedSuggestItem;\n        this._textModelVersionId = _textModelVersionId;\n        this._positions = _positions;\n        this._debounceValue = _debounceValue;\n        this._suggestPreviewEnabled = _suggestPreviewEnabled;\n        this._suggestPreviewMode = _suggestPreviewMode;\n        this._inlineSuggestMode = _inlineSuggestMode;\n        this._enabled = _enabled;\n        this._instantiationService = _instantiationService;\n        this._commandService = _commandService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this._textModelVersionId, this._debounceValue));\n        this._isActive = observableValue(this, false);\n        this._forceUpdateExplicitlySignal = observableSignal(this);\n        // We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n        this._selectedInlineCompletionId = observableValue(this, undefined);\n        this._primaryPosition = derived(this, reader => this._positions.read(reader)[0] ?? new Position(1, 1));\n        this._isAcceptingPartially = false;\n        this._preserveCurrentCompletionReasons = new Set([\n            VersionIdChangeReason.Redo,\n            VersionIdChangeReason.Undo,\n            VersionIdChangeReason.AcceptWord,\n        ]);\n        this._fetchInlineCompletionsPromise = derivedHandleChanges({\n            owner: this,\n            createEmptyChangeSummary: () => ({\n                preserveCurrentCompletion: false,\n                inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n            }),\n            handleChange: (ctx, changeSummary) => {\n                /** @description fetch inline completions */\n                if (ctx.didChange(this._textModelVersionId) && this._preserveCurrentCompletionReasons.has(this._getReason(ctx.change))) {\n                    changeSummary.preserveCurrentCompletion = true;\n                }\n                else if (ctx.didChange(this._forceUpdateExplicitlySignal)) {\n                    changeSummary.inlineCompletionTriggerKind = InlineCompletionTriggerKind.Explicit;\n                }\n                return true;\n            },\n        }, (reader, changeSummary) => {\n            this._forceUpdateExplicitlySignal.read(reader);\n            const shouldUpdate = (this._enabled.read(reader) && this.selectedSuggestItem.read(reader)) || this._isActive.read(reader);\n            if (!shouldUpdate) {\n                this._source.cancelUpdate();\n                return undefined;\n            }\n            this._textModelVersionId.read(reader); // Refetch on text change\n            const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();\n            const suggestItem = this.selectedSuggestItem.read(reader);\n            if (suggestWidgetInlineCompletions && !suggestItem) {\n                const inlineCompletions = this._source.inlineCompletions.get();\n                transaction(tx => {\n                    /** @description Seed inline completions with (newer) suggest widget inline completions */\n                    if (!inlineCompletions || suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {\n                        this._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);\n                    }\n                    this._source.clearSuggestWidgetInlineCompletions(tx);\n                });\n            }\n            const cursorPosition = this._primaryPosition.read(reader);\n            const context = {\n                triggerKind: changeSummary.inlineCompletionTriggerKind,\n                selectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),\n            };\n            const itemToPreserveCandidate = this.selectedInlineCompletion.get();\n            const itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable\n                ? itemToPreserveCandidate : undefined;\n            return this._source.fetch(cursorPosition, context, itemToPreserve);\n        });\n        this._filteredInlineCompletionItems = derivedOpts({ owner: this, equalsFn: itemsEquals() }, reader => {\n            const c = this._source.inlineCompletions.read(reader);\n            if (!c) {\n                return [];\n            }\n            const cursorPosition = this._primaryPosition.read(reader);\n            const filteredCompletions = c.inlineCompletions.filter(c => c.isVisible(this.textModel, cursorPosition, reader));\n            return filteredCompletions;\n        });\n        this.selectedInlineCompletionIndex = derived(this, (reader) => {\n            const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n            const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n            const idx = this._selectedInlineCompletionId === undefined ? -1\n                : filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n            if (idx === -1) {\n                // Reset the selection so that the selection does not jump back when it appears again\n                this._selectedInlineCompletionId.set(undefined, undefined);\n                return 0;\n            }\n            return idx;\n        });\n        this.selectedInlineCompletion = derived(this, (reader) => {\n            const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n            const idx = this.selectedInlineCompletionIndex.read(reader);\n            return filteredCompletions[idx];\n        });\n        this.activeCommands = derivedOpts({ owner: this, equalsFn: itemsEquals() }, r => this.selectedInlineCompletion.read(r)?.inlineCompletion.source.inlineCompletions.commands ?? []);\n        this.lastTriggerKind = this._source.inlineCompletions.map(this, v => v?.request.context.triggerKind);\n        this.inlineCompletionsCount = derived(this, reader => {\n            if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {\n                return this._filteredInlineCompletionItems.read(reader).length;\n            }\n            else {\n                return undefined;\n            }\n        });\n        this.state = derivedOpts({\n            owner: this,\n            equalsFn: (a, b) => {\n                if (!a || !b) {\n                    return a === b;\n                }\n                return ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts)\n                    && a.inlineCompletion === b.inlineCompletion\n                    && a.suggestItem === b.suggestItem;\n            }\n        }, (reader) => {\n            const model = this.textModel;\n            const suggestItem = this.selectedSuggestItem.read(reader);\n            if (suggestItem) {\n                const suggestCompletionEdit = singleTextRemoveCommonPrefix(suggestItem.toSingleTextEdit(), model);\n                const augmentation = this._computeAugmentation(suggestCompletionEdit, reader);\n                const isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);\n                if (!isSuggestionPreviewEnabled && !augmentation) {\n                    return undefined;\n                }\n                const fullEdit = augmentation?.edit ?? suggestCompletionEdit;\n                const fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;\n                const mode = this._suggestPreviewMode.read(reader);\n                const positions = this._positions.read(reader);\n                const edits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];\n                const ghostTexts = edits\n                    .map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], fullEditPreviewLength))\n                    .filter(isDefined);\n                const primaryGhostText = ghostTexts[0] ?? new GhostText(fullEdit.range.endLineNumber, []);\n                return { edits, primaryGhostText, ghostTexts, inlineCompletion: augmentation?.completion, suggestItem };\n            }\n            else {\n                if (!this._isActive.read(reader)) {\n                    return undefined;\n                }\n                const inlineCompletion = this.selectedInlineCompletion.read(reader);\n                if (!inlineCompletion) {\n                    return undefined;\n                }\n                const replacement = inlineCompletion.toSingleTextEdit(reader);\n                const mode = this._inlineSuggestMode.read(reader);\n                const positions = this._positions.read(reader);\n                const edits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];\n                const ghostTexts = edits\n                    .map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], 0))\n                    .filter(isDefined);\n                if (!ghostTexts[0]) {\n                    return undefined;\n                }\n                return { edits, primaryGhostText: ghostTexts[0], ghostTexts, inlineCompletion, suggestItem: undefined };\n            }\n        });\n        this.ghostTexts = derivedOpts({ owner: this, equalsFn: ghostTextsOrReplacementsEqual }, reader => {\n            const v = this.state.read(reader);\n            if (!v) {\n                return undefined;\n            }\n            return v.ghostTexts;\n        });\n        this.primaryGhostText = derivedOpts({ owner: this, equalsFn: ghostTextOrReplacementEquals }, reader => {\n            const v = this.state.read(reader);\n            if (!v) {\n                return undefined;\n            }\n            return v?.primaryGhostText;\n        });\n        this._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletionsPromise));\n        let lastItem = undefined;\n        this._register(autorun(reader => {\n            /** @description call handleItemDidShow */\n            const item = this.state.read(reader);\n            const completion = item?.inlineCompletion;\n            if (completion?.semanticId !== lastItem?.semanticId) {\n                lastItem = completion;\n                if (completion) {\n                    const i = completion.inlineCompletion;\n                    const src = i.source;\n                    src.provider.handleItemDidShow?.(src.inlineCompletions, i.sourceInlineCompletion, i.insertText);\n                }\n            }\n        }));\n    }\n    _getReason(e) {\n        if (e?.isUndoing) {\n            return VersionIdChangeReason.Undo;\n        }\n        if (e?.isRedoing) {\n            return VersionIdChangeReason.Redo;\n        }\n        if (this.isAcceptingPartially) {\n            return VersionIdChangeReason.AcceptWord;\n        }\n        return VersionIdChangeReason.Other;\n    }\n    async trigger(tx) {\n        this._isActive.set(true, tx);\n        await this._fetchInlineCompletionsPromise.get();\n    }\n    async triggerExplicitly(tx) {\n        subtransaction(tx, tx => {\n            this._isActive.set(true, tx);\n            this._forceUpdateExplicitlySignal.trigger(tx);\n        });\n        await this._fetchInlineCompletionsPromise.get();\n    }\n    stop(tx) {\n        subtransaction(tx, tx => {\n            this._isActive.set(false, tx);\n            this._source.clear(tx);\n        });\n    }\n    _computeAugmentation(suggestCompletion, reader) {\n        const model = this.textModel;\n        const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);\n        const candidateInlineCompletions = suggestWidgetInlineCompletions\n            ? suggestWidgetInlineCompletions.inlineCompletions\n            : [this.selectedInlineCompletion.read(reader)].filter(isDefined);\n        const augmentedCompletion = mapFindFirst(candidateInlineCompletions, completion => {\n            let r = completion.toSingleTextEdit(reader);\n            r = singleTextRemoveCommonPrefix(r, model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));\n            return singleTextEditAugments(r, suggestCompletion) ? { completion, edit: r } : undefined;\n        });\n        return augmentedCompletion;\n    }\n    async _deltaSelectedInlineCompletionIndex(delta) {\n        await this.triggerExplicitly();\n        const completions = this._filteredInlineCompletionItems.get() || [];\n        if (completions.length > 0) {\n            const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n            this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n        }\n        else {\n            this._selectedInlineCompletionId.set(undefined, undefined);\n        }\n    }\n    async next() {\n        await this._deltaSelectedInlineCompletionIndex(1);\n    }\n    async previous() {\n        await this._deltaSelectedInlineCompletionIndex(-1);\n    }\n    async accept(editor) {\n        if (editor.getModel() !== this.textModel) {\n            throw new BugIndicatingError();\n        }\n        const state = this.state.get();\n        if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n            return;\n        }\n        const completion = state.inlineCompletion.toInlineCompletion(undefined);\n        if (completion.command) {\n            // Make sure the completion list will not be disposed.\n            completion.source.addRef();\n        }\n        editor.pushUndoStop();\n        if (completion.snippetInfo) {\n            editor.executeEdits('inlineSuggestion.accept', [\n                EditOperation.replace(completion.range, ''),\n                ...completion.additionalTextEdits\n            ]);\n            editor.setPosition(completion.snippetInfo.range.getStartPosition(), 'inlineCompletionAccept');\n            SnippetController2.get(editor)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });\n        }\n        else {\n            const edits = state.edits;\n            const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n            editor.executeEdits('inlineSuggestion.accept', [\n                ...edits.map(edit => EditOperation.replace(edit.range, edit.text)),\n                ...completion.additionalTextEdits\n            ]);\n            editor.setSelections(selections, 'inlineCompletionAccept');\n        }\n        // Reset before invoking the command, as the command might cause a follow up trigger (which we don't want to reset).\n        this.stop();\n        if (completion.command) {\n            await this._commandService\n                .executeCommand(completion.command.id, ...(completion.command.arguments || []))\n                .then(undefined, onUnexpectedExternalError);\n            completion.source.removeRef();\n        }\n    }\n    async acceptNextWord(editor) {\n        await this._acceptNext(editor, (pos, text) => {\n            const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);\n            const config = this._languageConfigurationService.getLanguageConfiguration(langId);\n            const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));\n            const m1 = text.match(wordRegExp);\n            let acceptUntilIndexExclusive = 0;\n            if (m1 && m1.index !== undefined) {\n                if (m1.index === 0) {\n                    acceptUntilIndexExclusive = m1[0].length;\n                }\n                else {\n                    acceptUntilIndexExclusive = m1.index;\n                }\n            }\n            else {\n                acceptUntilIndexExclusive = text.length;\n            }\n            const wsRegExp = /\\s+/g;\n            const m2 = wsRegExp.exec(text);\n            if (m2 && m2.index !== undefined) {\n                if (m2.index + m2[0].length < acceptUntilIndexExclusive) {\n                    acceptUntilIndexExclusive = m2.index + m2[0].length;\n                }\n            }\n            return acceptUntilIndexExclusive;\n        }, 0 /* PartialAcceptTriggerKind.Word */);\n    }\n    async acceptNextLine(editor) {\n        await this._acceptNext(editor, (pos, text) => {\n            const m = text.match(/\\n/);\n            if (m && m.index !== undefined) {\n                return m.index + 1;\n            }\n            return text.length;\n        }, 1 /* PartialAcceptTriggerKind.Line */);\n    }\n    async _acceptNext(editor, getAcceptUntilIndex, kind) {\n        if (editor.getModel() !== this.textModel) {\n            throw new BugIndicatingError();\n        }\n        const state = this.state.get();\n        if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n            return;\n        }\n        const ghostText = state.primaryGhostText;\n        const completion = state.inlineCompletion.toInlineCompletion(undefined);\n        if (completion.snippetInfo || completion.filterText !== completion.insertText) {\n            // not in WYSIWYG mode, partial commit might change completion, thus it is not supported\n            await this.accept(editor);\n            return;\n        }\n        const firstPart = ghostText.parts[0];\n        const ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);\n        const ghostTextVal = firstPart.text;\n        const acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);\n        if (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {\n            this.accept(editor);\n            return;\n        }\n        const partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);\n        const positions = this._positions.get();\n        const cursorPosition = positions[0];\n        // Executing the edit might free the completion, so we have to hold a reference on it.\n        completion.source.addRef();\n        try {\n            this._isAcceptingPartially = true;\n            try {\n                editor.pushUndoStop();\n                const replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);\n                const newText = editor.getModel().getValueInRange(replaceRange) + partialGhostTextVal;\n                const primaryEdit = new SingleTextEdit(replaceRange, newText);\n                const edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)];\n                const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n                editor.executeEdits('inlineSuggestion.accept', edits.map(edit => EditOperation.replace(edit.range, edit.text)));\n                editor.setSelections(selections, 'inlineCompletionPartialAccept');\n                editor.revealPositionInCenterIfOutsideViewport(editor.getPosition(), 1 /* ScrollType.Immediate */);\n            }\n            finally {\n                this._isAcceptingPartially = false;\n            }\n            if (completion.source.provider.handlePartialAccept) {\n                const acceptedRange = Range.fromPositions(completion.range.getStartPosition(), TextLength.ofText(partialGhostTextVal).addToPosition(ghostTextPos));\n                // This assumes that the inline completion and the model use the same EOL style.\n                const text = editor.getModel().getValueInRange(acceptedRange, 1 /* EndOfLinePreference.LF */);\n                completion.source.provider.handlePartialAccept(completion.source.inlineCompletions, completion.sourceInlineCompletion, text.length, { kind, });\n            }\n        }\n        finally {\n            completion.source.removeRef();\n        }\n    }\n    handleSuggestAccepted(item) {\n        const itemEdit = singleTextRemoveCommonPrefix(item.toSingleTextEdit(), this.textModel);\n        const augmentedCompletion = this._computeAugmentation(itemEdit, undefined);\n        if (!augmentedCompletion) {\n            return;\n        }\n        const inlineCompletion = augmentedCompletion.completion.inlineCompletion;\n        inlineCompletion.source.provider.handlePartialAccept?.(inlineCompletion.source.inlineCompletions, inlineCompletion.sourceInlineCompletion, itemEdit.text.length, {\n            kind: 2 /* PartialAcceptTriggerKind.Suggest */,\n        });\n    }\n};\nInlineCompletionsModel = __decorate([\n    __param(9, IInstantiationService),\n    __param(10, ICommandService),\n    __param(11, ILanguageConfigurationService)\n], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport var VersionIdChangeReason;\n(function (VersionIdChangeReason) {\n    VersionIdChangeReason[VersionIdChangeReason[\"Undo\"] = 0] = \"Undo\";\n    VersionIdChangeReason[VersionIdChangeReason[\"Redo\"] = 1] = \"Redo\";\n    VersionIdChangeReason[VersionIdChangeReason[\"AcceptWord\"] = 2] = \"AcceptWord\";\n    VersionIdChangeReason[VersionIdChangeReason[\"Other\"] = 3] = \"Other\";\n})(VersionIdChangeReason || (VersionIdChangeReason = {}));\nexport function getSecondaryEdits(textModel, positions, primaryEdit) {\n    if (positions.length === 1) {\n        // No secondary cursor positions\n        return [];\n    }\n    const primaryPosition = positions[0];\n    const secondaryPositions = positions.slice(1);\n    const primaryEditStartPosition = primaryEdit.range.getStartPosition();\n    const primaryEditEndPosition = primaryEdit.range.getEndPosition();\n    const replacedTextAfterPrimaryCursor = textModel.getValueInRange(Range.fromPositions(primaryPosition, primaryEditEndPosition));\n    const positionWithinTextEdit = subtractPositions(primaryPosition, primaryEditStartPosition);\n    if (positionWithinTextEdit.lineNumber < 1) {\n        onUnexpectedError(new BugIndicatingError(`positionWithinTextEdit line number should be bigger than 0.\n\t\t\tInvalid subtraction between ${primaryPosition.toString()} and ${primaryEditStartPosition.toString()}`));\n        return [];\n    }\n    const secondaryEditText = substringPos(primaryEdit.text, positionWithinTextEdit);\n    return secondaryPositions.map(pos => {\n        const posEnd = addPositions(subtractPositions(pos, primaryEditStartPosition), primaryEditEndPosition);\n        const textAfterSecondaryCursor = textModel.getValueInRange(Range.fromPositions(pos, posEnd));\n        const l = commonPrefixLength(replacedTextAfterPrimaryCursor, textAfterSecondaryCursor);\n        const range = Range.fromPositions(pos, pos.delta(0, l));\n        return new SingleTextEdit(range, secondaryEditText);\n    });\n}\nfunction substringPos(text, pos) {\n    let subtext = '';\n    const lines = splitLinesIncludeSeparators(text);\n    for (let i = pos.lineNumber - 1; i < lines.length; i++) {\n        subtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);\n    }\n    return subtext;\n}\nfunction getEndPositionsAfterApplying(edits) {\n    const sortPerm = Permutation.createSortPermutation(edits, compareBy(e => e.range, Range.compareRangesUsingStarts));\n    const edit = new TextEdit(sortPerm.apply(edits));\n    const sortedNewRanges = edit.getNewRanges();\n    const newRanges = sortPerm.inverse().apply(sortedNewRanges);\n    return newRanges.map(range => range.getEndPosition());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as dom from '../../../../base/browser/dom.js';\nimport { DomScrollableElement } from '../../../../base/browser/ui/scrollbar/scrollableElement.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { MarkdownString } from '../../../../base/common/htmlContent.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { MarkdownRenderer } from '../../../browser/widget/markdownRenderer/browser/markdownRenderer.js';\nimport { ResizableHTMLElement } from '../../../../base/browser/ui/resizable/resizable.js';\nimport * as nls from '../../../../nls.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nexport function canExpandCompletionItem(item) {\n    return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);\n}\nlet SuggestDetailsWidget = class SuggestDetailsWidget {\n    constructor(_editor, instaService) {\n        this._editor = _editor;\n        this._onDidClose = new Emitter();\n        this.onDidClose = this._onDidClose.event;\n        this._onDidChangeContents = new Emitter();\n        this.onDidChangeContents = this._onDidChangeContents.event;\n        this._disposables = new DisposableStore();\n        this._renderDisposeable = new DisposableStore();\n        this._borderWidth = 1;\n        this._size = new dom.Dimension(330, 0);\n        this.domNode = dom.$('.suggest-details');\n        this.domNode.classList.add('no-docs');\n        this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });\n        this._body = dom.$('.body');\n        this._scrollbar = new DomScrollableElement(this._body, {\n            alwaysConsumeMouseWheel: true,\n        });\n        dom.append(this.domNode, this._scrollbar.getDomNode());\n        this._disposables.add(this._scrollbar);\n        this._header = dom.append(this._body, dom.$('.header'));\n        this._close = dom.append(this._header, dom.$('span' + ThemeIcon.asCSSSelector(Codicon.close)));\n        this._close.title = nls.localize('details.close', \"Close\");\n        this._type = dom.append(this._header, dom.$('p.type'));\n        this._docs = dom.append(this._body, dom.$('p.docs'));\n        this._configureFont();\n        this._disposables.add(this._editor.onDidChangeConfiguration(e => {\n            if (e.hasChanged(50 /* EditorOption.fontInfo */)) {\n                this._configureFont();\n            }\n        }));\n    }\n    dispose() {\n        this._disposables.dispose();\n        this._renderDisposeable.dispose();\n    }\n    _configureFont() {\n        const options = this._editor.getOptions();\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const fontFamily = fontInfo.getMassagedFontFamily();\n        const fontSize = options.get(120 /* EditorOption.suggestFontSize */) || fontInfo.fontSize;\n        const lineHeight = options.get(121 /* EditorOption.suggestLineHeight */) || fontInfo.lineHeight;\n        const fontWeight = fontInfo.fontWeight;\n        const fontSizePx = `${fontSize}px`;\n        const lineHeightPx = `${lineHeight}px`;\n        this.domNode.style.fontSize = fontSizePx;\n        this.domNode.style.lineHeight = `${lineHeight / fontSize}`;\n        this.domNode.style.fontWeight = fontWeight;\n        this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;\n        this._type.style.fontFamily = fontFamily;\n        this._close.style.height = lineHeightPx;\n        this._close.style.width = lineHeightPx;\n    }\n    getLayoutInfo() {\n        const lineHeight = this._editor.getOption(121 /* EditorOption.suggestLineHeight */) || this._editor.getOption(50 /* EditorOption.fontInfo */).lineHeight;\n        const borderWidth = this._borderWidth;\n        const borderHeight = borderWidth * 2;\n        return {\n            lineHeight,\n            borderWidth,\n            borderHeight,\n            verticalPadding: 22,\n            horizontalPadding: 14\n        };\n    }\n    renderLoading() {\n        this._type.textContent = nls.localize('loading', \"Loading...\");\n        this._docs.textContent = '';\n        this.domNode.classList.remove('no-docs', 'no-type');\n        this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);\n        this._onDidChangeContents.fire(this);\n    }\n    renderItem(item, explainMode) {\n        this._renderDisposeable.clear();\n        let { detail, documentation } = item.completion;\n        if (explainMode) {\n            let md = '';\n            md += `score: ${item.score[0]}\\n`;\n            md += `prefix: ${item.word ?? '(no prefix)'}\\n`;\n            md += `word: ${item.completion.filterText ? item.completion.filterText + ' (filterText)' : item.textLabel}\\n`;\n            md += `distance: ${item.distance} (localityBonus-setting)\\n`;\n            md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: \"${item.completion.sortText}\"` || 'label'}\\n`;\n            md += `commit_chars: ${item.completion.commitCharacters?.join('')}\\n`;\n            documentation = new MarkdownString().appendCodeblock('empty', md);\n            detail = `Provider: ${item.provider._debugDisplayName}`;\n        }\n        if (!explainMode && !canExpandCompletionItem(item)) {\n            this.clearContents();\n            return;\n        }\n        this.domNode.classList.remove('no-docs', 'no-type');\n        // --- details\n        if (detail) {\n            const cappedDetail = detail.length > 100000 ? `${detail.substr(0, 100000)}` : detail;\n            this._type.textContent = cappedDetail;\n            this._type.title = cappedDetail;\n            dom.show(this._type);\n            this._type.classList.toggle('auto-wrap', !/\\r?\\n^\\s+/gmi.test(cappedDetail));\n        }\n        else {\n            dom.clearNode(this._type);\n            this._type.title = '';\n            dom.hide(this._type);\n            this.domNode.classList.add('no-type');\n        }\n        // --- documentation\n        dom.clearNode(this._docs);\n        if (typeof documentation === 'string') {\n            this._docs.classList.remove('markdown-docs');\n            this._docs.textContent = documentation;\n        }\n        else if (documentation) {\n            this._docs.classList.add('markdown-docs');\n            dom.clearNode(this._docs);\n            const renderedContents = this._markdownRenderer.render(documentation);\n            this._docs.appendChild(renderedContents.element);\n            this._renderDisposeable.add(renderedContents);\n            this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {\n                this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\n                this._onDidChangeContents.fire(this);\n            }));\n        }\n        this.domNode.style.userSelect = 'text';\n        this.domNode.tabIndex = -1;\n        this._close.onmousedown = e => {\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        this._close.onclick = e => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._onDidClose.fire();\n        };\n        this._body.scrollTop = 0;\n        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\n        this._onDidChangeContents.fire(this);\n    }\n    clearContents() {\n        this.domNode.classList.add('no-docs');\n        this._type.textContent = '';\n        this._docs.textContent = '';\n    }\n    get isEmpty() {\n        return this.domNode.classList.contains('no-docs');\n    }\n    get size() {\n        return this._size;\n    }\n    layout(width, height) {\n        const newSize = new dom.Dimension(width, height);\n        if (!dom.Dimension.equals(newSize, this._size)) {\n            this._size = newSize;\n            dom.size(this.domNode, width, height);\n        }\n        this._scrollbar.scanDomNode();\n    }\n    scrollDown(much = 8) {\n        this._body.scrollTop += much;\n    }\n    scrollUp(much = 8) {\n        this._body.scrollTop -= much;\n    }\n    scrollTop() {\n        this._body.scrollTop = 0;\n    }\n    scrollBottom() {\n        this._body.scrollTop = this._body.scrollHeight;\n    }\n    pageDown() {\n        this.scrollDown(80);\n    }\n    pageUp() {\n        this.scrollUp(80);\n    }\n    set borderWidth(width) {\n        this._borderWidth = width;\n    }\n    get borderWidth() {\n        return this._borderWidth;\n    }\n};\nSuggestDetailsWidget = __decorate([\n    __param(1, IInstantiationService)\n], SuggestDetailsWidget);\nexport { SuggestDetailsWidget };\nexport class SuggestDetailsOverlay {\n    constructor(widget, _editor) {\n        this.widget = widget;\n        this._editor = _editor;\n        this.allowEditorOverflow = true;\n        this._disposables = new DisposableStore();\n        this._added = false;\n        this._preferAlignAtTop = true;\n        this._resizable = new ResizableHTMLElement();\n        this._resizable.domNode.classList.add('suggest-details-container');\n        this._resizable.domNode.appendChild(widget.domNode);\n        this._resizable.enableSashes(false, true, true, false);\n        let topLeftNow;\n        let sizeNow;\n        let deltaTop = 0;\n        let deltaLeft = 0;\n        this._disposables.add(this._resizable.onDidWillResize(() => {\n            topLeftNow = this._topLeft;\n            sizeNow = this._resizable.size;\n        }));\n        this._disposables.add(this._resizable.onDidResize(e => {\n            if (topLeftNow && sizeNow) {\n                this.widget.layout(e.dimension.width, e.dimension.height);\n                let updateTopLeft = false;\n                if (e.west) {\n                    deltaLeft = sizeNow.width - e.dimension.width;\n                    updateTopLeft = true;\n                }\n                if (e.north) {\n                    deltaTop = sizeNow.height - e.dimension.height;\n                    updateTopLeft = true;\n                }\n                if (updateTopLeft) {\n                    this._applyTopLeft({\n                        top: topLeftNow.top + deltaTop,\n                        left: topLeftNow.left + deltaLeft,\n                    });\n                }\n            }\n            if (e.done) {\n                topLeftNow = undefined;\n                sizeNow = undefined;\n                deltaTop = 0;\n                deltaLeft = 0;\n                this._userSize = e.dimension;\n            }\n        }));\n        this._disposables.add(this.widget.onDidChangeContents(() => {\n            if (this._anchorBox) {\n                this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, this._preferAlignAtTop);\n            }\n        }));\n    }\n    dispose() {\n        this._resizable.dispose();\n        this._disposables.dispose();\n        this.hide();\n    }\n    getId() {\n        return 'suggest.details';\n    }\n    getDomNode() {\n        return this._resizable.domNode;\n    }\n    getPosition() {\n        return this._topLeft ? { preference: this._topLeft } : null;\n    }\n    show() {\n        if (!this._added) {\n            this._editor.addOverlayWidget(this);\n            this._added = true;\n        }\n    }\n    hide(sessionEnded = false) {\n        this._resizable.clearSashHoverState();\n        if (this._added) {\n            this._editor.removeOverlayWidget(this);\n            this._added = false;\n            this._anchorBox = undefined;\n            this._topLeft = undefined;\n        }\n        if (sessionEnded) {\n            this._userSize = undefined;\n            this.widget.clearContents();\n        }\n    }\n    placeAtAnchor(anchor, preferAlignAtTop) {\n        const anchorBox = anchor.getBoundingClientRect();\n        this._anchorBox = anchorBox;\n        this._preferAlignAtTop = preferAlignAtTop;\n        this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, preferAlignAtTop);\n    }\n    _placeAtAnchor(anchorBox, size, preferAlignAtTop) {\n        const bodyBox = dom.getClientArea(this.getDomNode().ownerDocument.body);\n        const info = this.widget.getLayoutInfo();\n        const defaultMinSize = new dom.Dimension(220, 2 * info.lineHeight);\n        const defaultTop = anchorBox.top;\n        // EAST\n        const eastPlacement = (function () {\n            const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);\n            const left = -info.borderWidth + anchorBox.left + anchorBox.width;\n            const maxSizeTop = new dom.Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);\n            const maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);\n            return { top: defaultTop, left, fit: width - size.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };\n        })();\n        // WEST\n        const westPlacement = (function () {\n            const width = anchorBox.left - info.borderWidth - info.horizontalPadding;\n            const left = Math.max(info.horizontalPadding, anchorBox.left - size.width - info.borderWidth);\n            const maxSizeTop = new dom.Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);\n            const maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);\n            return { top: defaultTop, left, fit: width - size.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };\n        })();\n        // SOUTH\n        const southPacement = (function () {\n            const left = anchorBox.left;\n            const top = -info.borderWidth + anchorBox.top + anchorBox.height;\n            const maxSizeBottom = new dom.Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);\n            return { top, left, fit: maxSizeBottom.height - size.height, maxSizeBottom, maxSizeTop: maxSizeBottom, minSize: defaultMinSize.with(maxSizeBottom.width) };\n        })();\n        // take first placement that fits or the first with \"least bad\" fit\n        const placements = [eastPlacement, westPlacement, southPacement];\n        const placement = placements.find(p => p.fit >= 0) ?? placements.sort((a, b) => b.fit - a.fit)[0];\n        // top/bottom placement\n        const bottom = anchorBox.top + anchorBox.height - info.borderHeight;\n        let alignAtTop;\n        let height = size.height;\n        const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);\n        if (height > maxHeight) {\n            height = maxHeight;\n        }\n        let maxSize;\n        if (preferAlignAtTop) {\n            if (height <= placement.maxSizeTop.height) {\n                alignAtTop = true;\n                maxSize = placement.maxSizeTop;\n            }\n            else {\n                alignAtTop = false;\n                maxSize = placement.maxSizeBottom;\n            }\n        }\n        else {\n            if (height <= placement.maxSizeBottom.height) {\n                alignAtTop = false;\n                maxSize = placement.maxSizeBottom;\n            }\n            else {\n                alignAtTop = true;\n                maxSize = placement.maxSizeTop;\n            }\n        }\n        let { top, left } = placement;\n        if (!alignAtTop && height > anchorBox.height) {\n            top = bottom - height;\n        }\n        const editorDomNode = this._editor.getDomNode();\n        if (editorDomNode) {\n            // get bounding rectangle of the suggest widget relative to the editor\n            const editorBoundingBox = editorDomNode.getBoundingClientRect();\n            top -= editorBoundingBox.top;\n            left -= editorBoundingBox.left;\n        }\n        this._applyTopLeft({ left, top });\n        this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);\n        this._resizable.minSize = placement.minSize;\n        this._resizable.maxSize = maxSize;\n        this._resizable.layout(height, Math.min(maxSize.width, size.width));\n        this.widget.layout(this._resizable.size.width, this._resizable.size.height);\n    }\n    _applyTopLeft(topLeft) {\n        this._topLeft = topLeft;\n        this._editor.layoutOverlayWidget(this);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar InlineCompletionsController_1;\nimport { createStyleSheetFromObservable } from '../../../../../base/browser/domObservable.js';\nimport { alert } from '../../../../../base/browser/ui/aria/aria.js';\nimport { timeout } from '../../../../../base/common/async.js';\nimport { cancelOnDispose } from '../../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { autorun, constObservable, derived, observableFromEvent, observableSignal, observableValue, transaction, waitForState } from '../../../../../base/common/observable.js';\nimport { derivedDisposable } from '../../../../../base/common/observableInternal/derived.js';\nimport { derivedObservableWithCache, mapObservableArrayCached } from '../../../../../base/common/observableInternal/utils.js';\nimport { isUndefined } from '../../../../../base/common/types.js';\nimport { CoreEditingCommands } from '../../../../browser/coreCommands.js';\nimport { observableCodeEditor, reactToChange, reactToChangeWithStore } from '../../../../browser/observableCodeEditor.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { ILanguageFeatureDebounceService } from '../../../../common/services/languageFeatureDebounce.js';\nimport { ILanguageFeaturesService } from '../../../../common/services/languageFeatures.js';\nimport { inlineSuggestCommitId } from './commandIds.js';\nimport { GhostTextView } from '../view/ghostTextView.js';\nimport { InlineCompletionContextKeys } from './inlineCompletionContextKeys.js';\nimport { InlineCompletionsHintsWidget, InlineSuggestionHintsContentWidget } from '../hintsWidget/inlineCompletionsHintsWidget.js';\nimport { InlineCompletionsModel } from '../model/inlineCompletionsModel.js';\nimport { SuggestWidgetAdaptor } from '../model/suggestWidgetAdaptor.js';\nimport { localize } from '../../../../../nls.js';\nimport { IAccessibilityService } from '../../../../../platform/accessibility/common/accessibility.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';\nimport { IContextKeyService } from '../../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../../platform/keybinding/common/keybinding.js';\nlet InlineCompletionsController = class InlineCompletionsController extends Disposable {\n    static { InlineCompletionsController_1 = this; }\n    static { this.ID = 'editor.contrib.inlineCompletionsController'; }\n    static get(editor) {\n        return editor.getContribution(InlineCompletionsController_1.ID);\n    }\n    constructor(editor, _instantiationService, _contextKeyService, _configurationService, _commandService, _debounceService, _languageFeaturesService, _accessibilitySignalService, _keybindingService, _accessibilityService) {\n        super();\n        this.editor = editor;\n        this._instantiationService = _instantiationService;\n        this._contextKeyService = _contextKeyService;\n        this._configurationService = _configurationService;\n        this._commandService = _commandService;\n        this._debounceService = _debounceService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._accessibilitySignalService = _accessibilitySignalService;\n        this._keybindingService = _keybindingService;\n        this._accessibilityService = _accessibilityService;\n        this._editorObs = observableCodeEditor(this.editor);\n        this._positions = derived(this, reader => this._editorObs.selections.read(reader)?.map(s => s.getEndPosition()) ?? [new Position(1, 1)]);\n        this._suggestWidgetAdaptor = this._register(new SuggestWidgetAdaptor(this.editor, () => {\n            this._editorObs.forceUpdate();\n            return this.model.get()?.selectedInlineCompletion.get()?.toSingleTextEdit(undefined);\n        }, (item) => this._editorObs.forceUpdate(_tx => {\n            /** @description InlineCompletionsController.handleSuggestAccepted */\n            this.model.get()?.handleSuggestAccepted(item);\n        })));\n        this._suggestWidgetSelectedItem = observableFromEvent(this, cb => this._suggestWidgetAdaptor.onDidSelectedItemChange(() => {\n            this._editorObs.forceUpdate(_tx => cb(undefined));\n        }), () => this._suggestWidgetAdaptor.selectedItem);\n        this._enabledInConfig = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(62 /* EditorOption.inlineSuggest */).enabled);\n        this._isScreenReaderEnabled = observableFromEvent(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized());\n        this._editorDictationInProgress = observableFromEvent(this, this._contextKeyService.onDidChangeContext, () => this._contextKeyService.getContext(this.editor.getDomNode()).getValue('editorDictation.inProgress') === true);\n        this._enabled = derived(this, reader => this._enabledInConfig.read(reader) && (!this._isScreenReaderEnabled.read(reader) || !this._editorDictationInProgress.read(reader)));\n        this._debounceValue = this._debounceService.for(this._languageFeaturesService.inlineCompletionsProvider, 'InlineCompletionsDebounce', { min: 50, max: 50 });\n        this.model = derivedDisposable(this, reader => {\n            if (this._editorObs.isReadonly.read(reader)) {\n                return undefined;\n            }\n            const textModel = this._editorObs.model.read(reader);\n            if (!textModel) {\n                return undefined;\n            }\n            const model = this._instantiationService.createInstance(InlineCompletionsModel, textModel, this._suggestWidgetSelectedItem, this._editorObs.versionId, this._positions, this._debounceValue, observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(119 /* EditorOption.suggest */).preview), observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(119 /* EditorOption.suggest */).previewMode), observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(62 /* EditorOption.inlineSuggest */).mode), this._enabled);\n            return model;\n        }).recomputeInitiallyAndOnChange(this._store);\n        this._ghostTexts = derived(this, (reader) => {\n            const model = this.model.read(reader);\n            return model?.ghostTexts.read(reader) ?? [];\n        });\n        this._stablizedGhostTexts = convertItemsToStableObservables(this._ghostTexts, this._store);\n        this._ghostTextWidgets = mapObservableArrayCached(this, this._stablizedGhostTexts, (ghostText, store) => store.add(this._instantiationService.createInstance(GhostTextView, this.editor, {\n            ghostText: ghostText,\n            minReservedLineCount: constObservable(0),\n            targetTextModel: this.model.map(v => v?.textModel),\n        }))).recomputeInitiallyAndOnChange(this._store);\n        this._playAccessibilitySignal = observableSignal(this);\n        this._fontFamily = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(62 /* EditorOption.inlineSuggest */).fontFamily);\n        this._register(new InlineCompletionContextKeys(this._contextKeyService, this.model));\n        this._register(reactToChange(this._editorObs.onDidType, (_value, _changes) => {\n            if (this._enabled.get()) {\n                this.model.get()?.trigger();\n            }\n        }));\n        this._register(this._commandService.onDidExecuteCommand((e) => {\n            // These commands don't trigger onDidType.\n            const commands = new Set([\n                CoreEditingCommands.Tab.id,\n                CoreEditingCommands.DeleteLeft.id,\n                CoreEditingCommands.DeleteRight.id,\n                inlineSuggestCommitId,\n                'acceptSelectedSuggestion',\n            ]);\n            if (commands.has(e.commandId) && editor.hasTextFocus() && this._enabled.get()) {\n                this._editorObs.forceUpdate(tx => {\n                    /** @description onDidExecuteCommand */\n                    this.model.get()?.trigger(tx);\n                });\n            }\n        }));\n        this._register(reactToChange(this._editorObs.selections, (_value, changes) => {\n            if (changes.some(e => e.reason === 3 /* CursorChangeReason.Explicit */ || e.source === 'api')) {\n                this.model.get()?.stop();\n            }\n        }));\n        this._register(this.editor.onDidBlurEditorWidget(() => {\n            // This is a hidden setting very useful for debugging\n            if (this._contextKeyService.getContextKeyValue('accessibleViewIsShown')\n                || this._configurationService.getValue('editor.inlineSuggest.keepOnBlur')\n                || editor.getOption(62 /* EditorOption.inlineSuggest */).keepOnBlur\n                || InlineSuggestionHintsContentWidget.dropDownVisible) {\n                return;\n            }\n            transaction(tx => {\n                /** @description InlineCompletionsController.onDidBlurEditorWidget */\n                this.model.get()?.stop(tx);\n            });\n        }));\n        this._register(autorun(reader => {\n            /** @description InlineCompletionsController.forceRenderingAbove */\n            const state = this.model.read(reader)?.state.read(reader);\n            if (state?.suggestItem) {\n                if (state.primaryGhostText.lineCount >= 2) {\n                    this._suggestWidgetAdaptor.forceRenderingAbove();\n                }\n            }\n            else {\n                this._suggestWidgetAdaptor.stopForceRenderingAbove();\n            }\n        }));\n        this._register(toDisposable(() => {\n            this._suggestWidgetAdaptor.stopForceRenderingAbove();\n        }));\n        const currentInlineCompletionBySemanticId = derivedObservableWithCache(this, (reader, last) => {\n            const model = this.model.read(reader);\n            const state = model?.state.read(reader);\n            if (this._suggestWidgetSelectedItem.get()) {\n                return last;\n            }\n            return state?.inlineCompletion?.semanticId;\n        });\n        this._register(reactToChangeWithStore(derived(reader => {\n            this._playAccessibilitySignal.read(reader);\n            currentInlineCompletionBySemanticId.read(reader);\n            return {};\n        }), async (_value, _deltas, store) => {\n            /** @description InlineCompletionsController.playAccessibilitySignalAndReadSuggestion */\n            const model = this.model.get();\n            const state = model?.state.get();\n            if (!state || !model) {\n                return;\n            }\n            const lineText = model.textModel.getLineContent(state.primaryGhostText.lineNumber);\n            await timeout(50, cancelOnDispose(store));\n            await waitForState(this._suggestWidgetSelectedItem, isUndefined, () => false, cancelOnDispose(store));\n            await this._accessibilitySignalService.playSignal(AccessibilitySignal.inlineSuggestion);\n            if (this.editor.getOption(8 /* EditorOption.screenReaderAnnounceInlineSuggestion */)) {\n                this._provideScreenReaderUpdate(state.primaryGhostText.renderForScreenReader(lineText));\n            }\n        }));\n        this._register(new InlineCompletionsHintsWidget(this.editor, this.model, this._instantiationService));\n        this._register(createStyleSheetFromObservable(derived(reader => {\n            const fontFamily = this._fontFamily.read(reader);\n            if (fontFamily === '' || fontFamily === 'default') {\n                return '';\n            }\n            return `\n.monaco-editor .ghost-text-decoration,\n.monaco-editor .ghost-text-decoration-preview,\n.monaco-editor .ghost-text {\n\tfont-family: ${fontFamily};\n}`;\n        })));\n        // TODO@hediet\n        this._register(this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('accessibility.verbosity.inlineCompletions')) {\n                this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue('accessibility.verbosity.inlineCompletions') });\n            }\n        }));\n        this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue('accessibility.verbosity.inlineCompletions') });\n    }\n    playAccessibilitySignal(tx) {\n        this._playAccessibilitySignal.trigger(tx);\n    }\n    _provideScreenReaderUpdate(content) {\n        const accessibleViewShowing = this._contextKeyService.getContextKeyValue('accessibleViewIsShown');\n        const accessibleViewKeybinding = this._keybindingService.lookupKeybinding('editor.action.accessibleView');\n        let hint;\n        if (!accessibleViewShowing && accessibleViewKeybinding && this.editor.getOption(150 /* EditorOption.inlineCompletionsAccessibilityVerbose */)) {\n            hint = localize('showAccessibleViewHint', \"Inspect this in the accessible view ({0})\", accessibleViewKeybinding.getAriaLabel());\n        }\n        alert(hint ? content + ', ' + hint : content);\n    }\n    shouldShowHoverAt(range) {\n        const ghostText = this.model.get()?.primaryGhostText.get();\n        if (ghostText) {\n            return ghostText.parts.some(p => range.containsPosition(new Position(ghostText.lineNumber, p.column)));\n        }\n        return false;\n    }\n    shouldShowHoverAtViewZone(viewZoneId) {\n        return this._ghostTextWidgets.get()[0]?.ownsViewZone(viewZoneId) ?? false;\n    }\n};\nInlineCompletionsController = InlineCompletionsController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IContextKeyService),\n    __param(3, IConfigurationService),\n    __param(4, ICommandService),\n    __param(5, ILanguageFeatureDebounceService),\n    __param(6, ILanguageFeaturesService),\n    __param(7, IAccessibilitySignalService),\n    __param(8, IKeybindingService),\n    __param(9, IAccessibilityService)\n], InlineCompletionsController);\nexport { InlineCompletionsController };\nfunction convertItemsToStableObservables(items, store) {\n    const result = observableValue('result', []);\n    const innerObservables = [];\n    store.add(autorun(reader => {\n        const itemsValue = items.read(reader);\n        transaction(tx => {\n            if (itemsValue.length !== innerObservables.length) {\n                innerObservables.length = itemsValue.length;\n                for (let i = 0; i < innerObservables.length; i++) {\n                    if (!innerObservables[i]) {\n                        innerObservables[i] = observableValue('item', itemsValue[i]);\n                    }\n                }\n                result.set([...innerObservables], tx);\n            }\n            innerObservables.forEach((o, i) => o.set(itemsValue[i], tx));\n        });\n    }));\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nexport class CopyLinesCommand {\n    constructor(selection, isCopyingDown, noop) {\n        this._selection = selection;\n        this._isCopyingDown = isCopyingDown;\n        this._noop = noop || false;\n        this._selectionDirection = 0 /* SelectionDirection.LTR */;\n        this._selectionId = null;\n        this._startLineNumberDelta = 0;\n        this._endLineNumberDelta = 0;\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._startLineNumberDelta = 0;\n        this._endLineNumberDelta = 0;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._endLineNumberDelta = 1;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const sourceLines = [];\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            sourceLines.push(model.getLineContent(i));\n        }\n        const sourceText = sourceLines.join('\\n');\n        if (sourceText === '') {\n            // Duplicating empty line\n            if (this._isCopyingDown) {\n                this._startLineNumberDelta++;\n                this._endLineNumberDelta++;\n            }\n        }\n        if (this._noop) {\n            builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? '' : '\\n');\n        }\n        else {\n            if (!this._isCopyingDown) {\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + sourceText);\n            }\n            else {\n                builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + '\\n');\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        this._selectionDirection = this._selection.getDirection();\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {\n            let startLineNumber = result.startLineNumber;\n            let startColumn = result.startColumn;\n            let endLineNumber = result.endLineNumber;\n            let endColumn = result.endColumn;\n            if (this._startLineNumberDelta !== 0) {\n                startLineNumber = startLineNumber + this._startLineNumberDelta;\n                startColumn = 1;\n            }\n            if (this._endLineNumberDelta !== 0) {\n                endLineNumber = endLineNumber + this._endLineNumberDelta;\n                endColumn = 1;\n            }\n            result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/common/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        const getLanguageId = () => {\n            return model.getLanguageId();\n        };\n        const getLanguageIdAtPosition = (lineNumber, column) => {\n            return model.getLanguageIdAtPosition(lineNumber, column);\n        };\n        const modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            const lineNumber = s.startLineNumber;\n            const otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimStart(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        const virtualModel = {\n                            tokenization: {\n                                getLineTokens: (lineNumber) => {\n                                    if (lineNumber === s.startLineNumber) {\n                                        return model.tokenization.getLineTokens(movingLineNumber);\n                                    }\n                                    else {\n                                        return model.tokenization.getLineTokens(lineNumber);\n                                    }\n                                },\n                                getLanguageId,\n                                getLanguageIdAtPosition,\n                            },\n                            getLineContent: (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return model.getLineContent(movingLineNumber);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            },\n                        };\n                        const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfMovingLine !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimStart(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        const virtualModel = {\n                            tokenization: {\n                                getLineTokens: (lineNumber) => {\n                                    if (lineNumber === s.startLineNumber) {\n                                        // TODO@aiday-mar: the tokens here don't correspond exactly to the corresponding content (after indentation adjustment), have to fix this.\n                                        return model.tokenization.getLineTokens(movingLineNumber);\n                                    }\n                                    else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                        return model.tokenization.getLineTokens(lineNumber - 1);\n                                    }\n                                    else {\n                                        return model.tokenization.getLineTokens(lineNumber);\n                                    }\n                                },\n                                getLanguageId,\n                                getLanguageIdAtPosition,\n                            },\n                            getLineContent: (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return insertingText;\n                                }\n                                else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                    return model.getLineContent(lineNumber - 1);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            },\n                        };\n                        const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    const virtualModel = {\n                        tokenization: {\n                            getLineTokens: (lineNumber) => {\n                                if (lineNumber === movingLineNumber) {\n                                    return model.tokenization.getLineTokens(s.startLineNumber);\n                                }\n                                else {\n                                    return model.tokenization.getLineTokens(lineNumber);\n                                }\n                            },\n                            getLanguageId,\n                            getLanguageIdAtPosition,\n                        },\n                        getLineContent: (lineNumber) => {\n                            if (lineNumber === movingLineNumber) {\n                                return model.getLineContent(s.startLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        },\n                    };\n                    const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            const movingLineText = model.getLineContent(line);\n            if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                const lineContent = model.getLineContent(validPrecedingLine);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimStart(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            const lineContent = model.getLineContent(i);\n            const originalIndent = strings.getLeadingWhitespace(lineContent);\n            const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            const newSpacesCnt = originalSpacesCnt + offset;\n            const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n};\nMoveLinesCommand = __decorate([\n    __param(3, ILanguageConfigurationService)\n], MoveLinesCommand);\nexport { MoveLinesCommand };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nexport class SortLinesCommand {\n    static { this._COLLATOR = null; }\n    static getCollator() {\n        if (!SortLinesCommand._COLLATOR) {\n            SortLinesCommand._COLLATOR = new Intl.Collator();\n        }\n        return SortLinesCommand._COLLATOR;\n    }\n    constructor(selection, descending) {\n        this.selection = selection;\n        this.descending = descending;\n        this.selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        const op = sortLines(model, this.selection, this.descending);\n        if (op) {\n            builder.addEditOperation(op.range, op.text);\n        }\n        this.selectionId = builder.trackSelection(this.selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this.selectionId);\n    }\n    static canRun(model, selection, descending) {\n        if (model === null) {\n            return false;\n        }\n        const data = getSortData(model, selection, descending);\n        if (!data) {\n            return false;\n        }\n        for (let i = 0, len = data.before.length; i < len; i++) {\n            if (data.before[i] !== data.after[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nfunction getSortData(model, selection, descending) {\n    const startLineNumber = selection.startLineNumber;\n    let endLineNumber = selection.endLineNumber;\n    if (selection.endColumn === 1) {\n        endLineNumber--;\n    }\n    // Nothing to sort if user didn't select anything.\n    if (startLineNumber >= endLineNumber) {\n        return null;\n    }\n    const linesToSort = [];\n    // Get the contents of the selection to be sorted.\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        linesToSort.push(model.getLineContent(lineNumber));\n    }\n    let sorted = linesToSort.slice(0);\n    sorted.sort(SortLinesCommand.getCollator().compare);\n    // If descending, reverse the order.\n    if (descending === true) {\n        sorted = sorted.reverse();\n    }\n    return {\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        before: linesToSort,\n        after: sorted\n    };\n}\n/**\n * Generate commands for sorting lines on a model.\n */\nfunction sortLines(model, selection, descending) {\n    const data = getSortData(model, selection, descending);\n    if (!data) {\n        return null;\n    }\n    return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join('\\n'));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { CoreEditingCommands } from '../../../browser/coreCommands.js';\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection, ReplaceCommandThatSelectsText } from '../../../common/commands/replaceCommand.js';\nimport { TrimTrailingWhitespaceCommand } from '../../../common/commands/trimTrailingWhitespaceCommand.js';\nimport { TypeOperations } from '../../../common/cursor/cursorTypeOperations.js';\nimport { EnterOperation } from '../../../common/cursor/cursorTypeEditOperations.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { CopyLinesCommand } from './copyLinesCommand.js';\nimport { MoveLinesCommand } from './moveLinesCommand.js';\nimport { SortLinesCommand } from './sortLinesCommand.js';\nimport * as nls from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\n// copy lines\nclass AbstractCopyLinesAction extends EditorAction {\n    constructor(down, opts) {\n        super(opts);\n        this.down = down;\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections().map((selection, index) => ({ selection, index, ignore: false }));\n        selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        // Remove selections that would result in copying the same line\n        let prev = selections[0];\n        for (let i = 1; i < selections.length; i++) {\n            const curr = selections[i];\n            if (prev.selection.endLineNumber === curr.selection.startLineNumber) {\n                // these two selections would copy the same line\n                if (prev.index < curr.index) {\n                    // prev wins\n                    curr.ignore = true;\n                }\n                else {\n                    // curr wins\n                    prev.ignore = true;\n                    prev = curr;\n                }\n            }\n        }\n        const commands = [];\n        for (const selection of selections) {\n            commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nclass CopyLinesUpAction extends AbstractCopyLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.copyLinesUpAction',\n            label: nls.localize('lines.copyUp', \"Copy Line Up\"),\n            alias: 'Copy Line Up',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */,\n                linux: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, \"&&Copy Line Up\"),\n                order: 1\n            }\n        });\n    }\n}\nclass CopyLinesDownAction extends AbstractCopyLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.copyLinesDownAction',\n            label: nls.localize('lines.copyDown', \"Copy Line Down\"),\n            alias: 'Copy Line Down',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */,\n                linux: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, \"Co&&py Line Down\"),\n                order: 2\n            }\n        });\n    }\n}\nexport class DuplicateSelectionAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.duplicateSelection',\n            label: nls.localize('duplicateSelection', \"Duplicate Selection\"),\n            alias: 'Duplicate Selection',\n            precondition: EditorContextKeys.writable,\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miDuplicateSelection', comment: ['&& denotes a mnemonic'] }, \"&&Duplicate Selection\"),\n                order: 5\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const commands = [];\n        const selections = editor.getSelections();\n        const model = editor.getModel();\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                commands.push(new CopyLinesCommand(selection, true));\n            }\n            else {\n                const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);\n                commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\n// move lines\nclass AbstractMoveLinesAction extends EditorAction {\n    constructor(down, opts) {\n        super(opts);\n        this.down = down;\n    }\n    run(accessor, editor) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const commands = [];\n        const selections = editor.getSelections() || [];\n        const autoIndent = editor.getOption(12 /* EditorOption.autoIndent */);\n        for (const selection of selections) {\n            commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nclass MoveLinesUpAction extends AbstractMoveLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.moveLinesUpAction',\n            label: nls.localize('lines.moveUp', \"Move Line Up\"),\n            alias: 'Move Line Up',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                linux: { primary: 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, \"Mo&&ve Line Up\"),\n                order: 3\n            }\n        });\n    }\n}\nclass MoveLinesDownAction extends AbstractMoveLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.moveLinesDownAction',\n            label: nls.localize('lines.moveDown', \"Move Line Down\"),\n            alias: 'Move Line Down',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                linux: { primary: 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '2_line',\n                title: nls.localize({ key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, \"Move &&Line Down\"),\n                order: 4\n            }\n        });\n    }\n}\nexport class AbstractSortLinesAction extends EditorAction {\n    constructor(descending, opts) {\n        super(opts);\n        this.descending = descending;\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const model = editor.getModel();\n        let selections = editor.getSelections();\n        if (selections.length === 1 && selections[0].isEmpty()) {\n            // Apply to whole document.\n            selections = [new Selection(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))];\n        }\n        for (const selection of selections) {\n            if (!SortLinesCommand.canRun(editor.getModel(), selection, this.descending)) {\n                return;\n            }\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new SortLinesCommand(selections[i], this.descending);\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nexport class SortLinesAscendingAction extends AbstractSortLinesAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.sortLinesAscending',\n            label: nls.localize('lines.sortAscending', \"Sort Lines Ascending\"),\n            alias: 'Sort Lines Ascending',\n            precondition: EditorContextKeys.writable\n        });\n    }\n}\nexport class SortLinesDescendingAction extends AbstractSortLinesAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.sortLinesDescending',\n            label: nls.localize('lines.sortDescending', \"Sort Lines Descending\"),\n            alias: 'Sort Lines Descending',\n            precondition: EditorContextKeys.writable\n        });\n    }\n}\nexport class DeleteDuplicateLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.removeDuplicateLines',\n            label: nls.localize('lines.deleteDuplicates', \"Delete Duplicate Lines\"),\n            alias: 'Delete Duplicate Lines',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            return;\n        }\n        const edits = [];\n        const endCursorState = [];\n        let linesDeleted = 0;\n        let updateSelection = true;\n        let selections = editor.getSelections();\n        if (selections.length === 1 && selections[0].isEmpty()) {\n            // Apply to whole document.\n            selections = [new Selection(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))];\n            updateSelection = false;\n        }\n        for (const selection of selections) {\n            const uniqueLines = new Set();\n            const lines = [];\n            for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {\n                const line = model.getLineContent(i);\n                if (uniqueLines.has(line)) {\n                    continue;\n                }\n                lines.push(line);\n                uniqueLines.add(line);\n            }\n            const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));\n            const adjustedSelectionStart = selection.startLineNumber - linesDeleted;\n            const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);\n            edits.push(EditOperation.replace(selectionToReplace, lines.join('\\n')));\n            endCursorState.push(finalSelection);\n            linesDeleted += (selection.endLineNumber - selection.startLineNumber + 1) - lines.length;\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, updateSelection ? endCursorState : undefined);\n        editor.pushUndoStop();\n    }\n}\nexport class TrimTrailingWhitespaceAction extends EditorAction {\n    static { this.ID = 'editor.action.trimTrailingWhitespace'; }\n    constructor() {\n        super({\n            id: TrimTrailingWhitespaceAction.ID,\n            label: nls.localize('lines.trimTrailingWhitespace', \"Trim Trailing Whitespace\"),\n            alias: 'Trim Trailing Whitespace',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 54 /* KeyCode.KeyX */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor, args) {\n        let cursors = [];\n        if (args.reason === 'auto-save') {\n            // See https://github.com/editorconfig/editorconfig-vscode/issues/47\n            // It is very convenient for the editor config extension to invoke this action.\n            // So, if we get a reason:'auto-save' passed in, let's preserve cursor positions.\n            cursors = (editor.getSelections() || []).map(s => new Position(s.positionLineNumber, s.positionColumn));\n        }\n        const selection = editor.getSelection();\n        if (selection === null) {\n            return;\n        }\n        const config = _accessor.get(IConfigurationService);\n        const model = editor.getModel();\n        const trimInRegexAndStrings = config.getValue('files.trimTrailingWhitespaceInRegexAndStrings', { overrideIdentifier: model?.getLanguageId(), resource: model?.uri });\n        const command = new TrimTrailingWhitespaceCommand(selection, cursors, trimInRegexAndStrings);\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, [command]);\n        editor.pushUndoStop();\n    }\n}\nexport class DeleteLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.deleteLines',\n            label: nls.localize('lines.delete', \"Delete Line\"),\n            alias: 'Delete Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 41 /* KeyCode.KeyK */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const ops = this._getLinesToRemove(editor);\n        const model = editor.getModel();\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            // Model is empty\n            return;\n        }\n        let linesDeleted = 0;\n        const edits = [];\n        const cursorState = [];\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            let startLineNumber = op.startLineNumber;\n            let endLineNumber = op.endLineNumber;\n            let startColumn = 1;\n            let endColumn = model.getLineMaxColumn(endLineNumber);\n            if (endLineNumber < model.getLineCount()) {\n                endLineNumber += 1;\n                endColumn = 1;\n            }\n            else if (startLineNumber > 1) {\n                startLineNumber -= 1;\n                startColumn = model.getLineMaxColumn(startLineNumber);\n            }\n            edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ''));\n            cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));\n            linesDeleted += (op.endLineNumber - op.startLineNumber + 1);\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, cursorState);\n        editor.pushUndoStop();\n    }\n    _getLinesToRemove(editor) {\n        // Construct delete operations\n        const operations = editor.getSelections().map((s) => {\n            let endLineNumber = s.endLineNumber;\n            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n                endLineNumber -= 1;\n            }\n            return {\n                startLineNumber: s.startLineNumber,\n                selectionStartColumn: s.selectionStartColumn,\n                endLineNumber: endLineNumber,\n                positionColumn: s.positionColumn\n            };\n        });\n        // Sort delete operations\n        operations.sort((a, b) => {\n            if (a.startLineNumber === b.startLineNumber) {\n                return a.endLineNumber - b.endLineNumber;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        });\n        // Merge delete operations which are adjacent or overlapping\n        const mergedOperations = [];\n        let previousOperation = operations[0];\n        for (let i = 1; i < operations.length; i++) {\n            if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {\n                // Merge current operations into the previous one\n                previousOperation.endLineNumber = operations[i].endLineNumber;\n            }\n            else {\n                // Push previous operation\n                mergedOperations.push(previousOperation);\n                previousOperation = operations[i];\n            }\n        }\n        // Push the last operation\n        mergedOperations.push(previousOperation);\n        return mergedOperations;\n    }\n}\nexport class IndentLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.indentLines',\n            label: nls.localize('lines.indent', \"Indent Line\"),\n            alias: 'Indent Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 94 /* KeyCode.BracketRight */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n        editor.pushUndoStop();\n    }\n}\nclass OutdentLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.outdentLines',\n            label: nls.localize('lines.outdent', \"Outdent Line\"),\n            alias: 'Outdent Line',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 92 /* KeyCode.BracketLeft */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor, null);\n    }\n}\nexport class InsertLineBeforeAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertLineBefore',\n            label: nls.localize('lines.insertBefore', \"Insert Line Above\"),\n            alias: 'Insert Line Above',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 3 /* KeyCode.Enter */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, EnterOperation.lineInsertBefore(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n    }\n}\nexport class InsertLineAfterAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertLineAfter',\n            label: nls.localize('lines.insertAfter', \"Insert Line Below\"),\n            alias: 'Insert Line Below',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 3 /* KeyCode.Enter */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const viewModel = editor._getViewModel();\n        if (!viewModel) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, EnterOperation.lineInsertAfter(viewModel.cursorConfig, editor.getModel(), editor.getSelections()));\n    }\n}\nexport class AbstractDeleteAllToBoundaryAction extends EditorAction {\n    run(_accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const primaryCursor = editor.getSelection();\n        const rangesToDelete = this._getRangesToDelete(editor);\n        // merge overlapping selections\n        const effectiveRanges = [];\n        for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {\n            const range = rangesToDelete[i];\n            const nextRange = rangesToDelete[i + 1];\n            if (Range.intersectRanges(range, nextRange) === null) {\n                effectiveRanges.push(range);\n            }\n            else {\n                rangesToDelete[i + 1] = Range.plusRange(range, nextRange);\n            }\n        }\n        effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);\n        const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);\n        const edits = effectiveRanges.map(range => {\n            return EditOperation.replace(range, '');\n        });\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, endCursorState);\n        editor.pushUndoStop();\n    }\n}\nexport class DeleteAllLeftAction extends AbstractDeleteAllToBoundaryAction {\n    constructor() {\n        super({\n            id: 'deleteAllLeft',\n            label: nls.localize('lines.deleteAllLeft', \"Delete All Left\"),\n            alias: 'Delete All Left',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 0,\n                mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 1 /* KeyCode.Backspace */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _getEndCursorState(primaryCursor, rangesToDelete) {\n        let endPrimaryCursor = null;\n        const endCursorState = [];\n        let deletedLines = 0;\n        rangesToDelete.forEach(range => {\n            let endCursor;\n            if (range.endColumn === 1 && deletedLines > 0) {\n                const newStartLine = range.startLineNumber - deletedLines;\n                endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);\n            }\n            else {\n                endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n            }\n            deletedLines += range.endLineNumber - range.startLineNumber;\n            if (range.intersectRanges(primaryCursor)) {\n                endPrimaryCursor = endCursor;\n            }\n            else {\n                endCursorState.push(endCursor);\n            }\n        });\n        if (endPrimaryCursor) {\n            endCursorState.unshift(endPrimaryCursor);\n        }\n        return endCursorState;\n    }\n    _getRangesToDelete(editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return [];\n        }\n        let rangesToDelete = selections;\n        const model = editor.getModel();\n        if (model === null) {\n            return [];\n        }\n        rangesToDelete.sort(Range.compareRangesUsingStarts);\n        rangesToDelete = rangesToDelete.map(selection => {\n            if (selection.isEmpty()) {\n                if (selection.startColumn === 1) {\n                    const deleteFromLine = Math.max(1, selection.startLineNumber - 1);\n                    const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineLength(deleteFromLine) + 1;\n                    return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);\n                }\n                else {\n                    return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);\n                }\n            }\n            else {\n                return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n            }\n        });\n        return rangesToDelete;\n    }\n}\nexport class DeleteAllRightAction extends AbstractDeleteAllToBoundaryAction {\n    constructor() {\n        super({\n            id: 'deleteAllRight',\n            label: nls.localize('lines.deleteAllRight', \"Delete All Right\"),\n            alias: 'Delete All Right',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.textInputFocus,\n                primary: 0,\n                mac: { primary: 256 /* KeyMod.WinCtrl */ | 41 /* KeyCode.KeyK */, secondary: [2048 /* KeyMod.CtrlCmd */ | 20 /* KeyCode.Delete */] },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _getEndCursorState(primaryCursor, rangesToDelete) {\n        let endPrimaryCursor = null;\n        const endCursorState = [];\n        for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {\n            const range = rangesToDelete[i];\n            const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);\n            if (range.intersectRanges(primaryCursor)) {\n                endPrimaryCursor = endCursor;\n            }\n            else {\n                endCursorState.push(endCursor);\n            }\n        }\n        if (endPrimaryCursor) {\n            endCursorState.unshift(endPrimaryCursor);\n        }\n        return endCursorState;\n    }\n    _getRangesToDelete(editor) {\n        const model = editor.getModel();\n        if (model === null) {\n            return [];\n        }\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return [];\n        }\n        const rangesToDelete = selections.map((sel) => {\n            if (sel.isEmpty()) {\n                const maxColumn = model.getLineMaxColumn(sel.startLineNumber);\n                if (sel.startColumn === maxColumn) {\n                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);\n                }\n                else {\n                    return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);\n                }\n            }\n            return sel;\n        });\n        rangesToDelete.sort(Range.compareRangesUsingStarts);\n        return rangesToDelete;\n    }\n}\nexport class JoinLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.joinLines',\n            label: nls.localize('lines.joinLines', \"Join Lines\"),\n            alias: 'Join Lines',\n            precondition: EditorContextKeys.writable,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 0,\n                mac: { primary: 256 /* KeyMod.WinCtrl */ | 40 /* KeyCode.KeyJ */ },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        let primaryCursor = editor.getSelection();\n        if (primaryCursor === null) {\n            return;\n        }\n        selections.sort(Range.compareRangesUsingStarts);\n        const reducedSelections = [];\n        const lastSelection = selections.reduce((previousValue, currentValue) => {\n            if (previousValue.isEmpty()) {\n                if (previousValue.endLineNumber === currentValue.startLineNumber) {\n                    if (primaryCursor.equalsSelection(previousValue)) {\n                        primaryCursor = currentValue;\n                    }\n                    return currentValue;\n                }\n                if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {\n                    reducedSelections.push(previousValue);\n                    return currentValue;\n                }\n                else {\n                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                }\n            }\n            else {\n                if (currentValue.startLineNumber > previousValue.endLineNumber) {\n                    reducedSelections.push(previousValue);\n                    return currentValue;\n                }\n                else {\n                    return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                }\n            }\n        });\n        reducedSelections.push(lastSelection);\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const edits = [];\n        const endCursorState = [];\n        let endPrimaryCursor = primaryCursor;\n        let lineOffset = 0;\n        for (let i = 0, len = reducedSelections.length; i < len; i++) {\n            const selection = reducedSelections[i];\n            const startLineNumber = selection.startLineNumber;\n            const startColumn = 1;\n            let columnDeltaOffset = 0;\n            let endLineNumber, endColumn;\n            const selectionEndPositionOffset = model.getLineLength(selection.endLineNumber) - selection.endColumn;\n            if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {\n                const position = selection.getStartPosition();\n                if (position.lineNumber < model.getLineCount()) {\n                    endLineNumber = startLineNumber + 1;\n                    endColumn = model.getLineMaxColumn(endLineNumber);\n                }\n                else {\n                    endLineNumber = position.lineNumber;\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            else {\n                endLineNumber = selection.endLineNumber;\n                endColumn = model.getLineMaxColumn(endLineNumber);\n            }\n            let trimmedLinesContent = model.getLineContent(startLineNumber);\n            for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n                const lineText = model.getLineContent(i);\n                const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i);\n                if (firstNonWhitespaceIdx >= 1) {\n                    let insertSpace = true;\n                    if (trimmedLinesContent === '') {\n                        insertSpace = false;\n                    }\n                    if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||\n                        trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t')) {\n                        insertSpace = false;\n                        trimmedLinesContent = trimmedLinesContent.replace(/[\\s\\uFEFF\\xA0]+$/g, ' ');\n                    }\n                    const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);\n                    trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;\n                    if (insertSpace) {\n                        columnDeltaOffset = lineTextWithoutIndent.length + 1;\n                    }\n                    else {\n                        columnDeltaOffset = lineTextWithoutIndent.length;\n                    }\n                }\n                else {\n                    columnDeltaOffset = 0;\n                }\n            }\n            const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            if (!deleteSelection.isEmpty()) {\n                let resultSelection;\n                if (selection.isEmpty()) {\n                    edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                    resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);\n                }\n                else {\n                    if (selection.startLineNumber === selection.endLineNumber) {\n                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);\n                    }\n                    else {\n                        edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n                        resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);\n                    }\n                }\n                if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {\n                    endPrimaryCursor = resultSelection;\n                }\n                else {\n                    endCursorState.push(resultSelection);\n                }\n            }\n            lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;\n        }\n        endCursorState.unshift(endPrimaryCursor);\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, edits, endCursorState);\n        editor.pushUndoStop();\n    }\n}\nexport class TransposeAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.transpose',\n            label: nls.localize('editor.transpose', \"Transpose Characters around the Cursor\"),\n            alias: 'Transpose Characters around the Cursor',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                continue;\n            }\n            const cursor = selection.getStartPosition();\n            const maxColumn = model.getLineMaxColumn(cursor.lineNumber);\n            if (cursor.column >= maxColumn) {\n                if (cursor.lineNumber === model.getLineCount()) {\n                    continue;\n                }\n                // The cursor is at the end of current line and current line is not empty\n                // then we transpose the character before the cursor and the line break if there is any following line.\n                const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);\n                const chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));\n            }\n            else {\n                const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);\n                const chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, commands);\n        editor.pushUndoStop();\n    }\n}\nexport class AbstractCaseAction extends EditorAction {\n    run(_accessor, editor) {\n        const selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        const model = editor.getModel();\n        if (model === null) {\n            return;\n        }\n        const wordSeparators = editor.getOption(132 /* EditorOption.wordSeparators */);\n        const textEdits = [];\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                const cursor = selection.getStartPosition();\n                const word = editor.getConfiguredWordAtPosition(cursor);\n                if (!word) {\n                    continue;\n                }\n                const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);\n                const text = model.getValueInRange(wordRange);\n                textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));\n            }\n            else {\n                const text = model.getValueInRange(selection);\n                textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));\n            }\n        }\n        editor.pushUndoStop();\n        editor.executeEdits(this.id, textEdits);\n        editor.pushUndoStop();\n    }\n}\nexport class UpperCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToUppercase',\n            label: nls.localize('editor.transformToUppercase', \"Transform to Uppercase\"),\n            alias: 'Transform to Uppercase',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        return text.toLocaleUpperCase();\n    }\n}\nexport class LowerCaseAction extends AbstractCaseAction {\n    constructor() {\n        super({\n            id: 'editor.action.transformToLowercase',\n            label: nls.localize('editor.transformToLowercase', \"Transform to Lowercase\"),\n            alias: 'Transform to Lowercase',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        return text.toLocaleLowerCase();\n    }\n}\nclass BackwardsCompatibleRegExp {\n    constructor(_pattern, _flags) {\n        this._pattern = _pattern;\n        this._flags = _flags;\n        this._actual = null;\n        this._evaluated = false;\n    }\n    get() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            try {\n                this._actual = new RegExp(this._pattern, this._flags);\n            }\n            catch (err) {\n                // this browser does not support this regular expression\n            }\n        }\n        return this._actual;\n    }\n    isSupported() {\n        return (this.get() !== null);\n    }\n}\nexport class TitleCaseAction extends AbstractCaseAction {\n    static { this.titleBoundary = new BackwardsCompatibleRegExp('(^|[^\\\\p{L}\\\\p{N}\\']|((^|\\\\P{L})\\'))\\\\p{L}', 'gmu'); }\n    constructor() {\n        super({\n            id: 'editor.action.transformToTitlecase',\n            label: nls.localize('editor.transformToTitlecase', \"Transform to Title Case\"),\n            alias: 'Transform to Title Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const titleBoundary = TitleCaseAction.titleBoundary.get();\n        if (!titleBoundary) {\n            // cannot support this\n            return text;\n        }\n        return text\n            .toLocaleLowerCase()\n            .replace(titleBoundary, (b) => b.toLocaleUpperCase());\n    }\n}\nexport class SnakeCaseAction extends AbstractCaseAction {\n    static { this.caseBoundary = new BackwardsCompatibleRegExp('(\\\\p{Ll})(\\\\p{Lu})', 'gmu'); }\n    static { this.singleLetters = new BackwardsCompatibleRegExp('(\\\\p{Lu}|\\\\p{N})(\\\\p{Lu})(\\\\p{Ll})', 'gmu'); }\n    constructor() {\n        super({\n            id: 'editor.action.transformToSnakecase',\n            label: nls.localize('editor.transformToSnakecase', \"Transform to Snake Case\"),\n            alias: 'Transform to Snake Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const caseBoundary = SnakeCaseAction.caseBoundary.get();\n        const singleLetters = SnakeCaseAction.singleLetters.get();\n        if (!caseBoundary || !singleLetters) {\n            // cannot support this\n            return text;\n        }\n        return (text\n            .replace(caseBoundary, '$1_$2')\n            .replace(singleLetters, '$1_$2$3')\n            .toLocaleLowerCase());\n    }\n}\nexport class CamelCaseAction extends AbstractCaseAction {\n    static { this.wordBoundary = new BackwardsCompatibleRegExp('[_\\\\s-]', 'gm'); }\n    constructor() {\n        super({\n            id: 'editor.action.transformToCamelcase',\n            label: nls.localize('editor.transformToCamelcase', \"Transform to Camel Case\"),\n            alias: 'Transform to Camel Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const wordBoundary = CamelCaseAction.wordBoundary.get();\n        if (!wordBoundary) {\n            // cannot support this\n            return text;\n        }\n        const words = text.split(wordBoundary);\n        const firstWord = words.shift();\n        return firstWord + words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1))\n            .join('');\n    }\n}\nexport class PascalCaseAction extends AbstractCaseAction {\n    static { this.wordBoundary = new BackwardsCompatibleRegExp('[_\\\\s-]', 'gm'); }\n    static { this.wordBoundaryToMaintain = new BackwardsCompatibleRegExp('(?<=\\\\.)', 'gm'); }\n    constructor() {\n        super({\n            id: 'editor.action.transformToPascalcase',\n            label: nls.localize('editor.transformToPascalcase', \"Transform to Pascal Case\"),\n            alias: 'Transform to Pascal Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, wordSeparators) {\n        const wordBoundary = PascalCaseAction.wordBoundary.get();\n        const wordBoundaryToMaintain = PascalCaseAction.wordBoundaryToMaintain.get();\n        if (!wordBoundary || !wordBoundaryToMaintain) {\n            // cannot support this\n            return text;\n        }\n        const wordsWithMaintainBoundaries = text.split(wordBoundaryToMaintain);\n        const words = wordsWithMaintainBoundaries.map((word) => word.split(wordBoundary)).flat();\n        return words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1))\n            .join('');\n    }\n}\nexport class KebabCaseAction extends AbstractCaseAction {\n    static isSupported() {\n        const areAllRegexpsSupported = [\n            this.caseBoundary,\n            this.singleLetters,\n            this.underscoreBoundary,\n        ].every((regexp) => regexp.isSupported());\n        return areAllRegexpsSupported;\n    }\n    static { this.caseBoundary = new BackwardsCompatibleRegExp('(\\\\p{Ll})(\\\\p{Lu})', 'gmu'); }\n    static { this.singleLetters = new BackwardsCompatibleRegExp('(\\\\p{Lu}|\\\\p{N})(\\\\p{Lu}\\\\p{Ll})', 'gmu'); }\n    static { this.underscoreBoundary = new BackwardsCompatibleRegExp('(\\\\S)(_)(\\\\S)', 'gm'); }\n    constructor() {\n        super({\n            id: 'editor.action.transformToKebabcase',\n            label: nls.localize('editor.transformToKebabcase', 'Transform to Kebab Case'),\n            alias: 'Transform to Kebab Case',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    _modifyText(text, _) {\n        const caseBoundary = KebabCaseAction.caseBoundary.get();\n        const singleLetters = KebabCaseAction.singleLetters.get();\n        const underscoreBoundary = KebabCaseAction.underscoreBoundary.get();\n        if (!caseBoundary || !singleLetters || !underscoreBoundary) {\n            // one or more regexps aren't supported\n            return text;\n        }\n        return text\n            .replace(underscoreBoundary, '$1-$3')\n            .replace(caseBoundary, '$1-$2')\n            .replace(singleLetters, '$1-$2')\n            .toLocaleLowerCase();\n    }\n}\nregisterEditorAction(CopyLinesUpAction);\nregisterEditorAction(CopyLinesDownAction);\nregisterEditorAction(DuplicateSelectionAction);\nregisterEditorAction(MoveLinesUpAction);\nregisterEditorAction(MoveLinesDownAction);\nregisterEditorAction(SortLinesAscendingAction);\nregisterEditorAction(SortLinesDescendingAction);\nregisterEditorAction(DeleteDuplicateLinesAction);\nregisterEditorAction(TrimTrailingWhitespaceAction);\nregisterEditorAction(DeleteLinesAction);\nregisterEditorAction(IndentLinesAction);\nregisterEditorAction(OutdentLinesAction);\nregisterEditorAction(InsertLineBeforeAction);\nregisterEditorAction(InsertLineAfterAction);\nregisterEditorAction(DeleteAllLeftAction);\nregisterEditorAction(DeleteAllRightAction);\nregisterEditorAction(JoinLinesAction);\nregisterEditorAction(TransposeAction);\nregisterEditorAction(UpperCaseAction);\nregisterEditorAction(LowerCaseAction);\nif (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {\n    registerEditorAction(SnakeCaseAction);\n}\nif (CamelCaseAction.wordBoundary.isSupported()) {\n    registerEditorAction(CamelCaseAction);\n}\nif (PascalCaseAction.wordBoundary.isSupported()) {\n    registerEditorAction(PascalCaseAction);\n}\nif (TitleCaseAction.titleBoundary.isSupported()) {\n    registerEditorAction(TitleCaseAction);\n}\nif (KebabCaseAction.isSupported()) {\n    registerEditorAction(KebabCaseAction);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar SelectionHighlighter_1;\nimport { status } from '../../../../base/browser/ui/aria/aria.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { CursorMoveCommands } from '../../../common/cursor/cursorMoveCommands.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { CommonFindController } from '../../find/browser/findController.js';\nimport * as nls from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { getSelectionHighlightDecorationOptions } from '../../wordHighlighter/browser/highlightDecorations.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nfunction announceCursorChange(previousCursorState, cursorState) {\n    const cursorDiff = cursorState.filter(cs => !previousCursorState.find(pcs => pcs.equals(cs)));\n    if (cursorDiff.length >= 1) {\n        const cursorPositions = cursorDiff.map(cs => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(', ');\n        const msg = cursorDiff.length === 1 ? nls.localize('cursorAdded', \"Cursor added: {0}\", cursorPositions) : nls.localize('cursorsAdded', \"Cursors added: {0}\", cursorPositions);\n        status(msg);\n    }\n}\nexport class InsertCursorAbove extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorAbove',\n            label: nls.localize('mutlicursor.insertAbove', \"Add Cursor Above\"),\n            alias: 'Add Cursor Above',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                linux: {\n                    primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 16 /* KeyCode.UpArrow */,\n                    secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 16 /* KeyCode.UpArrow */]\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, \"&&Add Cursor Above\"),\n                order: 2\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        let useLogicalLine = true;\n        if (args && args.logicalLine === false) {\n            useLogicalLine = false;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = viewModel.getCursorStates();\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));\n        viewModel.revealTopMostCursor(args.source);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class InsertCursorBelow extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorBelow',\n            label: nls.localize('mutlicursor.insertBelow', \"Add Cursor Below\"),\n            alias: 'Add Cursor Below',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                linux: {\n                    primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 18 /* KeyCode.DownArrow */,\n                    secondary: [2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 18 /* KeyCode.DownArrow */]\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, \"A&&dd Cursor Below\"),\n                order: 3\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        let useLogicalLine = true;\n        if (args && args.logicalLine === false) {\n            useLogicalLine = false;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = viewModel.getCursorStates();\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));\n        viewModel.revealBottomMostCursor(args.source);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtEndOfEachLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.insertCursorAtEndOfEachLineSelected',\n            label: nls.localize('mutlicursor.insertAtEndOfEachLineSelected', \"Add Cursors to Line Ends\"),\n            alias: 'Add Cursors to Line Ends',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 1024 /* KeyMod.Shift */ | 512 /* KeyMod.Alt */ | 39 /* KeyCode.KeyI */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, \"Add C&&ursors to Line Ends\"),\n                order: 4\n            }\n        });\n    }\n    getCursorsForSelection(selection, model, result) {\n        if (selection.isEmpty()) {\n            return;\n        }\n        for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {\n            const currentLineMaxColumn = model.getLineMaxColumn(i);\n            result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));\n        }\n        if (selection.endColumn > 1) {\n            result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));\n        }\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const model = editor.getModel();\n        const selections = editor.getSelections();\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        const newSelections = [];\n        selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtEndOfLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.addCursorsToBottom',\n            label: nls.localize('mutlicursor.addCursorsToBottom', \"Add Cursors To Bottom\"),\n            alias: 'Add Cursors To Bottom',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections();\n        const lineCount = editor.getModel().getLineCount();\n        const newSelections = [];\n        for (let i = selections[0].startLineNumber; i <= lineCount; i++) {\n            newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n        }\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nclass InsertCursorAtTopOfLineSelected extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.addCursorsToTop',\n            label: nls.localize('mutlicursor.addCursorsToTop', \"Add Cursors To Top\"),\n            alias: 'Add Cursors To Top',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const selections = editor.getSelections();\n        const newSelections = [];\n        for (let i = selections[0].startLineNumber; i >= 1; i--) {\n            newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n        }\n        const viewModel = editor._getViewModel();\n        const previousCursorState = viewModel.getCursorStates();\n        if (newSelections.length > 0) {\n            editor.setSelections(newSelections);\n        }\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class MultiCursorSessionResult {\n    constructor(selections, revealRange, revealScrollType) {\n        this.selections = selections;\n        this.revealRange = revealRange;\n        this.revealScrollType = revealScrollType;\n    }\n}\nexport class MultiCursorSession {\n    static create(editor, findController) {\n        if (!editor.hasModel()) {\n            return null;\n        }\n        const findState = findController.getState();\n        // Find widget owns entirely what we search for if:\n        //  - focus is not in the editor (i.e. it is in the find widget)\n        //  - and the search widget is visible\n        //  - and the search string is non-empty\n        if (!editor.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {\n            // Find widget owns what is searched for\n            return new MultiCursorSession(editor, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);\n        }\n        // Otherwise, the selection gives the search text, and the find widget gives the search settings\n        // The exception is the find state disassociation case: when beginning with a single, collapsed selection\n        let isDisconnectedFromFindController = false;\n        let wholeWord;\n        let matchCase;\n        const selections = editor.getSelections();\n        if (selections.length === 1 && selections[0].isEmpty()) {\n            isDisconnectedFromFindController = true;\n            wholeWord = true;\n            matchCase = true;\n        }\n        else {\n            wholeWord = findState.wholeWord;\n            matchCase = findState.matchCase;\n        }\n        // Selection owns what is searched for\n        const s = editor.getSelection();\n        let searchText;\n        let currentMatch = null;\n        if (s.isEmpty()) {\n            // selection is empty => expand to current word\n            const word = editor.getConfiguredWordAtPosition(s.getStartPosition());\n            if (!word) {\n                return null;\n            }\n            searchText = word.word;\n            currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);\n        }\n        else {\n            searchText = editor.getModel().getValueInRange(s).replace(/\\r\\n/g, '\\n');\n        }\n        return new MultiCursorSession(editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);\n    }\n    constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {\n        this._editor = _editor;\n        this.findController = findController;\n        this.isDisconnectedFromFindController = isDisconnectedFromFindController;\n        this.searchText = searchText;\n        this.wholeWord = wholeWord;\n        this.matchCase = matchCase;\n        this.currentMatch = currentMatch;\n    }\n    addSelectionToNextFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const nextMatch = this._getNextMatch();\n        if (!nextMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0 /* ScrollType.Smooth */);\n    }\n    moveSelectionToNextFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const nextMatch = this._getNextMatch();\n        if (!nextMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0 /* ScrollType.Smooth */);\n    }\n    _getNextMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (this.currentMatch) {\n            const result = this.currentMatch;\n            this.currentMatch = null;\n            return result;\n        }\n        this.findController.highlightFindOptions();\n        const allSelections = this._editor.getSelections();\n        const lastAddedSelection = allSelections[allSelections.length - 1];\n        const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false);\n        if (!nextMatch) {\n            return null;\n        }\n        return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);\n    }\n    addSelectionToPreviousFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const previousMatch = this._getPreviousMatch();\n        if (!previousMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0 /* ScrollType.Smooth */);\n    }\n    moveSelectionToPreviousFindMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        const previousMatch = this._getPreviousMatch();\n        if (!previousMatch) {\n            return null;\n        }\n        const allSelections = this._editor.getSelections();\n        return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0 /* ScrollType.Smooth */);\n    }\n    _getPreviousMatch() {\n        if (!this._editor.hasModel()) {\n            return null;\n        }\n        if (this.currentMatch) {\n            const result = this.currentMatch;\n            this.currentMatch = null;\n            return result;\n        }\n        this.findController.highlightFindOptions();\n        const allSelections = this._editor.getSelections();\n        const lastAddedSelection = allSelections[allSelections.length - 1];\n        const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false);\n        if (!previousMatch) {\n            return null;\n        }\n        return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);\n    }\n    selectAll(searchScope) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this.findController.highlightFindOptions();\n        const editorModel = this._editor.getModel();\n        if (searchScope) {\n            return editorModel.findMatches(this.searchText, searchScope, false, this.matchCase, this.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        }\n        return editorModel.findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    }\n}\nexport class MultiCursorSelectionController extends Disposable {\n    static { this.ID = 'editor.contrib.multiCursorController'; }\n    static get(editor) {\n        return editor.getContribution(MultiCursorSelectionController.ID);\n    }\n    constructor(editor) {\n        super();\n        this._sessionDispose = this._register(new DisposableStore());\n        this._editor = editor;\n        this._ignoreSelectionChange = false;\n        this._session = null;\n    }\n    dispose() {\n        this._endSession();\n        super.dispose();\n    }\n    _beginSessionIfNeeded(findController) {\n        if (!this._session) {\n            // Create a new session\n            const session = MultiCursorSession.create(this._editor, findController);\n            if (!session) {\n                return;\n            }\n            this._session = session;\n            const newState = { searchString: this._session.searchText };\n            if (this._session.isDisconnectedFromFindController) {\n                newState.wholeWordOverride = 1 /* FindOptionOverride.True */;\n                newState.matchCaseOverride = 1 /* FindOptionOverride.True */;\n                newState.isRegexOverride = 2 /* FindOptionOverride.False */;\n            }\n            findController.getState().change(newState, false);\n            this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {\n                if (this._ignoreSelectionChange) {\n                    return;\n                }\n                this._endSession();\n            }));\n            this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {\n                this._endSession();\n            }));\n            this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {\n                if (e.matchCase || e.wholeWord) {\n                    this._endSession();\n                }\n            }));\n        }\n    }\n    _endSession() {\n        this._sessionDispose.clear();\n        if (this._session && this._session.isDisconnectedFromFindController) {\n            const newState = {\n                wholeWordOverride: 0 /* FindOptionOverride.NotSet */,\n                matchCaseOverride: 0 /* FindOptionOverride.NotSet */,\n                isRegexOverride: 0 /* FindOptionOverride.NotSet */,\n            };\n            this._session.findController.getState().change(newState, false);\n        }\n        this._session = null;\n    }\n    _setSelections(selections) {\n        this._ignoreSelectionChange = true;\n        this._editor.setSelections(selections);\n        this._ignoreSelectionChange = false;\n    }\n    _expandEmptyToWord(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());\n        if (!word) {\n            return selection;\n        }\n        return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n    }\n    _applySessionResult(result) {\n        if (!result) {\n            return;\n        }\n        this._setSelections(result.selections);\n        if (result.revealRange) {\n            this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);\n        }\n    }\n    getSession(findController) {\n        return this._session;\n    }\n    addSelectionToNextFindMatch(findController) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        if (!this._session) {\n            // If there are multiple cursors, handle the case where they do not all select the same text.\n            const allSelections = this._editor.getSelections();\n            if (allSelections.length > 1) {\n                const findState = findController.getState();\n                const matchCase = findState.matchCase;\n                const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);\n                if (!selectionsContainSameText) {\n                    const model = this._editor.getModel();\n                    const resultingSelections = [];\n                    for (let i = 0, len = allSelections.length; i < len; i++) {\n                        resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);\n                    }\n                    this._editor.setSelections(resultingSelections);\n                    return;\n                }\n            }\n        }\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.addSelectionToNextFindMatch());\n        }\n    }\n    addSelectionToPreviousFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.addSelectionToPreviousFindMatch());\n        }\n    }\n    moveSelectionToNextFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.moveSelectionToNextFindMatch());\n        }\n    }\n    moveSelectionToPreviousFindMatch(findController) {\n        this._beginSessionIfNeeded(findController);\n        if (this._session) {\n            this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());\n        }\n    }\n    selectAll(findController) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        let matches = null;\n        const findState = findController.getState();\n        // Special case: find widget owns entirely what we search for if:\n        // - focus is not in the editor (i.e. it is in the find widget)\n        // - and the search widget is visible\n        // - and the search string is non-empty\n        // - and we're searching for a regex\n        if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {\n            const editorModel = this._editor.getModel();\n            if (findState.searchScope) {\n                matches = editorModel.findMatches(findState.searchString, findState.searchScope, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n            }\n            else {\n                matches = editorModel.findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(132 /* EditorOption.wordSeparators */) : null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n            }\n        }\n        else {\n            this._beginSessionIfNeeded(findController);\n            if (!this._session) {\n                return;\n            }\n            matches = this._session.selectAll(findState.searchScope);\n        }\n        if (matches.length > 0) {\n            const editorSelection = this._editor.getSelection();\n            // Have the primary cursor remain the one where the action was invoked\n            for (let i = 0, len = matches.length; i < len; i++) {\n                const match = matches[i];\n                const intersection = match.range.intersectRanges(editorSelection);\n                if (intersection) {\n                    // bingo!\n                    matches[i] = matches[0];\n                    matches[0] = match;\n                    break;\n                }\n            }\n            this._setSelections(matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));\n        }\n    }\n}\nexport class MultiCursorSelectionControllerAction extends EditorAction {\n    run(accessor, editor) {\n        const multiCursorController = MultiCursorSelectionController.get(editor);\n        if (!multiCursorController) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel) {\n            const previousCursorState = viewModel.getCursorStates();\n            const findController = CommonFindController.get(editor);\n            if (findController) {\n                this._run(multiCursorController, findController);\n            }\n            else {\n                const newFindController = accessor.get(IInstantiationService).createInstance(CommonFindController, editor);\n                this._run(multiCursorController, newFindController);\n                newFindController.dispose();\n            }\n            announceCursorChange(previousCursorState, viewModel.getCursorStates());\n        }\n    }\n}\nexport class AddSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.addSelectionToNextFindMatch',\n            label: nls.localize('addSelectionToNextFindMatch', \"Add Selection To Next Find Match\"),\n            alias: 'Add Selection To Next Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 34 /* KeyCode.KeyD */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add &&Next Occurrence\"),\n                order: 5\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.addSelectionToNextFindMatch(findController);\n    }\n}\nexport class AddSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.addSelectionToPreviousFindMatch',\n            label: nls.localize('addSelectionToPreviousFindMatch', \"Add Selection To Previous Find Match\"),\n            alias: 'Add Selection To Previous Find Match',\n            precondition: undefined,\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add P&&revious Occurrence\"),\n                order: 6\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.addSelectionToPreviousFindMatch(findController);\n    }\n}\nexport class MoveSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.moveSelectionToNextFindMatch',\n            label: nls.localize('moveSelectionToNextFindMatch', \"Move Last Selection To Next Find Match\"),\n            alias: 'Move Last Selection To Next Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 34 /* KeyCode.KeyD */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.moveSelectionToNextFindMatch(findController);\n    }\n}\nexport class MoveSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.moveSelectionToPreviousFindMatch',\n            label: nls.localize('moveSelectionToPreviousFindMatch', \"Move Last Selection To Previous Find Match\"),\n            alias: 'Move Last Selection To Previous Find Match',\n            precondition: undefined\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.moveSelectionToPreviousFindMatch(findController);\n    }\n}\nexport class SelectHighlightsAction extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.selectHighlights',\n            label: nls.localize('selectAllOccurrencesOfFindMatch', \"Select All Occurrences of Find Match\"),\n            alias: 'Select All Occurrences of Find Match',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 42 /* KeyCode.KeyL */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            menuOpts: {\n                menuId: MenuId.MenubarSelectionMenu,\n                group: '3_multi',\n                title: nls.localize({ key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, \"Select All &&Occurrences\"),\n                order: 7\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.selectAll(findController);\n    }\n}\nexport class CompatChangeAll extends MultiCursorSelectionControllerAction {\n    constructor() {\n        super({\n            id: 'editor.action.changeAll',\n            label: nls.localize('changeAll.label', \"Change All Occurrences\"),\n            alias: 'Change All Occurrences',\n            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 60 /* KeyCode.F2 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            contextMenuOpts: {\n                group: '1_modification',\n                order: 1.2\n            }\n        });\n    }\n    _run(multiCursorController, findController) {\n        multiCursorController.selectAll(findController);\n    }\n}\nclass SelectionHighlighterState {\n    constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {\n        this._model = _model;\n        this._searchText = _searchText;\n        this._matchCase = _matchCase;\n        this._wordSeparators = _wordSeparators;\n        this._modelVersionId = this._model.getVersionId();\n        this._cachedFindMatches = null;\n        if (prevState\n            && this._model === prevState._model\n            && this._searchText === prevState._searchText\n            && this._matchCase === prevState._matchCase\n            && this._wordSeparators === prevState._wordSeparators\n            && this._modelVersionId === prevState._modelVersionId) {\n            this._cachedFindMatches = prevState._cachedFindMatches;\n        }\n    }\n    findMatches() {\n        if (this._cachedFindMatches === null) {\n            this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map(m => m.range);\n            this._cachedFindMatches.sort(Range.compareRangesUsingStarts);\n        }\n        return this._cachedFindMatches;\n    }\n}\nlet SelectionHighlighter = class SelectionHighlighter extends Disposable {\n    static { SelectionHighlighter_1 = this; }\n    static { this.ID = 'editor.contrib.selectionHighlighter'; }\n    constructor(editor, _languageFeaturesService) {\n        super();\n        this._languageFeaturesService = _languageFeaturesService;\n        this.editor = editor;\n        this._isEnabled = editor.getOption(109 /* EditorOption.selectionHighlight */);\n        this._decorations = editor.createDecorationsCollection();\n        this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));\n        this.state = null;\n        this._register(editor.onDidChangeConfiguration((e) => {\n            this._isEnabled = editor.getOption(109 /* EditorOption.selectionHighlight */);\n        }));\n        this._register(editor.onDidChangeCursorSelection((e) => {\n            if (!this._isEnabled) {\n                // Early exit if nothing needs to be done!\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                return;\n            }\n            if (e.selection.isEmpty()) {\n                if (e.reason === 3 /* CursorChangeReason.Explicit */) {\n                    if (this.state) {\n                        // no longer valid\n                        this._setState(null);\n                    }\n                    this.updateSoon.schedule();\n                }\n                else {\n                    this._setState(null);\n                }\n            }\n            else {\n                this._update();\n            }\n        }));\n        this._register(editor.onDidChangeModel((e) => {\n            this._setState(null);\n        }));\n        this._register(editor.onDidChangeModelContent((e) => {\n            if (this._isEnabled) {\n                this.updateSoon.schedule();\n            }\n        }));\n        const findController = CommonFindController.get(editor);\n        if (findController) {\n            this._register(findController.getState().onFindReplaceStateChange((e) => {\n                this._update();\n            }));\n        }\n        this.updateSoon.schedule();\n    }\n    _update() {\n        this._setState(SelectionHighlighter_1._createState(this.state, this._isEnabled, this.editor));\n    }\n    static _createState(oldState, isEnabled, editor) {\n        if (!isEnabled) {\n            return null;\n        }\n        if (!editor.hasModel()) {\n            return null;\n        }\n        const s = editor.getSelection();\n        if (s.startLineNumber !== s.endLineNumber) {\n            // multiline forbidden for perf reasons\n            return null;\n        }\n        const multiCursorController = MultiCursorSelectionController.get(editor);\n        if (!multiCursorController) {\n            return null;\n        }\n        const findController = CommonFindController.get(editor);\n        if (!findController) {\n            return null;\n        }\n        let r = multiCursorController.getSession(findController);\n        if (!r) {\n            const allSelections = editor.getSelections();\n            if (allSelections.length > 1) {\n                const findState = findController.getState();\n                const matchCase = findState.matchCase;\n                const selectionsContainSameText = modelRangesContainSameText(editor.getModel(), allSelections, matchCase);\n                if (!selectionsContainSameText) {\n                    return null;\n                }\n            }\n            r = MultiCursorSession.create(editor, findController);\n        }\n        if (!r) {\n            return null;\n        }\n        if (r.currentMatch) {\n            // This is an empty selection\n            // Do not interfere with semantic word highlighting in the no selection case\n            return null;\n        }\n        if (/^[ \\t]+$/.test(r.searchText)) {\n            // whitespace only selection\n            return null;\n        }\n        if (r.searchText.length > 200) {\n            // very long selection\n            return null;\n        }\n        // TODO: better handling of this case\n        const findState = findController.getState();\n        const caseSensitive = findState.matchCase;\n        // Return early if the find widget shows the exact same matches\n        if (findState.isRevealed) {\n            let findStateSearchString = findState.searchString;\n            if (!caseSensitive) {\n                findStateSearchString = findStateSearchString.toLowerCase();\n            }\n            let mySearchString = r.searchText;\n            if (!caseSensitive) {\n                mySearchString = mySearchString.toLowerCase();\n            }\n            if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {\n                return null;\n            }\n        }\n        return new SelectionHighlighterState(editor.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor.getOption(132 /* EditorOption.wordSeparators */) : null, oldState);\n    }\n    _setState(newState) {\n        this.state = newState;\n        if (!this.state) {\n            this._decorations.clear();\n            return;\n        }\n        if (!this.editor.hasModel()) {\n            return;\n        }\n        const model = this.editor.getModel();\n        if (model.isTooLargeForTokenization()) {\n            // the file is too large, so searching word under cursor in the whole document would be blocking the UI.\n            return;\n        }\n        const allMatches = this.state.findMatches();\n        const selections = this.editor.getSelections();\n        selections.sort(Range.compareRangesUsingStarts);\n        // do not overlap with selection (issue #64 and #512)\n        const matches = [];\n        for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {\n            const match = allMatches[i];\n            if (j >= lenJ) {\n                // finished all editor selections\n                matches.push(match);\n                i++;\n            }\n            else {\n                const cmp = Range.compareRangesUsingStarts(match, selections[j]);\n                if (cmp < 0) {\n                    // match is before sel\n                    if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {\n                        matches.push(match);\n                    }\n                    i++;\n                }\n                else if (cmp > 0) {\n                    // sel is before match\n                    j++;\n                }\n                else {\n                    // sel is equal to match\n                    i++;\n                    j++;\n                }\n            }\n        }\n        const occurrenceHighlighting = this.editor.getOption(81 /* EditorOption.occurrencesHighlight */) !== 'off';\n        const hasSemanticHighlights = this._languageFeaturesService.documentHighlightProvider.has(model) && occurrenceHighlighting;\n        const decorations = matches.map(r => {\n            return {\n                range: r,\n                options: getSelectionHighlightDecorationOptions(hasSemanticHighlights)\n            };\n        });\n        this._decorations.set(decorations);\n    }\n    dispose() {\n        this._setState(null);\n        super.dispose();\n    }\n};\nSelectionHighlighter = SelectionHighlighter_1 = __decorate([\n    __param(1, ILanguageFeaturesService)\n], SelectionHighlighter);\nexport { SelectionHighlighter };\nfunction modelRangesContainSameText(model, ranges, matchCase) {\n    const selectedText = getValueInRange(model, ranges[0], !matchCase);\n    for (let i = 1, len = ranges.length; i < len; i++) {\n        const range = ranges[i];\n        if (range.isEmpty()) {\n            return false;\n        }\n        const thisSelectedText = getValueInRange(model, range, !matchCase);\n        if (selectedText !== thisSelectedText) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getValueInRange(model, range, toLowerCase) {\n    const text = model.getValueInRange(range);\n    return (toLowerCase ? text.toLowerCase() : text);\n}\nexport class FocusNextCursor extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.focusNextCursor',\n            label: nls.localize('mutlicursor.focusNextCursor', \"Focus Next Cursor\"),\n            metadata: {\n                description: nls.localize('mutlicursor.focusNextCursor.description', \"Focuses the next cursor\"),\n                args: [],\n            },\n            alias: 'Focus Next Cursor',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = Array.from(viewModel.getCursorStates());\n        const firstCursor = previousCursorState.shift();\n        if (!firstCursor) {\n            return;\n        }\n        previousCursorState.push(firstCursor);\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, previousCursorState);\n        viewModel.revealPrimaryCursor(args.source, true);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nexport class FocusPreviousCursor extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.focusPreviousCursor',\n            label: nls.localize('mutlicursor.focusPreviousCursor', \"Focus Previous Cursor\"),\n            metadata: {\n                description: nls.localize('mutlicursor.focusPreviousCursor.description', \"Focuses the previous cursor\"),\n                args: [],\n            },\n            alias: 'Focus Previous Cursor',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor, args) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const viewModel = editor._getViewModel();\n        if (viewModel.cursorConfig.readOnly) {\n            return;\n        }\n        viewModel.model.pushStackElement();\n        const previousCursorState = Array.from(viewModel.getCursorStates());\n        const firstCursor = previousCursorState.pop();\n        if (!firstCursor) {\n            return;\n        }\n        previousCursorState.unshift(firstCursor);\n        viewModel.setCursorStates(args.source, 3 /* CursorChangeReason.Explicit */, previousCursorState);\n        viewModel.revealPrimaryCursor(args.source, true);\n        announceCursorChange(previousCursorState, viewModel.getCursorStates());\n    }\n}\nregisterEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController, 4 /* EditorContributionInstantiation.Lazy */);\nregisterEditorContribution(SelectionHighlighter.ID, SelectionHighlighter, 1 /* EditorContributionInstantiation.AfterFirstRender */);\nregisterEditorAction(InsertCursorAbove);\nregisterEditorAction(InsertCursorBelow);\nregisterEditorAction(InsertCursorAtEndOfEachLineSelected);\nregisterEditorAction(AddSelectionToNextFindMatchAction);\nregisterEditorAction(AddSelectionToPreviousFindMatchAction);\nregisterEditorAction(MoveSelectionToNextFindMatchAction);\nregisterEditorAction(MoveSelectionToPreviousFindMatchAction);\nregisterEditorAction(SelectHighlightsAction);\nregisterEditorAction(CompatChangeAll);\nregisterEditorAction(InsertCursorAtEndOfLineSelected);\nregisterEditorAction(InsertCursorAtTopOfLineSelected);\nregisterEditorAction(FocusNextCursor);\nregisterEditorAction(FocusPreviousCursor);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar InlineEditSideBySideWidget_1, InlineEditSideBySideContentWidget_1;\nimport { $ } from '../../../../base/browser/dom.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ObservablePromise, autorun, autorunWithStore, derived, observableSignalFromEvent } from '../../../../base/common/observable.js';\nimport { derivedDisposable } from '../../../../base/common/observableInternal/derived.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport './inlineEditSideBySideWidget.css';\nimport { observableCodeEditor } from '../../../browser/observableCodeEditor.js';\nimport { EmbeddedCodeEditorWidget } from '../../../browser/widget/codeEditor/embeddedCodeEditorWidget.js';\nimport { IDiffProviderFactoryService } from '../../../browser/widget/diffEditor/diffProviderFactoryService.js';\nimport { diffAddDecoration, diffAddDecorationEmpty, diffDeleteDecoration, diffDeleteDecorationEmpty, diffLineAddDecorationBackgroundWithIndicator, diffLineDeleteDecorationBackgroundWithIndicator, diffWholeLineAddDecoration, diffWholeLineDeleteDecoration } from '../../../browser/widget/diffEditor/registrations.contribution.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../../../common/languages/modesRegistry.js';\nimport { TextModel } from '../../../common/model/textModel.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nfunction* range(start, end, step = 1) {\n    if (end === undefined) {\n        [end, start] = [start, 0];\n    }\n    for (let n = start; n < end; n += step) {\n        yield n;\n    }\n}\nfunction removeIndentation(lines) {\n    const indentation = lines[0].match(/^\\s*/)?.[0] ?? '';\n    const length = indentation.length;\n    return {\n        text: lines.map(l => l.replace(new RegExp('^' + indentation), '')),\n        shift: length\n    };\n}\nlet InlineEditSideBySideWidget = class InlineEditSideBySideWidget extends Disposable {\n    static { InlineEditSideBySideWidget_1 = this; }\n    static { this._modelId = 0; }\n    static _createUniqueUri() {\n        return URI.from({ scheme: 'inline-edit-widget', path: new Date().toString() + String(InlineEditSideBySideWidget_1._modelId++) });\n    }\n    constructor(_editor, _model, _instantiationService, _diffProviderFactoryService, _modelService) {\n        super();\n        this._editor = _editor;\n        this._model = _model;\n        this._instantiationService = _instantiationService;\n        this._diffProviderFactoryService = _diffProviderFactoryService;\n        this._modelService = _modelService;\n        this._position = derived(this, reader => {\n            const ghostText = this._model.read(reader);\n            if (!ghostText || ghostText.text.length === 0) {\n                return null;\n            }\n            if (ghostText.range.startLineNumber === ghostText.range.endLineNumber && !(ghostText.range.startColumn === ghostText.range.endColumn && ghostText.range.startColumn === 1)) {\n                //for inner-line suggestions we still want to use minimal ghost text\n                return null;\n            }\n            const editorModel = this._editor.getModel();\n            if (!editorModel) {\n                return null;\n            }\n            const lines = Array.from(range(ghostText.range.startLineNumber, ghostText.range.endLineNumber + 1));\n            const lengths = lines.map(lineNumber => editorModel.getLineLastNonWhitespaceColumn(lineNumber));\n            const maxColumn = Math.max(...lengths);\n            const lineOfMaxColumn = lines[lengths.indexOf(maxColumn)];\n            const position = new Position(lineOfMaxColumn, maxColumn);\n            const pos = {\n                top: ghostText.range.startLineNumber,\n                left: position\n            };\n            return pos;\n        });\n        this._text = derived(this, reader => {\n            const ghostText = this._model.read(reader);\n            if (!ghostText) {\n                return { text: '', shift: 0 };\n            }\n            const t = removeIndentation(ghostText.text.split('\\n'));\n            return {\n                text: t.text.join('\\n'),\n                shift: t.shift\n            };\n        });\n        this._originalModel = derivedDisposable(() => this._modelService.createModel('', null, InlineEditSideBySideWidget_1._createUniqueUri())).keepObserved(this._store);\n        this._modifiedModel = derivedDisposable(() => this._modelService.createModel('', null, InlineEditSideBySideWidget_1._createUniqueUri())).keepObserved(this._store);\n        this._diff = derived(this, reader => {\n            return this._diffPromise.read(reader)?.promiseResult.read(reader)?.data;\n        });\n        this._diffPromise = derived(this, reader => {\n            const ghostText = this._model.read(reader);\n            if (!ghostText) {\n                return;\n            }\n            const editorModel = this._editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const originalText = removeIndentation(editorModel.getValueInRange(ghostText.range).split('\\n')).text.join('\\n');\n            const modifiedText = removeIndentation(ghostText.text.split('\\n')).text.join('\\n');\n            this._originalModel.get().setValue(originalText);\n            this._modifiedModel.get().setValue(modifiedText);\n            const d = this._diffProviderFactoryService.createDiffProvider({ diffAlgorithm: 'advanced' });\n            return ObservablePromise.fromFn(async () => {\n                const result = await d.computeDiff(this._originalModel.get(), this._modifiedModel.get(), {\n                    computeMoves: false,\n                    ignoreTrimWhitespace: false,\n                    maxComputationTimeMs: 1000,\n                }, CancellationToken.None);\n                if (result.identical) {\n                    return undefined;\n                }\n                return result.changes;\n            });\n        });\n        this._register(autorunWithStore((reader, store) => {\n            /** @description setup content widget */\n            const model = this._model.read(reader);\n            if (!model) {\n                return;\n            }\n            if (this._position.get() === null) {\n                return;\n            }\n            const contentWidget = store.add(this._instantiationService.createInstance(InlineEditSideBySideContentWidget, this._editor, this._position, this._text.map(t => t.text), this._text.map(t => t.shift), this._diff));\n            _editor.addOverlayWidget(contentWidget);\n            store.add(toDisposable(() => _editor.removeOverlayWidget(contentWidget)));\n        }));\n    }\n};\nInlineEditSideBySideWidget = InlineEditSideBySideWidget_1 = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, IDiffProviderFactoryService),\n    __param(4, IModelService)\n], InlineEditSideBySideWidget);\nexport { InlineEditSideBySideWidget };\nlet InlineEditSideBySideContentWidget = class InlineEditSideBySideContentWidget extends Disposable {\n    static { InlineEditSideBySideContentWidget_1 = this; }\n    static { this.id = 0; }\n    constructor(_editor, _position, _text, _shift, _diff, _instantiationService) {\n        super();\n        this._editor = _editor;\n        this._position = _position;\n        this._text = _text;\n        this._shift = _shift;\n        this._diff = _diff;\n        this._instantiationService = _instantiationService;\n        this.id = `InlineEditSideBySideContentWidget${InlineEditSideBySideContentWidget_1.id++}`;\n        this.allowEditorOverflow = false;\n        this._nodes = $('div.inlineEditSideBySide', undefined);\n        this._scrollChanged = observableSignalFromEvent('editor.onDidScrollChange', this._editor.onDidScrollChange);\n        this._previewEditor = this._register(this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._nodes, {\n            glyphMargin: false,\n            lineNumbers: 'off',\n            minimap: { enabled: false },\n            guides: {\n                indentation: false,\n                bracketPairs: false,\n                bracketPairsHorizontal: false,\n                highlightActiveIndentation: false,\n            },\n            folding: false,\n            selectOnLineNumbers: false,\n            selectionHighlight: false,\n            columnSelection: false,\n            overviewRulerBorder: false,\n            overviewRulerLanes: 0,\n            lineDecorationsWidth: 0,\n            lineNumbersMinChars: 0,\n            scrollbar: { vertical: 'hidden', horizontal: 'hidden', alwaysConsumeMouseWheel: false, handleMouseWheel: false },\n            readOnly: true,\n            wordWrap: 'off',\n            wordWrapOverride1: 'off',\n            wordWrapOverride2: 'off',\n            wrappingIndent: 'none',\n            wrappingStrategy: undefined,\n        }, { contributions: [], isSimpleWidget: true }, this._editor));\n        this._previewEditorObs = observableCodeEditor(this._previewEditor);\n        this._editorObs = observableCodeEditor(this._editor);\n        this._previewTextModel = this._register(this._instantiationService.createInstance(TextModel, '', this._editor.getModel()?.getLanguageId() ?? PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null));\n        this._setText = derived(reader => {\n            const edit = this._text.read(reader);\n            if (!edit) {\n                return;\n            }\n            this._previewTextModel.setValue(edit);\n        }).recomputeInitiallyAndOnChange(this._store);\n        this._decorations = derived(this, (reader) => {\n            this._setText.read(reader);\n            const position = this._position.read(reader);\n            if (!position) {\n                return { org: [], mod: [] };\n            }\n            const diff = this._diff.read(reader);\n            if (!diff) {\n                return { org: [], mod: [] };\n            }\n            const originalDecorations = [];\n            const modifiedDecorations = [];\n            if (diff.length === 1 && diff[0].innerChanges[0].modifiedRange.equalsRange(this._previewTextModel.getFullModelRange())) {\n                return { org: [], mod: [] };\n            }\n            const shift = this._shift.get();\n            const moveRange = (range) => {\n                return new Range(range.startLineNumber + position.top - 1, range.startColumn + shift, range.endLineNumber + position.top - 1, range.endColumn + shift);\n            };\n            for (const m of diff) {\n                if (!m.original.isEmpty) {\n                    originalDecorations.push({ range: moveRange(m.original.toInclusiveRange()), options: diffLineDeleteDecorationBackgroundWithIndicator });\n                }\n                if (!m.modified.isEmpty) {\n                    modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffLineAddDecorationBackgroundWithIndicator });\n                }\n                if (m.modified.isEmpty || m.original.isEmpty) {\n                    if (!m.original.isEmpty) {\n                        originalDecorations.push({ range: moveRange(m.original.toInclusiveRange()), options: diffWholeLineDeleteDecoration });\n                    }\n                    if (!m.modified.isEmpty) {\n                        modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });\n                    }\n                }\n                else {\n                    for (const i of m.innerChanges || []) {\n                        // Don't show empty markers outside the line range\n                        if (m.original.contains(i.originalRange.startLineNumber)) {\n                            originalDecorations.push({ range: moveRange(i.originalRange), options: i.originalRange.isEmpty() ? diffDeleteDecorationEmpty : diffDeleteDecoration });\n                        }\n                        if (m.modified.contains(i.modifiedRange.startLineNumber)) {\n                            modifiedDecorations.push({ range: i.modifiedRange, options: i.modifiedRange.isEmpty() ? diffAddDecorationEmpty : diffAddDecoration });\n                        }\n                    }\n                }\n            }\n            return { org: originalDecorations, mod: modifiedDecorations };\n        });\n        this._originalDecorations = derived(this, reader => {\n            return this._decorations.read(reader).org;\n        });\n        this._modifiedDecorations = derived(this, reader => {\n            return this._decorations.read(reader).mod;\n        });\n        this._previewEditor.setModel(this._previewTextModel);\n        this._register(this._editorObs.setDecorations(this._originalDecorations));\n        this._register(this._previewEditorObs.setDecorations(this._modifiedDecorations));\n        this._register(autorun(reader => {\n            const width = this._previewEditorObs.contentWidth.read(reader);\n            const lines = this._text.read(reader).split('\\n').length - 1;\n            const height = this._editor.getOption(67 /* EditorOption.lineHeight */) * lines;\n            if (width <= 0) {\n                return;\n            }\n            this._previewEditor.layout({ height: height, width: width });\n        }));\n        this._register(autorun(reader => {\n            /** @description update position */\n            this._position.read(reader);\n            this._editor.layoutOverlayWidget(this);\n        }));\n        this._register(autorun(reader => {\n            /** @description scroll change */\n            this._scrollChanged.read(reader);\n            const position = this._position.read(reader);\n            if (!position) {\n                return;\n            }\n            this._editor.layoutOverlayWidget(this);\n        }));\n    }\n    getId() { return this.id; }\n    getDomNode() {\n        return this._nodes;\n    }\n    getPosition() {\n        const position = this._position.get();\n        if (!position) {\n            return null;\n        }\n        const layoutInfo = this._editor.getLayoutInfo();\n        const visibPos = this._editor.getScrolledVisiblePosition(new Position(position.top, 1));\n        if (!visibPos) {\n            return null;\n        }\n        const top = visibPos.top - 1; //-1 to offset the border width\n        const offset = this._editor.getOffsetForColumn(position.left.lineNumber, position.left.column);\n        const left = layoutInfo.contentLeft + offset + 10;\n        return {\n            preference: {\n                left,\n                top,\n            }\n        };\n    }\n};\nInlineEditSideBySideContentWidget = InlineEditSideBySideContentWidget_1 = __decorate([\n    __param(5, IInstantiationService)\n], InlineEditSideBySideContentWidget);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar InlineEditController_1;\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { autorun, constObservable, observableFromEvent, observableSignalFromEvent, observableValue, transaction } from '../../../../base/common/observable.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GhostTextWidget } from './ghostTextWidget.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { InlineEditTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { GhostText, GhostTextPart } from '../../inlineCompletions/browser/model/ghostText.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { InlineEditHintsWidget } from './inlineEditHintsWidget.js';\nimport { createStyleSheet2 } from '../../../../base/browser/dom.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { derivedDisposable } from '../../../../base/common/observableInternal/derived.js';\nimport { InlineEditSideBySideWidget } from './inlineEditSideBySideWidget.js';\nimport { IDiffProviderFactoryService } from '../../../browser/widget/diffEditor/diffProviderFactoryService.js';\nimport { IModelService } from '../../../common/services/model.js';\nlet InlineEditController = class InlineEditController extends Disposable {\n    static { InlineEditController_1 = this; }\n    static { this.ID = 'editor.contrib.inlineEditController'; }\n    static { this.inlineEditVisibleKey = 'inlineEditVisible'; }\n    static { this.inlineEditVisibleContext = new RawContextKey(this.inlineEditVisibleKey, false); }\n    static { this.cursorAtInlineEditKey = 'cursorAtInlineEdit'; }\n    static { this.cursorAtInlineEditContext = new RawContextKey(this.cursorAtInlineEditKey, false); }\n    static get(editor) {\n        return editor.getContribution(InlineEditController_1.ID);\n    }\n    constructor(editor, instantiationService, contextKeyService, languageFeaturesService, _commandService, _configurationService, _diffProviderFactoryService, _modelService) {\n        super();\n        this.editor = editor;\n        this.instantiationService = instantiationService;\n        this.contextKeyService = contextKeyService;\n        this.languageFeaturesService = languageFeaturesService;\n        this._commandService = _commandService;\n        this._configurationService = _configurationService;\n        this._diffProviderFactoryService = _diffProviderFactoryService;\n        this._modelService = _modelService;\n        this._isVisibleContext = InlineEditController_1.inlineEditVisibleContext.bindTo(this.contextKeyService);\n        this._isCursorAtInlineEditContext = InlineEditController_1.cursorAtInlineEditContext.bindTo(this.contextKeyService);\n        this._currentEdit = observableValue(this, undefined);\n        this._currentWidget = derivedDisposable(this._currentEdit, (reader) => {\n            const edit = this._currentEdit.read(reader);\n            if (!edit) {\n                return undefined;\n            }\n            const line = edit.range.endLineNumber;\n            const column = edit.range.endColumn;\n            const textToDisplay = edit.text.endsWith('\\n') && !(edit.range.startLineNumber === edit.range.endLineNumber && edit.range.startColumn === edit.range.endColumn) ? edit.text.slice(0, -1) : edit.text;\n            const ghostText = new GhostText(line, [new GhostTextPart(column, textToDisplay, false)]);\n            //only show ghost text for single line edits\n            //unless it is a pure removal\n            //multi line edits are shown in the side by side widget\n            const isSingleLine = edit.range.startLineNumber === edit.range.endLineNumber && ghostText.parts.length === 1 && ghostText.parts[0].lines.length === 1;\n            const isPureRemoval = edit.text === '';\n            if (!isSingleLine && !isPureRemoval) {\n                return undefined;\n            }\n            const instance = this.instantiationService.createInstance(GhostTextWidget, this.editor, {\n                ghostText: constObservable(ghostText),\n                minReservedLineCount: constObservable(0),\n                targetTextModel: constObservable(this.editor.getModel() ?? undefined),\n                range: constObservable(edit.range)\n            });\n            return instance;\n        });\n        this._isAccepting = observableValue(this, false);\n        this._enabled = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(63 /* EditorOption.inlineEdit */).enabled);\n        this._fontFamily = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(63 /* EditorOption.inlineEdit */).fontFamily);\n        //Automatically request inline edit when the content was changed\n        //Cancel the previous request if there is one\n        //Remove the previous ghost text\n        const modelChangedSignal = observableSignalFromEvent('InlineEditController.modelContentChangedSignal', editor.onDidChangeModelContent);\n        this._register(autorun(reader => {\n            /** @description InlineEditController.modelContentChanged model */\n            if (!this._enabled.read(reader)) {\n                return;\n            }\n            modelChangedSignal.read(reader);\n            if (this._isAccepting.read(reader)) {\n                return;\n            }\n            this.getInlineEdit(editor, true);\n        }));\n        //Check if the cursor is at the ghost text\n        const cursorPosition = observableFromEvent(this, editor.onDidChangeCursorPosition, () => editor.getPosition());\n        this._register(autorun(reader => {\n            /** @description InlineEditController.cursorPositionChanged model */\n            if (!this._enabled.read(reader)) {\n                return;\n            }\n            const pos = cursorPosition.read(reader);\n            if (pos) {\n                this.checkCursorPosition(pos);\n            }\n        }));\n        //Perform stuff when the current edit has changed\n        this._register(autorun((reader) => {\n            /** @description InlineEditController.update model */\n            const currentEdit = this._currentEdit.read(reader);\n            this._isCursorAtInlineEditContext.set(false);\n            if (!currentEdit) {\n                this._isVisibleContext.set(false);\n                return;\n            }\n            this._isVisibleContext.set(true);\n            const pos = editor.getPosition();\n            if (pos) {\n                this.checkCursorPosition(pos);\n            }\n        }));\n        //Clear suggestions on lost focus\n        const editorBlurSingal = observableSignalFromEvent('InlineEditController.editorBlurSignal', editor.onDidBlurEditorWidget);\n        this._register(autorun(async (reader) => {\n            /** @description InlineEditController.editorBlur */\n            if (!this._enabled.read(reader)) {\n                return;\n            }\n            editorBlurSingal.read(reader);\n            // This is a hidden setting very useful for debugging\n            if (this._configurationService.getValue('editor.experimentalInlineEdit.keepOnBlur') || editor.getOption(63 /* EditorOption.inlineEdit */).keepOnBlur) {\n                return;\n            }\n            this._currentRequestCts?.dispose(true);\n            this._currentRequestCts = undefined;\n            await this.clear(false);\n        }));\n        //Invoke provider on focus\n        const editorFocusSignal = observableSignalFromEvent('InlineEditController.editorFocusSignal', editor.onDidFocusEditorText);\n        this._register(autorun(reader => {\n            /** @description InlineEditController.editorFocus */\n            if (!this._enabled.read(reader)) {\n                return;\n            }\n            editorFocusSignal.read(reader);\n            this.getInlineEdit(editor, true);\n        }));\n        //handle changes of font setting\n        const styleElement = this._register(createStyleSheet2());\n        this._register(autorun(reader => {\n            const fontFamily = this._fontFamily.read(reader);\n            styleElement.setStyle(fontFamily === '' || fontFamily === 'default' ? `` : `\n.monaco-editor .inline-edit-decoration,\n.monaco-editor .inline-edit-decoration-preview,\n.monaco-editor .inline-edit {\n\tfont-family: ${fontFamily};\n}`);\n        }));\n        this._register(new InlineEditHintsWidget(this.editor, this._currentWidget, this.instantiationService));\n        this._register(new InlineEditSideBySideWidget(this.editor, this._currentEdit, this.instantiationService, this._diffProviderFactoryService, this._modelService));\n    }\n    checkCursorPosition(position) {\n        if (!this._currentEdit) {\n            this._isCursorAtInlineEditContext.set(false);\n            return;\n        }\n        const gt = this._currentEdit.get();\n        if (!gt) {\n            this._isCursorAtInlineEditContext.set(false);\n            return;\n        }\n        this._isCursorAtInlineEditContext.set(Range.containsPosition(gt.range, position));\n    }\n    validateInlineEdit(editor, edit) {\n        //Multiline inline replacing edit must replace whole lines\n        if (edit.text.includes('\\n') && edit.range.startLineNumber !== edit.range.endLineNumber && edit.range.startColumn !== edit.range.endColumn) {\n            const firstColumn = edit.range.startColumn;\n            if (firstColumn !== 1) {\n                return false;\n            }\n            const lastLine = edit.range.endLineNumber;\n            const lastColumn = edit.range.endColumn;\n            const lineLength = editor.getModel()?.getLineLength(lastLine) ?? 0;\n            if (lastColumn !== lineLength + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async fetchInlineEdit(editor, auto) {\n        if (this._currentRequestCts) {\n            this._currentRequestCts.dispose(true);\n        }\n        const model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        const modelVersion = model.getVersionId();\n        const providers = this.languageFeaturesService.inlineEditProvider.all(model);\n        if (providers.length === 0) {\n            return;\n        }\n        const provider = providers[0];\n        this._currentRequestCts = new CancellationTokenSource();\n        const token = this._currentRequestCts.token;\n        const triggerKind = auto ? InlineEditTriggerKind.Automatic : InlineEditTriggerKind.Invoke;\n        const shouldDebounce = auto;\n        if (shouldDebounce) {\n            await wait(50, token);\n        }\n        if (token.isCancellationRequested || model.isDisposed() || model.getVersionId() !== modelVersion) {\n            return;\n        }\n        const edit = await provider.provideInlineEdit(model, { triggerKind }, token);\n        if (!edit) {\n            return;\n        }\n        if (token.isCancellationRequested || model.isDisposed() || model.getVersionId() !== modelVersion) {\n            return;\n        }\n        if (!this.validateInlineEdit(editor, edit)) {\n            return;\n        }\n        return edit;\n    }\n    async getInlineEdit(editor, auto) {\n        this._isCursorAtInlineEditContext.set(false);\n        await this.clear();\n        const edit = await this.fetchInlineEdit(editor, auto);\n        if (!edit) {\n            return;\n        }\n        this._currentEdit.set(edit, undefined);\n    }\n    async trigger() {\n        await this.getInlineEdit(this.editor, false);\n    }\n    async jumpBack() {\n        if (!this._jumpBackPosition) {\n            return;\n        }\n        this.editor.setPosition(this._jumpBackPosition);\n        //if position is outside viewports, scroll to it\n        this.editor.revealPositionInCenterIfOutsideViewport(this._jumpBackPosition);\n    }\n    async accept() {\n        this._isAccepting.set(true, undefined);\n        const data = this._currentEdit.get();\n        if (!data) {\n            return;\n        }\n        //It should only happen in case of last line suggestion\n        let text = data.text;\n        if (data.text.startsWith('\\n')) {\n            text = data.text.substring(1);\n        }\n        this.editor.pushUndoStop();\n        this.editor.executeEdits('acceptCurrent', [EditOperation.replace(Range.lift(data.range), text)]);\n        if (data.accepted) {\n            await this._commandService\n                .executeCommand(data.accepted.id, ...(data.accepted.arguments || []))\n                .then(undefined, onUnexpectedExternalError);\n        }\n        this.freeEdit(data);\n        transaction((tx) => {\n            this._currentEdit.set(undefined, tx);\n            this._isAccepting.set(false, tx);\n        });\n    }\n    jumpToCurrent() {\n        this._jumpBackPosition = this.editor.getSelection()?.getStartPosition();\n        const data = this._currentEdit.get();\n        if (!data) {\n            return;\n        }\n        const position = Position.lift({ lineNumber: data.range.startLineNumber, column: data.range.startColumn });\n        this.editor.setPosition(position);\n        //if position is outside viewports, scroll to it\n        this.editor.revealPositionInCenterIfOutsideViewport(position);\n    }\n    async clear(sendRejection = true) {\n        const edit = this._currentEdit.get();\n        if (edit && edit?.rejected && sendRejection) {\n            await this._commandService\n                .executeCommand(edit.rejected.id, ...(edit.rejected.arguments || []))\n                .then(undefined, onUnexpectedExternalError);\n        }\n        if (edit) {\n            this.freeEdit(edit);\n        }\n        this._currentEdit.set(undefined, undefined);\n    }\n    freeEdit(edit) {\n        const model = this.editor.getModel();\n        if (!model) {\n            return;\n        }\n        const providers = this.languageFeaturesService.inlineEditProvider.all(model);\n        if (providers.length === 0) {\n            return;\n        }\n        providers[0].freeInlineEdit(edit);\n    }\n};\nInlineEditController = InlineEditController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IContextKeyService),\n    __param(3, ILanguageFeaturesService),\n    __param(4, ICommandService),\n    __param(5, IConfigurationService),\n    __param(6, IDiffProviderFactoryService),\n    __param(7, IModelService)\n], InlineEditController);\nexport { InlineEditController };\nfunction wait(ms, cancellationToken) {\n    return new Promise(resolve => {\n        let d = undefined;\n        const handle = setTimeout(() => {\n            if (d) {\n                d.dispose();\n            }\n            resolve();\n        }, ms);\n        if (cancellationToken) {\n            d = cancellationToken.onCancellationRequested(() => {\n                clearTimeout(handle);\n                if (d) {\n                    d.dispose();\n                }\n                resolve();\n            });\n        }\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { h, svgElem } from '../../../../base/browser/dom.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { autorun, constObservable, derived } from '../../../../base/common/observable.js';\nimport { derivedWithSetter } from '../../../../base/common/observableInternal/derived.js';\nimport './inlineEditsWidget.css';\nimport { EditorExtensionsRegistry } from '../../../browser/editorExtensions.js';\nimport { observableCodeEditor } from '../../../browser/observableCodeEditor.js';\nimport { EmbeddedCodeEditorWidget } from '../../../browser/widget/codeEditor/embeddedCodeEditorWidget.js';\nimport { diffAddDecoration, diffAddDecorationEmpty, diffDeleteDecoration, diffDeleteDecorationEmpty, diffLineAddDecorationBackgroundWithIndicator, diffLineDeleteDecorationBackgroundWithIndicator, diffWholeLineAddDecoration, diffWholeLineDeleteDecoration } from '../../../browser/widget/diffEditor/registrations.contribution.js';\nimport { appendRemoveOnDispose, applyStyle } from '../../../browser/widget/diffEditor/utils.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../../../common/languages/modesRegistry.js';\nimport { TextModel } from '../../../common/model/textModel.js';\nimport { ContextMenuController } from '../../contextmenu/browser/contextmenu.js';\nimport { PlaceholderTextContribution } from '../../placeholderText/browser/placeholderTextContribution.js';\nimport { SuggestController } from '../../suggest/browser/suggestController.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nexport class InlineEdit {\n    constructor(range, newLines, changes) {\n        this.range = range;\n        this.newLines = newLines;\n        this.changes = changes;\n    }\n}\nlet InlineEditsWidget = class InlineEditsWidget extends Disposable {\n    constructor(_editor, _edit, _userPrompt, _instantiationService) {\n        super();\n        this._editor = _editor;\n        this._edit = _edit;\n        this._userPrompt = _userPrompt;\n        this._instantiationService = _instantiationService;\n        this._editorObs = observableCodeEditor(this._editor);\n        this._elements = h('div.inline-edits-widget', {\n            style: {\n                position: 'absolute',\n                overflow: 'visible',\n                top: '0px',\n                left: '0px',\n            },\n        }, [\n            h('div@editorContainer', { style: { position: 'absolute', top: '0px', left: '0px', width: '500px', height: '500px', } }, [\n                h('div.toolbar@toolbar', { style: { position: 'absolute', top: '-25px', left: '0px' } }),\n                h('div.promptEditor@promptEditor', { style: { position: 'absolute', top: '-25px', left: '80px', width: '300px', height: '22px' } }),\n                h('div.preview@editor', { style: { position: 'absolute', top: '0px', left: '0px' } }),\n            ]),\n            svgElem('svg', { style: { overflow: 'visible', pointerEvents: 'none' }, }, [\n                svgElem('defs', [\n                    svgElem('linearGradient', {\n                        id: 'Gradient2',\n                        x1: '0',\n                        y1: '0',\n                        x2: '1',\n                        y2: '0',\n                    }, [\n                        /*svgElem('stop', { offset: '0%', class: 'gradient-start', }),\n                        svgElem('stop', { offset: '0%', class: 'gradient-start', }),\n                        svgElem('stop', { offset: '20%', class: 'gradient-stop', }),*/\n                        svgElem('stop', { offset: '0%', class: 'gradient-stop', }),\n                        svgElem('stop', { offset: '100%', class: 'gradient-stop', }),\n                    ]),\n                ]),\n                svgElem('path@path', {\n                    d: '',\n                    fill: 'url(#Gradient2)',\n                }),\n            ]),\n        ]);\n        this._previewTextModel = this._register(this._instantiationService.createInstance(TextModel, '', PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null));\n        this._setText = derived(reader => {\n            const edit = this._edit.read(reader);\n            if (!edit) {\n                return;\n            }\n            this._previewTextModel.setValue(edit.newLines.join('\\n'));\n        }).recomputeInitiallyAndOnChange(this._store);\n        this._promptTextModel = this._register(this._instantiationService.createInstance(TextModel, '', PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null));\n        this._promptEditor = this._register(this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._elements.promptEditor, {\n            glyphMargin: false,\n            lineNumbers: 'off',\n            minimap: { enabled: false },\n            guides: {\n                indentation: false,\n                bracketPairs: false,\n                bracketPairsHorizontal: false,\n                highlightActiveIndentation: false,\n            },\n            folding: false,\n            selectOnLineNumbers: false,\n            selectionHighlight: false,\n            columnSelection: false,\n            overviewRulerBorder: false,\n            overviewRulerLanes: 0,\n            lineDecorationsWidth: 0,\n            lineNumbersMinChars: 0,\n            placeholder: 'Describe the change you want...',\n            fontFamily: DEFAULT_FONT_FAMILY,\n        }, {\n            contributions: EditorExtensionsRegistry.getSomeEditorContributions([\n                SuggestController.ID,\n                PlaceholderTextContribution.ID,\n                ContextMenuController.ID,\n            ]),\n            isSimpleWidget: true\n        }, this._editor));\n        this._previewEditor = this._register(this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._elements.editor, {\n            glyphMargin: false,\n            lineNumbers: 'off',\n            minimap: { enabled: false },\n            guides: {\n                indentation: false,\n                bracketPairs: false,\n                bracketPairsHorizontal: false,\n                highlightActiveIndentation: false,\n            },\n            folding: false,\n            selectOnLineNumbers: false,\n            selectionHighlight: false,\n            columnSelection: false,\n            overviewRulerBorder: false,\n            overviewRulerLanes: 0,\n            lineDecorationsWidth: 0,\n            lineNumbersMinChars: 0,\n        }, { contributions: [], }, this._editor));\n        this._previewEditorObs = observableCodeEditor(this._previewEditor);\n        this._decorations = derived(this, (reader) => {\n            this._setText.read(reader);\n            const diff = this._edit.read(reader)?.changes;\n            if (!diff) {\n                return [];\n            }\n            const originalDecorations = [];\n            const modifiedDecorations = [];\n            if (diff.length === 1 && diff[0].innerChanges[0].modifiedRange.equalsRange(this._previewTextModel.getFullModelRange())) {\n                return [];\n            }\n            for (const m of diff) {\n                if (!m.original.isEmpty) {\n                    originalDecorations.push({ range: m.original.toInclusiveRange(), options: diffLineDeleteDecorationBackgroundWithIndicator });\n                }\n                if (!m.modified.isEmpty) {\n                    modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffLineAddDecorationBackgroundWithIndicator });\n                }\n                if (m.modified.isEmpty || m.original.isEmpty) {\n                    if (!m.original.isEmpty) {\n                        originalDecorations.push({ range: m.original.toInclusiveRange(), options: diffWholeLineDeleteDecoration });\n                    }\n                    if (!m.modified.isEmpty) {\n                        modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });\n                    }\n                }\n                else {\n                    for (const i of m.innerChanges || []) {\n                        // Don't show empty markers outside the line range\n                        if (m.original.contains(i.originalRange.startLineNumber)) {\n                            originalDecorations.push({ range: i.originalRange, options: i.originalRange.isEmpty() ? diffDeleteDecorationEmpty : diffDeleteDecoration });\n                        }\n                        if (m.modified.contains(i.modifiedRange.startLineNumber)) {\n                            modifiedDecorations.push({ range: i.modifiedRange, options: i.modifiedRange.isEmpty() ? diffAddDecorationEmpty : diffAddDecoration });\n                        }\n                    }\n                }\n            }\n            return modifiedDecorations;\n        });\n        this._layout1 = derived(this, reader => {\n            const model = this._editor.getModel();\n            const inlineEdit = this._edit.read(reader);\n            if (!inlineEdit) {\n                return null;\n            }\n            const range = inlineEdit.range;\n            let maxLeft = 0;\n            for (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {\n                const column = model.getLineMaxColumn(i);\n                const left = this._editor.getOffsetForColumn(i, column);\n                maxLeft = Math.max(maxLeft, left);\n            }\n            const layoutInfo = this._editor.getLayoutInfo();\n            const contentLeft = layoutInfo.contentLeft;\n            return { left: contentLeft + maxLeft };\n        });\n        this._layout = derived(this, (reader) => {\n            const inlineEdit = this._edit.read(reader);\n            if (!inlineEdit) {\n                return null;\n            }\n            const range = inlineEdit.range;\n            const scrollLeft = this._editorObs.scrollLeft.read(reader);\n            const left = this._layout1.read(reader).left + 20 - scrollLeft;\n            const selectionTop = this._editor.getTopForLineNumber(range.startLineNumber) - this._editorObs.scrollTop.read(reader);\n            const selectionBottom = this._editor.getTopForLineNumber(range.endLineNumberExclusive) - this._editorObs.scrollTop.read(reader);\n            const topCode = new Point(left, selectionTop);\n            const bottomCode = new Point(left, selectionBottom);\n            const codeHeight = selectionBottom - selectionTop;\n            const codeEditDist = 50;\n            const editHeight = this._editor.getOption(67 /* EditorOption.lineHeight */) * inlineEdit.newLines.length;\n            const difference = codeHeight - editHeight;\n            const topEdit = new Point(left + codeEditDist, selectionTop + (difference / 2));\n            const bottomEdit = new Point(left + codeEditDist, selectionBottom - (difference / 2));\n            return {\n                topCode,\n                bottomCode,\n                codeHeight,\n                topEdit,\n                bottomEdit,\n                editHeight,\n            };\n        });\n        const visible = derived(this, reader => this._edit.read(reader) !== undefined || this._userPrompt.read(reader) !== undefined);\n        this._register(applyStyle(this._elements.root, {\n            display: derived(this, reader => visible.read(reader) ? 'block' : 'none')\n        }));\n        this._register(appendRemoveOnDispose(this._editor.getDomNode(), this._elements.root));\n        this._register(observableCodeEditor(_editor).createOverlayWidget({\n            domNode: this._elements.root,\n            position: constObservable(null),\n            allowEditorOverflow: false,\n            minContentWidthInPx: derived(reader => {\n                const x = this._layout1.read(reader)?.left;\n                if (x === undefined) {\n                    return 0;\n                }\n                const width = this._previewEditorObs.contentWidth.read(reader);\n                return x + width;\n            }),\n        }));\n        this._previewEditor.setModel(this._previewTextModel);\n        this._register(this._previewEditorObs.setDecorations(this._decorations));\n        this._register(autorun(reader => {\n            const layoutInfo = this._layout.read(reader);\n            if (!layoutInfo) {\n                return;\n            }\n            const { topCode, bottomCode, topEdit, bottomEdit, editHeight } = layoutInfo;\n            const straightWidthCode = 10;\n            const straightWidthEdit = 0;\n            const bezierDist = 40;\n            const path = new PathBuilder()\n                .moveTo(topCode)\n                .lineTo(topCode.deltaX(straightWidthCode))\n                .curveTo(topCode.deltaX(straightWidthCode + bezierDist), topEdit.deltaX(-bezierDist - straightWidthEdit), topEdit.deltaX(-straightWidthEdit))\n                .lineTo(topEdit)\n                .lineTo(bottomEdit)\n                .lineTo(bottomEdit.deltaX(-straightWidthEdit))\n                .curveTo(bottomEdit.deltaX(-bezierDist - straightWidthEdit), bottomCode.deltaX(straightWidthCode + bezierDist), bottomCode.deltaX(straightWidthCode))\n                .lineTo(bottomCode)\n                .build();\n            this._elements.path.setAttribute('d', path);\n            this._elements.editorContainer.style.top = `${topEdit.y}px`;\n            this._elements.editorContainer.style.left = `${topEdit.x}px`;\n            this._elements.editorContainer.style.height = `${editHeight}px`;\n            const width = this._previewEditorObs.contentWidth.read(reader);\n            this._previewEditor.layout({ height: editHeight, width });\n        }));\n        this._promptEditor.setModel(this._promptTextModel);\n        this._promptEditor.layout();\n        this._register(createTwoWaySync(mapSettableObservable(this._userPrompt, v => v ?? '', v => v), observableCodeEditor(this._promptEditor).value));\n        this._register(autorun(reader => {\n            const isFocused = observableCodeEditor(this._promptEditor).isFocused.read(reader);\n            this._elements.root.classList.toggle('focused', isFocused);\n        }));\n    }\n};\nInlineEditsWidget = __decorate([\n    __param(3, IInstantiationService)\n], InlineEditsWidget);\nexport { InlineEditsWidget };\nfunction mapSettableObservable(obs, fn1, fn2) {\n    return derivedWithSetter(undefined, reader => fn1(obs.read(reader)), (value, tx) => obs.set(fn2(value), tx));\n}\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    deltaX(delta) {\n        return new Point(this.x + delta, this.y);\n    }\n}\nclass PathBuilder {\n    constructor() {\n        this._data = '';\n    }\n    moveTo(point) {\n        this._data += `M ${point.x} ${point.y} `;\n        return this;\n    }\n    lineTo(point) {\n        this._data += `L ${point.x} ${point.y} `;\n        return this;\n    }\n    curveTo(cp1, cp2, to) {\n        this._data += `C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${to.x} ${to.y} `;\n        return this;\n    }\n    build() {\n        return this._data;\n    }\n}\nfunction createTwoWaySync(main, target) {\n    const store = new DisposableStore();\n    store.add(autorun(reader => {\n        const value = main.read(reader);\n        target.set(value, undefined);\n    }));\n    store.add(autorun(reader => {\n        const value = target.read(reader);\n        main.set(value, undefined);\n    }));\n    return store;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar InlineEditsModel_1;\nimport { timeout } from '../../../../base/common/async.js';\nimport { CancellationToken, cancelOnDispose } from '../../../../base/common/cancellation.js';\nimport { itemsEquals, structuralEquals } from '../../../../base/common/equals.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ObservablePromise, derived, derivedHandleChanges, derivedOpts, disposableObservableValue, observableSignal, observableValue, recomputeInitiallyAndOnChange, subtransaction } from '../../../../base/common/observable.js';\nimport { derivedDisposable } from '../../../../base/common/observableInternal/derived.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IDiffProviderFactoryService } from '../../../browser/widget/diffEditor/diffProviderFactoryService.js';\nimport { LineRange } from '../../../common/core/lineRange.js';\nimport { InlineCompletionTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { provideInlineCompletions } from '../../inlineCompletions/browser/model/provideInlineCompletions.js';\nimport { InlineEdit } from './inlineEditsWidget.js';\nlet InlineEditsModel = class InlineEditsModel extends Disposable {\n    static { InlineEditsModel_1 = this; }\n    static { this._modelId = 0; }\n    static _createUniqueUri() {\n        return URI.from({ scheme: 'inline-edits', path: new Date().toString() + String(InlineEditsModel_1._modelId++) });\n    }\n    constructor(textModel, _textModelVersionId, _selection, _debounceValue, languageFeaturesService, _diffProviderFactoryService, _modelService) {\n        super();\n        this.textModel = textModel;\n        this._textModelVersionId = _textModelVersionId;\n        this._selection = _selection;\n        this._debounceValue = _debounceValue;\n        this.languageFeaturesService = languageFeaturesService;\n        this._diffProviderFactoryService = _diffProviderFactoryService;\n        this._modelService = _modelService;\n        this._forceUpdateExplicitlySignal = observableSignal(this);\n        // We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n        this._selectedInlineCompletionId = observableValue(this, undefined);\n        this._isActive = observableValue(this, false);\n        this._originalModel = derivedDisposable(() => this._modelService.createModel('', null, InlineEditsModel_1._createUniqueUri())).keepObserved(this._store);\n        this._modifiedModel = derivedDisposable(() => this._modelService.createModel('', null, InlineEditsModel_1._createUniqueUri())).keepObserved(this._store);\n        this._pinnedRange = new TrackedRange(this.textModel, this._textModelVersionId);\n        this.isPinned = this._pinnedRange.range.map(range => !!range);\n        this.userPrompt = observableValue(this, undefined);\n        this.inlineEdit = derived(this, reader => {\n            return this._inlineEdit.read(reader)?.promiseResult.read(reader)?.data;\n        });\n        this._inlineEdit = derived(this, reader => {\n            const edit = this.selectedInlineEdit.read(reader);\n            if (!edit) {\n                return undefined;\n            }\n            const range = edit.inlineCompletion.range;\n            if (edit.inlineCompletion.insertText.trim() === '') {\n                return undefined;\n            }\n            let newLines = edit.inlineCompletion.insertText.split(/\\r\\n|\\r|\\n/);\n            function removeIndentation(lines) {\n                const indentation = lines[0].match(/^\\s*/)?.[0] ?? '';\n                return lines.map(l => l.replace(new RegExp('^' + indentation), ''));\n            }\n            newLines = removeIndentation(newLines);\n            const existing = this.textModel.getValueInRange(range);\n            let existingLines = existing.split(/\\r\\n|\\r|\\n/);\n            existingLines = removeIndentation(existingLines);\n            this._originalModel.get().setValue(existingLines.join('\\n'));\n            this._modifiedModel.get().setValue(newLines.join('\\n'));\n            const d = this._diffProviderFactoryService.createDiffProvider({ diffAlgorithm: 'advanced' });\n            return ObservablePromise.fromFn(async () => {\n                const result = await d.computeDiff(this._originalModel.get(), this._modifiedModel.get(), {\n                    computeMoves: false,\n                    ignoreTrimWhitespace: false,\n                    maxComputationTimeMs: 1000,\n                }, CancellationToken.None);\n                if (result.identical) {\n                    return undefined;\n                }\n                return new InlineEdit(LineRange.fromRangeInclusive(range), removeIndentation(newLines), result.changes);\n            });\n        });\n        this._fetchStore = this._register(new DisposableStore());\n        this._inlineEditsFetchResult = disposableObservableValue(this, undefined);\n        this._inlineEdits = derivedOpts({ owner: this, equalsFn: structuralEquals }, reader => {\n            return this._inlineEditsFetchResult.read(reader)?.completions.map(c => new InlineEditData(c)) ?? [];\n        });\n        this._fetchInlineEditsPromise = derivedHandleChanges({\n            owner: this,\n            createEmptyChangeSummary: () => ({\n                inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n            }),\n            handleChange: (ctx, changeSummary) => {\n                /** @description fetch inline completions */\n                if (ctx.didChange(this._forceUpdateExplicitlySignal)) {\n                    changeSummary.inlineCompletionTriggerKind = InlineCompletionTriggerKind.Explicit;\n                }\n                return true;\n            },\n        }, async (reader, changeSummary) => {\n            this._fetchStore.clear();\n            this._forceUpdateExplicitlySignal.read(reader);\n            /*if (!this._isActive.read(reader)) {\n                return undefined;\n            }*/\n            this._textModelVersionId.read(reader);\n            function mapValue(value, fn) {\n                return fn(value);\n            }\n            const selection = this._pinnedRange.range.read(reader) ?? mapValue(this._selection.read(reader), v => v.isEmpty() ? undefined : v);\n            if (!selection) {\n                this._inlineEditsFetchResult.set(undefined, undefined);\n                this.userPrompt.set(undefined, undefined);\n                return undefined;\n            }\n            const context = {\n                triggerKind: changeSummary.inlineCompletionTriggerKind,\n                selectedSuggestionInfo: undefined,\n                userPrompt: this.userPrompt.read(reader),\n            };\n            const token = cancelOnDispose(this._fetchStore);\n            await timeout(200, token);\n            const result = await provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, selection, this.textModel, context, token);\n            if (token.isCancellationRequested) {\n                return;\n            }\n            this._inlineEditsFetchResult.set(result, undefined);\n        });\n        this._filteredInlineEditItems = derivedOpts({ owner: this, equalsFn: itemsEquals() }, reader => {\n            return this._inlineEdits.read(reader);\n        });\n        this.selectedInlineCompletionIndex = derived(this, (reader) => {\n            const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n            const filteredCompletions = this._filteredInlineEditItems.read(reader);\n            const idx = this._selectedInlineCompletionId === undefined ? -1\n                : filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n            if (idx === -1) {\n                // Reset the selection so that the selection does not jump back when it appears again\n                this._selectedInlineCompletionId.set(undefined, undefined);\n                return 0;\n            }\n            return idx;\n        });\n        this.selectedInlineEdit = derived(this, (reader) => {\n            const filteredCompletions = this._filteredInlineEditItems.read(reader);\n            const idx = this.selectedInlineCompletionIndex.read(reader);\n            return filteredCompletions[idx];\n        });\n        this._register(recomputeInitiallyAndOnChange(this._fetchInlineEditsPromise));\n    }\n    async triggerExplicitly(tx) {\n        subtransaction(tx, tx => {\n            this._isActive.set(true, tx);\n            this._forceUpdateExplicitlySignal.trigger(tx);\n        });\n        await this._fetchInlineEditsPromise.get();\n    }\n    stop(tx) {\n        subtransaction(tx, tx => {\n            this.userPrompt.set(undefined, tx);\n            this._isActive.set(false, tx);\n            this._inlineEditsFetchResult.set(undefined, tx);\n            this._pinnedRange.setRange(undefined, tx);\n            //this._source.clear(tx);\n        });\n    }\n    async _deltaSelectedInlineCompletionIndex(delta) {\n        await this.triggerExplicitly();\n        const completions = this._filteredInlineEditItems.get() || [];\n        if (completions.length > 0) {\n            const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n            this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n        }\n        else {\n            this._selectedInlineCompletionId.set(undefined, undefined);\n        }\n    }\n    async next() {\n        await this._deltaSelectedInlineCompletionIndex(1);\n    }\n    async previous() {\n        await this._deltaSelectedInlineCompletionIndex(-1);\n    }\n    async accept(editor) {\n        if (editor.getModel() !== this.textModel) {\n            throw new BugIndicatingError();\n        }\n        const edit = this.selectedInlineEdit.get();\n        if (!edit) {\n            return;\n        }\n        editor.pushUndoStop();\n        editor.executeEdits('inlineSuggestion.accept', [\n            edit.inlineCompletion.toSingleTextEdit().toSingleEditOperation()\n        ]);\n        this.stop();\n    }\n};\nInlineEditsModel = InlineEditsModel_1 = __decorate([\n    __param(4, ILanguageFeaturesService),\n    __param(5, IDiffProviderFactoryService),\n    __param(6, IModelService)\n], InlineEditsModel);\nexport { InlineEditsModel };\nclass InlineEditData {\n    constructor(inlineCompletion) {\n        this.inlineCompletion = inlineCompletion;\n        this.semanticId = this.inlineCompletion.hash();\n    }\n}\nclass TrackedRange extends Disposable {\n    constructor(_textModel, _versionId) {\n        super();\n        this._textModel = _textModel;\n        this._versionId = _versionId;\n        this._decorations = observableValue(this, []);\n        this.range = derived(this, reader => {\n            this._versionId.read(reader);\n            const deco = this._decorations.read(reader)[0];\n            if (!deco) {\n                return null;\n            }\n            return this._textModel.getDecorationRange(deco) ?? null;\n        });\n        this._register(toDisposable(() => {\n            this._textModel.deltaDecorations(this._decorations.get(), []);\n        }));\n    }\n    setRange(range, tx) {\n        this._decorations.set(this._textModel.deltaDecorations(this._decorations.get(), range ? [{ range, options: { description: 'trackedRange' } }] : []), tx);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar RenameController_1;\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { CancellationError, onUnexpectedError } from '../../../../base/common/errors.js';\nimport { isMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { NewSymbolNameTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ITextResourceConfigurationService } from '../../../common/services/textResourceConfiguration.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport * as nls from '../../../../nls.js';\nimport { Action2, registerAction2 } from '../../../../platform/actions/common/actions.js';\nimport { Extensions } from '../../../../platform/configuration/common/configurationRegistry.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { IEditorProgressService } from '../../../../platform/progress/common/progress.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { CONTEXT_RENAME_INPUT_VISIBLE, RenameWidget } from './renameWidget.js';\nclass RenameSkeleton {\n    constructor(model, position, registry) {\n        this.model = model;\n        this.position = position;\n        this._providerRenameIdx = 0;\n        this._providers = registry.ordered(model);\n    }\n    hasProvider() {\n        return this._providers.length > 0;\n    }\n    async resolveRenameLocation(token) {\n        const rejects = [];\n        for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {\n            const provider = this._providers[this._providerRenameIdx];\n            if (!provider.resolveRenameLocation) {\n                break;\n            }\n            const res = await provider.resolveRenameLocation(this.model, this.position, token);\n            if (!res) {\n                continue;\n            }\n            if (res.rejectReason) {\n                rejects.push(res.rejectReason);\n                continue;\n            }\n            return res;\n        }\n        // we are here when no provider prepared a location which means we can\n        // just rely on the word under cursor and start with the first provider\n        this._providerRenameIdx = 0;\n        const word = this.model.getWordAtPosition(this.position);\n        if (!word) {\n            return {\n                range: Range.fromPositions(this.position),\n                text: '',\n                rejectReason: rejects.length > 0 ? rejects.join('\\n') : undefined\n            };\n        }\n        return {\n            range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),\n            text: word.word,\n            rejectReason: rejects.length > 0 ? rejects.join('\\n') : undefined\n        };\n    }\n    async provideRenameEdits(newName, token) {\n        return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);\n    }\n    async _provideRenameEdits(newName, i, rejects, token) {\n        const provider = this._providers[i];\n        if (!provider) {\n            return {\n                edits: [],\n                rejectReason: rejects.join('\\n')\n            };\n        }\n        const result = await provider.provideRenameEdits(this.model, this.position, newName, token);\n        if (!result) {\n            return this._provideRenameEdits(newName, i + 1, rejects.concat(nls.localize('no result', \"No result.\")), token);\n        }\n        else if (result.rejectReason) {\n            return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);\n        }\n        return result;\n    }\n}\nexport async function rename(registry, model, position, newName) {\n    const skeleton = new RenameSkeleton(model, position, registry);\n    const loc = await skeleton.resolveRenameLocation(CancellationToken.None);\n    if (loc?.rejectReason) {\n        return { edits: [], rejectReason: loc.rejectReason };\n    }\n    return skeleton.provideRenameEdits(newName, CancellationToken.None);\n}\n// ---  register actions and commands\nlet RenameController = class RenameController {\n    static { RenameController_1 = this; }\n    static { this.ID = 'editor.contrib.renameController'; }\n    static get(editor) {\n        return editor.getContribution(RenameController_1.ID);\n    }\n    constructor(editor, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService, _telemetryService) {\n        this.editor = editor;\n        this._instaService = _instaService;\n        this._notificationService = _notificationService;\n        this._bulkEditService = _bulkEditService;\n        this._progressService = _progressService;\n        this._logService = _logService;\n        this._configService = _configService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._telemetryService = _telemetryService;\n        this._disposableStore = new DisposableStore();\n        this._cts = new CancellationTokenSource();\n        this._renameWidget = this._disposableStore.add(this._instaService.createInstance(RenameWidget, this.editor, ['acceptRenameInput', 'acceptRenameInputWithPreview']));\n    }\n    dispose() {\n        this._disposableStore.dispose();\n        this._cts.dispose(true);\n    }\n    async run() {\n        const trace = this._logService.trace.bind(this._logService, '[rename]');\n        // set up cancellation token to prevent reentrant rename, this\n        // is the parent to the resolve- and rename-tokens\n        this._cts.dispose(true);\n        this._cts = new CancellationTokenSource();\n        if (!this.editor.hasModel()) {\n            trace('editor has no model');\n            return undefined;\n        }\n        const position = this.editor.getPosition();\n        const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);\n        if (!skeleton.hasProvider()) {\n            trace('skeleton has no provider');\n            return undefined;\n        }\n        // part 1 - resolve rename location\n        const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, undefined, this._cts.token);\n        let loc;\n        try {\n            trace('resolving rename location');\n            const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);\n            this._progressService.showWhile(resolveLocationOperation, 250);\n            loc = await resolveLocationOperation;\n            trace('resolved rename location');\n        }\n        catch (e) {\n            if (e instanceof CancellationError) {\n                trace('resolve rename location cancelled', JSON.stringify(e, null, '\\t'));\n            }\n            else {\n                trace('resolve rename location failed', e instanceof Error ? e : JSON.stringify(e, null, '\\t'));\n                if (typeof e === 'string' || isMarkdownString(e)) {\n                    MessageController.get(this.editor)?.showMessage(e || nls.localize('resolveRenameLocationFailed', \"An unknown error occurred while resolving rename location\"), position);\n                }\n            }\n            return undefined;\n        }\n        finally {\n            cts1.dispose();\n        }\n        if (!loc) {\n            trace('returning early - no loc');\n            return undefined;\n        }\n        if (loc.rejectReason) {\n            trace(`returning early - rejected with reason: ${loc.rejectReason}`, loc.rejectReason);\n            MessageController.get(this.editor)?.showMessage(loc.rejectReason, position);\n            return undefined;\n        }\n        if (cts1.token.isCancellationRequested) {\n            trace('returning early - cts1 cancelled');\n            return undefined;\n        }\n        // part 2 - do rename at location\n        const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, loc.range, this._cts.token);\n        const model = this.editor.getModel(); // @ulugbekna: assumes editor still has a model, otherwise, cts1 should've been cancelled\n        const newSymbolNamesProviders = this._languageFeaturesService.newSymbolNamesProvider.all(model);\n        const resolvedNewSymbolnamesProviders = await Promise.all(newSymbolNamesProviders.map(async (p) => [p, await p.supportsAutomaticNewSymbolNamesTriggerKind ?? false]));\n        const requestRenameSuggestions = (triggerKind, cts) => {\n            let providers = resolvedNewSymbolnamesProviders.slice();\n            if (triggerKind === NewSymbolNameTriggerKind.Automatic) {\n                providers = providers.filter(([_, supportsAutomatic]) => supportsAutomatic);\n            }\n            return providers.map(([p,]) => p.provideNewSymbolNames(model, loc.range, triggerKind, cts));\n        };\n        trace('creating rename input field and awaiting its result');\n        const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, 'editor.rename.enablePreview');\n        const inputFieldResult = await this._renameWidget.getInput(loc.range, loc.text, supportPreview, newSymbolNamesProviders.length > 0 ? requestRenameSuggestions : undefined, cts2);\n        trace('received response from rename input field');\n        if (newSymbolNamesProviders.length > 0) { // @ulugbekna: we're interested only in telemetry for rename suggestions currently\n            this._reportTelemetry(newSymbolNamesProviders.length, model.getLanguageId(), inputFieldResult);\n        }\n        // no result, only hint to focus the editor or not\n        if (typeof inputFieldResult === 'boolean') {\n            trace(`returning early - rename input field response - ${inputFieldResult}`);\n            if (inputFieldResult) {\n                this.editor.focus();\n            }\n            cts2.dispose();\n            return undefined;\n        }\n        this.editor.focus();\n        trace('requesting rename edits');\n        const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then(async (renameResult) => {\n            if (!renameResult) {\n                trace('returning early - no rename edits result');\n                return;\n            }\n            if (!this.editor.hasModel()) {\n                trace('returning early - no model after rename edits are provided');\n                return;\n            }\n            if (renameResult.rejectReason) {\n                trace(`returning early - rejected with reason: ${renameResult.rejectReason}`);\n                this._notificationService.info(renameResult.rejectReason);\n                return;\n            }\n            // collapse selection to active end\n            this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));\n            trace('applying edits');\n            this._bulkEditService.apply(renameResult, {\n                editor: this.editor,\n                showPreview: inputFieldResult.wantsPreview,\n                label: nls.localize('label', \"Renaming '{0}' to '{1}'\", loc?.text, inputFieldResult.newName),\n                code: 'undoredo.rename',\n                quotableLabel: nls.localize('quotableLabel', \"Renaming {0} to {1}\", loc?.text, inputFieldResult.newName),\n                respectAutoSaveConfig: true\n            }).then(result => {\n                trace('edits applied');\n                if (result.ariaSummary) {\n                    alert(nls.localize('aria', \"Successfully renamed '{0}' to '{1}'. Summary: {2}\", loc.text, inputFieldResult.newName, result.ariaSummary));\n                }\n            }).catch(err => {\n                trace(`error when applying edits ${JSON.stringify(err, null, '\\t')}`);\n                this._notificationService.error(nls.localize('rename.failedApply', \"Rename failed to apply edits\"));\n                this._logService.error(err);\n            });\n        }, err => {\n            trace('error when providing rename edits', JSON.stringify(err, null, '\\t'));\n            this._notificationService.error(nls.localize('rename.failed', \"Rename failed to compute edits\"));\n            this._logService.error(err);\n        }).finally(() => {\n            cts2.dispose();\n        });\n        trace('returning rename operation');\n        this._progressService.showWhile(renameOperation, 250);\n        return renameOperation;\n    }\n    acceptRenameInput(wantsPreview) {\n        this._renameWidget.acceptInput(wantsPreview);\n    }\n    cancelRenameInput() {\n        this._renameWidget.cancelInput(true, 'cancelRenameInput command');\n    }\n    focusNextRenameSuggestion() {\n        this._renameWidget.focusNextRenameSuggestion();\n    }\n    focusPreviousRenameSuggestion() {\n        this._renameWidget.focusPreviousRenameSuggestion();\n    }\n    _reportTelemetry(nRenameSuggestionProviders, languageId, inputFieldResult) {\n        const value = typeof inputFieldResult === 'boolean'\n            ? {\n                kind: 'cancelled',\n                languageId,\n                nRenameSuggestionProviders,\n            }\n            : {\n                kind: 'accepted',\n                languageId,\n                nRenameSuggestionProviders,\n                source: inputFieldResult.stats.source.k,\n                nRenameSuggestions: inputFieldResult.stats.nRenameSuggestions,\n                timeBeforeFirstInputFieldEdit: inputFieldResult.stats.timeBeforeFirstInputFieldEdit,\n                wantsPreview: inputFieldResult.wantsPreview,\n                nRenameSuggestionsInvocations: inputFieldResult.stats.nRenameSuggestionsInvocations,\n                hadAutomaticRenameSuggestionsInvocation: inputFieldResult.stats.hadAutomaticRenameSuggestionsInvocation,\n            };\n        this._telemetryService.publicLog2('renameInvokedEvent', value);\n    }\n};\nRenameController = RenameController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, INotificationService),\n    __param(3, IBulkEditService),\n    __param(4, IEditorProgressService),\n    __param(5, ILogService),\n    __param(6, ITextResourceConfigurationService),\n    __param(7, ILanguageFeaturesService),\n    __param(8, ITelemetryService)\n], RenameController);\n// ---- action implementation\nexport class RenameAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.rename',\n            label: nls.localize('rename.label', \"Rename Symbol\"),\n            alias: 'Rename Symbol',\n            precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 60 /* KeyCode.F2 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            contextMenuOpts: {\n                group: '1_modification',\n                order: 1.1\n            }\n        });\n    }\n    runCommand(accessor, args) {\n        const editorService = accessor.get(ICodeEditorService);\n        const [uri, pos] = Array.isArray(args) && args || [undefined, undefined];\n        if (URI.isUri(uri) && Position.isIPosition(pos)) {\n            return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then(editor => {\n                if (!editor) {\n                    return;\n                }\n                editor.setPosition(pos);\n                editor.invokeWithinContext(accessor => {\n                    this.reportTelemetry(accessor, editor);\n                    return this.run(accessor, editor);\n                });\n            }, onUnexpectedError);\n        }\n        return super.runCommand(accessor, args);\n    }\n    run(accessor, editor) {\n        const logService = accessor.get(ILogService);\n        const controller = RenameController.get(editor);\n        if (controller) {\n            logService.trace('[RenameAction] got controller, running...');\n            return controller.run();\n        }\n        logService.trace('[RenameAction] returning early - controller missing');\n        return Promise.resolve();\n    }\n}\nregisterEditorContribution(RenameController.ID, RenameController, 4 /* EditorContributionInstantiation.Lazy */);\nregisterEditorAction(RenameAction);\nconst RenameCommand = EditorCommand.bindToContribution(RenameController.get);\nregisterEditorCommand(new RenameCommand({\n    id: 'acceptRenameInput',\n    precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n    handler: x => x.acceptRenameInput(false),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not('isComposing')),\n        primary: 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new RenameCommand({\n    id: 'acceptRenameInputWithPreview',\n    precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has('config.editor.rename.enablePreview')),\n    handler: x => x.acceptRenameInput(true),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not('isComposing')),\n        primary: 2048 /* KeyMod.CtrlCmd */ + 3 /* KeyCode.Enter */\n    }\n}));\nregisterEditorCommand(new RenameCommand({\n    id: 'cancelRenameInput',\n    precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n    handler: x => x.cancelRenameInput(),\n    kbOpts: {\n        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n        kbExpr: EditorContextKeys.focus,\n        primary: 9 /* KeyCode.Escape */,\n        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]\n    }\n}));\nregisterAction2(class FocusNextRenameSuggestion extends Action2 {\n    constructor() {\n        super({\n            id: 'focusNextRenameSuggestion',\n            title: {\n                ...nls.localize2('focusNextRenameSuggestion', \"Focus Next Rename Suggestion\"),\n            },\n            precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n            keybinding: [\n                {\n                    primary: 18 /* KeyCode.DownArrow */,\n                    weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n                }\n            ]\n        });\n    }\n    run(accessor) {\n        const currentEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n        if (!currentEditor) {\n            return;\n        }\n        const controller = RenameController.get(currentEditor);\n        if (!controller) {\n            return;\n        }\n        controller.focusNextRenameSuggestion();\n    }\n});\nregisterAction2(class FocusPreviousRenameSuggestion extends Action2 {\n    constructor() {\n        super({\n            id: 'focusPreviousRenameSuggestion',\n            title: {\n                ...nls.localize2('focusPreviousRenameSuggestion', \"Focus Previous Rename Suggestion\"),\n            },\n            precondition: CONTEXT_RENAME_INPUT_VISIBLE,\n            keybinding: [\n                {\n                    primary: 16 /* KeyCode.UpArrow */,\n                    weight: 100 /* KeybindingWeight.EditorContrib */ + 99,\n                }\n            ]\n        });\n    }\n    run(accessor) {\n        const currentEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();\n        if (!currentEditor) {\n            return;\n        }\n        const controller = RenameController.get(currentEditor);\n        if (!controller) {\n            return;\n        }\n        controller.focusPreviousRenameSuggestion();\n    }\n});\n// ---- api bridge command\nregisterModelAndPositionCommand('_executeDocumentRenameProvider', function (accessor, model, position, ...args) {\n    const [newName] = args;\n    assertType(typeof newName === 'string');\n    const { renameProvider } = accessor.get(ILanguageFeaturesService);\n    return rename(renameProvider, model, position, newName);\n});\nregisterModelAndPositionCommand('_executePrepareRename', async function (accessor, model, position) {\n    const { renameProvider } = accessor.get(ILanguageFeaturesService);\n    const skeleton = new RenameSkeleton(model, position, renameProvider);\n    const loc = await skeleton.resolveRenameLocation(CancellationToken.None);\n    if (loc?.rejectReason) {\n        throw new Error(loc.rejectReason);\n    }\n    return loc;\n});\n//todo@jrieken use editor options world\nRegistry.as(Extensions.Configuration).registerConfiguration({\n    id: 'editor',\n    properties: {\n        'editor.rename.enablePreview': {\n            scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,\n            description: nls.localize('enablePreview', \"Enable/disable the ability to preview changes before renaming\"),\n            default: true,\n            type: 'boolean'\n        }\n    }\n});\n","/**\n * Copyright (c) 2014-2024 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)\n * @license MIT\n *\n * Originally forked from (with the author's permission):\n *   Fabrice Bellard's javascript vt100 for jslinux:\n *   http://bellard.org/jslinux/\n *   Copyright (c) 2011 Fabrice Bellard\n */\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar zs=Object.defineProperty;var Rl=Object.getOwnPropertyDescriptor;var Ll=(s,t)=>{for(var e in t)zs(s,e,{get:t[e],enumerable:!0})};var M=(s,t,e,i)=>{for(var r=i>1?void 0:i?Rl(t,e):t,n=s.length-1,o;n>=0;n--)(o=s[n])&&(r=(i?o(t,e,r):o(r))||r);return i&&r&&zs(t,e,r),r},S=(s,t)=>(e,i)=>t(e,i,s);var Gs=\"Terminal input\",mi={get:()=>Gs,set:s=>Gs=s},$s=\"Too much output to announce, navigate to rows manually to read\",_i={get:()=>$s,set:s=>$s=s};function Al(s){return s.replace(/\\r?\\n/g,\"\\r\")}function kl(s,t){return t?\"\\x1B[200~\"+s+\"\\x1B[201~\":s}function Vs(s,t){s.clipboardData&&s.clipboardData.setData(\"text/plain\",t.selectionText),s.preventDefault()}function qs(s,t,e,i){if(s.stopPropagation(),s.clipboardData){let r=s.clipboardData.getData(\"text/plain\");Cn(r,t,e,i)}}function Cn(s,t,e,i){s=Al(s),s=kl(s,e.decPrivateModes.bracketedPasteMode&&i.rawOptions.ignoreBracketedPasteMode!==!0),e.triggerDataEvent(s,!0),t.value=\"\"}function Mn(s,t,e){let i=e.getBoundingClientRect(),r=s.clientX-i.left-10,n=s.clientY-i.top-10;t.style.width=\"20px\",t.style.height=\"20px\",t.style.left=`${r}px`,t.style.top=`${n}px`,t.style.zIndex=\"1000\",t.focus()}function Pn(s,t,e,i,r){Mn(s,t,e),r&&i.rightClickSelect(s),t.value=i.selectionText,t.select()}function Ce(s){return s>65535?(s-=65536,String.fromCharCode((s>>10)+55296)+String.fromCharCode(s%1024+56320)):String.fromCharCode(s)}function It(s,t=0,e=s.length){let i=\"\";for(let r=t;r<e;++r){let n=s[r];n>65535?(n-=65536,i+=String.fromCharCode((n>>10)+55296)+String.fromCharCode(n%1024+56320)):i+=String.fromCharCode(n)}return i}var er=class{constructor(){this._interim=0}clear(){this._interim=0}decode(t,e){let i=t.length;if(!i)return 0;let r=0,n=0;if(this._interim){let o=t.charCodeAt(n++);56320<=o&&o<=57343?e[r++]=(this._interim-55296)*1024+o-56320+65536:(e[r++]=this._interim,e[r++]=o),this._interim=0}for(let o=n;o<i;++o){let l=t.charCodeAt(o);if(55296<=l&&l<=56319){if(++o>=i)return this._interim=l,r;let a=t.charCodeAt(o);56320<=a&&a<=57343?e[r++]=(l-55296)*1024+a-56320+65536:(e[r++]=l,e[r++]=a);continue}l!==65279&&(e[r++]=l)}return r}},tr=class{constructor(){this.interim=new Uint8Array(3)}clear(){this.interim.fill(0)}decode(t,e){let i=t.length;if(!i)return 0;let r=0,n,o,l,a,u=0,h=0;if(this.interim[0]){let _=!1,p=this.interim[0];p&=(p&224)===192?31:(p&240)===224?15:7;let m=0,f;for(;(f=this.interim[++m]&63)&&m<4;)p<<=6,p|=f;let A=(this.interim[0]&224)===192?2:(this.interim[0]&240)===224?3:4,R=A-m;for(;h<R;){if(h>=i)return 0;if(f=t[h++],(f&192)!==128){h--,_=!0;break}else this.interim[m++]=f,p<<=6,p|=f&63}_||(A===2?p<128?h--:e[r++]=p:A===3?p<2048||p>=55296&&p<=57343||p===65279||(e[r++]=p):p<65536||p>1114111||(e[r++]=p)),this.interim.fill(0)}let c=i-4,d=h;for(;d<i;){for(;d<c&&!((n=t[d])&128)&&!((o=t[d+1])&128)&&!((l=t[d+2])&128)&&!((a=t[d+3])&128);)e[r++]=n,e[r++]=o,e[r++]=l,e[r++]=a,d+=4;if(n=t[d++],n<128)e[r++]=n;else if((n&224)===192){if(d>=i)return this.interim[0]=n,r;if(o=t[d++],(o&192)!==128){d--;continue}if(u=(n&31)<<6|o&63,u<128){d--;continue}e[r++]=u}else if((n&240)===224){if(d>=i)return this.interim[0]=n,r;if(o=t[d++],(o&192)!==128){d--;continue}if(d>=i)return this.interim[0]=n,this.interim[1]=o,r;if(l=t[d++],(l&192)!==128){d--;continue}if(u=(n&15)<<12|(o&63)<<6|l&63,u<2048||u>=55296&&u<=57343||u===65279)continue;e[r++]=u}else if((n&248)===240){if(d>=i)return this.interim[0]=n,r;if(o=t[d++],(o&192)!==128){d--;continue}if(d>=i)return this.interim[0]=n,this.interim[1]=o,r;if(l=t[d++],(l&192)!==128){d--;continue}if(d>=i)return this.interim[0]=n,this.interim[1]=o,this.interim[2]=l,r;if(a=t[d++],(a&192)!==128){d--;continue}if(u=(n&7)<<18|(o&63)<<12|(l&63)<<6|a&63,u<65536||u>1114111)continue;e[r++]=u}}return r}};var ir=\"\";var we=\" \";var De=class s{constructor(){this.fg=0;this.bg=0;this.extended=new rt}static toColorRGB(t){return[t>>>16&255,t>>>8&255,t&255]}static fromColorRGB(t){return(t[0]&255)<<16|(t[1]&255)<<8|t[2]&255}clone(){let t=new s;return t.fg=this.fg,t.bg=this.bg,t.extended=this.extended.clone(),t}isInverse(){return this.fg&67108864}isBold(){return this.fg&134217728}isUnderline(){return this.hasExtendedAttrs()&&this.extended.underlineStyle!==0?1:this.fg&268435456}isBlink(){return this.fg&536870912}isInvisible(){return this.fg&1073741824}isItalic(){return this.bg&67108864}isDim(){return this.bg&134217728}isStrikethrough(){return this.fg&2147483648}isProtected(){return this.bg&536870912}isOverline(){return this.bg&1073741824}getFgColorMode(){return this.fg&50331648}getBgColorMode(){return this.bg&50331648}isFgRGB(){return(this.fg&50331648)===50331648}isBgRGB(){return(this.bg&50331648)===50331648}isFgPalette(){return(this.fg&50331648)===16777216||(this.fg&50331648)===33554432}isBgPalette(){return(this.bg&50331648)===16777216||(this.bg&50331648)===33554432}isFgDefault(){return(this.fg&50331648)===0}isBgDefault(){return(this.bg&50331648)===0}isAttributeDefault(){return this.fg===0&&this.bg===0}getFgColor(){switch(this.fg&50331648){case 16777216:case 33554432:return this.fg&255;case 50331648:return this.fg&16777215;default:return-1}}getBgColor(){switch(this.bg&50331648){case 16777216:case 33554432:return this.bg&255;case 50331648:return this.bg&16777215;default:return-1}}hasExtendedAttrs(){return this.bg&268435456}updateExtended(){this.extended.isEmpty()?this.bg&=-268435457:this.bg|=268435456}getUnderlineColor(){if(this.bg&268435456&&~this.extended.underlineColor)switch(this.extended.underlineColor&50331648){case 16777216:case 33554432:return this.extended.underlineColor&255;case 50331648:return this.extended.underlineColor&16777215;default:return this.getFgColor()}return this.getFgColor()}getUnderlineColorMode(){return this.bg&268435456&&~this.extended.underlineColor?this.extended.underlineColor&50331648:this.getFgColorMode()}isUnderlineColorRGB(){return this.bg&268435456&&~this.extended.underlineColor?(this.extended.underlineColor&50331648)===50331648:this.isFgRGB()}isUnderlineColorPalette(){return this.bg&268435456&&~this.extended.underlineColor?(this.extended.underlineColor&50331648)===16777216||(this.extended.underlineColor&50331648)===33554432:this.isFgPalette()}isUnderlineColorDefault(){return this.bg&268435456&&~this.extended.underlineColor?(this.extended.underlineColor&50331648)===0:this.isFgDefault()}getUnderlineStyle(){return this.fg&268435456?this.bg&268435456?this.extended.underlineStyle:1:0}getUnderlineVariantOffset(){return this.extended.underlineVariantOffset}},rt=class s{constructor(t=0,e=0){this._ext=0;this._urlId=0;this._ext=t,this._urlId=e}get ext(){return this._urlId?this._ext&-469762049|this.underlineStyle<<26:this._ext}set ext(t){this._ext=t}get underlineStyle(){return this._urlId?5:(this._ext&469762048)>>26}set underlineStyle(t){this._ext&=-469762049,this._ext|=t<<26&469762048}get underlineColor(){return this._ext&67108863}set underlineColor(t){this._ext&=-67108864,this._ext|=t&67108863}get urlId(){return this._urlId}set urlId(t){this._urlId=t}get underlineVariantOffset(){let t=(this._ext&3758096384)>>29;return t<0?t^4294967288:t}set underlineVariantOffset(t){this._ext&=536870911,this._ext|=t<<29&3758096384}clone(){return new s(this._ext,this._urlId)}isEmpty(){return this.underlineStyle===0&&this._urlId===0}};var q=class s extends De{constructor(){super(...arguments);this.content=0;this.fg=0;this.bg=0;this.extended=new rt;this.combinedData=\"\"}static fromCharData(e){let i=new s;return i.setFromCharData(e),i}isCombined(){return this.content&2097152}getWidth(){return this.content>>22}getChars(){return this.content&2097152?this.combinedData:this.content&2097151?Ce(this.content&2097151):\"\"}getCode(){return this.isCombined()?this.combinedData.charCodeAt(this.combinedData.length-1):this.content&2097151}setFromCharData(e){this.fg=e[0],this.bg=0;let i=!1;if(e[1].length>2)i=!0;else if(e[1].length===2){let r=e[1].charCodeAt(0);if(55296<=r&&r<=56319){let n=e[1].charCodeAt(1);56320<=n&&n<=57343?this.content=(r-55296)*1024+n-56320+65536|e[2]<<22:i=!0}else i=!0}else this.content=e[1].charCodeAt(0)|e[2]<<22;i&&(this.combinedData=e[1],this.content=2097152|e[2]<<22)}getAsCharData(){return[this.fg,this.getChars(),this.getWidth(),this.getCode()]}};var js=\"di$target\",Hn=\"di$dependencies\",Fn=new Map;function Xs(s){return s[Hn]||[]}function ie(s){if(Fn.has(s))return Fn.get(s);let t=function(e,i,r){if(arguments.length!==3)throw new Error(\"@IServiceName-decorator can only be used to decorate a parameter\");Pl(t,e,r)};return t._id=s,Fn.set(s,t),t}function Pl(s,t,e){t[js]===t?t[Hn].push({id:s,index:e}):(t[Hn]=[{id:s,index:e}],t[js]=t)}var F=ie(\"BufferService\"),rr=ie(\"CoreMouseService\"),ge=ie(\"CoreService\"),Zs=ie(\"CharsetService\"),xt=ie(\"InstantiationService\");var nr=ie(\"LogService\"),H=ie(\"OptionsService\"),sr=ie(\"OscLinkService\"),Js=ie(\"UnicodeService\"),Be=ie(\"DecorationService\");var wt=class{constructor(t,e,i){this._bufferService=t;this._optionsService=e;this._oscLinkService=i}provideLinks(t,e){let i=this._bufferService.buffer.lines.get(t-1);if(!i){e(void 0);return}let r=[],n=this._optionsService.rawOptions.linkHandler,o=new q,l=i.getTrimmedLength(),a=-1,u=-1,h=!1;for(let c=0;c<l;c++)if(!(u===-1&&!i.hasContent(c))){if(i.loadCell(c,o),o.hasExtendedAttrs()&&o.extended.urlId)if(u===-1){u=c,a=o.extended.urlId;continue}else h=o.extended.urlId!==a;else u!==-1&&(h=!0);if(h||u!==-1&&c===l-1){let d=this._oscLinkService.getLinkData(a)?.uri;if(d){let _={start:{x:u+1,y:t},end:{x:c+(!h&&c===l-1?1:0),y:t}},p=!1;if(!n?.allowNonHttpProtocols)try{let m=new URL(d);[\"http:\",\"https:\"].includes(m.protocol)||(p=!0)}catch{p=!0}p||r.push({text:d,range:_,activate:(m,f)=>n?n.activate(m,f,_):Ol(m,f),hover:(m,f)=>n?.hover?.(m,f,_),leave:(m,f)=>n?.leave?.(m,f,_)})}h=!1,o.hasExtendedAttrs()&&o.extended.urlId?(u=c,a=o.extended.urlId):(u=-1,a=-1)}}e(r)}};wt=M([S(0,F),S(1,H),S(2,sr)],wt);function Ol(s,t){if(confirm(`Do you want to navigate to ${t}?\n\nWARNING: This link could potentially be dangerous`)){let i=window.open();if(i){try{i.opener=null}catch{}i.location.href=t}else console.warn(\"Opening link blocked as opener could not be cleared\")}}var nt=ie(\"CharSizeService\"),ae=ie(\"CoreBrowserService\"),Dt=ie(\"MouseService\"),ce=ie(\"RenderService\"),Qs=ie(\"SelectionService\"),or=ie(\"CharacterJoinerService\"),Re=ie(\"ThemeService\"),lr=ie(\"LinkProviderService\");var Wn=class{constructor(){this.listeners=[],this.unexpectedErrorHandler=function(t){setTimeout(()=>{throw t.stack?ar.isErrorNoTelemetry(t)?new ar(t.message+`\n\n`+t.stack):new Error(t.message+`\n\n`+t.stack):t},0)}}addListener(t){return this.listeners.push(t),()=>{this._removeListener(t)}}emit(t){this.listeners.forEach(e=>{e(t)})}_removeListener(t){this.listeners.splice(this.listeners.indexOf(t),1)}setUnexpectedErrorHandler(t){this.unexpectedErrorHandler=t}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(t){this.unexpectedErrorHandler(t),this.emit(t)}onUnexpectedExternalError(t){this.unexpectedErrorHandler(t)}},Bl=new Wn;function Lt(s){Nl(s)||Bl.onUnexpectedError(s)}var Un=\"Canceled\";function Nl(s){return s instanceof bi?!0:s instanceof Error&&s.name===Un&&s.message===Un}var bi=class extends Error{constructor(){super(Un),this.name=this.message}};function eo(s){return s?new Error(`Illegal argument: ${s}`):new Error(\"Illegal argument\")}var ar=class s extends Error{constructor(t){super(t),this.name=\"CodeExpectedError\"}static fromError(t){if(t instanceof s)return t;let e=new s;return e.message=t.message,e.stack=t.stack,e}static isErrorNoTelemetry(t){return t.name===\"CodeExpectedError\"}},Rt=class s extends Error{constructor(t){super(t||\"An unexpected bug occurred.\"),Object.setPrototypeOf(this,s.prototype)}};function Fl(s,t,e=0,i=s.length){let r=e,n=i;for(;r<n;){let o=Math.floor((r+n)/2);t(s[o])?r=o+1:n=o}return r-1}var cr=class cr{constructor(t){this._array=t;this._findLastMonotonousLastIdx=0}findLastMonotonous(t){if(cr.assertInvariants){if(this._prevFindLastPredicate){for(let i of this._array)if(this._prevFindLastPredicate(i)&&!t(i))throw new Error(\"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.\")}this._prevFindLastPredicate=t}let e=Fl(this._array,t,this._findLastMonotonousLastIdx);return this._findLastMonotonousLastIdx=e+1,e===-1?void 0:this._array[e]}};cr.assertInvariants=!1;var to=cr;function Se(s,t=0){return s[s.length-(1+t)]}var ro;(l=>{function s(a){return a<0}l.isLessThan=s;function t(a){return a<=0}l.isLessThanOrEqual=t;function e(a){return a>0}l.isGreaterThan=e;function i(a){return a===0}l.isNeitherLessOrGreaterThan=i,l.greaterThan=1,l.lessThan=-1,l.neitherLessOrGreaterThan=0})(ro||={});function no(s,t){return(e,i)=>t(s(e),s(i))}var so=(s,t)=>s-t;var At=class At{constructor(t){this.iterate=t}forEach(t){this.iterate(e=>(t(e),!0))}toArray(){let t=[];return this.iterate(e=>(t.push(e),!0)),t}filter(t){return new At(e=>this.iterate(i=>t(i)?e(i):!0))}map(t){return new At(e=>this.iterate(i=>e(t(i))))}some(t){let e=!1;return this.iterate(i=>(e=t(i),!e)),e}findFirst(t){let e;return this.iterate(i=>t(i)?(e=i,!1):!0),e}findLast(t){let e;return this.iterate(i=>(t(i)&&(e=i),!0)),e}findLastMaxBy(t){let e,i=!0;return this.iterate(r=>((i||ro.isGreaterThan(t(r,e)))&&(i=!1,e=r),!0)),e}};At.empty=new At(t=>{});var io=At;function co(s,t){let e=Object.create(null);for(let i of s){let r=t(i),n=e[r];n||(n=e[r]=[]),n.push(i)}return e}var lo,ao,oo=class{constructor(t,e){this.toKey=e;this._map=new Map;this[lo]=\"SetWithKey\";for(let i of t)this.add(i)}get size(){return this._map.size}add(t){let e=this.toKey(t);return this._map.set(e,t),this}delete(t){return this._map.delete(this.toKey(t))}has(t){return this._map.has(this.toKey(t))}*entries(){for(let t of this._map.values())yield[t,t]}keys(){return this.values()}*values(){for(let t of this._map.values())yield t}clear(){this._map.clear()}forEach(t,e){this._map.forEach(i=>t.call(e,i,i,this))}[(ao=Symbol.iterator,lo=Symbol.toStringTag,ao)](){return this.values()}};var ur=class{constructor(){this.map=new Map}add(t,e){let i=this.map.get(t);i||(i=new Set,this.map.set(t,i)),i.add(e)}delete(t,e){let i=this.map.get(t);i&&(i.delete(e),i.size===0&&this.map.delete(t))}forEach(t,e){let i=this.map.get(t);i&&i.forEach(e)}get(t){let e=this.map.get(t);return e||new Set}};function Kn(s,t){let e=this,i=!1,r;return function(){if(i)return r;if(i=!0,t)try{r=s.apply(e,arguments)}finally{t()}else r=s.apply(e,arguments);return r}}var zn;(O=>{function s(I){return I&&typeof I==\"object\"&&typeof I[Symbol.iterator]==\"function\"}O.is=s;let t=Object.freeze([]);function e(){return t}O.empty=e;function*i(I){yield I}O.single=i;function r(I){return s(I)?I:i(I)}O.wrap=r;function n(I){return I||t}O.from=n;function*o(I){for(let k=I.length-1;k>=0;k--)yield I[k]}O.reverse=o;function l(I){return!I||I[Symbol.iterator]().next().done===!0}O.isEmpty=l;function a(I){return I[Symbol.iterator]().next().value}O.first=a;function u(I,k){let P=0;for(let oe of I)if(k(oe,P++))return!0;return!1}O.some=u;function h(I,k){for(let P of I)if(k(P))return P}O.find=h;function*c(I,k){for(let P of I)k(P)&&(yield P)}O.filter=c;function*d(I,k){let P=0;for(let oe of I)yield k(oe,P++)}O.map=d;function*_(I,k){let P=0;for(let oe of I)yield*k(oe,P++)}O.flatMap=_;function*p(...I){for(let k of I)yield*k}O.concat=p;function m(I,k,P){let oe=P;for(let Me of I)oe=k(oe,Me);return oe}O.reduce=m;function*f(I,k,P=I.length){for(k<0&&(k+=I.length),P<0?P+=I.length:P>I.length&&(P=I.length);k<P;k++)yield I[k]}O.slice=f;function A(I,k=Number.POSITIVE_INFINITY){let P=[];if(k===0)return[P,I];let oe=I[Symbol.iterator]();for(let Me=0;Me<k;Me++){let Pe=oe.next();if(Pe.done)return[P,O.empty()];P.push(Pe.value)}return[P,{[Symbol.iterator](){return oe}}]}O.consume=A;async function R(I){let k=[];for await(let P of I)k.push(P);return Promise.resolve(k)}O.asyncToArray=R})(zn||={});var Wl=!1,dt=null,hr=class hr{constructor(){this.livingDisposables=new Map}getDisposableData(t){let e=this.livingDisposables.get(t);return e||(e={parent:null,source:null,isSingleton:!1,value:t,idx:hr.idx++},this.livingDisposables.set(t,e)),e}trackDisposable(t){let e=this.getDisposableData(t);e.source||(e.source=new Error().stack)}setParent(t,e){let i=this.getDisposableData(t);i.parent=e}markAsDisposed(t){this.livingDisposables.delete(t)}markAsSingleton(t){this.getDisposableData(t).isSingleton=!0}getRootParent(t,e){let i=e.get(t);if(i)return i;let r=t.parent?this.getRootParent(this.getDisposableData(t.parent),e):t;return e.set(t,r),r}getTrackedDisposables(){let t=new Map;return[...this.livingDisposables.entries()].filter(([,i])=>i.source!==null&&!this.getRootParent(i,t).isSingleton).flatMap(([i])=>i)}computeLeakingDisposables(t=10,e){let i;if(e)i=e;else{let a=new Map,u=[...this.livingDisposables.values()].filter(c=>c.source!==null&&!this.getRootParent(c,a).isSingleton);if(u.length===0)return;let h=new Set(u.map(c=>c.value));if(i=u.filter(c=>!(c.parent&&h.has(c.parent))),i.length===0)throw new Error(\"There are cyclic diposable chains!\")}if(!i)return;function r(a){function u(c,d){for(;c.length>0&&d.some(_=>typeof _==\"string\"?_===c[0]:c[0].match(_));)c.shift()}let h=a.source.split(`\n`).map(c=>c.trim().replace(\"at \",\"\")).filter(c=>c!==\"\");return u(h,[\"Error\",/^trackDisposable \\(.*\\)$/,/^DisposableTracker.trackDisposable \\(.*\\)$/]),h.reverse()}let n=new ur;for(let a of i){let u=r(a);for(let h=0;h<=u.length;h++)n.add(u.slice(0,h).join(`\n`),a)}i.sort(no(a=>a.idx,so));let o=\"\",l=0;for(let a of i.slice(0,t)){l++;let u=r(a),h=[];for(let c=0;c<u.length;c++){let d=u[c];d=`(shared with ${n.get(u.slice(0,c+1).join(`\n`)).size}/${i.length} leaks) at ${d}`;let p=n.get(u.slice(0,c).join(`\n`)),m=co([...p].map(f=>r(f)[c]),f=>f);delete m[u[c]];for(let[f,A]of Object.entries(m))h.unshift(`    - stacktraces of ${A.length} other leaks continue with ${f}`);h.unshift(d)}o+=`\n\n\n==================== Leaking disposable ${l}/${i.length}: ${a.value.constructor.name} ====================\n${h.join(`\n`)}\n============================================================\n\n`}return i.length>t&&(o+=`\n\n\n... and ${i.length-t} more leaking disposables\n\n`),{leaks:i,details:o}}};hr.idx=0;var uo=hr;function Ul(s){dt=s}if(Wl){let s=\"__is_disposable_tracked__\";Ul(new class{trackDisposable(t){let e=new Error(\"Potentially leaked disposable\").stack;setTimeout(()=>{t[s]||console.log(e)},3e3)}setParent(t,e){if(t&&t!==D.None)try{t[s]=!0}catch{}}markAsDisposed(t){if(t&&t!==D.None)try{t[s]=!0}catch{}}markAsSingleton(t){}})}function fr(s){return dt?.trackDisposable(s),s}function pr(s){dt?.markAsDisposed(s)}function vi(s,t){dt?.setParent(s,t)}function Kl(s,t){if(dt)for(let e of s)dt.setParent(e,t)}function Gn(s){return dt?.markAsSingleton(s),s}function Ne(s){if(zn.is(s)){let t=[];for(let e of s)if(e)try{e.dispose()}catch(i){t.push(i)}if(t.length===1)throw t[0];if(t.length>1)throw new AggregateError(t,\"Encountered errors while disposing of store\");return Array.isArray(s)?[]:s}else if(s)return s.dispose(),s}function ho(...s){let t=C(()=>Ne(s));return Kl(s,t),t}function C(s){let t=fr({dispose:Kn(()=>{pr(t),s()})});return t}var dr=class dr{constructor(){this._toDispose=new Set;this._isDisposed=!1;fr(this)}dispose(){this._isDisposed||(pr(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){if(this._toDispose.size!==0)try{Ne(this._toDispose)}finally{this._toDispose.clear()}}add(t){if(!t)return t;if(t===this)throw new Error(\"Cannot register a disposable on itself!\");return vi(t,this),this._isDisposed?dr.DISABLE_DISPOSED_WARNING||console.warn(new Error(\"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!\").stack):this._toDispose.add(t),t}delete(t){if(t){if(t===this)throw new Error(\"Cannot dispose a disposable on itself!\");this._toDispose.delete(t),t.dispose()}}deleteAndLeak(t){t&&this._toDispose.has(t)&&(this._toDispose.delete(t),vi(t,null))}};dr.DISABLE_DISPOSED_WARNING=!1;var Ee=dr,D=class{constructor(){this._store=new Ee;fr(this),vi(this._store,this)}dispose(){pr(this),this._store.dispose()}_register(t){if(t===this)throw new Error(\"Cannot register a disposable on itself!\");return this._store.add(t)}};D.None=Object.freeze({dispose(){}});var ye=class{constructor(){this._isDisposed=!1;fr(this)}get value(){return this._isDisposed?void 0:this._value}set value(t){this._isDisposed||t===this._value||(this._value?.dispose(),t&&vi(t,this),this._value=t)}clear(){this.value=void 0}dispose(){this._isDisposed=!0,pr(this),this._value?.dispose(),this._value=void 0}clearAndLeak(){let t=this._value;return this._value=void 0,t&&vi(t,null),t}};var fe=typeof window==\"object\"?window:globalThis;var kt=class kt{constructor(t){this.element=t,this.next=kt.Undefined,this.prev=kt.Undefined}};kt.Undefined=new kt(void 0);var G=kt,Ct=class{constructor(){this._first=G.Undefined;this._last=G.Undefined;this._size=0}get size(){return this._size}isEmpty(){return this._first===G.Undefined}clear(){let t=this._first;for(;t!==G.Undefined;){let e=t.next;t.prev=G.Undefined,t.next=G.Undefined,t=e}this._first=G.Undefined,this._last=G.Undefined,this._size=0}unshift(t){return this._insert(t,!1)}push(t){return this._insert(t,!0)}_insert(t,e){let i=new G(t);if(this._first===G.Undefined)this._first=i,this._last=i;else if(e){let n=this._last;this._last=i,i.prev=n,n.next=i}else{let n=this._first;this._first=i,i.next=n,n.prev=i}this._size+=1;let r=!1;return()=>{r||(r=!0,this._remove(i))}}shift(){if(this._first!==G.Undefined){let t=this._first.element;return this._remove(this._first),t}}pop(){if(this._last!==G.Undefined){let t=this._last.element;return this._remove(this._last),t}}_remove(t){if(t.prev!==G.Undefined&&t.next!==G.Undefined){let e=t.prev;e.next=t.next,t.next.prev=e}else t.prev===G.Undefined&&t.next===G.Undefined?(this._first=G.Undefined,this._last=G.Undefined):t.next===G.Undefined?(this._last=this._last.prev,this._last.next=G.Undefined):t.prev===G.Undefined&&(this._first=this._first.next,this._first.prev=G.Undefined);this._size-=1}*[Symbol.iterator](){let t=this._first;for(;t!==G.Undefined;)yield t.element,t=t.next}};var zl=globalThis.performance&&typeof globalThis.performance.now==\"function\",mr=class s{static create(t){return new s(t)}constructor(t){this._now=zl&&t===!1?Date.now:globalThis.performance.now.bind(globalThis.performance),this._startTime=this._now(),this._stopTime=-1}stop(){this._stopTime=this._now()}reset(){this._startTime=this._now(),this._stopTime=-1}elapsed(){return this._stopTime!==-1?this._stopTime-this._startTime:this._now()-this._startTime}};var Gl=!1,fo=!1,$l=!1,$;(Qe=>{Qe.None=()=>D.None;function t(y){if($l){let{onDidAddListener:T}=y,g=gi.create(),w=0;y.onDidAddListener=()=>{++w===2&&(console.warn(\"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here\"),g.print()),T?.()}}}function e(y,T){return d(y,()=>{},0,void 0,!0,void 0,T)}Qe.defer=e;function i(y){return(T,g=null,w)=>{let E=!1,x;return x=y(N=>{if(!E)return x?x.dispose():E=!0,T.call(g,N)},null,w),E&&x.dispose(),x}}Qe.once=i;function r(y,T,g){return h((w,E=null,x)=>y(N=>w.call(E,T(N)),null,x),g)}Qe.map=r;function n(y,T,g){return h((w,E=null,x)=>y(N=>{T(N),w.call(E,N)},null,x),g)}Qe.forEach=n;function o(y,T,g){return h((w,E=null,x)=>y(N=>T(N)&&w.call(E,N),null,x),g)}Qe.filter=o;function l(y){return y}Qe.signal=l;function a(...y){return(T,g=null,w)=>{let E=ho(...y.map(x=>x(N=>T.call(g,N))));return c(E,w)}}Qe.any=a;function u(y,T,g,w){let E=g;return r(y,x=>(E=T(E,x),E),w)}Qe.reduce=u;function h(y,T){let g,w={onWillAddFirstListener(){g=y(E.fire,E)},onDidRemoveLastListener(){g?.dispose()}};T||t(w);let E=new v(w);return T?.add(E),E.event}function c(y,T){return T instanceof Array?T.push(y):T&&T.add(y),y}function d(y,T,g=100,w=!1,E=!1,x,N){let Z,te,Oe,ze=0,le,et={leakWarningThreshold:x,onWillAddFirstListener(){Z=y(ht=>{ze++,te=T(te,ht),w&&!Oe&&(me.fire(te),te=void 0),le=()=>{let fi=te;te=void 0,Oe=void 0,(!w||ze>1)&&me.fire(fi),ze=0},typeof g==\"number\"?(clearTimeout(Oe),Oe=setTimeout(le,g)):Oe===void 0&&(Oe=0,queueMicrotask(le))})},onWillRemoveListener(){E&&ze>0&&le?.()},onDidRemoveLastListener(){le=void 0,Z.dispose()}};N||t(et);let me=new v(et);return N?.add(me),me.event}Qe.debounce=d;function _(y,T=0,g){return Qe.debounce(y,(w,E)=>w?(w.push(E),w):[E],T,void 0,!0,void 0,g)}Qe.accumulate=_;function p(y,T=(w,E)=>w===E,g){let w=!0,E;return o(y,x=>{let N=w||!T(x,E);return w=!1,E=x,N},g)}Qe.latch=p;function m(y,T,g){return[Qe.filter(y,T,g),Qe.filter(y,w=>!T(w),g)]}Qe.split=m;function f(y,T=!1,g=[],w){let E=g.slice(),x=y(te=>{E?E.push(te):Z.fire(te)});w&&w.add(x);let N=()=>{E?.forEach(te=>Z.fire(te)),E=null},Z=new v({onWillAddFirstListener(){x||(x=y(te=>Z.fire(te)),w&&w.add(x))},onDidAddFirstListener(){E&&(T?setTimeout(N):N())},onDidRemoveLastListener(){x&&x.dispose(),x=null}});return w&&w.add(Z),Z.event}Qe.buffer=f;function A(y,T){return(w,E,x)=>{let N=T(new O);return y(function(Z){let te=N.evaluate(Z);te!==R&&w.call(E,te)},void 0,x)}}Qe.chain=A;let R=Symbol(\"HaltChainable\");class O{constructor(){this.steps=[]}map(T){return this.steps.push(T),this}forEach(T){return this.steps.push(g=>(T(g),g)),this}filter(T){return this.steps.push(g=>T(g)?g:R),this}reduce(T,g){let w=g;return this.steps.push(E=>(w=T(w,E),w)),this}latch(T=(g,w)=>g===w){let g=!0,w;return this.steps.push(E=>{let x=g||!T(E,w);return g=!1,w=E,x?E:R}),this}evaluate(T){for(let g of this.steps)if(T=g(T),T===R)break;return T}}function I(y,T,g=w=>w){let w=(...Z)=>N.fire(g(...Z)),E=()=>y.on(T,w),x=()=>y.removeListener(T,w),N=new v({onWillAddFirstListener:E,onDidRemoveLastListener:x});return N.event}Qe.fromNodeEventEmitter=I;function k(y,T,g=w=>w){let w=(...Z)=>N.fire(g(...Z)),E=()=>y.addEventListener(T,w),x=()=>y.removeEventListener(T,w),N=new v({onWillAddFirstListener:E,onDidRemoveLastListener:x});return N.event}Qe.fromDOMEventEmitter=k;function P(y){return new Promise(T=>i(y)(T))}Qe.toPromise=P;function oe(y){let T=new v;return y.then(g=>{T.fire(g)},()=>{T.fire(void 0)}).finally(()=>{T.dispose()}),T.event}Qe.fromPromise=oe;function Me(y,T){return y(g=>T.fire(g))}Qe.forward=Me;function Pe(y,T,g){return T(g),y(w=>T(w))}Qe.runAndSubscribe=Pe;class Ke{constructor(T,g){this._observable=T;this._counter=0;this._hasChanged=!1;let w={onWillAddFirstListener:()=>{T.addObserver(this)},onDidRemoveLastListener:()=>{T.removeObserver(this)}};g||t(w),this.emitter=new v(w),g&&g.add(this.emitter)}beginUpdate(T){this._counter++}handlePossibleChange(T){}handleChange(T,g){this._hasChanged=!0}endUpdate(T){this._counter--,this._counter===0&&(this._observable.reportChanges(),this._hasChanged&&(this._hasChanged=!1,this.emitter.fire(this._observable.get())))}}function di(y,T){return new Ke(y,T).emitter.event}Qe.fromObservable=di;function V(y){return(T,g,w)=>{let E=0,x=!1,N={beginUpdate(){E++},endUpdate(){E--,E===0&&(y.reportChanges(),x&&(x=!1,T.call(g)))},handlePossibleChange(){},handleChange(){x=!0}};y.addObserver(N),y.reportChanges();let Z={dispose(){y.removeObserver(N)}};return w instanceof Ee?w.add(Z):Array.isArray(w)&&w.push(Z),Z}}Qe.fromObservableLight=V})($||={});var Mt=class Mt{constructor(t){this.listenerCount=0;this.invocationCount=0;this.elapsedOverall=0;this.durations=[];this.name=`${t}_${Mt._idPool++}`,Mt.all.add(this)}start(t){this._stopWatch=new mr,this.listenerCount=t}stop(){if(this._stopWatch){let t=this._stopWatch.elapsed();this.durations.push(t),this.elapsedOverall+=t,this.invocationCount+=1,this._stopWatch=void 0}}};Mt.all=new Set,Mt._idPool=0;var $n=Mt,po=-1;var br=class br{constructor(t,e,i=(br._idPool++).toString(16).padStart(3,\"0\")){this._errorHandler=t;this.threshold=e;this.name=i;this._warnCountdown=0}dispose(){this._stacks?.clear()}check(t,e){let i=this.threshold;if(i<=0||e<i)return;this._stacks||(this._stacks=new Map);let r=this._stacks.get(t.value)||0;if(this._stacks.set(t.value,r+1),this._warnCountdown-=1,this._warnCountdown<=0){this._warnCountdown=i*.5;let[n,o]=this.getMostFrequentStack(),l=`[${this.name}] potential listener LEAK detected, having ${e} listeners already. MOST frequent listener (${o}):`;console.warn(l),console.warn(n);let a=new qn(l,n);this._errorHandler(a)}return()=>{let n=this._stacks.get(t.value)||0;this._stacks.set(t.value,n-1)}}getMostFrequentStack(){if(!this._stacks)return;let t,e=0;for(let[i,r]of this._stacks)(!t||e<r)&&(t=[i,r],e=r);return t}};br._idPool=1;var Vn=br,gi=class s{constructor(t){this.value=t}static create(){let t=new Error;return new s(t.stack??\"\")}print(){console.warn(this.value.split(`\n`).slice(2).join(`\n`))}},qn=class extends Error{constructor(t,e){super(t),this.name=\"ListenerLeakError\",this.stack=e}},Yn=class extends Error{constructor(t,e){super(t),this.name=\"ListenerRefusalError\",this.stack=e}},Vl=0,Pt=class{constructor(t){this.value=t;this.id=Vl++}},ql=2,Yl=(s,t)=>{if(s instanceof Pt)t(s);else for(let e=0;e<s.length;e++){let i=s[e];i&&t(i)}},_r;if(Gl){let s=[];setInterval(()=>{s.length!==0&&(console.warn(\"[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:\"),console.warn(s.join(`\n`)),s.length=0)},3e3),_r=new FinalizationRegistry(t=>{typeof t==\"string\"&&s.push(t)})}var v=class{constructor(t){this._size=0;this._options=t,this._leakageMon=po>0||this._options?.leakWarningThreshold?new Vn(t?.onListenerError??Lt,this._options?.leakWarningThreshold??po):void 0,this._perfMon=this._options?._profName?new $n(this._options._profName):void 0,this._deliveryQueue=this._options?.deliveryQueue}dispose(){if(!this._disposed){if(this._disposed=!0,this._deliveryQueue?.current===this&&this._deliveryQueue.reset(),this._listeners){if(fo){let t=this._listeners;queueMicrotask(()=>{Yl(t,e=>e.stack?.print())})}this._listeners=void 0,this._size=0}this._options?.onDidRemoveLastListener?.(),this._leakageMon?.dispose()}}get event(){return this._event??=(t,e,i)=>{if(this._leakageMon&&this._size>this._leakageMon.threshold**2){let a=`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;console.warn(a);let u=this._leakageMon.getMostFrequentStack()??[\"UNKNOWN stack\",-1],h=new Yn(`${a}. HINT: Stack shows most frequent listener (${u[1]}-times)`,u[0]);return(this._options?.onListenerError||Lt)(h),D.None}if(this._disposed)return D.None;e&&(t=t.bind(e));let r=new Pt(t),n,o;this._leakageMon&&this._size>=Math.ceil(this._leakageMon.threshold*.2)&&(r.stack=gi.create(),n=this._leakageMon.check(r.stack,this._size+1)),fo&&(r.stack=o??gi.create()),this._listeners?this._listeners instanceof Pt?(this._deliveryQueue??=new jn,this._listeners=[this._listeners,r]):this._listeners.push(r):(this._options?.onWillAddFirstListener?.(this),this._listeners=r,this._options?.onDidAddFirstListener?.(this)),this._size++;let l=C(()=>{_r?.unregister(l),n?.(),this._removeListener(r)});if(i instanceof Ee?i.add(l):Array.isArray(i)&&i.push(l),_r){let a=new Error().stack.split(`\n`).slice(2,3).join(`\n`).trim(),u=/(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(a);_r.register(l,u?.[2]??a,l)}return l},this._event}_removeListener(t){if(this._options?.onWillRemoveListener?.(this),!this._listeners)return;if(this._size===1){this._listeners=void 0,this._options?.onDidRemoveLastListener?.(this),this._size=0;return}let e=this._listeners,i=e.indexOf(t);if(i===-1)throw console.log(\"disposed?\",this._disposed),console.log(\"size?\",this._size),console.log(\"arr?\",JSON.stringify(this._listeners)),new Error(\"Attempted to dispose unknown listener\");this._size--,e[i]=void 0;let r=this._deliveryQueue.current===this;if(this._size*ql<=e.length){let n=0;for(let o=0;o<e.length;o++)e[o]?e[n++]=e[o]:r&&(this._deliveryQueue.end--,n<this._deliveryQueue.i&&this._deliveryQueue.i--);e.length=n}}_deliver(t,e){if(!t)return;let i=this._options?.onListenerError||Lt;if(!i){t.value(e);return}try{t.value(e)}catch(r){i(r)}}_deliverQueue(t){let e=t.current._listeners;for(;t.i<t.end;)this._deliver(e[t.i++],t.value);t.reset()}fire(t){if(this._deliveryQueue?.current&&(this._deliverQueue(this._deliveryQueue),this._perfMon?.stop()),this._perfMon?.start(this._size),this._listeners)if(this._listeners instanceof Pt)this._deliver(this._listeners,t);else{let e=this._deliveryQueue;e.enqueue(this,t,this._listeners.length),this._deliverQueue(e)}this._perfMon?.stop()}hasListeners(){return this._size>0}};var jn=class{constructor(){this.i=-1;this.end=0}enqueue(t,e,i){this.i=0,this.end=i,this.current=t,this.value=e}reset(){this.i=this.end,this.current=void 0,this.value=void 0}};var gr=class gr{constructor(){this.mapWindowIdToZoomLevel=new Map;this._onDidChangeZoomLevel=new v;this.onDidChangeZoomLevel=this._onDidChangeZoomLevel.event;this.mapWindowIdToZoomFactor=new Map;this._onDidChangeFullscreen=new v;this.onDidChangeFullscreen=this._onDidChangeFullscreen.event;this.mapWindowIdToFullScreen=new Map}getZoomLevel(t){return this.mapWindowIdToZoomLevel.get(this.getWindowId(t))??0}setZoomLevel(t,e){if(this.getZoomLevel(e)===t)return;let i=this.getWindowId(e);this.mapWindowIdToZoomLevel.set(i,t),this._onDidChangeZoomLevel.fire(i)}getZoomFactor(t){return this.mapWindowIdToZoomFactor.get(this.getWindowId(t))??1}setZoomFactor(t,e){this.mapWindowIdToZoomFactor.set(this.getWindowId(e),t)}setFullscreen(t,e){if(this.isFullscreen(e)===t)return;let i=this.getWindowId(e);this.mapWindowIdToFullScreen.set(i,t),this._onDidChangeFullscreen.fire(i)}isFullscreen(t){return!!this.mapWindowIdToFullScreen.get(this.getWindowId(t))}getWindowId(t){return t.vscodeWindowId}};gr.INSTANCE=new gr;var Si=gr;function Xl(s,t,e){typeof t==\"string\"&&(t=s.matchMedia(t)),t.addEventListener(\"change\",e)}var Eu=Si.INSTANCE.onDidChangeZoomLevel;function mo(s){return Si.INSTANCE.getZoomFactor(s)}var Tu=Si.INSTANCE.onDidChangeFullscreen,Ot=typeof navigator==\"object\"?navigator.userAgent:\"\",Ei=Ot.indexOf(\"Firefox\")>=0,Bt=Ot.indexOf(\"AppleWebKit\")>=0,Ti=Ot.indexOf(\"Chrome\")>=0,Sr=!Ti&&Ot.indexOf(\"Safari\")>=0;var Iu=Ot.indexOf(\"Electron/\")>=0,yu=Ot.indexOf(\"Android\")>=0,vr=!1;if(typeof fe.matchMedia==\"function\"){let s=fe.matchMedia(\"(display-mode: standalone) or (display-mode: window-controls-overlay)\"),t=fe.matchMedia(\"(display-mode: fullscreen)\");vr=s.matches,Xl(fe,s,({matches:e})=>{vr&&t.matches||(vr=e)})}function _o(){return vr}var Nt=\"en\",yr=!1,xr=!1,Ii=!1,Zl=!1,vo=!1,go=!1,Jl=!1,Ql=!1,ea=!1,ta=!1,Tr,Ir=Nt,bo=Nt,ia,$e,Ve=globalThis,xe;typeof Ve.vscode<\"u\"&&typeof Ve.vscode.process<\"u\"?xe=Ve.vscode.process:typeof process<\"u\"&&typeof process?.versions?.node==\"string\"&&(xe=process);var So=typeof xe?.versions?.electron==\"string\",ra=So&&xe?.type===\"renderer\";if(typeof xe==\"object\"){yr=xe.platform===\"win32\",xr=xe.platform===\"darwin\",Ii=xe.platform===\"linux\",Zl=Ii&&!!xe.env.SNAP&&!!xe.env.SNAP_REVISION,Jl=So,ea=!!xe.env.CI||!!xe.env.BUILD_ARTIFACTSTAGINGDIRECTORY,Tr=Nt,Ir=Nt;let s=xe.env.VSCODE_NLS_CONFIG;if(s)try{let t=JSON.parse(s);Tr=t.userLocale,bo=t.osLocale,Ir=t.resolvedLanguage||Nt,ia=t.languagePack?.translationsConfigFile}catch{}vo=!0}else typeof navigator==\"object\"&&!ra?($e=navigator.userAgent,yr=$e.indexOf(\"Windows\")>=0,xr=$e.indexOf(\"Macintosh\")>=0,Ql=($e.indexOf(\"Macintosh\")>=0||$e.indexOf(\"iPad\")>=0||$e.indexOf(\"iPhone\")>=0)&&!!navigator.maxTouchPoints&&navigator.maxTouchPoints>0,Ii=$e.indexOf(\"Linux\")>=0,ta=$e?.indexOf(\"Mobi\")>=0,go=!0,Ir=globalThis._VSCODE_NLS_LANGUAGE||Nt,Tr=navigator.language.toLowerCase(),bo=Tr):console.error(\"Unable to resolve platform.\");var Xn=0;xr?Xn=1:yr?Xn=3:Ii&&(Xn=2);var wr=yr,Te=xr,Zn=Ii;var Dr=vo;var na=go&&typeof Ve.importScripts==\"function\",xu=na?Ve.origin:void 0;var Fe=$e,st=Ir,sa;(i=>{function s(){return st}i.value=s;function t(){return st.length===2?st===\"en\":st.length>=3?st[0]===\"e\"&&st[1]===\"n\"&&st[2]===\"-\":!1}i.isDefaultVariant=t;function e(){return st===\"en\"}i.isDefault=e})(sa||={});var oa=typeof Ve.postMessage==\"function\"&&!Ve.importScripts,Eo=(()=>{if(oa){let s=[];Ve.addEventListener(\"message\",e=>{if(e.data&&e.data.vscodeScheduleAsyncWork)for(let i=0,r=s.length;i<r;i++){let n=s[i];if(n.id===e.data.vscodeScheduleAsyncWork){s.splice(i,1),n.callback();return}}});let t=0;return e=>{let i=++t;s.push({id:i,callback:e}),Ve.postMessage({vscodeScheduleAsyncWork:i},\"*\")}}return s=>setTimeout(s)})();var la=!!(Fe&&Fe.indexOf(\"Chrome\")>=0),wu=!!(Fe&&Fe.indexOf(\"Firefox\")>=0),Du=!!(!la&&Fe&&Fe.indexOf(\"Safari\")>=0),Ru=!!(Fe&&Fe.indexOf(\"Edg/\")>=0),Lu=!!(Fe&&Fe.indexOf(\"Android\")>=0);var ot=typeof navigator==\"object\"?navigator:{},aa={clipboard:{writeText:Dr||document.queryCommandSupported&&document.queryCommandSupported(\"copy\")||!!(ot&&ot.clipboard&&ot.clipboard.writeText),readText:Dr||!!(ot&&ot.clipboard&&ot.clipboard.readText)},keyboard:Dr||_o()?0:ot.keyboard||Sr?1:2,touch:\"ontouchstart\"in fe||ot.maxTouchPoints>0,pointerEvents:fe.PointerEvent&&(\"ontouchstart\"in fe||navigator.maxTouchPoints>0)};var yi=class{constructor(){this._keyCodeToStr=[],this._strToKeyCode=Object.create(null)}define(t,e){this._keyCodeToStr[t]=e,this._strToKeyCode[e.toLowerCase()]=t}keyCodeToStr(t){return this._keyCodeToStr[t]}strToKeyCode(t){return this._strToKeyCode[t.toLowerCase()]||0}},Jn=new yi,To=new yi,Io=new yi,yo=new Array(230);var Qn;(o=>{function s(l){return Jn.keyCodeToStr(l)}o.toString=s;function t(l){return Jn.strToKeyCode(l)}o.fromString=t;function e(l){return To.keyCodeToStr(l)}o.toUserSettingsUS=e;function i(l){return Io.keyCodeToStr(l)}o.toUserSettingsGeneral=i;function r(l){return To.strToKeyCode(l)||Io.strToKeyCode(l)}o.fromUserSettings=r;function n(l){if(l>=98&&l<=113)return null;switch(l){case 16:return\"Up\";case 18:return\"Down\";case 15:return\"Left\";case 17:return\"Right\"}return Jn.keyCodeToStr(l)}o.toElectronAccelerator=n})(Qn||={});var Rr=class s{constructor(t,e,i,r,n){this.ctrlKey=t;this.shiftKey=e;this.altKey=i;this.metaKey=r;this.keyCode=n}equals(t){return t instanceof s&&this.ctrlKey===t.ctrlKey&&this.shiftKey===t.shiftKey&&this.altKey===t.altKey&&this.metaKey===t.metaKey&&this.keyCode===t.keyCode}getHashCode(){let t=this.ctrlKey?\"1\":\"0\",e=this.shiftKey?\"1\":\"0\",i=this.altKey?\"1\":\"0\",r=this.metaKey?\"1\":\"0\";return`K${t}${e}${i}${r}${this.keyCode}`}isModifierKey(){return this.keyCode===0||this.keyCode===5||this.keyCode===57||this.keyCode===6||this.keyCode===4}toKeybinding(){return new es([this])}isDuplicateModifierCase(){return this.ctrlKey&&this.keyCode===5||this.shiftKey&&this.keyCode===4||this.altKey&&this.keyCode===6||this.metaKey&&this.keyCode===57}};var es=class{constructor(t){if(t.length===0)throw eo(\"chords\");this.chords=t}getHashCode(){let t=\"\";for(let e=0,i=this.chords.length;e<i;e++)e!==0&&(t+=\";\"),t+=this.chords[e].getHashCode();return t}equals(t){if(t===null||this.chords.length!==t.chords.length)return!1;for(let e=0;e<this.chords.length;e++)if(!this.chords[e].equals(t.chords[e]))return!1;return!0}};function ca(s){if(s.charCode){let e=String.fromCharCode(s.charCode).toUpperCase();return Qn.fromString(e)}let t=s.keyCode;if(t===3)return 7;if(Ei)switch(t){case 59:return 85;case 60:if(Zn)return 97;break;case 61:return 86;case 107:return 109;case 109:return 111;case 173:return 88;case 224:if(Te)return 57;break}else if(Bt){if(Te&&t===93)return 57;if(!Te&&t===92)return 57}return yo[t]||0}var ua=Te?256:2048,ha=512,da=1024,fa=Te?2048:256;var ft=class{constructor(t){this._standardKeyboardEventBrand=!0;let e=t;this.browserEvent=e,this.target=e.target,this.ctrlKey=e.ctrlKey,this.shiftKey=e.shiftKey,this.altKey=e.altKey,this.metaKey=e.metaKey,this.altGraphKey=e.getModifierState?.(\"AltGraph\"),this.keyCode=ca(e),this.code=e.code,this.ctrlKey=this.ctrlKey||this.keyCode===5,this.altKey=this.altKey||this.keyCode===6,this.shiftKey=this.shiftKey||this.keyCode===4,this.metaKey=this.metaKey||this.keyCode===57,this._asKeybinding=this._computeKeybinding(),this._asKeyCodeChord=this._computeKeyCodeChord()}preventDefault(){this.browserEvent&&this.browserEvent.preventDefault&&this.browserEvent.preventDefault()}stopPropagation(){this.browserEvent&&this.browserEvent.stopPropagation&&this.browserEvent.stopPropagation()}toKeyCodeChord(){return this._asKeyCodeChord}equals(t){return this._asKeybinding===t}_computeKeybinding(){let t=0;this.keyCode!==5&&this.keyCode!==4&&this.keyCode!==6&&this.keyCode!==57&&(t=this.keyCode);let e=0;return this.ctrlKey&&(e|=ua),this.altKey&&(e|=ha),this.shiftKey&&(e|=da),this.metaKey&&(e|=fa),e|=t,e}_computeKeyCodeChord(){let t=0;return this.keyCode!==5&&this.keyCode!==4&&this.keyCode!==6&&this.keyCode!==57&&(t=this.keyCode),new Rr(this.ctrlKey,this.shiftKey,this.altKey,this.metaKey,t)}};var wo=new WeakMap;function pa(s){if(!s.parent||s.parent===s)return null;try{let t=s.location,e=s.parent.location;if(t.origin!==\"null\"&&e.origin!==\"null\"&&t.origin!==e.origin)return null}catch{return null}return s.parent}var Lr=class{static getSameOriginWindowChain(t){let e=wo.get(t);if(!e){e=[],wo.set(t,e);let i=t,r;do r=pa(i),r?e.push({window:new WeakRef(i),iframeElement:i.frameElement||null}):e.push({window:new WeakRef(i),iframeElement:null}),i=r;while(i)}return e.slice(0)}static getPositionOfChildWindowRelativeToAncestorWindow(t,e){if(!e||t===e)return{top:0,left:0};let i=0,r=0,n=this.getSameOriginWindowChain(t);for(let o of n){let l=o.window.deref();if(i+=l?.scrollY??0,r+=l?.scrollX??0,l===e||!o.iframeElement)break;let a=o.iframeElement.getBoundingClientRect();i+=a.top,r+=a.left}return{top:i,left:r}}};var qe=class{constructor(t,e){this.timestamp=Date.now(),this.browserEvent=e,this.leftButton=e.button===0,this.middleButton=e.button===1,this.rightButton=e.button===2,this.buttons=e.buttons,this.target=e.target,this.detail=e.detail||1,e.type===\"dblclick\"&&(this.detail=2),this.ctrlKey=e.ctrlKey,this.shiftKey=e.shiftKey,this.altKey=e.altKey,this.metaKey=e.metaKey,typeof e.pageX==\"number\"?(this.posx=e.pageX,this.posy=e.pageY):(this.posx=e.clientX+this.target.ownerDocument.body.scrollLeft+this.target.ownerDocument.documentElement.scrollLeft,this.posy=e.clientY+this.target.ownerDocument.body.scrollTop+this.target.ownerDocument.documentElement.scrollTop);let i=Lr.getPositionOfChildWindowRelativeToAncestorWindow(t,e.view);this.posx-=i.left,this.posy-=i.top}preventDefault(){this.browserEvent.preventDefault()}stopPropagation(){this.browserEvent.stopPropagation()}};var xi=class{constructor(t,e=0,i=0){this.browserEvent=t||null,this.target=t?t.target||t.targetNode||t.srcElement:null,this.deltaY=i,this.deltaX=e;let r=!1;if(Ti){let n=navigator.userAgent.match(/Chrome\\/(\\d+)/);r=(n?parseInt(n[1]):123)<=122}if(t){let n=t,o=t,l=t.view?.devicePixelRatio||1;if(typeof n.wheelDeltaY<\"u\")r?this.deltaY=n.wheelDeltaY/(120*l):this.deltaY=n.wheelDeltaY/120;else if(typeof o.VERTICAL_AXIS<\"u\"&&o.axis===o.VERTICAL_AXIS)this.deltaY=-o.detail/3;else if(t.type===\"wheel\"){let a=t;a.deltaMode===a.DOM_DELTA_LINE?Ei&&!Te?this.deltaY=-t.deltaY/3:this.deltaY=-t.deltaY:this.deltaY=-t.deltaY/40}if(typeof n.wheelDeltaX<\"u\")Sr&&wr?this.deltaX=-(n.wheelDeltaX/120):r?this.deltaX=n.wheelDeltaX/(120*l):this.deltaX=n.wheelDeltaX/120;else if(typeof o.HORIZONTAL_AXIS<\"u\"&&o.axis===o.HORIZONTAL_AXIS)this.deltaX=-t.detail/3;else if(t.type===\"wheel\"){let a=t;a.deltaMode===a.DOM_DELTA_LINE?Ei&&!Te?this.deltaX=-t.deltaX/3:this.deltaX=-t.deltaX:this.deltaX=-t.deltaX/40}this.deltaY===0&&this.deltaX===0&&t.wheelDelta&&(r?this.deltaY=t.wheelDelta/(120*l):this.deltaY=t.wheelDelta/120)}}preventDefault(){this.browserEvent?.preventDefault()}stopPropagation(){this.browserEvent?.stopPropagation()}};var Do=Object.freeze(function(s,t){let e=setTimeout(s.bind(t),0);return{dispose(){clearTimeout(e)}}}),ma;(i=>{function s(r){return r===i.None||r===i.Cancelled||r instanceof ts?!0:!r||typeof r!=\"object\"?!1:typeof r.isCancellationRequested==\"boolean\"&&typeof r.onCancellationRequested==\"function\"}i.isCancellationToken=s,i.None=Object.freeze({isCancellationRequested:!1,onCancellationRequested:$.None}),i.Cancelled=Object.freeze({isCancellationRequested:!0,onCancellationRequested:Do})})(ma||={});var ts=class{constructor(){this._isCancelled=!1;this._emitter=null}cancel(){this._isCancelled||(this._isCancelled=!0,this._emitter&&(this._emitter.fire(void 0),this.dispose()))}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){return this._isCancelled?Do:(this._emitter||(this._emitter=new v),this._emitter.event)}dispose(){this._emitter&&(this._emitter.dispose(),this._emitter=null)}};var _a=Symbol(\"MicrotaskDelay\");var Ye=class{constructor(t,e){this._isDisposed=!1;this._token=-1,typeof t==\"function\"&&typeof e==\"number\"&&this.setIfNotSet(t,e)}dispose(){this.cancel(),this._isDisposed=!0}cancel(){this._token!==-1&&(clearTimeout(this._token),this._token=-1)}cancelAndSet(t,e){if(this._isDisposed)throw new Rt(\"Calling 'cancelAndSet' on a disposed TimeoutTimer\");this.cancel(),this._token=setTimeout(()=>{this._token=-1,t()},e)}setIfNotSet(t,e){if(this._isDisposed)throw new Rt(\"Calling 'setIfNotSet' on a disposed TimeoutTimer\");this._token===-1&&(this._token=setTimeout(()=>{this._token=-1,t()},e))}},kr=class{constructor(){this.disposable=void 0;this.isDisposed=!1}cancel(){this.disposable?.dispose(),this.disposable=void 0}cancelAndSet(t,e,i=globalThis){if(this.isDisposed)throw new Rt(\"Calling 'cancelAndSet' on a disposed IntervalTimer\");this.cancel();let r=i.setInterval(()=>{t()},e);this.disposable=C(()=>{i.clearInterval(r),this.disposable=void 0})}dispose(){this.cancel(),this.isDisposed=!0}};var ba,Ar;(function(){typeof globalThis.requestIdleCallback!=\"function\"||typeof globalThis.cancelIdleCallback!=\"function\"?Ar=(s,t)=>{Eo(()=>{if(e)return;let i=Date.now()+15;t(Object.freeze({didTimeout:!0,timeRemaining(){return Math.max(0,i-Date.now())}}))});let e=!1;return{dispose(){e||(e=!0)}}}:Ar=(s,t,e)=>{let i=s.requestIdleCallback(t,typeof e==\"number\"?{timeout:e}:void 0),r=!1;return{dispose(){r||(r=!0,s.cancelIdleCallback(i))}}},ba=s=>Ar(globalThis,s)})();var va;(e=>{async function s(i){let r,n=await Promise.all(i.map(o=>o.then(l=>l,l=>{r||(r=l)})));if(typeof r<\"u\")throw r;return n}e.settled=s;function t(i){return new Promise(async(r,n)=>{try{await i(r,n)}catch(o){n(o)}})}e.withAsyncBody=t})(va||={});var _e=class _e{static fromArray(t){return new _e(e=>{e.emitMany(t)})}static fromPromise(t){return new _e(async e=>{e.emitMany(await t)})}static fromPromises(t){return new _e(async e=>{await Promise.all(t.map(async i=>e.emitOne(await i)))})}static merge(t){return new _e(async e=>{await Promise.all(t.map(async i=>{for await(let r of i)e.emitOne(r)}))})}constructor(t,e){this._state=0,this._results=[],this._error=null,this._onReturn=e,this._onStateChanged=new v,queueMicrotask(async()=>{let i={emitOne:r=>this.emitOne(r),emitMany:r=>this.emitMany(r),reject:r=>this.reject(r)};try{await Promise.resolve(t(i)),this.resolve()}catch(r){this.reject(r)}finally{i.emitOne=void 0,i.emitMany=void 0,i.reject=void 0}})}[Symbol.asyncIterator](){let t=0;return{next:async()=>{do{if(this._state===2)throw this._error;if(t<this._results.length)return{done:!1,value:this._results[t++]};if(this._state===1)return{done:!0,value:void 0};await $.toPromise(this._onStateChanged.event)}while(!0)},return:async()=>(this._onReturn?.(),{done:!0,value:void 0})}}static map(t,e){return new _e(async i=>{for await(let r of t)i.emitOne(e(r))})}map(t){return _e.map(this,t)}static filter(t,e){return new _e(async i=>{for await(let r of t)e(r)&&i.emitOne(r)})}filter(t){return _e.filter(this,t)}static coalesce(t){return _e.filter(t,e=>!!e)}coalesce(){return _e.coalesce(this)}static async toPromise(t){let e=[];for await(let i of t)e.push(i);return e}toPromise(){return _e.toPromise(this)}emitOne(t){this._state===0&&(this._results.push(t),this._onStateChanged.fire())}emitMany(t){this._state===0&&(this._results=this._results.concat(t),this._onStateChanged.fire())}resolve(){this._state===0&&(this._state=1,this._onStateChanged.fire())}reject(t){this._state===0&&(this._state=2,this._error=t,this._onStateChanged.fire())}};_e.EMPTY=_e.fromArray([]);var Ro=_e;function Lo(s){return 55296<=s&&s<=56319}function is(s){return 56320<=s&&s<=57343}function Ao(s,t){return(s-55296<<10)+(t-56320)+65536}function Mo(s){return ns(s,0)}function ns(s,t){switch(typeof s){case\"object\":return s===null?je(349,t):Array.isArray(s)?Ea(s,t):Ta(s,t);case\"string\":return Po(s,t);case\"boolean\":return Sa(s,t);case\"number\":return je(s,t);case\"undefined\":return je(937,t);default:return je(617,t)}}function je(s,t){return(t<<5)-t+s|0}function Sa(s,t){return je(s?433:863,t)}function Po(s,t){t=je(149417,t);for(let e=0,i=s.length;e<i;e++)t=je(s.charCodeAt(e),t);return t}function Ea(s,t){return t=je(104579,t),s.reduce((e,i)=>ns(i,e),t)}function Ta(s,t){return t=je(181387,t),Object.keys(s).sort().reduce((e,i)=>(e=Po(i,e),ns(s[i],e)),t)}function rs(s,t,e=32){let i=e-t,r=~((1<<i)-1);return(s<<t|(r&s)>>>i)>>>0}function ko(s,t=0,e=s.byteLength,i=0){for(let r=0;r<e;r++)s[t+r]=i}function Ia(s,t,e=\"0\"){for(;s.length<t;)s=e+s;return s}function wi(s,t=32){return s instanceof ArrayBuffer?Array.from(new Uint8Array(s)).map(e=>e.toString(16).padStart(2,\"0\")).join(\"\"):Ia((s>>>0).toString(16),t/4)}var Cr=class Cr{constructor(){this._h0=1732584193;this._h1=4023233417;this._h2=2562383102;this._h3=271733878;this._h4=3285377520;this._buff=new Uint8Array(67),this._buffDV=new DataView(this._buff.buffer),this._buffLen=0,this._totalLen=0,this._leftoverHighSurrogate=0,this._finished=!1}update(t){let e=t.length;if(e===0)return;let i=this._buff,r=this._buffLen,n=this._leftoverHighSurrogate,o,l;for(n!==0?(o=n,l=-1,n=0):(o=t.charCodeAt(0),l=0);;){let a=o;if(Lo(o))if(l+1<e){let u=t.charCodeAt(l+1);is(u)?(l++,a=Ao(o,u)):a=65533}else{n=o;break}else is(o)&&(a=65533);if(r=this._push(i,r,a),l++,l<e)o=t.charCodeAt(l);else break}this._buffLen=r,this._leftoverHighSurrogate=n}_push(t,e,i){return i<128?t[e++]=i:i<2048?(t[e++]=192|(i&1984)>>>6,t[e++]=128|(i&63)>>>0):i<65536?(t[e++]=224|(i&61440)>>>12,t[e++]=128|(i&4032)>>>6,t[e++]=128|(i&63)>>>0):(t[e++]=240|(i&1835008)>>>18,t[e++]=128|(i&258048)>>>12,t[e++]=128|(i&4032)>>>6,t[e++]=128|(i&63)>>>0),e>=64&&(this._step(),e-=64,this._totalLen+=64,t[0]=t[64],t[1]=t[65],t[2]=t[66]),e}digest(){return this._finished||(this._finished=!0,this._leftoverHighSurrogate&&(this._leftoverHighSurrogate=0,this._buffLen=this._push(this._buff,this._buffLen,65533)),this._totalLen+=this._buffLen,this._wrapUp()),wi(this._h0)+wi(this._h1)+wi(this._h2)+wi(this._h3)+wi(this._h4)}_wrapUp(){this._buff[this._buffLen++]=128,ko(this._buff,this._buffLen),this._buffLen>56&&(this._step(),ko(this._buff));let t=8*this._totalLen;this._buffDV.setUint32(56,Math.floor(t/4294967296),!1),this._buffDV.setUint32(60,t%4294967296,!1),this._step()}_step(){let t=Cr._bigBlock32,e=this._buffDV;for(let c=0;c<64;c+=4)t.setUint32(c,e.getUint32(c,!1),!1);for(let c=64;c<320;c+=4)t.setUint32(c,rs(t.getUint32(c-12,!1)^t.getUint32(c-32,!1)^t.getUint32(c-56,!1)^t.getUint32(c-64,!1),1),!1);let i=this._h0,r=this._h1,n=this._h2,o=this._h3,l=this._h4,a,u,h;for(let c=0;c<80;c++)c<20?(a=r&n|~r&o,u=1518500249):c<40?(a=r^n^o,u=1859775393):c<60?(a=r&n|r&o|n&o,u=2400959708):(a=r^n^o,u=3395469782),h=rs(i,5)+a+l+u+t.getUint32(c*4,!1)&4294967295,l=o,o=n,n=rs(r,30),r=i,i=h;this._h0=this._h0+i&4294967295,this._h1=this._h1+r&4294967295,this._h2=this._h2+n&4294967295,this._h3=this._h3+o&4294967295,this._h4=this._h4+l&4294967295}};Cr._bigBlock32=new DataView(new ArrayBuffer(320));var Co=Cr;var{registerWindow:Bh,getWindow:be,getDocument:Nh,getWindows:Fh,getWindowsCount:Hh,getWindowId:Oo,getWindowById:Wh,hasWindow:Uh,onDidRegisterWindow:No,onWillUnregisterWindow:Kh,onDidUnregisterWindow:zh}=function(){let s=new Map;fe;let t={window:fe,disposables:new Ee};s.set(fe.vscodeWindowId,t);let e=new v,i=new v,r=new v;function n(o,l){return(typeof o==\"number\"?s.get(o):void 0)??(l?t:void 0)}return{onDidRegisterWindow:e.event,onWillUnregisterWindow:r.event,onDidUnregisterWindow:i.event,registerWindow(o){if(s.has(o.vscodeWindowId))return D.None;let l=new Ee,a={window:o,disposables:l.add(new Ee)};return s.set(o.vscodeWindowId,a),l.add(C(()=>{s.delete(o.vscodeWindowId),i.fire(o)})),l.add(L(o,Y.BEFORE_UNLOAD,()=>{r.fire(o)})),e.fire(a),l},getWindows(){return s.values()},getWindowsCount(){return s.size},getWindowId(o){return o.vscodeWindowId},hasWindow(o){return s.has(o)},getWindowById:n,getWindow(o){let l=o;if(l?.ownerDocument?.defaultView)return l.ownerDocument.defaultView.window;let a=o;return a?.view?a.view.window:fe},getDocument(o){return be(o).document}}}();var ss=class{constructor(t,e,i,r){this._node=t,this._type=e,this._handler=i,this._options=r||!1,this._node.addEventListener(this._type,this._handler,this._options)}dispose(){this._handler&&(this._node.removeEventListener(this._type,this._handler,this._options),this._node=null,this._handler=null)}};function L(s,t,e,i){return new ss(s,t,e,i)}function ya(s,t){return function(e){return t(new qe(s,e))}}function xa(s){return function(t){return s(new ft(t))}}var os=function(t,e,i,r){let n=i;return e===\"click\"||e===\"mousedown\"||e===\"contextmenu\"?n=ya(be(t),i):(e===\"keydown\"||e===\"keypress\"||e===\"keyup\")&&(n=xa(i)),L(t,e,n,r)};var wa,mt;var Mr=class extends kr{constructor(t){super(),this.defaultTarget=t&&be(t)}cancelAndSet(t,e,i){return super.cancelAndSet(t,e,i??this.defaultTarget)}},Di=class{constructor(t,e=0){this._runner=t,this.priority=e,this._canceled=!1}dispose(){this._canceled=!0}execute(){if(!this._canceled)try{this._runner()}catch(t){Lt(t)}}static sort(t,e){return e.priority-t.priority}};(function(){let s=new Map,t=new Map,e=new Map,i=new Map,r=n=>{e.set(n,!1);let o=s.get(n)??[];for(t.set(n,o),s.set(n,[]),i.set(n,!0);o.length>0;)o.sort(Di.sort),o.shift().execute();i.set(n,!1)};mt=(n,o,l=0)=>{let a=Oo(n),u=new Di(o,l),h=s.get(a);return h||(h=[],s.set(a,h)),h.push(u),e.get(a)||(e.set(a,!0),n.requestAnimationFrame(()=>r(a))),u},wa=(n,o,l)=>{let a=Oo(n);if(i.get(a)){let u=new Di(o,l),h=t.get(a);return h||(h=[],t.set(a,h)),h.push(u),u}else return mt(n,o,l)}})();var pt=class pt{constructor(t,e){this.width=t;this.height=e}with(t=this.width,e=this.height){return t!==this.width||e!==this.height?new pt(t,e):this}static is(t){return typeof t==\"object\"&&typeof t.height==\"number\"&&typeof t.width==\"number\"}static lift(t){return t instanceof pt?t:new pt(t.width,t.height)}static equals(t,e){return t===e?!0:!t||!e?!1:t.width===e.width&&t.height===e.height}};pt.None=new pt(0,0);var Bo=pt;function Fo(s){let t=s.getBoundingClientRect(),e=be(s);return{left:t.left+e.scrollX,top:t.top+e.scrollY,width:t.width,height:t.height}}var Gh=new class{constructor(){this.mutationObservers=new Map}observe(s,t,e){let i=this.mutationObservers.get(s);i||(i=new Map,this.mutationObservers.set(s,i));let r=Mo(e),n=i.get(r);if(n)n.users+=1;else{let o=new v,l=new MutationObserver(u=>o.fire(u));l.observe(s,e);let a=n={users:1,observer:l,onDidMutate:o.event};t.add(C(()=>{a.users-=1,a.users===0&&(o.dispose(),l.disconnect(),i?.delete(r),i?.size===0&&this.mutationObservers.delete(s))})),i.set(r,n)}return n.onDidMutate}};var Y={CLICK:\"click\",AUXCLICK:\"auxclick\",DBLCLICK:\"dblclick\",MOUSE_UP:\"mouseup\",MOUSE_DOWN:\"mousedown\",MOUSE_OVER:\"mouseover\",MOUSE_MOVE:\"mousemove\",MOUSE_OUT:\"mouseout\",MOUSE_ENTER:\"mouseenter\",MOUSE_LEAVE:\"mouseleave\",MOUSE_WHEEL:\"wheel\",POINTER_UP:\"pointerup\",POINTER_DOWN:\"pointerdown\",POINTER_MOVE:\"pointermove\",POINTER_LEAVE:\"pointerleave\",CONTEXT_MENU:\"contextmenu\",WHEEL:\"wheel\",KEY_DOWN:\"keydown\",KEY_PRESS:\"keypress\",KEY_UP:\"keyup\",LOAD:\"load\",BEFORE_UNLOAD:\"beforeunload\",UNLOAD:\"unload\",PAGE_SHOW:\"pageshow\",PAGE_HIDE:\"pagehide\",PASTE:\"paste\",ABORT:\"abort\",ERROR:\"error\",RESIZE:\"resize\",SCROLL:\"scroll\",FULLSCREEN_CHANGE:\"fullscreenchange\",WK_FULLSCREEN_CHANGE:\"webkitfullscreenchange\",SELECT:\"select\",CHANGE:\"change\",SUBMIT:\"submit\",RESET:\"reset\",FOCUS:\"focus\",FOCUS_IN:\"focusin\",FOCUS_OUT:\"focusout\",BLUR:\"blur\",INPUT:\"input\",STORAGE:\"storage\",DRAG_START:\"dragstart\",DRAG:\"drag\",DRAG_ENTER:\"dragenter\",DRAG_LEAVE:\"dragleave\",DRAG_OVER:\"dragover\",DROP:\"drop\",DRAG_END:\"dragend\",ANIMATION_START:Bt?\"webkitAnimationStart\":\"animationstart\",ANIMATION_END:Bt?\"webkitAnimationEnd\":\"animationend\",ANIMATION_ITERATION:Bt?\"webkitAnimationIteration\":\"animationiteration\"};var Da=/([\\w\\-]+)?(#([\\w\\-]+))?((\\.([\\w\\-]+))*)/;function Ho(s,t,e,...i){let r=Da.exec(t);if(!r)throw new Error(\"Bad use of emmet\");let n=r[1]||\"div\",o;return s!==\"http://www.w3.org/1999/xhtml\"?o=document.createElementNS(s,n):o=document.createElement(n),r[3]&&(o.id=r[3]),r[4]&&(o.className=r[4].replace(/\\./g,\" \").trim()),e&&Object.entries(e).forEach(([l,a])=>{typeof a>\"u\"||(/^on\\w+$/.test(l)?o[l]=a:l===\"selected\"?a&&o.setAttribute(l,\"true\"):o.setAttribute(l,a))}),o.append(...i),o}function Ra(s,t,...e){return Ho(\"http://www.w3.org/1999/xhtml\",s,t,...e)}Ra.SVG=function(s,t,...e){return Ho(\"http://www.w3.org/2000/svg\",s,t,...e)};var ls=class{constructor(t){this.domNode=t;this._maxWidth=\"\";this._width=\"\";this._height=\"\";this._top=\"\";this._left=\"\";this._bottom=\"\";this._right=\"\";this._paddingTop=\"\";this._paddingLeft=\"\";this._paddingBottom=\"\";this._paddingRight=\"\";this._fontFamily=\"\";this._fontWeight=\"\";this._fontSize=\"\";this._fontStyle=\"\";this._fontFeatureSettings=\"\";this._fontVariationSettings=\"\";this._textDecoration=\"\";this._lineHeight=\"\";this._letterSpacing=\"\";this._className=\"\";this._display=\"\";this._position=\"\";this._visibility=\"\";this._color=\"\";this._backgroundColor=\"\";this._layerHint=!1;this._contain=\"none\";this._boxShadow=\"\"}setMaxWidth(t){let e=Ie(t);this._maxWidth!==e&&(this._maxWidth=e,this.domNode.style.maxWidth=this._maxWidth)}setWidth(t){let e=Ie(t);this._width!==e&&(this._width=e,this.domNode.style.width=this._width)}setHeight(t){let e=Ie(t);this._height!==e&&(this._height=e,this.domNode.style.height=this._height)}setTop(t){let e=Ie(t);this._top!==e&&(this._top=e,this.domNode.style.top=this._top)}setLeft(t){let e=Ie(t);this._left!==e&&(this._left=e,this.domNode.style.left=this._left)}setBottom(t){let e=Ie(t);this._bottom!==e&&(this._bottom=e,this.domNode.style.bottom=this._bottom)}setRight(t){let e=Ie(t);this._right!==e&&(this._right=e,this.domNode.style.right=this._right)}setPaddingTop(t){let e=Ie(t);this._paddingTop!==e&&(this._paddingTop=e,this.domNode.style.paddingTop=this._paddingTop)}setPaddingLeft(t){let e=Ie(t);this._paddingLeft!==e&&(this._paddingLeft=e,this.domNode.style.paddingLeft=this._paddingLeft)}setPaddingBottom(t){let e=Ie(t);this._paddingBottom!==e&&(this._paddingBottom=e,this.domNode.style.paddingBottom=this._paddingBottom)}setPaddingRight(t){let e=Ie(t);this._paddingRight!==e&&(this._paddingRight=e,this.domNode.style.paddingRight=this._paddingRight)}setFontFamily(t){this._fontFamily!==t&&(this._fontFamily=t,this.domNode.style.fontFamily=this._fontFamily)}setFontWeight(t){this._fontWeight!==t&&(this._fontWeight=t,this.domNode.style.fontWeight=this._fontWeight)}setFontSize(t){let e=Ie(t);this._fontSize!==e&&(this._fontSize=e,this.domNode.style.fontSize=this._fontSize)}setFontStyle(t){this._fontStyle!==t&&(this._fontStyle=t,this.domNode.style.fontStyle=this._fontStyle)}setFontFeatureSettings(t){this._fontFeatureSettings!==t&&(this._fontFeatureSettings=t,this.domNode.style.fontFeatureSettings=this._fontFeatureSettings)}setFontVariationSettings(t){this._fontVariationSettings!==t&&(this._fontVariationSettings=t,this.domNode.style.fontVariationSettings=this._fontVariationSettings)}setTextDecoration(t){this._textDecoration!==t&&(this._textDecoration=t,this.domNode.style.textDecoration=this._textDecoration)}setLineHeight(t){let e=Ie(t);this._lineHeight!==e&&(this._lineHeight=e,this.domNode.style.lineHeight=this._lineHeight)}setLetterSpacing(t){let e=Ie(t);this._letterSpacing!==e&&(this._letterSpacing=e,this.domNode.style.letterSpacing=this._letterSpacing)}setClassName(t){this._className!==t&&(this._className=t,this.domNode.className=this._className)}toggleClassName(t,e){this.domNode.classList.toggle(t,e),this._className=this.domNode.className}setDisplay(t){this._display!==t&&(this._display=t,this.domNode.style.display=this._display)}setPosition(t){this._position!==t&&(this._position=t,this.domNode.style.position=this._position)}setVisibility(t){this._visibility!==t&&(this._visibility=t,this.domNode.style.visibility=this._visibility)}setColor(t){this._color!==t&&(this._color=t,this.domNode.style.color=this._color)}setBackgroundColor(t){this._backgroundColor!==t&&(this._backgroundColor=t,this.domNode.style.backgroundColor=this._backgroundColor)}setLayerHinting(t){this._layerHint!==t&&(this._layerHint=t,this.domNode.style.transform=this._layerHint?\"translate3d(0px, 0px, 0px)\":\"\")}setBoxShadow(t){this._boxShadow!==t&&(this._boxShadow=t,this.domNode.style.boxShadow=t)}setContain(t){this._contain!==t&&(this._contain=t,this.domNode.style.contain=this._contain)}setAttribute(t,e){this.domNode.setAttribute(t,e)}removeAttribute(t){this.domNode.removeAttribute(t)}appendChild(t){this.domNode.appendChild(t.domNode)}removeChild(t){this.domNode.removeChild(t.domNode)}};function Ie(s){return typeof s==\"number\"?`${s}px`:s}function _t(s){return new ls(s)}var Wt=class{constructor(){this._hooks=new Ee;this._pointerMoveCallback=null;this._onStopCallback=null}dispose(){this.stopMonitoring(!1),this._hooks.dispose()}stopMonitoring(t,e){if(!this.isMonitoring())return;this._hooks.clear(),this._pointerMoveCallback=null;let i=this._onStopCallback;this._onStopCallback=null,t&&i&&i(e)}isMonitoring(){return!!this._pointerMoveCallback}startMonitoring(t,e,i,r,n){this.isMonitoring()&&this.stopMonitoring(!1),this._pointerMoveCallback=r,this._onStopCallback=n;let o=t;try{t.setPointerCapture(e),this._hooks.add(C(()=>{try{t.releasePointerCapture(e)}catch{}}))}catch{o=be(t)}this._hooks.add(L(o,Y.POINTER_MOVE,l=>{if(l.buttons!==i){this.stopMonitoring(!0);return}l.preventDefault(),this._pointerMoveCallback(l)})),this._hooks.add(L(o,Y.POINTER_UP,l=>this.stopMonitoring(!0)))}};function Wo(s,t,e){let i=null,r=null;if(typeof e.value==\"function\"?(i=\"value\",r=e.value,r.length!==0&&console.warn(\"Memoize should only be used in functions with zero parameters\")):typeof e.get==\"function\"&&(i=\"get\",r=e.get),!r)throw new Error(\"not supported\");let n=`$memoize$${t}`;e[i]=function(...o){return this.hasOwnProperty(n)||Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:r.apply(this,o)}),this[n]}}var He;(n=>(n.Tap=\"-xterm-gesturetap\",n.Change=\"-xterm-gesturechange\",n.Start=\"-xterm-gesturestart\",n.End=\"-xterm-gesturesend\",n.Contextmenu=\"-xterm-gesturecontextmenu\"))(He||={});var Q=class Q extends D{constructor(){super();this.dispatched=!1;this.targets=new Ct;this.ignoreTargets=new Ct;this.activeTouches={},this.handle=null,this._lastSetTapCountTime=0,this._register($.runAndSubscribe(No,({window:e,disposables:i})=>{i.add(L(e.document,\"touchstart\",r=>this.onTouchStart(r),{passive:!1})),i.add(L(e.document,\"touchend\",r=>this.onTouchEnd(e,r))),i.add(L(e.document,\"touchmove\",r=>this.onTouchMove(r),{passive:!1}))},{window:fe,disposables:this._store}))}static addTarget(e){if(!Q.isTouchDevice())return D.None;Q.INSTANCE||(Q.INSTANCE=Gn(new Q));let i=Q.INSTANCE.targets.push(e);return C(i)}static ignoreTarget(e){if(!Q.isTouchDevice())return D.None;Q.INSTANCE||(Q.INSTANCE=Gn(new Q));let i=Q.INSTANCE.ignoreTargets.push(e);return C(i)}static isTouchDevice(){return\"ontouchstart\"in fe||navigator.maxTouchPoints>0}dispose(){this.handle&&(this.handle.dispose(),this.handle=null),super.dispose()}onTouchStart(e){let i=Date.now();this.handle&&(this.handle.dispose(),this.handle=null);for(let r=0,n=e.targetTouches.length;r<n;r++){let o=e.targetTouches.item(r);this.activeTouches[o.identifier]={id:o.identifier,initialTarget:o.target,initialTimeStamp:i,initialPageX:o.pageX,initialPageY:o.pageY,rollingTimestamps:[i],rollingPageX:[o.pageX],rollingPageY:[o.pageY]};let l=this.newGestureEvent(He.Start,o.target);l.pageX=o.pageX,l.pageY=o.pageY,this.dispatchEvent(l)}this.dispatched&&(e.preventDefault(),e.stopPropagation(),this.dispatched=!1)}onTouchEnd(e,i){let r=Date.now(),n=Object.keys(this.activeTouches).length;for(let o=0,l=i.changedTouches.length;o<l;o++){let a=i.changedTouches.item(o);if(!this.activeTouches.hasOwnProperty(String(a.identifier))){console.warn(\"move of an UNKNOWN touch\",a);continue}let u=this.activeTouches[a.identifier],h=Date.now()-u.initialTimeStamp;if(h<Q.HOLD_DELAY&&Math.abs(u.initialPageX-Se(u.rollingPageX))<30&&Math.abs(u.initialPageY-Se(u.rollingPageY))<30){let c=this.newGestureEvent(He.Tap,u.initialTarget);c.pageX=Se(u.rollingPageX),c.pageY=Se(u.rollingPageY),this.dispatchEvent(c)}else if(h>=Q.HOLD_DELAY&&Math.abs(u.initialPageX-Se(u.rollingPageX))<30&&Math.abs(u.initialPageY-Se(u.rollingPageY))<30){let c=this.newGestureEvent(He.Contextmenu,u.initialTarget);c.pageX=Se(u.rollingPageX),c.pageY=Se(u.rollingPageY),this.dispatchEvent(c)}else if(n===1){let c=Se(u.rollingPageX),d=Se(u.rollingPageY),_=Se(u.rollingTimestamps)-u.rollingTimestamps[0],p=c-u.rollingPageX[0],m=d-u.rollingPageY[0],f=[...this.targets].filter(A=>u.initialTarget instanceof Node&&A.contains(u.initialTarget));this.inertia(e,f,r,Math.abs(p)/_,p>0?1:-1,c,Math.abs(m)/_,m>0?1:-1,d)}this.dispatchEvent(this.newGestureEvent(He.End,u.initialTarget)),delete this.activeTouches[a.identifier]}this.dispatched&&(i.preventDefault(),i.stopPropagation(),this.dispatched=!1)}newGestureEvent(e,i){let r=document.createEvent(\"CustomEvent\");return r.initEvent(e,!1,!0),r.initialTarget=i,r.tapCount=0,r}dispatchEvent(e){if(e.type===He.Tap){let i=new Date().getTime(),r=0;i-this._lastSetTapCountTime>Q.CLEAR_TAP_COUNT_TIME?r=1:r=2,this._lastSetTapCountTime=i,e.tapCount=r}else(e.type===He.Change||e.type===He.Contextmenu)&&(this._lastSetTapCountTime=0);if(e.initialTarget instanceof Node){for(let r of this.ignoreTargets)if(r.contains(e.initialTarget))return;let i=[];for(let r of this.targets)if(r.contains(e.initialTarget)){let n=0,o=e.initialTarget;for(;o&&o!==r;)n++,o=o.parentElement;i.push([n,r])}i.sort((r,n)=>r[0]-n[0]);for(let[r,n]of i)n.dispatchEvent(e),this.dispatched=!0}}inertia(e,i,r,n,o,l,a,u,h){this.handle=mt(e,()=>{let c=Date.now(),d=c-r,_=0,p=0,m=!0;n+=Q.SCROLL_FRICTION*d,a+=Q.SCROLL_FRICTION*d,n>0&&(m=!1,_=o*n*d),a>0&&(m=!1,p=u*a*d);let f=this.newGestureEvent(He.Change);f.translationX=_,f.translationY=p,i.forEach(A=>A.dispatchEvent(f)),m||this.inertia(e,i,c,n,o,l+_,a,u,h+p)})}onTouchMove(e){let i=Date.now();for(let r=0,n=e.changedTouches.length;r<n;r++){let o=e.changedTouches.item(r);if(!this.activeTouches.hasOwnProperty(String(o.identifier))){console.warn(\"end of an UNKNOWN touch\",o);continue}let l=this.activeTouches[o.identifier],a=this.newGestureEvent(He.Change,l.initialTarget);a.translationX=o.pageX-Se(l.rollingPageX),a.translationY=o.pageY-Se(l.rollingPageY),a.pageX=o.pageX,a.pageY=o.pageY,this.dispatchEvent(a),l.rollingPageX.length>3&&(l.rollingPageX.shift(),l.rollingPageY.shift(),l.rollingTimestamps.shift()),l.rollingPageX.push(o.pageX),l.rollingPageY.push(o.pageY),l.rollingTimestamps.push(i)}this.dispatched&&(e.preventDefault(),e.stopPropagation(),this.dispatched=!1)}};Q.SCROLL_FRICTION=-.005,Q.HOLD_DELAY=700,Q.CLEAR_TAP_COUNT_TIME=400,M([Wo],Q,\"isTouchDevice\",1);var Pr=Q;var lt=class extends D{onclick(t,e){this._register(L(t,Y.CLICK,i=>e(new qe(be(t),i))))}onmousedown(t,e){this._register(L(t,Y.MOUSE_DOWN,i=>e(new qe(be(t),i))))}onmouseover(t,e){this._register(L(t,Y.MOUSE_OVER,i=>e(new qe(be(t),i))))}onmouseleave(t,e){this._register(L(t,Y.MOUSE_LEAVE,i=>e(new qe(be(t),i))))}onkeydown(t,e){this._register(L(t,Y.KEY_DOWN,i=>e(new ft(i))))}onkeyup(t,e){this._register(L(t,Y.KEY_UP,i=>e(new ft(i))))}oninput(t,e){this._register(L(t,Y.INPUT,e))}onblur(t,e){this._register(L(t,Y.BLUR,e))}onfocus(t,e){this._register(L(t,Y.FOCUS,e))}onchange(t,e){this._register(L(t,Y.CHANGE,e))}ignoreGesture(t){return Pr.ignoreTarget(t)}};var Uo=11,Or=class extends lt{constructor(t){super(),this._onActivate=t.onActivate,this.bgDomNode=document.createElement(\"div\"),this.bgDomNode.className=\"arrow-background\",this.bgDomNode.style.position=\"absolute\",this.bgDomNode.style.width=t.bgWidth+\"px\",this.bgDomNode.style.height=t.bgHeight+\"px\",typeof t.top<\"u\"&&(this.bgDomNode.style.top=\"0px\"),typeof t.left<\"u\"&&(this.bgDomNode.style.left=\"0px\"),typeof t.bottom<\"u\"&&(this.bgDomNode.style.bottom=\"0px\"),typeof t.right<\"u\"&&(this.bgDomNode.style.right=\"0px\"),this.domNode=document.createElement(\"div\"),this.domNode.className=t.className,this.domNode.style.position=\"absolute\",this.domNode.style.width=Uo+\"px\",this.domNode.style.height=Uo+\"px\",typeof t.top<\"u\"&&(this.domNode.style.top=t.top+\"px\"),typeof t.left<\"u\"&&(this.domNode.style.left=t.left+\"px\"),typeof t.bottom<\"u\"&&(this.domNode.style.bottom=t.bottom+\"px\"),typeof t.right<\"u\"&&(this.domNode.style.right=t.right+\"px\"),this._pointerMoveMonitor=this._register(new Wt),this._register(os(this.bgDomNode,Y.POINTER_DOWN,e=>this._arrowPointerDown(e))),this._register(os(this.domNode,Y.POINTER_DOWN,e=>this._arrowPointerDown(e))),this._pointerdownRepeatTimer=this._register(new Mr),this._pointerdownScheduleRepeatTimer=this._register(new Ye)}_arrowPointerDown(t){if(!t.target||!(t.target instanceof Element))return;let e=()=>{this._pointerdownRepeatTimer.cancelAndSet(()=>this._onActivate(),1e3/24,be(t))};this._onActivate(),this._pointerdownRepeatTimer.cancel(),this._pointerdownScheduleRepeatTimer.cancelAndSet(e,200),this._pointerMoveMonitor.startMonitoring(t.target,t.pointerId,t.buttons,i=>{},()=>{this._pointerdownRepeatTimer.cancel(),this._pointerdownScheduleRepeatTimer.cancel()}),t.preventDefault()}};var cs=class s{constructor(t,e,i,r,n,o,l){this._forceIntegerValues=t;this._scrollStateBrand=void 0;this._forceIntegerValues&&(e=e|0,i=i|0,r=r|0,n=n|0,o=o|0,l=l|0),this.rawScrollLeft=r,this.rawScrollTop=l,e<0&&(e=0),r+e>i&&(r=i-e),r<0&&(r=0),n<0&&(n=0),l+n>o&&(l=o-n),l<0&&(l=0),this.width=e,this.scrollWidth=i,this.scrollLeft=r,this.height=n,this.scrollHeight=o,this.scrollTop=l}equals(t){return this.rawScrollLeft===t.rawScrollLeft&&this.rawScrollTop===t.rawScrollTop&&this.width===t.width&&this.scrollWidth===t.scrollWidth&&this.scrollLeft===t.scrollLeft&&this.height===t.height&&this.scrollHeight===t.scrollHeight&&this.scrollTop===t.scrollTop}withScrollDimensions(t,e){return new s(this._forceIntegerValues,typeof t.width<\"u\"?t.width:this.width,typeof t.scrollWidth<\"u\"?t.scrollWidth:this.scrollWidth,e?this.rawScrollLeft:this.scrollLeft,typeof t.height<\"u\"?t.height:this.height,typeof t.scrollHeight<\"u\"?t.scrollHeight:this.scrollHeight,e?this.rawScrollTop:this.scrollTop)}withScrollPosition(t){return new s(this._forceIntegerValues,this.width,this.scrollWidth,typeof t.scrollLeft<\"u\"?t.scrollLeft:this.rawScrollLeft,this.height,this.scrollHeight,typeof t.scrollTop<\"u\"?t.scrollTop:this.rawScrollTop)}createScrollEvent(t,e){let i=this.width!==t.width,r=this.scrollWidth!==t.scrollWidth,n=this.scrollLeft!==t.scrollLeft,o=this.height!==t.height,l=this.scrollHeight!==t.scrollHeight,a=this.scrollTop!==t.scrollTop;return{inSmoothScrolling:e,oldWidth:t.width,oldScrollWidth:t.scrollWidth,oldScrollLeft:t.scrollLeft,width:this.width,scrollWidth:this.scrollWidth,scrollLeft:this.scrollLeft,oldHeight:t.height,oldScrollHeight:t.scrollHeight,oldScrollTop:t.scrollTop,height:this.height,scrollHeight:this.scrollHeight,scrollTop:this.scrollTop,widthChanged:i,scrollWidthChanged:r,scrollLeftChanged:n,heightChanged:o,scrollHeightChanged:l,scrollTopChanged:a}}},Ri=class extends D{constructor(e){super();this._scrollableBrand=void 0;this._onScroll=this._register(new v);this.onScroll=this._onScroll.event;this._smoothScrollDuration=e.smoothScrollDuration,this._scheduleAtNextAnimationFrame=e.scheduleAtNextAnimationFrame,this._state=new cs(e.forceIntegerValues,0,0,0,0,0,0),this._smoothScrolling=null}dispose(){this._smoothScrolling&&(this._smoothScrolling.dispose(),this._smoothScrolling=null),super.dispose()}setSmoothScrollDuration(e){this._smoothScrollDuration=e}validateScrollPosition(e){return this._state.withScrollPosition(e)}getScrollDimensions(){return this._state}setScrollDimensions(e,i){let r=this._state.withScrollDimensions(e,i);this._setState(r,!!this._smoothScrolling),this._smoothScrolling?.acceptScrollDimensions(this._state)}getFutureScrollPosition(){return this._smoothScrolling?this._smoothScrolling.to:this._state}getCurrentScrollPosition(){return this._state}setScrollPositionNow(e){let i=this._state.withScrollPosition(e);this._smoothScrolling&&(this._smoothScrolling.dispose(),this._smoothScrolling=null),this._setState(i,!1)}setScrollPositionSmooth(e,i){if(this._smoothScrollDuration===0)return this.setScrollPositionNow(e);if(this._smoothScrolling){e={scrollLeft:typeof e.scrollLeft>\"u\"?this._smoothScrolling.to.scrollLeft:e.scrollLeft,scrollTop:typeof e.scrollTop>\"u\"?this._smoothScrolling.to.scrollTop:e.scrollTop};let r=this._state.withScrollPosition(e);if(this._smoothScrolling.to.scrollLeft===r.scrollLeft&&this._smoothScrolling.to.scrollTop===r.scrollTop)return;let n;i?n=new Nr(this._smoothScrolling.from,r,this._smoothScrolling.startTime,this._smoothScrolling.duration):n=this._smoothScrolling.combine(this._state,r,this._smoothScrollDuration),this._smoothScrolling.dispose(),this._smoothScrolling=n}else{let r=this._state.withScrollPosition(e);this._smoothScrolling=Nr.start(this._state,r,this._smoothScrollDuration)}this._smoothScrolling.animationFrameDisposable=this._scheduleAtNextAnimationFrame(()=>{this._smoothScrolling&&(this._smoothScrolling.animationFrameDisposable=null,this._performSmoothScrolling())})}hasPendingScrollAnimation(){return!!this._smoothScrolling}_performSmoothScrolling(){if(!this._smoothScrolling)return;let e=this._smoothScrolling.tick(),i=this._state.withScrollPosition(e);if(this._setState(i,!0),!!this._smoothScrolling){if(e.isDone){this._smoothScrolling.dispose(),this._smoothScrolling=null;return}this._smoothScrolling.animationFrameDisposable=this._scheduleAtNextAnimationFrame(()=>{this._smoothScrolling&&(this._smoothScrolling.animationFrameDisposable=null,this._performSmoothScrolling())})}}_setState(e,i){let r=this._state;r.equals(e)||(this._state=e,this._onScroll.fire(this._state.createScrollEvent(r,i)))}},Br=class{constructor(t,e,i){this.scrollLeft=t,this.scrollTop=e,this.isDone=i}};function as(s,t){let e=t-s;return function(i){return s+e*ka(i)}}function La(s,t,e){return function(i){return i<e?s(i/e):t((i-e)/(1-e))}}var Nr=class s{constructor(t,e,i,r){this.from=t,this.to=e,this.duration=r,this.startTime=i,this.animationFrameDisposable=null,this._initAnimations()}_initAnimations(){this.scrollLeft=this._initAnimation(this.from.scrollLeft,this.to.scrollLeft,this.to.width),this.scrollTop=this._initAnimation(this.from.scrollTop,this.to.scrollTop,this.to.height)}_initAnimation(t,e,i){if(Math.abs(t-e)>2.5*i){let n,o;return t<e?(n=t+.75*i,o=e-.75*i):(n=t-.75*i,o=e+.75*i),La(as(t,n),as(o,e),.33)}return as(t,e)}dispose(){this.animationFrameDisposable!==null&&(this.animationFrameDisposable.dispose(),this.animationFrameDisposable=null)}acceptScrollDimensions(t){this.to=t.withScrollPosition(this.to),this._initAnimations()}tick(){return this._tick(Date.now())}_tick(t){let e=(t-this.startTime)/this.duration;if(e<1){let i=this.scrollLeft(e),r=this.scrollTop(e);return new Br(i,r,!1)}return new Br(this.to.scrollLeft,this.to.scrollTop,!0)}combine(t,e,i){return s.start(t,e,i)}static start(t,e,i){i=i+10;let r=Date.now()-10;return new s(t,e,r,i)}};function Aa(s){return Math.pow(s,3)}function ka(s){return 1-Aa(1-s)}var Fr=class extends D{constructor(t,e,i){super(),this._visibility=t,this._visibleClassName=e,this._invisibleClassName=i,this._domNode=null,this._isVisible=!1,this._isNeeded=!1,this._rawShouldBeVisible=!1,this._shouldBeVisible=!1,this._revealTimer=this._register(new Ye)}setVisibility(t){this._visibility!==t&&(this._visibility=t,this._updateShouldBeVisible())}setShouldBeVisible(t){this._rawShouldBeVisible=t,this._updateShouldBeVisible()}_applyVisibilitySetting(){return this._visibility===2?!1:this._visibility===3?!0:this._rawShouldBeVisible}_updateShouldBeVisible(){let t=this._applyVisibilitySetting();this._shouldBeVisible!==t&&(this._shouldBeVisible=t,this.ensureVisibility())}setIsNeeded(t){this._isNeeded!==t&&(this._isNeeded=t,this.ensureVisibility())}setDomNode(t){this._domNode=t,this._domNode.setClassName(this._invisibleClassName),this.setShouldBeVisible(!1)}ensureVisibility(){if(!this._isNeeded){this._hide(!1);return}this._shouldBeVisible?this._reveal():this._hide(!0)}_reveal(){this._isVisible||(this._isVisible=!0,this._revealTimer.setIfNotSet(()=>{this._domNode?.setClassName(this._visibleClassName)},0))}_hide(t){this._revealTimer.cancel(),this._isVisible&&(this._isVisible=!1,this._domNode?.setClassName(this._invisibleClassName+(t?\" fade\":\"\")))}};var Ca=140,Ut=class extends lt{constructor(t){super(),this._lazyRender=t.lazyRender,this._host=t.host,this._scrollable=t.scrollable,this._scrollByPage=t.scrollByPage,this._scrollbarState=t.scrollbarState,this._visibilityController=this._register(new Fr(t.visibility,\"visible scrollbar \"+t.extraScrollbarClassName,\"invisible scrollbar \"+t.extraScrollbarClassName)),this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()),this._pointerMoveMonitor=this._register(new Wt),this._shouldRender=!0,this.domNode=_t(document.createElement(\"div\")),this.domNode.setAttribute(\"role\",\"presentation\"),this.domNode.setAttribute(\"aria-hidden\",\"true\"),this._visibilityController.setDomNode(this.domNode),this.domNode.setPosition(\"absolute\"),this._register(L(this.domNode.domNode,Y.POINTER_DOWN,e=>this._domNodePointerDown(e)))}_createArrow(t){let e=this._register(new Or(t));this.domNode.domNode.appendChild(e.bgDomNode),this.domNode.domNode.appendChild(e.domNode)}_createSlider(t,e,i,r){this.slider=_t(document.createElement(\"div\")),this.slider.setClassName(\"slider\"),this.slider.setPosition(\"absolute\"),this.slider.setTop(t),this.slider.setLeft(e),typeof i==\"number\"&&this.slider.setWidth(i),typeof r==\"number\"&&this.slider.setHeight(r),this.slider.setLayerHinting(!0),this.slider.setContain(\"strict\"),this.domNode.domNode.appendChild(this.slider.domNode),this._register(L(this.slider.domNode,Y.POINTER_DOWN,n=>{n.button===0&&(n.preventDefault(),this._sliderPointerDown(n))})),this.onclick(this.slider.domNode,n=>{n.leftButton&&n.stopPropagation()})}_onElementSize(t){return this._scrollbarState.setVisibleSize(t)&&(this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()),this._shouldRender=!0,this._lazyRender||this.render()),this._shouldRender}_onElementScrollSize(t){return this._scrollbarState.setScrollSize(t)&&(this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()),this._shouldRender=!0,this._lazyRender||this.render()),this._shouldRender}_onElementScrollPosition(t){return this._scrollbarState.setScrollPosition(t)&&(this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()),this._shouldRender=!0,this._lazyRender||this.render()),this._shouldRender}beginReveal(){this._visibilityController.setShouldBeVisible(!0)}beginHide(){this._visibilityController.setShouldBeVisible(!1)}render(){this._shouldRender&&(this._shouldRender=!1,this._renderDomNode(this._scrollbarState.getRectangleLargeSize(),this._scrollbarState.getRectangleSmallSize()),this._updateSlider(this._scrollbarState.getSliderSize(),this._scrollbarState.getArrowSize()+this._scrollbarState.getSliderPosition()))}_domNodePointerDown(t){t.target===this.domNode.domNode&&this._onPointerDown(t)}delegatePointerDown(t){let e=this.domNode.domNode.getClientRects()[0].top,i=e+this._scrollbarState.getSliderPosition(),r=e+this._scrollbarState.getSliderPosition()+this._scrollbarState.getSliderSize(),n=this._sliderPointerPosition(t);i<=n&&n<=r?t.button===0&&(t.preventDefault(),this._sliderPointerDown(t)):this._onPointerDown(t)}_onPointerDown(t){let e,i;if(t.target===this.domNode.domNode&&typeof t.offsetX==\"number\"&&typeof t.offsetY==\"number\")e=t.offsetX,i=t.offsetY;else{let n=Fo(this.domNode.domNode);e=t.pageX-n.left,i=t.pageY-n.top}let r=this._pointerDownRelativePosition(e,i);this._setDesiredScrollPositionNow(this._scrollByPage?this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(r):this._scrollbarState.getDesiredScrollPositionFromOffset(r)),t.button===0&&(t.preventDefault(),this._sliderPointerDown(t))}_sliderPointerDown(t){if(!t.target||!(t.target instanceof Element))return;let e=this._sliderPointerPosition(t),i=this._sliderOrthogonalPointerPosition(t),r=this._scrollbarState.clone();this.slider.toggleClassName(\"active\",!0),this._pointerMoveMonitor.startMonitoring(t.target,t.pointerId,t.buttons,n=>{let o=this._sliderOrthogonalPointerPosition(n),l=Math.abs(o-i);if(wr&&l>Ca){this._setDesiredScrollPositionNow(r.getScrollPosition());return}let u=this._sliderPointerPosition(n)-e;this._setDesiredScrollPositionNow(r.getDesiredScrollPositionFromDelta(u))},()=>{this.slider.toggleClassName(\"active\",!1),this._host.onDragEnd()}),this._host.onDragStart()}_setDesiredScrollPositionNow(t){let e={};this.writeScrollPosition(e,t),this._scrollable.setScrollPositionNow(e)}updateScrollbarSize(t){this._updateScrollbarSize(t),this._scrollbarState.setScrollbarSize(t),this._shouldRender=!0,this._lazyRender||this.render()}isNeeded(){return this._scrollbarState.isNeeded()}};var Kt=class s{constructor(t,e,i,r,n,o){this._scrollbarSize=Math.round(e),this._oppositeScrollbarSize=Math.round(i),this._arrowSize=Math.round(t),this._visibleSize=r,this._scrollSize=n,this._scrollPosition=o,this._computedAvailableSize=0,this._computedIsNeeded=!1,this._computedSliderSize=0,this._computedSliderRatio=0,this._computedSliderPosition=0,this._refreshComputedValues()}clone(){return new s(this._arrowSize,this._scrollbarSize,this._oppositeScrollbarSize,this._visibleSize,this._scrollSize,this._scrollPosition)}setVisibleSize(t){let e=Math.round(t);return this._visibleSize!==e?(this._visibleSize=e,this._refreshComputedValues(),!0):!1}setScrollSize(t){let e=Math.round(t);return this._scrollSize!==e?(this._scrollSize=e,this._refreshComputedValues(),!0):!1}setScrollPosition(t){let e=Math.round(t);return this._scrollPosition!==e?(this._scrollPosition=e,this._refreshComputedValues(),!0):!1}setScrollbarSize(t){this._scrollbarSize=Math.round(t)}setOppositeScrollbarSize(t){this._oppositeScrollbarSize=Math.round(t)}static _computeValues(t,e,i,r,n){let o=Math.max(0,i-t),l=Math.max(0,o-2*e),a=r>0&&r>i;if(!a)return{computedAvailableSize:Math.round(o),computedIsNeeded:a,computedSliderSize:Math.round(l),computedSliderRatio:0,computedSliderPosition:0};let u=Math.round(Math.max(20,Math.floor(i*l/r))),h=(l-u)/(r-i),c=n*h;return{computedAvailableSize:Math.round(o),computedIsNeeded:a,computedSliderSize:Math.round(u),computedSliderRatio:h,computedSliderPosition:Math.round(c)}}_refreshComputedValues(){let t=s._computeValues(this._oppositeScrollbarSize,this._arrowSize,this._visibleSize,this._scrollSize,this._scrollPosition);this._computedAvailableSize=t.computedAvailableSize,this._computedIsNeeded=t.computedIsNeeded,this._computedSliderSize=t.computedSliderSize,this._computedSliderRatio=t.computedSliderRatio,this._computedSliderPosition=t.computedSliderPosition}getArrowSize(){return this._arrowSize}getScrollPosition(){return this._scrollPosition}getRectangleLargeSize(){return this._computedAvailableSize}getRectangleSmallSize(){return this._scrollbarSize}isNeeded(){return this._computedIsNeeded}getSliderSize(){return this._computedSliderSize}getSliderPosition(){return this._computedSliderPosition}getDesiredScrollPositionFromOffset(t){if(!this._computedIsNeeded)return 0;let e=t-this._arrowSize-this._computedSliderSize/2;return Math.round(e/this._computedSliderRatio)}getDesiredScrollPositionFromOffsetPaged(t){if(!this._computedIsNeeded)return 0;let e=t-this._arrowSize,i=this._scrollPosition;return e<this._computedSliderPosition?i-=this._visibleSize:i+=this._visibleSize,i}getDesiredScrollPositionFromDelta(t){if(!this._computedIsNeeded)return 0;let e=this._computedSliderPosition+t;return Math.round(e/this._computedSliderRatio)}};var Wr=class extends Ut{constructor(t,e,i){let r=t.getScrollDimensions(),n=t.getCurrentScrollPosition();if(super({lazyRender:e.lazyRender,host:i,scrollbarState:new Kt(e.horizontalHasArrows?e.arrowSize:0,e.horizontal===2?0:e.horizontalScrollbarSize,e.vertical===2?0:e.verticalScrollbarSize,r.width,r.scrollWidth,n.scrollLeft),visibility:e.horizontal,extraScrollbarClassName:\"horizontal\",scrollable:t,scrollByPage:e.scrollByPage}),e.horizontalHasArrows)throw new Error(\"horizontalHasArrows is not supported in xterm.js\");this._createSlider(Math.floor((e.horizontalScrollbarSize-e.horizontalSliderSize)/2),0,void 0,e.horizontalSliderSize)}_updateSlider(t,e){this.slider.setWidth(t),this.slider.setLeft(e)}_renderDomNode(t,e){this.domNode.setWidth(t),this.domNode.setHeight(e),this.domNode.setLeft(0),this.domNode.setBottom(0)}onDidScroll(t){return this._shouldRender=this._onElementScrollSize(t.scrollWidth)||this._shouldRender,this._shouldRender=this._onElementScrollPosition(t.scrollLeft)||this._shouldRender,this._shouldRender=this._onElementSize(t.width)||this._shouldRender,this._shouldRender}_pointerDownRelativePosition(t,e){return t}_sliderPointerPosition(t){return t.pageX}_sliderOrthogonalPointerPosition(t){return t.pageY}_updateScrollbarSize(t){this.slider.setHeight(t)}writeScrollPosition(t,e){t.scrollLeft=e}updateOptions(t){this.updateScrollbarSize(t.horizontal===2?0:t.horizontalScrollbarSize),this._scrollbarState.setOppositeScrollbarSize(t.vertical===2?0:t.verticalScrollbarSize),this._visibilityController.setVisibility(t.horizontal),this._scrollByPage=t.scrollByPage}};var Ur=class extends Ut{constructor(t,e,i){let r=t.getScrollDimensions(),n=t.getCurrentScrollPosition();if(super({lazyRender:e.lazyRender,host:i,scrollbarState:new Kt(e.verticalHasArrows?e.arrowSize:0,e.vertical===2?0:e.verticalScrollbarSize,0,r.height,r.scrollHeight,n.scrollTop),visibility:e.vertical,extraScrollbarClassName:\"vertical\",scrollable:t,scrollByPage:e.scrollByPage}),e.verticalHasArrows)throw new Error(\"horizontalHasArrows is not supported in xterm.js\");this._createSlider(0,Math.floor((e.verticalScrollbarSize-e.verticalSliderSize)/2),e.verticalSliderSize,void 0)}_updateSlider(t,e){this.slider.setHeight(t),this.slider.setTop(e)}_renderDomNode(t,e){this.domNode.setWidth(e),this.domNode.setHeight(t),this.domNode.setRight(0),this.domNode.setTop(0)}onDidScroll(t){return this._shouldRender=this._onElementScrollSize(t.scrollHeight)||this._shouldRender,this._shouldRender=this._onElementScrollPosition(t.scrollTop)||this._shouldRender,this._shouldRender=this._onElementSize(t.height)||this._shouldRender,this._shouldRender}_pointerDownRelativePosition(t,e){return e}_sliderPointerPosition(t){return t.pageY}_sliderOrthogonalPointerPosition(t){return t.pageX}_updateScrollbarSize(t){this.slider.setWidth(t)}writeScrollPosition(t,e){t.scrollTop=e}updateOptions(t){this.updateScrollbarSize(t.vertical===2?0:t.verticalScrollbarSize),this._scrollbarState.setOppositeScrollbarSize(0),this._visibilityController.setVisibility(t.vertical),this._scrollByPage=t.scrollByPage}};var Ma=500,Ko=50,zo=!0,us=class{constructor(t,e,i){this.timestamp=t,this.deltaX=e,this.deltaY=i,this.score=0}},zr=class zr{constructor(){this._capacity=5,this._memory=[],this._front=-1,this._rear=-1}isPhysicalMouseWheel(){if(this._front===-1&&this._rear===-1)return!1;let t=1,e=0,i=1,r=this._rear;do{let n=r===this._front?t:Math.pow(2,-i);if(t-=n,e+=this._memory[r].score*n,r===this._front)break;r=(this._capacity+r-1)%this._capacity,i++}while(!0);return e<=.5}acceptStandardWheelEvent(t){if(Ti){let e=be(t.browserEvent),i=mo(e);this.accept(Date.now(),t.deltaX*i,t.deltaY*i)}else this.accept(Date.now(),t.deltaX,t.deltaY)}accept(t,e,i){let r=null,n=new us(t,e,i);this._front===-1&&this._rear===-1?(this._memory[0]=n,this._front=0,this._rear=0):(r=this._memory[this._rear],this._rear=(this._rear+1)%this._capacity,this._rear===this._front&&(this._front=(this._front+1)%this._capacity),this._memory[this._rear]=n),n.score=this._computeScore(n,r)}_computeScore(t,e){if(Math.abs(t.deltaX)>0&&Math.abs(t.deltaY)>0)return 1;let i=.5;if((!this._isAlmostInt(t.deltaX)||!this._isAlmostInt(t.deltaY))&&(i+=.25),e){let r=Math.abs(t.deltaX),n=Math.abs(t.deltaY),o=Math.abs(e.deltaX),l=Math.abs(e.deltaY),a=Math.max(Math.min(r,o),1),u=Math.max(Math.min(n,l),1),h=Math.max(r,o),c=Math.max(n,l);h%a===0&&c%u===0&&(i-=.5)}return Math.min(Math.max(i,0),1)}_isAlmostInt(t){return Math.abs(Math.round(t)-t)<.01}};zr.INSTANCE=new zr;var hs=zr,ds=class extends lt{constructor(e,i,r){super();this._onScroll=this._register(new v);this.onScroll=this._onScroll.event;this._onWillScroll=this._register(new v);this.onWillScroll=this._onWillScroll.event;this._options=Pa(i),this._scrollable=r,this._register(this._scrollable.onScroll(o=>{this._onWillScroll.fire(o),this._onDidScroll(o),this._onScroll.fire(o)}));let n={onMouseWheel:o=>this._onMouseWheel(o),onDragStart:()=>this._onDragStart(),onDragEnd:()=>this._onDragEnd()};this._verticalScrollbar=this._register(new Ur(this._scrollable,this._options,n)),this._horizontalScrollbar=this._register(new Wr(this._scrollable,this._options,n)),this._domNode=document.createElement(\"div\"),this._domNode.className=\"xterm-scrollable-element \"+this._options.className,this._domNode.setAttribute(\"role\",\"presentation\"),this._domNode.style.position=\"relative\",this._domNode.appendChild(e),this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode),this._domNode.appendChild(this._verticalScrollbar.domNode.domNode),this._options.useShadows?(this._leftShadowDomNode=_t(document.createElement(\"div\")),this._leftShadowDomNode.setClassName(\"shadow\"),this._domNode.appendChild(this._leftShadowDomNode.domNode),this._topShadowDomNode=_t(document.createElement(\"div\")),this._topShadowDomNode.setClassName(\"shadow\"),this._domNode.appendChild(this._topShadowDomNode.domNode),this._topLeftShadowDomNode=_t(document.createElement(\"div\")),this._topLeftShadowDomNode.setClassName(\"shadow\"),this._domNode.appendChild(this._topLeftShadowDomNode.domNode)):(this._leftShadowDomNode=null,this._topShadowDomNode=null,this._topLeftShadowDomNode=null),this._listenOnDomNode=this._options.listenOnDomNode||this._domNode,this._mouseWheelToDispose=[],this._setListeningToMouseWheel(this._options.handleMouseWheel),this.onmouseover(this._listenOnDomNode,o=>this._onMouseOver(o)),this.onmouseleave(this._listenOnDomNode,o=>this._onMouseLeave(o)),this._hideTimeout=this._register(new Ye),this._isDragging=!1,this._mouseIsOver=!1,this._shouldRender=!0,this._revealOnScroll=!0}get options(){return this._options}dispose(){this._mouseWheelToDispose=Ne(this._mouseWheelToDispose),super.dispose()}getDomNode(){return this._domNode}getOverviewRulerLayoutInfo(){return{parent:this._domNode,insertBefore:this._verticalScrollbar.domNode.domNode}}delegateVerticalScrollbarPointerDown(e){this._verticalScrollbar.delegatePointerDown(e)}getScrollDimensions(){return this._scrollable.getScrollDimensions()}setScrollDimensions(e){this._scrollable.setScrollDimensions(e,!1)}updateClassName(e){this._options.className=e,Te&&(this._options.className+=\" mac\"),this._domNode.className=\"xterm-scrollable-element \"+this._options.className}updateOptions(e){typeof e.handleMouseWheel<\"u\"&&(this._options.handleMouseWheel=e.handleMouseWheel,this._setListeningToMouseWheel(this._options.handleMouseWheel)),typeof e.mouseWheelScrollSensitivity<\"u\"&&(this._options.mouseWheelScrollSensitivity=e.mouseWheelScrollSensitivity),typeof e.fastScrollSensitivity<\"u\"&&(this._options.fastScrollSensitivity=e.fastScrollSensitivity),typeof e.scrollPredominantAxis<\"u\"&&(this._options.scrollPredominantAxis=e.scrollPredominantAxis),typeof e.horizontal<\"u\"&&(this._options.horizontal=e.horizontal),typeof e.vertical<\"u\"&&(this._options.vertical=e.vertical),typeof e.horizontalScrollbarSize<\"u\"&&(this._options.horizontalScrollbarSize=e.horizontalScrollbarSize),typeof e.verticalScrollbarSize<\"u\"&&(this._options.verticalScrollbarSize=e.verticalScrollbarSize),typeof e.scrollByPage<\"u\"&&(this._options.scrollByPage=e.scrollByPage),this._horizontalScrollbar.updateOptions(this._options),this._verticalScrollbar.updateOptions(this._options),this._options.lazyRender||this._render()}setRevealOnScroll(e){this._revealOnScroll=e}delegateScrollFromMouseWheelEvent(e){this._onMouseWheel(new xi(e))}_setListeningToMouseWheel(e){if(this._mouseWheelToDispose.length>0!==e&&(this._mouseWheelToDispose=Ne(this._mouseWheelToDispose),e)){let r=n=>{this._onMouseWheel(new xi(n))};this._mouseWheelToDispose.push(L(this._listenOnDomNode,Y.MOUSE_WHEEL,r,{passive:!1}))}}_onMouseWheel(e){if(e.browserEvent?.defaultPrevented)return;let i=hs.INSTANCE;zo&&i.acceptStandardWheelEvent(e);let r=!1;if(e.deltaY||e.deltaX){let o=e.deltaY*this._options.mouseWheelScrollSensitivity,l=e.deltaX*this._options.mouseWheelScrollSensitivity;this._options.scrollPredominantAxis&&(this._options.scrollYToX&&l+o===0?l=o=0:Math.abs(o)>=Math.abs(l)?l=0:o=0),this._options.flipAxes&&([o,l]=[l,o]);let a=!Te&&e.browserEvent&&e.browserEvent.shiftKey;(this._options.scrollYToX||a)&&!l&&(l=o,o=0),e.browserEvent&&e.browserEvent.altKey&&(l=l*this._options.fastScrollSensitivity,o=o*this._options.fastScrollSensitivity);let u=this._scrollable.getFutureScrollPosition(),h={};if(o){let c=Ko*o,d=u.scrollTop-(c<0?Math.floor(c):Math.ceil(c));this._verticalScrollbar.writeScrollPosition(h,d)}if(l){let c=Ko*l,d=u.scrollLeft-(c<0?Math.floor(c):Math.ceil(c));this._horizontalScrollbar.writeScrollPosition(h,d)}h=this._scrollable.validateScrollPosition(h),(u.scrollLeft!==h.scrollLeft||u.scrollTop!==h.scrollTop)&&(zo&&this._options.mouseWheelSmoothScroll&&i.isPhysicalMouseWheel()?this._scrollable.setScrollPositionSmooth(h):this._scrollable.setScrollPositionNow(h),r=!0)}let n=r;!n&&this._options.alwaysConsumeMouseWheel&&(n=!0),!n&&this._options.consumeMouseWheelIfScrollbarIsNeeded&&(this._verticalScrollbar.isNeeded()||this._horizontalScrollbar.isNeeded())&&(n=!0),n&&(e.preventDefault(),e.stopPropagation())}_onDidScroll(e){this._shouldRender=this._horizontalScrollbar.onDidScroll(e)||this._shouldRender,this._shouldRender=this._verticalScrollbar.onDidScroll(e)||this._shouldRender,this._options.useShadows&&(this._shouldRender=!0),this._revealOnScroll&&this._reveal(),this._options.lazyRender||this._render()}renderNow(){if(!this._options.lazyRender)throw new Error(\"Please use `lazyRender` together with `renderNow`!\");this._render()}_render(){if(this._shouldRender&&(this._shouldRender=!1,this._horizontalScrollbar.render(),this._verticalScrollbar.render(),this._options.useShadows)){let e=this._scrollable.getCurrentScrollPosition(),i=e.scrollTop>0,r=e.scrollLeft>0,n=r?\" left\":\"\",o=i?\" top\":\"\",l=r||i?\" top-left-corner\":\"\";this._leftShadowDomNode.setClassName(`shadow${n}`),this._topShadowDomNode.setClassName(`shadow${o}`),this._topLeftShadowDomNode.setClassName(`shadow${l}${o}${n}`)}}_onDragStart(){this._isDragging=!0,this._reveal()}_onDragEnd(){this._isDragging=!1,this._hide()}_onMouseLeave(e){this._mouseIsOver=!1,this._hide()}_onMouseOver(e){this._mouseIsOver=!0,this._reveal()}_reveal(){this._verticalScrollbar.beginReveal(),this._horizontalScrollbar.beginReveal(),this._scheduleHide()}_hide(){!this._mouseIsOver&&!this._isDragging&&(this._verticalScrollbar.beginHide(),this._horizontalScrollbar.beginHide())}_scheduleHide(){!this._mouseIsOver&&!this._isDragging&&this._hideTimeout.cancelAndSet(()=>this._hide(),Ma)}};var Kr=class extends ds{constructor(t,e,i){super(t,e,i)}setScrollPosition(t){t.reuseAnimation?this._scrollable.setScrollPositionSmooth(t,t.reuseAnimation):this._scrollable.setScrollPositionNow(t)}getScrollPosition(){return this._scrollable.getCurrentScrollPosition()}};function Pa(s){let t={lazyRender:typeof s.lazyRender<\"u\"?s.lazyRender:!1,className:typeof s.className<\"u\"?s.className:\"\",useShadows:typeof s.useShadows<\"u\"?s.useShadows:!0,handleMouseWheel:typeof s.handleMouseWheel<\"u\"?s.handleMouseWheel:!0,flipAxes:typeof s.flipAxes<\"u\"?s.flipAxes:!1,consumeMouseWheelIfScrollbarIsNeeded:typeof s.consumeMouseWheelIfScrollbarIsNeeded<\"u\"?s.consumeMouseWheelIfScrollbarIsNeeded:!1,alwaysConsumeMouseWheel:typeof s.alwaysConsumeMouseWheel<\"u\"?s.alwaysConsumeMouseWheel:!1,scrollYToX:typeof s.scrollYToX<\"u\"?s.scrollYToX:!1,mouseWheelScrollSensitivity:typeof s.mouseWheelScrollSensitivity<\"u\"?s.mouseWheelScrollSensitivity:1,fastScrollSensitivity:typeof s.fastScrollSensitivity<\"u\"?s.fastScrollSensitivity:5,scrollPredominantAxis:typeof s.scrollPredominantAxis<\"u\"?s.scrollPredominantAxis:!0,mouseWheelSmoothScroll:typeof s.mouseWheelSmoothScroll<\"u\"?s.mouseWheelSmoothScroll:!0,arrowSize:typeof s.arrowSize<\"u\"?s.arrowSize:11,listenOnDomNode:typeof s.listenOnDomNode<\"u\"?s.listenOnDomNode:null,horizontal:typeof s.horizontal<\"u\"?s.horizontal:1,horizontalScrollbarSize:typeof s.horizontalScrollbarSize<\"u\"?s.horizontalScrollbarSize:10,horizontalSliderSize:typeof s.horizontalSliderSize<\"u\"?s.horizontalSliderSize:0,horizontalHasArrows:typeof s.horizontalHasArrows<\"u\"?s.horizontalHasArrows:!1,vertical:typeof s.vertical<\"u\"?s.vertical:1,verticalScrollbarSize:typeof s.verticalScrollbarSize<\"u\"?s.verticalScrollbarSize:10,verticalHasArrows:typeof s.verticalHasArrows<\"u\"?s.verticalHasArrows:!1,verticalSliderSize:typeof s.verticalSliderSize<\"u\"?s.verticalSliderSize:0,scrollByPage:typeof s.scrollByPage<\"u\"?s.scrollByPage:!1};return t.horizontalSliderSize=typeof s.horizontalSliderSize<\"u\"?s.horizontalSliderSize:t.horizontalScrollbarSize,t.verticalSliderSize=typeof s.verticalSliderSize<\"u\"?s.verticalSliderSize:t.verticalScrollbarSize,Te&&(t.className+=\" mac\"),t}var zt=class extends D{constructor(e,i,r,n,o,l,a,u){super();this._bufferService=r;this._optionsService=a;this._renderService=u;this._onRequestScrollLines=this._register(new v);this.onRequestScrollLines=this._onRequestScrollLines.event;this._isSyncing=!1;this._isHandlingScroll=!1;this._suppressOnScrollHandler=!1;let h=this._register(new Ri({forceIntegerValues:!1,smoothScrollDuration:this._optionsService.rawOptions.smoothScrollDuration,scheduleAtNextAnimationFrame:c=>mt(n.window,c)}));this._register(this._optionsService.onSpecificOptionChange(\"smoothScrollDuration\",()=>{h.setSmoothScrollDuration(this._optionsService.rawOptions.smoothScrollDuration)})),this._scrollableElement=this._register(new Kr(i,{vertical:1,horizontal:2,useShadows:!1,mouseWheelSmoothScroll:!0,...this._getChangeOptions()},h)),this._register(this._optionsService.onMultipleOptionChange([\"scrollSensitivity\",\"fastScrollSensitivity\",\"overviewRuler\"],()=>this._scrollableElement.updateOptions(this._getChangeOptions()))),this._register(o.onProtocolChange(c=>{this._scrollableElement.updateOptions({handleMouseWheel:!(c&16)})})),this._scrollableElement.setScrollDimensions({height:0,scrollHeight:0}),this._register($.runAndSubscribe(l.onChangeColors,()=>{this._scrollableElement.getDomNode().style.backgroundColor=l.colors.background.css})),e.appendChild(this._scrollableElement.getDomNode()),this._register(C(()=>this._scrollableElement.getDomNode().remove())),this._styleElement=n.mainDocument.createElement(\"style\"),i.appendChild(this._styleElement),this._register(C(()=>this._styleElement.remove())),this._register($.runAndSubscribe(l.onChangeColors,()=>{this._styleElement.textContent=[\".xterm .xterm-scrollable-element > .scrollbar > .slider {\",`  background: ${l.colors.scrollbarSliderBackground.css};`,\"}\",\".xterm .xterm-scrollable-element > .scrollbar > .slider:hover {\",`  background: ${l.colors.scrollbarSliderHoverBackground.css};`,\"}\",\".xterm .xterm-scrollable-element > .scrollbar > .slider.active {\",`  background: ${l.colors.scrollbarSliderActiveBackground.css};`,\"}\"].join(`\n`)})),this._register(this._bufferService.onResize(()=>this.queueSync())),this._register(this._bufferService.buffers.onBufferActivate(()=>{this._latestYDisp=void 0,this.queueSync()})),this._register(this._bufferService.onScroll(()=>this._sync())),this._register(this._scrollableElement.onScroll(c=>this._handleScroll(c)))}scrollLines(e){let i=this._scrollableElement.getScrollPosition();this._scrollableElement.setScrollPosition({reuseAnimation:!0,scrollTop:i.scrollTop+e*this._renderService.dimensions.css.cell.height})}scrollToLine(e,i){i&&(this._latestYDisp=e),this._scrollableElement.setScrollPosition({reuseAnimation:!i,scrollTop:e*this._renderService.dimensions.css.cell.height})}_getChangeOptions(){return{mouseWheelScrollSensitivity:this._optionsService.rawOptions.scrollSensitivity,fastScrollSensitivity:this._optionsService.rawOptions.fastScrollSensitivity,verticalScrollbarSize:this._optionsService.rawOptions.overviewRuler?.width||14}}queueSync(e){e!==void 0&&(this._latestYDisp=e),this._queuedAnimationFrame===void 0&&(this._queuedAnimationFrame=this._renderService.addRefreshCallback(()=>{this._queuedAnimationFrame=void 0,this._sync(this._latestYDisp)}))}_sync(e=this._bufferService.buffer.ydisp){!this._renderService||this._isSyncing||(this._isSyncing=!0,this._suppressOnScrollHandler=!0,this._scrollableElement.setScrollDimensions({height:this._renderService.dimensions.css.canvas.height,scrollHeight:this._renderService.dimensions.css.cell.height*this._bufferService.buffer.lines.length}),this._suppressOnScrollHandler=!1,e!==this._latestYDisp&&this._scrollableElement.setScrollPosition({scrollTop:e*this._renderService.dimensions.css.cell.height}),this._isSyncing=!1)}_handleScroll(e){if(!this._renderService||this._isHandlingScroll||this._suppressOnScrollHandler)return;this._isHandlingScroll=!0;let i=Math.round(e.scrollTop/this._renderService.dimensions.css.cell.height),r=i-this._bufferService.buffer.ydisp;r!==0&&(this._latestYDisp=i,this._onRequestScrollLines.fire(r)),this._isHandlingScroll=!1}};zt=M([S(2,F),S(3,ae),S(4,rr),S(5,Re),S(6,H),S(7,ce)],zt);var Gt=class extends D{constructor(e,i,r,n,o){super();this._screenElement=e;this._bufferService=i;this._coreBrowserService=r;this._decorationService=n;this._renderService=o;this._decorationElements=new Map;this._altBufferIsActive=!1;this._dimensionsChanged=!1;this._container=document.createElement(\"div\"),this._container.classList.add(\"xterm-decoration-container\"),this._screenElement.appendChild(this._container),this._register(this._renderService.onRenderedViewportChange(()=>this._doRefreshDecorations())),this._register(this._renderService.onDimensionsChange(()=>{this._dimensionsChanged=!0,this._queueRefresh()})),this._register(this._coreBrowserService.onDprChange(()=>this._queueRefresh())),this._register(this._bufferService.buffers.onBufferActivate(()=>{this._altBufferIsActive=this._bufferService.buffer===this._bufferService.buffers.alt})),this._register(this._decorationService.onDecorationRegistered(()=>this._queueRefresh())),this._register(this._decorationService.onDecorationRemoved(l=>this._removeDecoration(l))),this._register(C(()=>{this._container.remove(),this._decorationElements.clear()}))}_queueRefresh(){this._animationFrame===void 0&&(this._animationFrame=this._renderService.addRefreshCallback(()=>{this._doRefreshDecorations(),this._animationFrame=void 0}))}_doRefreshDecorations(){for(let e of this._decorationService.decorations)this._renderDecoration(e);this._dimensionsChanged=!1}_renderDecoration(e){this._refreshStyle(e),this._dimensionsChanged&&this._refreshXPosition(e)}_createElement(e){let i=this._coreBrowserService.mainDocument.createElement(\"div\");i.classList.add(\"xterm-decoration\"),i.classList.toggle(\"xterm-decoration-top-layer\",e?.options?.layer===\"top\"),i.style.width=`${Math.round((e.options.width||1)*this._renderService.dimensions.css.cell.width)}px`,i.style.height=`${(e.options.height||1)*this._renderService.dimensions.css.cell.height}px`,i.style.top=`${(e.marker.line-this._bufferService.buffers.active.ydisp)*this._renderService.dimensions.css.cell.height}px`,i.style.lineHeight=`${this._renderService.dimensions.css.cell.height}px`;let r=e.options.x??0;return r&&r>this._bufferService.cols&&(i.style.display=\"none\"),this._refreshXPosition(e,i),i}_refreshStyle(e){let i=e.marker.line-this._bufferService.buffers.active.ydisp;if(i<0||i>=this._bufferService.rows)e.element&&(e.element.style.display=\"none\",e.onRenderEmitter.fire(e.element));else{let r=this._decorationElements.get(e);r||(r=this._createElement(e),e.element=r,this._decorationElements.set(e,r),this._container.appendChild(r),e.onDispose(()=>{this._decorationElements.delete(e),r.remove()})),r.style.display=this._altBufferIsActive?\"none\":\"block\",this._altBufferIsActive||(r.style.width=`${Math.round((e.options.width||1)*this._renderService.dimensions.css.cell.width)}px`,r.style.height=`${(e.options.height||1)*this._renderService.dimensions.css.cell.height}px`,r.style.top=`${i*this._renderService.dimensions.css.cell.height}px`,r.style.lineHeight=`${this._renderService.dimensions.css.cell.height}px`),e.onRenderEmitter.fire(r)}}_refreshXPosition(e,i=e.element){if(!i)return;let r=e.options.x??0;(e.options.anchor||\"left\")===\"right\"?i.style.right=r?`${r*this._renderService.dimensions.css.cell.width}px`:\"\":i.style.left=r?`${r*this._renderService.dimensions.css.cell.width}px`:\"\"}_removeDecoration(e){this._decorationElements.get(e)?.remove(),this._decorationElements.delete(e),e.dispose()}};Gt=M([S(1,F),S(2,ae),S(3,Be),S(4,ce)],Gt);var Gr=class{constructor(){this._zones=[];this._zonePool=[];this._zonePoolIndex=0;this._linePadding={full:0,left:0,center:0,right:0}}get zones(){return this._zonePool.length=Math.min(this._zonePool.length,this._zones.length),this._zones}clear(){this._zones.length=0,this._zonePoolIndex=0}addDecoration(t){if(t.options.overviewRulerOptions){for(let e of this._zones)if(e.color===t.options.overviewRulerOptions.color&&e.position===t.options.overviewRulerOptions.position){if(this._lineIntersectsZone(e,t.marker.line))return;if(this._lineAdjacentToZone(e,t.marker.line,t.options.overviewRulerOptions.position)){this._addLineToZone(e,t.marker.line);return}}if(this._zonePoolIndex<this._zonePool.length){this._zonePool[this._zonePoolIndex].color=t.options.overviewRulerOptions.color,this._zonePool[this._zonePoolIndex].position=t.options.overviewRulerOptions.position,this._zonePool[this._zonePoolIndex].startBufferLine=t.marker.line,this._zonePool[this._zonePoolIndex].endBufferLine=t.marker.line,this._zones.push(this._zonePool[this._zonePoolIndex++]);return}this._zones.push({color:t.options.overviewRulerOptions.color,position:t.options.overviewRulerOptions.position,startBufferLine:t.marker.line,endBufferLine:t.marker.line}),this._zonePool.push(this._zones[this._zones.length-1]),this._zonePoolIndex++}}setPadding(t){this._linePadding=t}_lineIntersectsZone(t,e){return e>=t.startBufferLine&&e<=t.endBufferLine}_lineAdjacentToZone(t,e,i){return e>=t.startBufferLine-this._linePadding[i||\"full\"]&&e<=t.endBufferLine+this._linePadding[i||\"full\"]}_addLineToZone(t,e){t.startBufferLine=Math.min(t.startBufferLine,e),t.endBufferLine=Math.max(t.endBufferLine,e)}};var We={full:0,left:0,center:0,right:0},at={full:0,left:0,center:0,right:0},Li={full:0,left:0,center:0,right:0},bt=class extends D{constructor(e,i,r,n,o,l,a,u){super();this._viewportElement=e;this._screenElement=i;this._bufferService=r;this._decorationService=n;this._renderService=o;this._optionsService=l;this._themeService=a;this._coreBrowserService=u;this._colorZoneStore=new Gr;this._shouldUpdateDimensions=!0;this._shouldUpdateAnchor=!0;this._lastKnownBufferLength=0;this._canvas=this._coreBrowserService.mainDocument.createElement(\"canvas\"),this._canvas.classList.add(\"xterm-decoration-overview-ruler\"),this._refreshCanvasDimensions(),this._viewportElement.parentElement?.insertBefore(this._canvas,this._viewportElement),this._register(C(()=>this._canvas?.remove()));let h=this._canvas.getContext(\"2d\");if(h)this._ctx=h;else throw new Error(\"Ctx cannot be null\");this._register(this._decorationService.onDecorationRegistered(()=>this._queueRefresh(void 0,!0))),this._register(this._decorationService.onDecorationRemoved(()=>this._queueRefresh(void 0,!0))),this._register(this._renderService.onRenderedViewportChange(()=>this._queueRefresh())),this._register(this._bufferService.buffers.onBufferActivate(()=>{this._canvas.style.display=this._bufferService.buffer===this._bufferService.buffers.alt?\"none\":\"block\"})),this._register(this._bufferService.onScroll(()=>{this._lastKnownBufferLength!==this._bufferService.buffers.normal.lines.length&&(this._refreshDrawHeightConstants(),this._refreshColorZonePadding())})),this._register(this._renderService.onRender(()=>{(!this._containerHeight||this._containerHeight!==this._screenElement.clientHeight)&&(this._queueRefresh(!0),this._containerHeight=this._screenElement.clientHeight)})),this._register(this._coreBrowserService.onDprChange(()=>this._queueRefresh(!0))),this._register(this._optionsService.onSpecificOptionChange(\"overviewRuler\",()=>this._queueRefresh(!0))),this._register(this._themeService.onChangeColors(()=>this._queueRefresh())),this._queueRefresh(!0)}get _width(){return this._optionsService.options.overviewRuler?.width||0}_refreshDrawConstants(){let e=Math.floor((this._canvas.width-1)/3),i=Math.ceil((this._canvas.width-1)/3);at.full=this._canvas.width,at.left=e,at.center=i,at.right=e,this._refreshDrawHeightConstants(),Li.full=1,Li.left=1,Li.center=1+at.left,Li.right=1+at.left+at.center}_refreshDrawHeightConstants(){We.full=Math.round(2*this._coreBrowserService.dpr);let e=this._canvas.height/this._bufferService.buffer.lines.length,i=Math.round(Math.max(Math.min(e,12),6)*this._coreBrowserService.dpr);We.left=i,We.center=i,We.right=i}_refreshColorZonePadding(){this._colorZoneStore.setPadding({full:Math.floor(this._bufferService.buffers.active.lines.length/(this._canvas.height-1)*We.full),left:Math.floor(this._bufferService.buffers.active.lines.length/(this._canvas.height-1)*We.left),center:Math.floor(this._bufferService.buffers.active.lines.length/(this._canvas.height-1)*We.center),right:Math.floor(this._bufferService.buffers.active.lines.length/(this._canvas.height-1)*We.right)}),this._lastKnownBufferLength=this._bufferService.buffers.normal.lines.length}_refreshCanvasDimensions(){this._canvas.style.width=`${this._width}px`,this._canvas.width=Math.round(this._width*this._coreBrowserService.dpr),this._canvas.style.height=`${this._screenElement.clientHeight}px`,this._canvas.height=Math.round(this._screenElement.clientHeight*this._coreBrowserService.dpr),this._refreshDrawConstants(),this._refreshColorZonePadding()}_refreshDecorations(){this._shouldUpdateDimensions&&this._refreshCanvasDimensions(),this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height),this._colorZoneStore.clear();for(let i of this._decorationService.decorations)this._colorZoneStore.addDecoration(i);this._ctx.lineWidth=1,this._renderRulerOutline();let e=this._colorZoneStore.zones;for(let i of e)i.position!==\"full\"&&this._renderColorZone(i);for(let i of e)i.position===\"full\"&&this._renderColorZone(i);this._shouldUpdateDimensions=!1,this._shouldUpdateAnchor=!1}_renderRulerOutline(){this._ctx.fillStyle=this._themeService.colors.overviewRulerBorder.css,this._ctx.fillRect(0,0,1,this._canvas.height),this._optionsService.rawOptions.overviewRuler.showTopBorder&&this._ctx.fillRect(1,0,this._canvas.width-1,1),this._optionsService.rawOptions.overviewRuler.showBottomBorder&&this._ctx.fillRect(1,this._canvas.height-1,this._canvas.width-1,this._canvas.height)}_renderColorZone(e){this._ctx.fillStyle=e.color,this._ctx.fillRect(Li[e.position||\"full\"],Math.round((this._canvas.height-1)*(e.startBufferLine/this._bufferService.buffers.active.lines.length)-We[e.position||\"full\"]/2),at[e.position||\"full\"],Math.round((this._canvas.height-1)*((e.endBufferLine-e.startBufferLine)/this._bufferService.buffers.active.lines.length)+We[e.position||\"full\"]))}_queueRefresh(e,i){this._shouldUpdateDimensions=e||this._shouldUpdateDimensions,this._shouldUpdateAnchor=i||this._shouldUpdateAnchor,this._animationFrame===void 0&&(this._animationFrame=this._coreBrowserService.window.requestAnimationFrame(()=>{this._refreshDecorations(),this._animationFrame=void 0}))}};bt=M([S(2,F),S(3,Be),S(4,ce),S(5,H),S(6,Re),S(7,ae)],bt);var b;(E=>(E.NUL=\"\\0\",E.SOH=\"\u0001\",E.STX=\"\u0002\",E.ETX=\"\u0003\",E.EOT=\"\u0004\",E.ENQ=\"\u0005\",E.ACK=\"\u0006\",E.BEL=\"\\x07\",E.BS=\"\\b\",E.HT=\"\t\",E.LF=`\n`,E.VT=\"\\v\",E.FF=\"\\f\",E.CR=\"\\r\",E.SO=\"\u000e\",E.SI=\"\u000f\",E.DLE=\"\u0010\",E.DC1=\"\u0011\",E.DC2=\"\u0012\",E.DC3=\"\u0013\",E.DC4=\"\u0014\",E.NAK=\"\u0015\",E.SYN=\"\u0016\",E.ETB=\"\u0017\",E.CAN=\"\u0018\",E.EM=\"\u0019\",E.SUB=\"\u001a\",E.ESC=\"\\x1B\",E.FS=\"\u001c\",E.GS=\"\u001d\",E.RS=\"\u001e\",E.US=\"\u001f\",E.SP=\" \",E.DEL=\"\\x7F\"))(b||={});var Ai;(g=>(g.PAD=\"\\x80\",g.HOP=\"\\x81\",g.BPH=\"\\x82\",g.NBH=\"\\x83\",g.IND=\"\\x84\",g.NEL=\"\\x85\",g.SSA=\"\\x86\",g.ESA=\"\\x87\",g.HTS=\"\\x88\",g.HTJ=\"\\x89\",g.VTS=\"\\x8A\",g.PLD=\"\\x8B\",g.PLU=\"\\x8C\",g.RI=\"\\x8D\",g.SS2=\"\\x8E\",g.SS3=\"\\x8F\",g.DCS=\"\\x90\",g.PU1=\"\\x91\",g.PU2=\"\\x92\",g.STS=\"\\x93\",g.CCH=\"\\x94\",g.MW=\"\\x95\",g.SPA=\"\\x96\",g.EPA=\"\\x97\",g.SOS=\"\\x98\",g.SGCI=\"\\x99\",g.SCI=\"\\x9A\",g.CSI=\"\\x9B\",g.ST=\"\\x9C\",g.OSC=\"\\x9D\",g.PM=\"\\x9E\",g.APC=\"\\x9F\"))(Ai||={});var fs;(t=>t.ST=`${b.ESC}\\\\`)(fs||={});var $t=class{constructor(t,e,i,r,n,o){this._textarea=t;this._compositionView=e;this._bufferService=i;this._optionsService=r;this._coreService=n;this._renderService=o;this._isComposing=!1,this._isSendingComposition=!1,this._compositionPosition={start:0,end:0},this._dataAlreadySent=\"\"}get isComposing(){return this._isComposing}compositionstart(){this._isComposing=!0,this._compositionPosition.start=this._textarea.value.length,this._compositionView.textContent=\"\",this._dataAlreadySent=\"\",this._compositionView.classList.add(\"active\")}compositionupdate(t){this._compositionView.textContent=t.data,this.updateCompositionElements(),setTimeout(()=>{this._compositionPosition.end=this._textarea.value.length},0)}compositionend(){this._finalizeComposition(!0)}keydown(t){if(this._isComposing||this._isSendingComposition){if(t.keyCode===20||t.keyCode===229||t.keyCode===16||t.keyCode===17||t.keyCode===18)return!1;this._finalizeComposition(!1)}return t.keyCode===229?(this._handleAnyTextareaChanges(),!1):!0}_finalizeComposition(t){if(this._compositionView.classList.remove(\"active\"),this._isComposing=!1,t){let e={start:this._compositionPosition.start,end:this._compositionPosition.end};this._isSendingComposition=!0,setTimeout(()=>{if(this._isSendingComposition){this._isSendingComposition=!1;let i;e.start+=this._dataAlreadySent.length,this._isComposing?i=this._textarea.value.substring(e.start,this._compositionPosition.start):i=this._textarea.value.substring(e.start),i.length>0&&this._coreService.triggerDataEvent(i,!0)}},0)}else{this._isSendingComposition=!1;let e=this._textarea.value.substring(this._compositionPosition.start,this._compositionPosition.end);this._coreService.triggerDataEvent(e,!0)}}_handleAnyTextareaChanges(){let t=this._textarea.value;setTimeout(()=>{if(!this._isComposing){let e=this._textarea.value,i=e.replace(t,\"\");this._dataAlreadySent=i,e.length>t.length?this._coreService.triggerDataEvent(i,!0):e.length<t.length?this._coreService.triggerDataEvent(`${b.DEL}`,!0):e.length===t.length&&e!==t&&this._coreService.triggerDataEvent(e,!0)}},0)}updateCompositionElements(t){if(this._isComposing){if(this._bufferService.buffer.isCursorInViewport){let e=Math.min(this._bufferService.buffer.x,this._bufferService.cols-1),i=this._renderService.dimensions.css.cell.height,r=this._bufferService.buffer.y*this._renderService.dimensions.css.cell.height,n=e*this._renderService.dimensions.css.cell.width;this._compositionView.style.left=n+\"px\",this._compositionView.style.top=r+\"px\",this._compositionView.style.height=i+\"px\",this._compositionView.style.lineHeight=i+\"px\",this._compositionView.style.fontFamily=this._optionsService.rawOptions.fontFamily,this._compositionView.style.fontSize=this._optionsService.rawOptions.fontSize+\"px\";let o=this._compositionView.getBoundingClientRect();this._textarea.style.left=n+\"px\",this._textarea.style.top=r+\"px\",this._textarea.style.width=Math.max(o.width,1)+\"px\",this._textarea.style.height=Math.max(o.height,1)+\"px\",this._textarea.style.lineHeight=o.height+\"px\"}t||setTimeout(()=>this.updateCompositionElements(!0),0)}}};$t=M([S(2,F),S(3,H),S(4,ge),S(5,ce)],$t);var ue=0,he=0,de=0,J=0,ps={css:\"#00000000\",rgba:0},j;(i=>{function s(r,n,o,l){return l!==void 0?`#${vt(r)}${vt(n)}${vt(o)}${vt(l)}`:`#${vt(r)}${vt(n)}${vt(o)}`}i.toCss=s;function t(r,n,o,l=255){return(r<<24|n<<16|o<<8|l)>>>0}i.toRgba=t;function e(r,n,o,l){return{css:i.toCss(r,n,o,l),rgba:i.toRgba(r,n,o,l)}}i.toColor=e})(j||={});var U;(l=>{function s(a,u){if(J=(u.rgba&255)/255,J===1)return{css:u.css,rgba:u.rgba};let h=u.rgba>>24&255,c=u.rgba>>16&255,d=u.rgba>>8&255,_=a.rgba>>24&255,p=a.rgba>>16&255,m=a.rgba>>8&255;ue=_+Math.round((h-_)*J),he=p+Math.round((c-p)*J),de=m+Math.round((d-m)*J);let f=j.toCss(ue,he,de),A=j.toRgba(ue,he,de);return{css:f,rgba:A}}l.blend=s;function t(a){return(a.rgba&255)===255}l.isOpaque=t;function e(a,u,h){let c=$r.ensureContrastRatio(a.rgba,u.rgba,h);if(c)return j.toColor(c>>24&255,c>>16&255,c>>8&255)}l.ensureContrastRatio=e;function i(a){let u=(a.rgba|255)>>>0;return[ue,he,de]=$r.toChannels(u),{css:j.toCss(ue,he,de),rgba:u}}l.opaque=i;function r(a,u){return J=Math.round(u*255),[ue,he,de]=$r.toChannels(a.rgba),{css:j.toCss(ue,he,de,J),rgba:j.toRgba(ue,he,de,J)}}l.opacity=r;function n(a,u){return J=a.rgba&255,r(a,J*u/255)}l.multiplyOpacity=n;function o(a){return[a.rgba>>24&255,a.rgba>>16&255,a.rgba>>8&255]}l.toColorRGB=o})(U||={});var z;(i=>{let s,t;try{let r=document.createElement(\"canvas\");r.width=1,r.height=1;let n=r.getContext(\"2d\",{willReadFrequently:!0});n&&(s=n,s.globalCompositeOperation=\"copy\",t=s.createLinearGradient(0,0,1,1))}catch{}function e(r){if(r.match(/#[\\da-f]{3,8}/i))switch(r.length){case 4:return ue=parseInt(r.slice(1,2).repeat(2),16),he=parseInt(r.slice(2,3).repeat(2),16),de=parseInt(r.slice(3,4).repeat(2),16),j.toColor(ue,he,de);case 5:return ue=parseInt(r.slice(1,2).repeat(2),16),he=parseInt(r.slice(2,3).repeat(2),16),de=parseInt(r.slice(3,4).repeat(2),16),J=parseInt(r.slice(4,5).repeat(2),16),j.toColor(ue,he,de,J);case 7:return{css:r,rgba:(parseInt(r.slice(1),16)<<8|255)>>>0};case 9:return{css:r,rgba:parseInt(r.slice(1),16)>>>0}}let n=r.match(/rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(,\\s*(0|1|\\d?\\.(\\d+))\\s*)?\\)/);if(n)return ue=parseInt(n[1]),he=parseInt(n[2]),de=parseInt(n[3]),J=Math.round((n[5]===void 0?1:parseFloat(n[5]))*255),j.toColor(ue,he,de,J);if(!s||!t)throw new Error(\"css.toColor: Unsupported css format\");if(s.fillStyle=t,s.fillStyle=r,typeof s.fillStyle!=\"string\")throw new Error(\"css.toColor: Unsupported css format\");if(s.fillRect(0,0,1,1),[ue,he,de,J]=s.getImageData(0,0,1,1).data,J!==255)throw new Error(\"css.toColor: Unsupported css format\");return{rgba:j.toRgba(ue,he,de,J),css:r}}i.toColor=e})(z||={});var ve;(e=>{function s(i){return t(i>>16&255,i>>8&255,i&255)}e.relativeLuminance=s;function t(i,r,n){let o=i/255,l=r/255,a=n/255,u=o<=.03928?o/12.92:Math.pow((o+.055)/1.055,2.4),h=l<=.03928?l/12.92:Math.pow((l+.055)/1.055,2.4),c=a<=.03928?a/12.92:Math.pow((a+.055)/1.055,2.4);return u*.2126+h*.7152+c*.0722}e.relativeLuminance2=t})(ve||={});var $r;(n=>{function s(o,l){if(J=(l&255)/255,J===1)return l;let a=l>>24&255,u=l>>16&255,h=l>>8&255,c=o>>24&255,d=o>>16&255,_=o>>8&255;return ue=c+Math.round((a-c)*J),he=d+Math.round((u-d)*J),de=_+Math.round((h-_)*J),j.toRgba(ue,he,de)}n.blend=s;function t(o,l,a){let u=ve.relativeLuminance(o>>8),h=ve.relativeLuminance(l>>8);if(Xe(u,h)<a){if(h<u){let p=e(o,l,a),m=Xe(u,ve.relativeLuminance(p>>8));if(m<a){let f=i(o,l,a),A=Xe(u,ve.relativeLuminance(f>>8));return m>A?p:f}return p}let d=i(o,l,a),_=Xe(u,ve.relativeLuminance(d>>8));if(_<a){let p=e(o,l,a),m=Xe(u,ve.relativeLuminance(p>>8));return _>m?d:p}return d}}n.ensureContrastRatio=t;function e(o,l,a){let u=o>>24&255,h=o>>16&255,c=o>>8&255,d=l>>24&255,_=l>>16&255,p=l>>8&255,m=Xe(ve.relativeLuminance2(d,_,p),ve.relativeLuminance2(u,h,c));for(;m<a&&(d>0||_>0||p>0);)d-=Math.max(0,Math.ceil(d*.1)),_-=Math.max(0,Math.ceil(_*.1)),p-=Math.max(0,Math.ceil(p*.1)),m=Xe(ve.relativeLuminance2(d,_,p),ve.relativeLuminance2(u,h,c));return(d<<24|_<<16|p<<8|255)>>>0}n.reduceLuminance=e;function i(o,l,a){let u=o>>24&255,h=o>>16&255,c=o>>8&255,d=l>>24&255,_=l>>16&255,p=l>>8&255,m=Xe(ve.relativeLuminance2(d,_,p),ve.relativeLuminance2(u,h,c));for(;m<a&&(d<255||_<255||p<255);)d=Math.min(255,d+Math.ceil((255-d)*.1)),_=Math.min(255,_+Math.ceil((255-_)*.1)),p=Math.min(255,p+Math.ceil((255-p)*.1)),m=Xe(ve.relativeLuminance2(d,_,p),ve.relativeLuminance2(u,h,c));return(d<<24|_<<16|p<<8|255)>>>0}n.increaseLuminance=i;function r(o){return[o>>24&255,o>>16&255,o>>8&255,o&255]}n.toChannels=r})($r||={});function vt(s){let t=s.toString(16);return t.length<2?\"0\"+t:t}function Xe(s,t){return s<t?(t+.05)/(s+.05):(s+.05)/(t+.05)}var Vr=class extends De{constructor(e,i,r){super();this.content=0;this.combinedData=\"\";this.fg=e.fg,this.bg=e.bg,this.combinedData=i,this._width=r}isCombined(){return 2097152}getWidth(){return this._width}getChars(){return this.combinedData}getCode(){return 2097151}setFromCharData(e){throw new Error(\"not implemented\")}getAsCharData(){return[this.fg,this.getChars(),this.getWidth(),this.getCode()]}},ct=class{constructor(t){this._bufferService=t;this._characterJoiners=[];this._nextCharacterJoinerId=0;this._workCell=new q}register(t){let e={id:this._nextCharacterJoinerId++,handler:t};return this._characterJoiners.push(e),e.id}deregister(t){for(let e=0;e<this._characterJoiners.length;e++)if(this._characterJoiners[e].id===t)return this._characterJoiners.splice(e,1),!0;return!1}getJoinedCharacters(t){if(this._characterJoiners.length===0)return[];let e=this._bufferService.buffer.lines.get(t);if(!e||e.length===0)return[];let i=[],r=e.translateToString(!0),n=0,o=0,l=0,a=e.getFg(0),u=e.getBg(0);for(let h=0;h<e.getTrimmedLength();h++)if(e.loadCell(h,this._workCell),this._workCell.getWidth()!==0){if(this._workCell.fg!==a||this._workCell.bg!==u){if(h-n>1){let c=this._getJoinedRanges(r,l,o,e,n);for(let d=0;d<c.length;d++)i.push(c[d])}n=h,l=o,a=this._workCell.fg,u=this._workCell.bg}o+=this._workCell.getChars().length||we.length}if(this._bufferService.cols-n>1){let h=this._getJoinedRanges(r,l,o,e,n);for(let c=0;c<h.length;c++)i.push(h[c])}return i}_getJoinedRanges(t,e,i,r,n){let o=t.substring(e,i),l=[];try{l=this._characterJoiners[0].handler(o)}catch(a){console.error(a)}for(let a=1;a<this._characterJoiners.length;a++)try{let u=this._characterJoiners[a].handler(o);for(let h=0;h<u.length;h++)ct._mergeRanges(l,u[h])}catch(u){console.error(u)}return this._stringRangesToCellRanges(l,r,n),l}_stringRangesToCellRanges(t,e,i){let r=0,n=!1,o=0,l=t[r];if(l){for(let a=i;a<this._bufferService.cols;a++){let u=e.getWidth(a),h=e.getString(a).length||we.length;if(u!==0){if(!n&&l[0]<=o&&(l[0]=a,n=!0),l[1]<=o){if(l[1]=a,l=t[++r],!l)break;l[0]<=o?(l[0]=a,n=!0):n=!1}o+=h}}l&&(l[1]=this._bufferService.cols)}}static _mergeRanges(t,e){let i=!1;for(let r=0;r<t.length;r++){let n=t[r];if(i){if(e[1]<=n[0])return t[r-1][1]=e[1],t;if(e[1]<=n[1])return t[r-1][1]=Math.max(e[1],n[1]),t.splice(r,1),t;t.splice(r,1),r--}else{if(e[1]<=n[0])return t.splice(r,0,e),t;if(e[1]<=n[1])return n[0]=Math.min(e[0],n[0]),t;e[0]<n[1]&&(n[0]=Math.min(e[0],n[0]),i=!0);continue}}return i?t[t.length-1][1]=e[1]:t.push(e),t}};ct=M([S(0,F)],ct);function Oa(s){return 57508<=s&&s<=57558}function Ba(s){return 9472<=s&&s<=9631}function $o(s){return Oa(s)||Ba(s)}function Vo(){return{css:{canvas:qr(),cell:qr()},device:{canvas:qr(),cell:qr(),char:{width:0,height:0,left:0,top:0}}}}function qr(){return{width:0,height:0}}var Vt=class{constructor(t,e,i,r,n,o,l){this._document=t;this._characterJoinerService=e;this._optionsService=i;this._coreBrowserService=r;this._coreService=n;this._decorationService=o;this._themeService=l;this._workCell=new q;this._columnSelectMode=!1;this.defaultSpacing=0}handleSelectionChanged(t,e,i){this._selectionStart=t,this._selectionEnd=e,this._columnSelectMode=i}createRow(t,e,i,r,n,o,l,a,u,h,c){let d=[],_=this._characterJoinerService.getJoinedCharacters(e),p=this._themeService.colors,m=t.getNoBgTrimmedLength();i&&m<o+1&&(m=o+1);let f,A=0,R=\"\",O=0,I=0,k=0,P=0,oe=!1,Me=0,Pe=!1,Ke=0,di=0,V=[],Qe=h!==-1&&c!==-1;for(let y=0;y<m;y++){t.loadCell(y,this._workCell);let T=this._workCell.getWidth();if(T===0)continue;let g=!1,w=y>=di,E=y,x=this._workCell;if(_.length>0&&y===_[0][0]&&w){let W=_.shift(),An=this._isCellInSelection(W[0],e);for(O=W[0]+1;O<W[1];O++)w&&=An===this._isCellInSelection(O,e);w&&=!i||o<W[0]||o>=W[1],w?(g=!0,x=new Vr(this._workCell,t.translateToString(!0,W[0],W[1]),W[1]-W[0]),E=W[1]-1,T=x.getWidth()):di=W[1]}let N=this._isCellInSelection(y,e),Z=i&&y===o,te=Qe&&y>=h&&y<=c,Oe=!1;this._decorationService.forEachDecorationAtCell(y,e,void 0,W=>{Oe=!0});let ze=x.getChars()||we;if(ze===\" \"&&(x.isUnderline()||x.isOverline())&&(ze=\"\\xA0\"),Ke=T*a-u.get(ze,x.isBold(),x.isItalic()),!f)f=this._document.createElement(\"span\");else if(A&&(N&&Pe||!N&&!Pe&&x.bg===I)&&(N&&Pe&&p.selectionForeground||x.fg===k)&&x.extended.ext===P&&te===oe&&Ke===Me&&!Z&&!g&&!Oe&&w){x.isInvisible()?R+=we:R+=ze,A++;continue}else A&&(f.textContent=R),f=this._document.createElement(\"span\"),A=0,R=\"\";if(I=x.bg,k=x.fg,P=x.extended.ext,oe=te,Me=Ke,Pe=N,g&&o>=y&&o<=E&&(o=y),!this._coreService.isCursorHidden&&Z&&this._coreService.isCursorInitialized){if(V.push(\"xterm-cursor\"),this._coreBrowserService.isFocused)l&&V.push(\"xterm-cursor-blink\"),V.push(r===\"bar\"?\"xterm-cursor-bar\":r===\"underline\"?\"xterm-cursor-underline\":\"xterm-cursor-block\");else if(n)switch(n){case\"outline\":V.push(\"xterm-cursor-outline\");break;case\"block\":V.push(\"xterm-cursor-block\");break;case\"bar\":V.push(\"xterm-cursor-bar\");break;case\"underline\":V.push(\"xterm-cursor-underline\");break;default:break}}if(x.isBold()&&V.push(\"xterm-bold\"),x.isItalic()&&V.push(\"xterm-italic\"),x.isDim()&&V.push(\"xterm-dim\"),x.isInvisible()?R=we:R=x.getChars()||we,x.isUnderline()&&(V.push(`xterm-underline-${x.extended.underlineStyle}`),R===\" \"&&(R=\"\\xA0\"),!x.isUnderlineColorDefault()))if(x.isUnderlineColorRGB())f.style.textDecorationColor=`rgb(${De.toColorRGB(x.getUnderlineColor()).join(\",\")})`;else{let W=x.getUnderlineColor();this._optionsService.rawOptions.drawBoldTextInBrightColors&&x.isBold()&&W<8&&(W+=8),f.style.textDecorationColor=p.ansi[W].css}x.isOverline()&&(V.push(\"xterm-overline\"),R===\" \"&&(R=\"\\xA0\")),x.isStrikethrough()&&V.push(\"xterm-strikethrough\"),te&&(f.style.textDecoration=\"underline\");let le=x.getFgColor(),et=x.getFgColorMode(),me=x.getBgColor(),ht=x.getBgColorMode(),fi=!!x.isInverse();if(fi){let W=le;le=me,me=W;let An=et;et=ht,ht=An}let tt,Qi,pi=!1;this._decorationService.forEachDecorationAtCell(y,e,void 0,W=>{W.options.layer!==\"top\"&&pi||(W.backgroundColorRGB&&(ht=50331648,me=W.backgroundColorRGB.rgba>>8&16777215,tt=W.backgroundColorRGB),W.foregroundColorRGB&&(et=50331648,le=W.foregroundColorRGB.rgba>>8&16777215,Qi=W.foregroundColorRGB),pi=W.options.layer===\"top\")}),!pi&&N&&(tt=this._coreBrowserService.isFocused?p.selectionBackgroundOpaque:p.selectionInactiveBackgroundOpaque,me=tt.rgba>>8&16777215,ht=50331648,pi=!0,p.selectionForeground&&(et=50331648,le=p.selectionForeground.rgba>>8&16777215,Qi=p.selectionForeground)),pi&&V.push(\"xterm-decoration-top\");let it;switch(ht){case 16777216:case 33554432:it=p.ansi[me],V.push(`xterm-bg-${me}`);break;case 50331648:it=j.toColor(me>>16,me>>8&255,me&255),this._addStyle(f,`background-color:#${qo((me>>>0).toString(16),\"0\",6)}`);break;case 0:default:fi?(it=p.foreground,V.push(`xterm-bg-${257}`)):it=p.background}switch(tt||x.isDim()&&(tt=U.multiplyOpacity(it,.5)),et){case 16777216:case 33554432:x.isBold()&&le<8&&this._optionsService.rawOptions.drawBoldTextInBrightColors&&(le+=8),this._applyMinimumContrast(f,it,p.ansi[le],x,tt,void 0)||V.push(`xterm-fg-${le}`);break;case 50331648:let W=j.toColor(le>>16&255,le>>8&255,le&255);this._applyMinimumContrast(f,it,W,x,tt,Qi)||this._addStyle(f,`color:#${qo(le.toString(16),\"0\",6)}`);break;case 0:default:this._applyMinimumContrast(f,it,p.foreground,x,tt,Qi)||fi&&V.push(`xterm-fg-${257}`)}V.length&&(f.className=V.join(\" \"),V.length=0),!Z&&!g&&!Oe&&w?A++:f.textContent=R,Ke!==this.defaultSpacing&&(f.style.letterSpacing=`${Ke}px`),d.push(f),y=E}return f&&A&&(f.textContent=R),d}_applyMinimumContrast(t,e,i,r,n,o){if(this._optionsService.rawOptions.minimumContrastRatio===1||$o(r.getCode()))return!1;let l=this._getContrastCache(r),a;if(!n&&!o&&(a=l.getColor(e.rgba,i.rgba)),a===void 0){let u=this._optionsService.rawOptions.minimumContrastRatio/(r.isDim()?2:1);a=U.ensureContrastRatio(n||e,o||i,u),l.setColor((n||e).rgba,(o||i).rgba,a??null)}return a?(this._addStyle(t,`color:${a.css}`),!0):!1}_getContrastCache(t){return t.isDim()?this._themeService.colors.halfContrastCache:this._themeService.colors.contrastCache}_addStyle(t,e){t.setAttribute(\"style\",`${t.getAttribute(\"style\")||\"\"}${e};`)}_isCellInSelection(t,e){let i=this._selectionStart,r=this._selectionEnd;return!i||!r?!1:this._columnSelectMode?i[0]<=r[0]?t>=i[0]&&e>=i[1]&&t<r[0]&&e<=r[1]:t<i[0]&&e>=i[1]&&t>=r[0]&&e<=r[1]:e>i[1]&&e<r[1]||i[1]===r[1]&&e===i[1]&&t>=i[0]&&t<r[0]||i[1]<r[1]&&e===r[1]&&t<r[0]||i[1]<r[1]&&e===i[1]&&t>=i[0]}};Vt=M([S(1,or),S(2,H),S(3,ae),S(4,ge),S(5,Be),S(6,Re)],Vt);function qo(s,t,e){for(;s.length<e;)s=t+s;return s}var Yr=class{constructor(t,e){this._flat=new Float32Array(256);this._font=\"\";this._fontSize=0;this._weight=\"normal\";this._weightBold=\"bold\";this._measureElements=[];this._container=t.createElement(\"div\"),this._container.classList.add(\"xterm-width-cache-measure-container\"),this._container.setAttribute(\"aria-hidden\",\"true\"),this._container.style.whiteSpace=\"pre\",this._container.style.fontKerning=\"none\";let i=t.createElement(\"span\");i.classList.add(\"xterm-char-measure-element\");let r=t.createElement(\"span\");r.classList.add(\"xterm-char-measure-element\"),r.style.fontWeight=\"bold\";let n=t.createElement(\"span\");n.classList.add(\"xterm-char-measure-element\"),n.style.fontStyle=\"italic\";let o=t.createElement(\"span\");o.classList.add(\"xterm-char-measure-element\"),o.style.fontWeight=\"bold\",o.style.fontStyle=\"italic\",this._measureElements=[i,r,n,o],this._container.appendChild(i),this._container.appendChild(r),this._container.appendChild(n),this._container.appendChild(o),e.appendChild(this._container),this.clear()}dispose(){this._container.remove(),this._measureElements.length=0,this._holey=void 0}clear(){this._flat.fill(-9999),this._holey=new Map}setFont(t,e,i,r){t===this._font&&e===this._fontSize&&i===this._weight&&r===this._weightBold||(this._font=t,this._fontSize=e,this._weight=i,this._weightBold=r,this._container.style.fontFamily=this._font,this._container.style.fontSize=`${this._fontSize}px`,this._measureElements[0].style.fontWeight=`${i}`,this._measureElements[1].style.fontWeight=`${r}`,this._measureElements[2].style.fontWeight=`${i}`,this._measureElements[3].style.fontWeight=`${r}`,this.clear())}get(t,e,i){let r=0;if(!e&&!i&&t.length===1&&(r=t.charCodeAt(0))<256){if(this._flat[r]!==-9999)return this._flat[r];let l=this._measure(t,0);return l>0&&(this._flat[r]=l),l}let n=t;e&&(n+=\"B\"),i&&(n+=\"I\");let o=this._holey.get(n);if(o===void 0){let l=0;e&&(l|=1),i&&(l|=2),o=this._measure(t,l),o>0&&this._holey.set(n,o)}return o}_measure(t,e){let i=this._measureElements[e];return i.textContent=t.repeat(32),i.offsetWidth/32}};var ms=class{constructor(){this.clear()}clear(){this.hasSelection=!1,this.columnSelectMode=!1,this.viewportStartRow=0,this.viewportEndRow=0,this.viewportCappedStartRow=0,this.viewportCappedEndRow=0,this.startCol=0,this.endCol=0,this.selectionStart=void 0,this.selectionEnd=void 0}update(t,e,i,r=!1){if(this.selectionStart=e,this.selectionEnd=i,!e||!i||e[0]===i[0]&&e[1]===i[1]){this.clear();return}let n=t.buffers.active.ydisp,o=e[1]-n,l=i[1]-n,a=Math.max(o,0),u=Math.min(l,t.rows-1);if(a>=t.rows||u<0){this.clear();return}this.hasSelection=!0,this.columnSelectMode=r,this.viewportStartRow=o,this.viewportEndRow=l,this.viewportCappedStartRow=a,this.viewportCappedEndRow=u,this.startCol=e[0],this.endCol=i[0]}isCellSelected(t,e,i){return this.hasSelection?(i-=t.buffer.active.viewportY,this.columnSelectMode?this.startCol<=this.endCol?e>=this.startCol&&i>=this.viewportCappedStartRow&&e<this.endCol&&i<=this.viewportCappedEndRow:e<this.startCol&&i>=this.viewportCappedStartRow&&e>=this.endCol&&i<=this.viewportCappedEndRow:i>this.viewportStartRow&&i<this.viewportEndRow||this.viewportStartRow===this.viewportEndRow&&i===this.viewportStartRow&&e>=this.startCol&&e<this.endCol||this.viewportStartRow<this.viewportEndRow&&i===this.viewportEndRow&&e<this.endCol||this.viewportStartRow<this.viewportEndRow&&i===this.viewportStartRow&&e>=this.startCol):!1}};function Yo(){return new ms}var _s=\"xterm-dom-renderer-owner-\",Le=\"xterm-rows\",jr=\"xterm-fg-\",jo=\"xterm-bg-\",ki=\"xterm-focus\",Xr=\"xterm-selection\",Na=1,Yt=class extends D{constructor(e,i,r,n,o,l,a,u,h,c,d,_,p,m){super();this._terminal=e;this._document=i;this._element=r;this._screenElement=n;this._viewportElement=o;this._helperContainer=l;this._linkifier2=a;this._charSizeService=h;this._optionsService=c;this._bufferService=d;this._coreService=_;this._coreBrowserService=p;this._themeService=m;this._terminalClass=Na++;this._rowElements=[];this._selectionRenderModel=Yo();this.onRequestRedraw=this._register(new v).event;this._rowContainer=this._document.createElement(\"div\"),this._rowContainer.classList.add(Le),this._rowContainer.style.lineHeight=\"normal\",this._rowContainer.setAttribute(\"aria-hidden\",\"true\"),this._refreshRowElements(this._bufferService.cols,this._bufferService.rows),this._selectionContainer=this._document.createElement(\"div\"),this._selectionContainer.classList.add(Xr),this._selectionContainer.setAttribute(\"aria-hidden\",\"true\"),this.dimensions=Vo(),this._updateDimensions(),this._register(this._optionsService.onOptionChange(()=>this._handleOptionsChanged())),this._register(this._themeService.onChangeColors(f=>this._injectCss(f))),this._injectCss(this._themeService.colors),this._rowFactory=u.createInstance(Vt,document),this._element.classList.add(_s+this._terminalClass),this._screenElement.appendChild(this._rowContainer),this._screenElement.appendChild(this._selectionContainer),this._register(this._linkifier2.onShowLinkUnderline(f=>this._handleLinkHover(f))),this._register(this._linkifier2.onHideLinkUnderline(f=>this._handleLinkLeave(f))),this._register(C(()=>{this._element.classList.remove(_s+this._terminalClass),this._rowContainer.remove(),this._selectionContainer.remove(),this._widthCache.dispose(),this._themeStyleElement.remove(),this._dimensionsStyleElement.remove()})),this._widthCache=new Yr(this._document,this._helperContainer),this._widthCache.setFont(this._optionsService.rawOptions.fontFamily,this._optionsService.rawOptions.fontSize,this._optionsService.rawOptions.fontWeight,this._optionsService.rawOptions.fontWeightBold),this._setDefaultSpacing()}_updateDimensions(){let e=this._coreBrowserService.dpr;this.dimensions.device.char.width=this._charSizeService.width*e,this.dimensions.device.char.height=Math.ceil(this._charSizeService.height*e),this.dimensions.device.cell.width=this.dimensions.device.char.width+Math.round(this._optionsService.rawOptions.letterSpacing),this.dimensions.device.cell.height=Math.floor(this.dimensions.device.char.height*this._optionsService.rawOptions.lineHeight),this.dimensions.device.char.left=0,this.dimensions.device.char.top=0,this.dimensions.device.canvas.width=this.dimensions.device.cell.width*this._bufferService.cols,this.dimensions.device.canvas.height=this.dimensions.device.cell.height*this._bufferService.rows,this.dimensions.css.canvas.width=Math.round(this.dimensions.device.canvas.width/e),this.dimensions.css.canvas.height=Math.round(this.dimensions.device.canvas.height/e),this.dimensions.css.cell.width=this.dimensions.css.canvas.width/this._bufferService.cols,this.dimensions.css.cell.height=this.dimensions.css.canvas.height/this._bufferService.rows;for(let r of this._rowElements)r.style.width=`${this.dimensions.css.canvas.width}px`,r.style.height=`${this.dimensions.css.cell.height}px`,r.style.lineHeight=`${this.dimensions.css.cell.height}px`,r.style.overflow=\"hidden\";this._dimensionsStyleElement||(this._dimensionsStyleElement=this._document.createElement(\"style\"),this._screenElement.appendChild(this._dimensionsStyleElement));let i=`${this._terminalSelector} .${Le} span { display: inline-block; height: 100%; vertical-align: top;}`;this._dimensionsStyleElement.textContent=i,this._selectionContainer.style.height=this._viewportElement.style.height,this._screenElement.style.width=`${this.dimensions.css.canvas.width}px`,this._screenElement.style.height=`${this.dimensions.css.canvas.height}px`}_injectCss(e){this._themeStyleElement||(this._themeStyleElement=this._document.createElement(\"style\"),this._screenElement.appendChild(this._themeStyleElement));let i=`${this._terminalSelector} .${Le} { pointer-events: none; color: ${e.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;i+=`${this._terminalSelector} .${Le} .xterm-dim { color: ${U.multiplyOpacity(e.foreground,.5).css};}`,i+=`${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;let r=`blink_underline_${this._terminalClass}`,n=`blink_bar_${this._terminalClass}`,o=`blink_block_${this._terminalClass}`;i+=`@keyframes ${r} { 50% {  border-bottom-style: hidden; }}`,i+=`@keyframes ${n} { 50% {  box-shadow: none; }}`,i+=`@keyframes ${o} { 0% {  background-color: ${e.cursor.css};  color: ${e.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e.cursor.css}; }}`,i+=`${this._terminalSelector} .${Le}.${ki} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${r} 1s step-end infinite;}${this._terminalSelector} .${Le}.${ki} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${n} 1s step-end infinite;}${this._terminalSelector} .${Le}.${ki} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${o} 1s step-end infinite;}${this._terminalSelector} .${Le} .xterm-cursor.xterm-cursor-block { background-color: ${e.cursor.css}; color: ${e.cursorAccent.css};}${this._terminalSelector} .${Le} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e.cursor.css} !important; color: ${e.cursorAccent.css} !important;}${this._terminalSelector} .${Le} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${Le} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e.cursor.css} inset;}${this._terminalSelector} .${Le} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`,i+=`${this._terminalSelector} .${Xr} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${Xr} div { position: absolute; background-color: ${e.selectionBackgroundOpaque.css};}${this._terminalSelector} .${Xr} div { position: absolute; background-color: ${e.selectionInactiveBackgroundOpaque.css};}`;for(let[l,a]of e.ansi.entries())i+=`${this._terminalSelector} .${jr}${l} { color: ${a.css}; }${this._terminalSelector} .${jr}${l}.xterm-dim { color: ${U.multiplyOpacity(a,.5).css}; }${this._terminalSelector} .${jo}${l} { background-color: ${a.css}; }`;i+=`${this._terminalSelector} .${jr}${257} { color: ${U.opaque(e.background).css}; }${this._terminalSelector} .${jr}${257}.xterm-dim { color: ${U.multiplyOpacity(U.opaque(e.background),.5).css}; }${this._terminalSelector} .${jo}${257} { background-color: ${e.foreground.css}; }`,this._themeStyleElement.textContent=i}_setDefaultSpacing(){let e=this.dimensions.css.cell.width-this._widthCache.get(\"W\",!1,!1);this._rowContainer.style.letterSpacing=`${e}px`,this._rowFactory.defaultSpacing=e}handleDevicePixelRatioChange(){this._updateDimensions(),this._widthCache.clear(),this._setDefaultSpacing()}_refreshRowElements(e,i){for(let r=this._rowElements.length;r<=i;r++){let n=this._document.createElement(\"div\");this._rowContainer.appendChild(n),this._rowElements.push(n)}for(;this._rowElements.length>i;)this._rowContainer.removeChild(this._rowElements.pop())}handleResize(e,i){this._refreshRowElements(e,i),this._updateDimensions(),this.handleSelectionChanged(this._selectionRenderModel.selectionStart,this._selectionRenderModel.selectionEnd,this._selectionRenderModel.columnSelectMode)}handleCharSizeChanged(){this._updateDimensions(),this._widthCache.clear(),this._setDefaultSpacing()}handleBlur(){this._rowContainer.classList.remove(ki),this.renderRows(0,this._bufferService.rows-1)}handleFocus(){this._rowContainer.classList.add(ki),this.renderRows(this._bufferService.buffer.y,this._bufferService.buffer.y)}handleSelectionChanged(e,i,r){if(this._selectionContainer.replaceChildren(),this._rowFactory.handleSelectionChanged(e,i,r),this.renderRows(0,this._bufferService.rows-1),!e||!i||(this._selectionRenderModel.update(this._terminal,e,i,r),!this._selectionRenderModel.hasSelection))return;let n=this._selectionRenderModel.viewportStartRow,o=this._selectionRenderModel.viewportEndRow,l=this._selectionRenderModel.viewportCappedStartRow,a=this._selectionRenderModel.viewportCappedEndRow,u=this._document.createDocumentFragment();if(r){let h=e[0]>i[0];u.appendChild(this._createSelectionElement(l,h?i[0]:e[0],h?e[0]:i[0],a-l+1))}else{let h=n===l?e[0]:0,c=l===o?i[0]:this._bufferService.cols;u.appendChild(this._createSelectionElement(l,h,c));let d=a-l-1;if(u.appendChild(this._createSelectionElement(l+1,0,this._bufferService.cols,d)),l!==a){let _=o===a?i[0]:this._bufferService.cols;u.appendChild(this._createSelectionElement(a,0,_))}}this._selectionContainer.appendChild(u)}_createSelectionElement(e,i,r,n=1){let o=this._document.createElement(\"div\"),l=i*this.dimensions.css.cell.width,a=this.dimensions.css.cell.width*(r-i);return l+a>this.dimensions.css.canvas.width&&(a=this.dimensions.css.canvas.width-l),o.style.height=`${n*this.dimensions.css.cell.height}px`,o.style.top=`${e*this.dimensions.css.cell.height}px`,o.style.left=`${l}px`,o.style.width=`${a}px`,o}handleCursorMove(){}_handleOptionsChanged(){this._updateDimensions(),this._injectCss(this._themeService.colors),this._widthCache.setFont(this._optionsService.rawOptions.fontFamily,this._optionsService.rawOptions.fontSize,this._optionsService.rawOptions.fontWeight,this._optionsService.rawOptions.fontWeightBold),this._setDefaultSpacing()}clear(){for(let e of this._rowElements)e.replaceChildren()}renderRows(e,i){let r=this._bufferService.buffer,n=r.ybase+r.y,o=Math.min(r.x,this._bufferService.cols-1),l=this._coreService.decPrivateModes.cursorBlink??this._optionsService.rawOptions.cursorBlink,a=this._coreService.decPrivateModes.cursorStyle??this._optionsService.rawOptions.cursorStyle,u=this._optionsService.rawOptions.cursorInactiveStyle;for(let h=e;h<=i;h++){let c=h+r.ydisp,d=this._rowElements[h],_=r.lines.get(c);if(!d||!_)break;d.replaceChildren(...this._rowFactory.createRow(_,c,c===n,a,u,o,l,this.dimensions.css.cell.width,this._widthCache,-1,-1))}}get _terminalSelector(){return`.${_s}${this._terminalClass}`}_handleLinkHover(e){this._setCellUnderline(e.x1,e.x2,e.y1,e.y2,e.cols,!0)}_handleLinkLeave(e){this._setCellUnderline(e.x1,e.x2,e.y1,e.y2,e.cols,!1)}_setCellUnderline(e,i,r,n,o,l){r<0&&(e=0),n<0&&(i=0);let a=this._bufferService.rows-1;r=Math.max(Math.min(r,a),0),n=Math.max(Math.min(n,a),0),o=Math.min(o,this._bufferService.cols);let u=this._bufferService.buffer,h=u.ybase+u.y,c=Math.min(u.x,o-1),d=this._optionsService.rawOptions.cursorBlink,_=this._optionsService.rawOptions.cursorStyle,p=this._optionsService.rawOptions.cursorInactiveStyle;for(let m=r;m<=n;++m){let f=m+u.ydisp,A=this._rowElements[m],R=u.lines.get(f);if(!A||!R)break;A.replaceChildren(...this._rowFactory.createRow(R,f,f===h,_,p,c,d,this.dimensions.css.cell.width,this._widthCache,l?m===r?e:0:-1,l?(m===n?i:o)-1:-1))}}};Yt=M([S(7,xt),S(8,nt),S(9,H),S(10,F),S(11,ge),S(12,ae),S(13,Re)],Yt);var jt=class extends D{constructor(e,i,r){super();this._optionsService=r;this.width=0;this.height=0;this._onCharSizeChange=this._register(new v);this.onCharSizeChange=this._onCharSizeChange.event;try{this._measureStrategy=this._register(new vs(this._optionsService))}catch{this._measureStrategy=this._register(new bs(e,i,this._optionsService))}this._register(this._optionsService.onMultipleOptionChange([\"fontFamily\",\"fontSize\"],()=>this.measure()))}get hasValidSize(){return this.width>0&&this.height>0}measure(){let e=this._measureStrategy.measure();(e.width!==this.width||e.height!==this.height)&&(this.width=e.width,this.height=e.height,this._onCharSizeChange.fire())}};jt=M([S(2,H)],jt);var Zr=class extends D{constructor(){super(...arguments);this._result={width:0,height:0}}_validateAndSet(e,i){e!==void 0&&e>0&&i!==void 0&&i>0&&(this._result.width=e,this._result.height=i)}},bs=class extends Zr{constructor(e,i,r){super();this._document=e;this._parentElement=i;this._optionsService=r;this._measureElement=this._document.createElement(\"span\"),this._measureElement.classList.add(\"xterm-char-measure-element\"),this._measureElement.textContent=\"W\".repeat(32),this._measureElement.setAttribute(\"aria-hidden\",\"true\"),this._measureElement.style.whiteSpace=\"pre\",this._measureElement.style.fontKerning=\"none\",this._parentElement.appendChild(this._measureElement)}measure(){return this._measureElement.style.fontFamily=this._optionsService.rawOptions.fontFamily,this._measureElement.style.fontSize=`${this._optionsService.rawOptions.fontSize}px`,this._validateAndSet(Number(this._measureElement.offsetWidth)/32,Number(this._measureElement.offsetHeight)),this._result}},vs=class extends Zr{constructor(e){super();this._optionsService=e;this._canvas=new OffscreenCanvas(100,100),this._ctx=this._canvas.getContext(\"2d\");let i=this._ctx.measureText(\"W\");if(!(\"width\"in i&&\"fontBoundingBoxAscent\"in i&&\"fontBoundingBoxDescent\"in i))throw new Error(\"Required font metrics not supported\")}measure(){this._ctx.font=`${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;let e=this._ctx.measureText(\"W\");return this._validateAndSet(e.width,e.fontBoundingBoxAscent+e.fontBoundingBoxDescent),this._result}};var Jr=class extends D{constructor(e,i,r){super();this._textarea=e;this._window=i;this.mainDocument=r;this._isFocused=!1;this._cachedIsFocused=void 0;this._screenDprMonitor=this._register(new gs(this._window));this._onDprChange=this._register(new v);this.onDprChange=this._onDprChange.event;this._onWindowChange=this._register(new v);this.onWindowChange=this._onWindowChange.event;this._register(this.onWindowChange(n=>this._screenDprMonitor.setWindow(n))),this._register($.forward(this._screenDprMonitor.onDprChange,this._onDprChange)),this._register(L(this._textarea,\"focus\",()=>this._isFocused=!0)),this._register(L(this._textarea,\"blur\",()=>this._isFocused=!1))}get window(){return this._window}set window(e){this._window!==e&&(this._window=e,this._onWindowChange.fire(this._window))}get dpr(){return this.window.devicePixelRatio}get isFocused(){return this._cachedIsFocused===void 0&&(this._cachedIsFocused=this._isFocused&&this._textarea.ownerDocument.hasFocus(),queueMicrotask(()=>this._cachedIsFocused=void 0)),this._cachedIsFocused}},gs=class extends D{constructor(e){super();this._parentWindow=e;this._windowResizeListener=this._register(new ye);this._onDprChange=this._register(new v);this.onDprChange=this._onDprChange.event;this._outerListener=()=>this._setDprAndFireIfDiffers(),this._currentDevicePixelRatio=this._parentWindow.devicePixelRatio,this._updateDpr(),this._setWindowResizeListener(),this._register(C(()=>this.clearListener()))}setWindow(e){this._parentWindow=e,this._setWindowResizeListener(),this._setDprAndFireIfDiffers()}_setWindowResizeListener(){this._windowResizeListener.value=L(this._parentWindow,\"resize\",()=>this._setDprAndFireIfDiffers())}_setDprAndFireIfDiffers(){this._parentWindow.devicePixelRatio!==this._currentDevicePixelRatio&&this._onDprChange.fire(this._parentWindow.devicePixelRatio),this._updateDpr()}_updateDpr(){this._outerListener&&(this._resolutionMediaMatchList?.removeListener(this._outerListener),this._currentDevicePixelRatio=this._parentWindow.devicePixelRatio,this._resolutionMediaMatchList=this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`),this._resolutionMediaMatchList.addListener(this._outerListener))}clearListener(){!this._resolutionMediaMatchList||!this._outerListener||(this._resolutionMediaMatchList.removeListener(this._outerListener),this._resolutionMediaMatchList=void 0,this._outerListener=void 0)}};var Qr=class extends D{constructor(){super();this.linkProviders=[];this._register(C(()=>this.linkProviders.length=0))}registerLinkProvider(e){return this.linkProviders.push(e),{dispose:()=>{let i=this.linkProviders.indexOf(e);i!==-1&&this.linkProviders.splice(i,1)}}}};function Ci(s,t,e){let i=e.getBoundingClientRect(),r=s.getComputedStyle(e),n=parseInt(r.getPropertyValue(\"padding-left\")),o=parseInt(r.getPropertyValue(\"padding-top\"));return[t.clientX-i.left-n,t.clientY-i.top-o]}function Xo(s,t,e,i,r,n,o,l,a){if(!n)return;let u=Ci(s,t,e);if(u)return u[0]=Math.ceil((u[0]+(a?o/2:0))/o),u[1]=Math.ceil(u[1]/l),u[0]=Math.min(Math.max(u[0],1),i+(a?1:0)),u[1]=Math.min(Math.max(u[1],1),r),u}var Xt=class{constructor(t,e){this._renderService=t;this._charSizeService=e}getCoords(t,e,i,r,n){return Xo(window,t,e,i,r,this._charSizeService.hasValidSize,this._renderService.dimensions.css.cell.width,this._renderService.dimensions.css.cell.height,n)}getMouseReportCoords(t,e){let i=Ci(window,t,e);if(this._charSizeService.hasValidSize)return i[0]=Math.min(Math.max(i[0],0),this._renderService.dimensions.css.canvas.width-1),i[1]=Math.min(Math.max(i[1],0),this._renderService.dimensions.css.canvas.height-1),{col:Math.floor(i[0]/this._renderService.dimensions.css.cell.width),row:Math.floor(i[1]/this._renderService.dimensions.css.cell.height),x:Math.floor(i[0]),y:Math.floor(i[1])}}};Xt=M([S(0,ce),S(1,nt)],Xt);var en=class{constructor(t,e){this._renderCallback=t;this._coreBrowserService=e;this._refreshCallbacks=[]}dispose(){this._animationFrame&&(this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame),this._animationFrame=void 0)}addRefreshCallback(t){return this._refreshCallbacks.push(t),this._animationFrame||(this._animationFrame=this._coreBrowserService.window.requestAnimationFrame(()=>this._innerRefresh())),this._animationFrame}refresh(t,e,i){this._rowCount=i,t=t!==void 0?t:0,e=e!==void 0?e:this._rowCount-1,this._rowStart=this._rowStart!==void 0?Math.min(this._rowStart,t):t,this._rowEnd=this._rowEnd!==void 0?Math.max(this._rowEnd,e):e,!this._animationFrame&&(this._animationFrame=this._coreBrowserService.window.requestAnimationFrame(()=>this._innerRefresh()))}_innerRefresh(){if(this._animationFrame=void 0,this._rowStart===void 0||this._rowEnd===void 0||this._rowCount===void 0){this._runRefreshCallbacks();return}let t=Math.max(this._rowStart,0),e=Math.min(this._rowEnd,this._rowCount-1);this._rowStart=void 0,this._rowEnd=void 0,this._renderCallback(t,e),this._runRefreshCallbacks()}_runRefreshCallbacks(){for(let t of this._refreshCallbacks)t(0);this._refreshCallbacks=[]}};var tn={};Ll(tn,{getSafariVersion:()=>Ha,isChromeOS:()=>Ts,isFirefox:()=>Ss,isIpad:()=>Wa,isIphone:()=>Ua,isLegacyEdge:()=>Fa,isLinux:()=>Bi,isMac:()=>Zt,isNode:()=>Mi,isSafari:()=>Zo,isWindows:()=>Es});var Mi=typeof process<\"u\"&&\"title\"in process,Pi=Mi?\"node\":navigator.userAgent,Oi=Mi?\"node\":navigator.platform,Ss=Pi.includes(\"Firefox\"),Fa=Pi.includes(\"Edge\"),Zo=/^((?!chrome|android).)*safari/i.test(Pi);function Ha(){if(!Zo)return 0;let s=Pi.match(/Version\\/(\\d+)/);return s===null||s.length<2?0:parseInt(s[1])}var Zt=[\"Macintosh\",\"MacIntel\",\"MacPPC\",\"Mac68K\"].includes(Oi),Wa=Oi===\"iPad\",Ua=Oi===\"iPhone\",Es=[\"Windows\",\"Win16\",\"Win32\",\"WinCE\"].includes(Oi),Bi=Oi.indexOf(\"Linux\")>=0,Ts=/\\bCrOS\\b/.test(Pi);var rn=class{constructor(){this._tasks=[];this._i=0}enqueue(t){this._tasks.push(t),this._start()}flush(){for(;this._i<this._tasks.length;)this._tasks[this._i]()||this._i++;this.clear()}clear(){this._idleCallback&&(this._cancelCallback(this._idleCallback),this._idleCallback=void 0),this._i=0,this._tasks.length=0}_start(){this._idleCallback||(this._idleCallback=this._requestCallback(this._process.bind(this)))}_process(t){this._idleCallback=void 0;let e=0,i=0,r=t.timeRemaining(),n=0;for(;this._i<this._tasks.length;){if(e=performance.now(),this._tasks[this._i]()||this._i++,e=Math.max(1,performance.now()-e),i=Math.max(e,i),n=t.timeRemaining(),i*1.5>n){r-e<-20&&console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(r-e))}ms`),this._start();return}r=n}this.clear()}},Is=class extends rn{_requestCallback(t){return setTimeout(()=>t(this._createDeadline(16)))}_cancelCallback(t){clearTimeout(t)}_createDeadline(t){let e=performance.now()+t;return{timeRemaining:()=>Math.max(0,e-performance.now())}}},ys=class extends rn{_requestCallback(t){return requestIdleCallback(t)}_cancelCallback(t){cancelIdleCallback(t)}},Jt=!Mi&&\"requestIdleCallback\"in window?ys:Is,nn=class{constructor(){this._queue=new Jt}set(t){this._queue.clear(),this._queue.enqueue(t)}flush(){this._queue.flush()}};var Qt=class extends D{constructor(e,i,r,n,o,l,a,u,h){super();this._rowCount=e;this._optionsService=r;this._charSizeService=n;this._coreService=o;this._coreBrowserService=u;this._renderer=this._register(new ye);this._pausedResizeTask=new nn;this._observerDisposable=this._register(new ye);this._isPaused=!1;this._needsFullRefresh=!1;this._isNextRenderRedrawOnly=!0;this._needsSelectionRefresh=!1;this._canvasWidth=0;this._canvasHeight=0;this._selectionState={start:void 0,end:void 0,columnSelectMode:!1};this._onDimensionsChange=this._register(new v);this.onDimensionsChange=this._onDimensionsChange.event;this._onRenderedViewportChange=this._register(new v);this.onRenderedViewportChange=this._onRenderedViewportChange.event;this._onRender=this._register(new v);this.onRender=this._onRender.event;this._onRefreshRequest=this._register(new v);this.onRefreshRequest=this._onRefreshRequest.event;this._renderDebouncer=new en((c,d)=>this._renderRows(c,d),this._coreBrowserService),this._register(this._renderDebouncer),this._syncOutputHandler=new xs(this._coreBrowserService,this._coreService,()=>this._fullRefresh()),this._register(C(()=>this._syncOutputHandler.dispose())),this._register(this._coreBrowserService.onDprChange(()=>this.handleDevicePixelRatioChange())),this._register(a.onResize(()=>this._fullRefresh())),this._register(a.buffers.onBufferActivate(()=>this._renderer.value?.clear())),this._register(this._optionsService.onOptionChange(()=>this._handleOptionsChanged())),this._register(this._charSizeService.onCharSizeChange(()=>this.handleCharSizeChanged())),this._register(l.onDecorationRegistered(()=>this._fullRefresh())),this._register(l.onDecorationRemoved(()=>this._fullRefresh())),this._register(this._optionsService.onMultipleOptionChange([\"customGlyphs\",\"drawBoldTextInBrightColors\",\"letterSpacing\",\"lineHeight\",\"fontFamily\",\"fontSize\",\"fontWeight\",\"fontWeightBold\",\"minimumContrastRatio\",\"rescaleOverlappingGlyphs\"],()=>{this.clear(),this.handleResize(a.cols,a.rows),this._fullRefresh()})),this._register(this._optionsService.onMultipleOptionChange([\"cursorBlink\",\"cursorStyle\"],()=>this.refreshRows(a.buffer.y,a.buffer.y,!0))),this._register(h.onChangeColors(()=>this._fullRefresh())),this._registerIntersectionObserver(this._coreBrowserService.window,i),this._register(this._coreBrowserService.onWindowChange(c=>this._registerIntersectionObserver(c,i)))}get dimensions(){return this._renderer.value.dimensions}_registerIntersectionObserver(e,i){if(\"IntersectionObserver\"in e){let r=new e.IntersectionObserver(n=>this._handleIntersectionChange(n[n.length-1]),{threshold:0});r.observe(i),this._observerDisposable.value=C(()=>r.disconnect())}}_handleIntersectionChange(e){this._isPaused=e.isIntersecting===void 0?e.intersectionRatio===0:!e.isIntersecting,!this._isPaused&&!this._charSizeService.hasValidSize&&this._charSizeService.measure(),!this._isPaused&&this._needsFullRefresh&&(this._pausedResizeTask.flush(),this.refreshRows(0,this._rowCount-1),this._needsFullRefresh=!1)}refreshRows(e,i,r=!1){if(this._isPaused){this._needsFullRefresh=!0;return}if(this._coreService.decPrivateModes.synchronizedOutput){this._syncOutputHandler.bufferRows(e,i);return}let n=this._syncOutputHandler.flush();n&&(e=Math.min(e,n.start),i=Math.max(i,n.end)),r||(this._isNextRenderRedrawOnly=!1),this._renderDebouncer.refresh(e,i,this._rowCount)}_renderRows(e,i){if(this._renderer.value){if(this._coreService.decPrivateModes.synchronizedOutput){this._syncOutputHandler.bufferRows(e,i);return}e=Math.min(e,this._rowCount-1),i=Math.min(i,this._rowCount-1),this._renderer.value.renderRows(e,i),this._needsSelectionRefresh&&(this._renderer.value.handleSelectionChanged(this._selectionState.start,this._selectionState.end,this._selectionState.columnSelectMode),this._needsSelectionRefresh=!1),this._isNextRenderRedrawOnly||this._onRenderedViewportChange.fire({start:e,end:i}),this._onRender.fire({start:e,end:i}),this._isNextRenderRedrawOnly=!0}}resize(e,i){this._rowCount=i,this._fireOnCanvasResize()}_handleOptionsChanged(){this._renderer.value&&(this.refreshRows(0,this._rowCount-1),this._fireOnCanvasResize())}_fireOnCanvasResize(){this._renderer.value&&(this._renderer.value.dimensions.css.canvas.width===this._canvasWidth&&this._renderer.value.dimensions.css.canvas.height===this._canvasHeight||this._onDimensionsChange.fire(this._renderer.value.dimensions))}hasRenderer(){return!!this._renderer.value}setRenderer(e){this._renderer.value=e,this._renderer.value&&(this._renderer.value.onRequestRedraw(i=>this.refreshRows(i.start,i.end,!0)),this._needsSelectionRefresh=!0,this._fullRefresh())}addRefreshCallback(e){return this._renderDebouncer.addRefreshCallback(e)}_fullRefresh(){this._isPaused?this._needsFullRefresh=!0:this.refreshRows(0,this._rowCount-1)}clearTextureAtlas(){this._renderer.value&&(this._renderer.value.clearTextureAtlas?.(),this._fullRefresh())}handleDevicePixelRatioChange(){this._charSizeService.measure(),this._renderer.value&&(this._renderer.value.handleDevicePixelRatioChange(),this.refreshRows(0,this._rowCount-1))}handleResize(e,i){this._renderer.value&&(this._isPaused?this._pausedResizeTask.set(()=>this._renderer.value?.handleResize(e,i)):this._renderer.value.handleResize(e,i),this._fullRefresh())}handleCharSizeChanged(){this._renderer.value?.handleCharSizeChanged()}handleBlur(){this._renderer.value?.handleBlur()}handleFocus(){this._renderer.value?.handleFocus()}handleSelectionChanged(e,i,r){this._selectionState.start=e,this._selectionState.end=i,this._selectionState.columnSelectMode=r,this._renderer.value?.handleSelectionChanged(e,i,r)}handleCursorMove(){this._renderer.value?.handleCursorMove()}clear(){this._renderer.value?.clear()}};Qt=M([S(2,H),S(3,nt),S(4,ge),S(5,Be),S(6,F),S(7,ae),S(8,Re)],Qt);var xs=class{constructor(t,e,i){this._coreBrowserService=t;this._coreService=e;this._onTimeout=i;this._start=0;this._end=0;this._isBuffering=!1}bufferRows(t,e){this._isBuffering?(this._start=Math.min(this._start,t),this._end=Math.max(this._end,e)):(this._start=t,this._end=e,this._isBuffering=!0),this._timeout===void 0&&(this._timeout=this._coreBrowserService.window.setTimeout(()=>{this._timeout=void 0,this._coreService.decPrivateModes.synchronizedOutput=!1,this._onTimeout()},1e3))}flush(){if(this._timeout!==void 0&&(this._coreBrowserService.window.clearTimeout(this._timeout),this._timeout=void 0),!this._isBuffering)return;let t={start:this._start,end:this._end};return this._isBuffering=!1,t}dispose(){this._timeout!==void 0&&(this._coreBrowserService.window.clearTimeout(this._timeout),this._timeout=void 0)}};function Jo(s,t,e,i){let r=e.buffer.x,n=e.buffer.y;if(!e.buffer.hasScrollback)return Ga(r,n,s,t,e,i)+sn(n,t,e,i)+$a(r,n,s,t,e,i);let o;if(n===t)return o=r>s?\"D\":\"C\",Fi(Math.abs(r-s),Ni(o,i));o=n>t?\"D\":\"C\";let l=Math.abs(n-t),a=za(n>t?s:r,e)+(l-1)*e.cols+1+Ka(n>t?r:s,e);return Fi(a,Ni(o,i))}function Ka(s,t){return s-1}function za(s,t){return t.cols-s}function Ga(s,t,e,i,r,n){return sn(t,i,r,n).length===0?\"\":Fi(el(s,t,s,t-gt(t,r),!1,r).length,Ni(\"D\",n))}function sn(s,t,e,i){let r=s-gt(s,e),n=t-gt(t,e),o=Math.abs(r-n)-Va(s,t,e);return Fi(o,Ni(Qo(s,t),i))}function $a(s,t,e,i,r,n){let o;sn(t,i,r,n).length>0?o=i-gt(i,r):o=t;let l=i,a=qa(s,t,e,i,r,n);return Fi(el(s,o,e,l,a===\"C\",r).length,Ni(a,n))}function Va(s,t,e){let i=0,r=s-gt(s,e),n=t-gt(t,e);for(let o=0;o<Math.abs(r-n);o++){let l=Qo(s,t)===\"A\"?-1:1;e.buffer.lines.get(r+l*o)?.isWrapped&&i++}return i}function gt(s,t){let e=0,i=t.buffer.lines.get(s),r=i?.isWrapped;for(;r&&s>=0&&s<t.rows;)e++,i=t.buffer.lines.get(--s),r=i?.isWrapped;return e}function qa(s,t,e,i,r,n){let o;return sn(e,i,r,n).length>0?o=i-gt(i,r):o=t,s<e&&o<=i||s>=e&&o<i?\"C\":\"D\"}function Qo(s,t){return s>t?\"A\":\"B\"}function el(s,t,e,i,r,n){let o=s,l=t,a=\"\";for(;(o!==e||l!==i)&&l>=0&&l<n.buffer.lines.length;)o+=r?1:-1,r&&o>n.cols-1?(a+=n.buffer.translateBufferLineToString(l,!1,s,o),o=0,s=0,l++):!r&&o<0&&(a+=n.buffer.translateBufferLineToString(l,!1,0,s+1),o=n.cols-1,s=o,l--);return a+n.buffer.translateBufferLineToString(l,!1,s,o)}function Ni(s,t){let e=t?\"O\":\"[\";return b.ESC+e+s}function Fi(s,t){s=Math.floor(s);let e=\"\";for(let i=0;i<s;i++)e+=t;return e}var on=class{constructor(t){this._bufferService=t;this.isSelectAllActive=!1;this.selectionStartLength=0}clearSelection(){this.selectionStart=void 0,this.selectionEnd=void 0,this.isSelectAllActive=!1,this.selectionStartLength=0}get finalSelectionStart(){return this.isSelectAllActive?[0,0]:!this.selectionEnd||!this.selectionStart?this.selectionStart:this.areSelectionValuesReversed()?this.selectionEnd:this.selectionStart}get finalSelectionEnd(){if(this.isSelectAllActive)return[this._bufferService.cols,this._bufferService.buffer.ybase+this._bufferService.rows-1];if(this.selectionStart){if(!this.selectionEnd||this.areSelectionValuesReversed()){let t=this.selectionStart[0]+this.selectionStartLength;return t>this._bufferService.cols?t%this._bufferService.cols===0?[this._bufferService.cols,this.selectionStart[1]+Math.floor(t/this._bufferService.cols)-1]:[t%this._bufferService.cols,this.selectionStart[1]+Math.floor(t/this._bufferService.cols)]:[t,this.selectionStart[1]]}if(this.selectionStartLength&&this.selectionEnd[1]===this.selectionStart[1]){let t=this.selectionStart[0]+this.selectionStartLength;return t>this._bufferService.cols?[t%this._bufferService.cols,this.selectionStart[1]+Math.floor(t/this._bufferService.cols)]:[Math.max(t,this.selectionEnd[0]),this.selectionEnd[1]]}return this.selectionEnd}}areSelectionValuesReversed(){let t=this.selectionStart,e=this.selectionEnd;return!t||!e?!1:t[1]>e[1]||t[1]===e[1]&&t[0]>e[0]}handleTrim(t){return this.selectionStart&&(this.selectionStart[1]-=t),this.selectionEnd&&(this.selectionEnd[1]-=t),this.selectionEnd&&this.selectionEnd[1]<0?(this.clearSelection(),!0):(this.selectionStart&&this.selectionStart[1]<0&&(this.selectionStart[1]=0),!1)}};function ws(s,t){if(s.start.y>s.end.y)throw new Error(`Buffer range end (${s.end.x}, ${s.end.y}) cannot be before start (${s.start.x}, ${s.start.y})`);return t*(s.end.y-s.start.y)+(s.end.x-s.start.x+1)}var Ds=50,Ya=15,ja=50,Xa=500,Za=\"\\xA0\",Ja=new RegExp(Za,\"g\");var ei=class extends D{constructor(e,i,r,n,o,l,a,u,h){super();this._element=e;this._screenElement=i;this._linkifier=r;this._bufferService=n;this._coreService=o;this._mouseService=l;this._optionsService=a;this._renderService=u;this._coreBrowserService=h;this._dragScrollAmount=0;this._enabled=!0;this._workCell=new q;this._mouseDownTimeStamp=0;this._oldHasSelection=!1;this._oldSelectionStart=void 0;this._oldSelectionEnd=void 0;this._onLinuxMouseSelection=this._register(new v);this.onLinuxMouseSelection=this._onLinuxMouseSelection.event;this._onRedrawRequest=this._register(new v);this.onRequestRedraw=this._onRedrawRequest.event;this._onSelectionChange=this._register(new v);this.onSelectionChange=this._onSelectionChange.event;this._onRequestScrollLines=this._register(new v);this.onRequestScrollLines=this._onRequestScrollLines.event;this._mouseMoveListener=c=>this._handleMouseMove(c),this._mouseUpListener=c=>this._handleMouseUp(c),this._coreService.onUserInput(()=>{this.hasSelection&&this.clearSelection()}),this._trimListener=this._bufferService.buffer.lines.onTrim(c=>this._handleTrim(c)),this._register(this._bufferService.buffers.onBufferActivate(c=>this._handleBufferActivate(c))),this.enable(),this._model=new on(this._bufferService),this._activeSelectionMode=0,this._register(C(()=>{this._removeMouseDownListeners()})),this._register(this._bufferService.onResize(c=>{c.rowsChanged&&this.clearSelection()}))}reset(){this.clearSelection()}disable(){this.clearSelection(),this._enabled=!1}enable(){this._enabled=!0}get selectionStart(){return this._model.finalSelectionStart}get selectionEnd(){return this._model.finalSelectionEnd}get hasSelection(){let e=this._model.finalSelectionStart,i=this._model.finalSelectionEnd;return!e||!i?!1:e[0]!==i[0]||e[1]!==i[1]}get selectionText(){let e=this._model.finalSelectionStart,i=this._model.finalSelectionEnd;if(!e||!i)return\"\";let r=this._bufferService.buffer,n=[];if(this._activeSelectionMode===3){if(e[0]===i[0])return\"\";let l=e[0]<i[0]?e[0]:i[0],a=e[0]<i[0]?i[0]:e[0];for(let u=e[1];u<=i[1];u++){let h=r.translateBufferLineToString(u,!0,l,a);n.push(h)}}else{let l=e[1]===i[1]?i[0]:void 0;n.push(r.translateBufferLineToString(e[1],!0,e[0],l));for(let a=e[1]+1;a<=i[1]-1;a++){let u=r.lines.get(a),h=r.translateBufferLineToString(a,!0);u?.isWrapped?n[n.length-1]+=h:n.push(h)}if(e[1]!==i[1]){let a=r.lines.get(i[1]),u=r.translateBufferLineToString(i[1],!0,0,i[0]);a&&a.isWrapped?n[n.length-1]+=u:n.push(u)}}return n.map(l=>l.replace(Ja,\" \")).join(Es?`\\r\n`:`\n`)}clearSelection(){this._model.clearSelection(),this._removeMouseDownListeners(),this.refresh(),this._onSelectionChange.fire()}refresh(e){this._refreshAnimationFrame||(this._refreshAnimationFrame=this._coreBrowserService.window.requestAnimationFrame(()=>this._refresh())),Bi&&e&&this.selectionText.length&&this._onLinuxMouseSelection.fire(this.selectionText)}_refresh(){this._refreshAnimationFrame=void 0,this._onRedrawRequest.fire({start:this._model.finalSelectionStart,end:this._model.finalSelectionEnd,columnSelectMode:this._activeSelectionMode===3})}_isClickInSelection(e){let i=this._getMouseBufferCoords(e),r=this._model.finalSelectionStart,n=this._model.finalSelectionEnd;return!r||!n||!i?!1:this._areCoordsInSelection(i,r,n)}isCellInSelection(e,i){let r=this._model.finalSelectionStart,n=this._model.finalSelectionEnd;return!r||!n?!1:this._areCoordsInSelection([e,i],r,n)}_areCoordsInSelection(e,i,r){return e[1]>i[1]&&e[1]<r[1]||i[1]===r[1]&&e[1]===i[1]&&e[0]>=i[0]&&e[0]<r[0]||i[1]<r[1]&&e[1]===r[1]&&e[0]<r[0]||i[1]<r[1]&&e[1]===i[1]&&e[0]>=i[0]}_selectWordAtCursor(e,i){let r=this._linkifier.currentLink?.link?.range;if(r)return this._model.selectionStart=[r.start.x-1,r.start.y-1],this._model.selectionStartLength=ws(r,this._bufferService.cols),this._model.selectionEnd=void 0,!0;let n=this._getMouseBufferCoords(e);return n?(this._selectWordAt(n,i),this._model.selectionEnd=void 0,!0):!1}selectAll(){this._model.isSelectAllActive=!0,this.refresh(),this._onSelectionChange.fire()}selectLines(e,i){this._model.clearSelection(),e=Math.max(e,0),i=Math.min(i,this._bufferService.buffer.lines.length-1),this._model.selectionStart=[0,e],this._model.selectionEnd=[this._bufferService.cols,i],this.refresh(),this._onSelectionChange.fire()}_handleTrim(e){this._model.handleTrim(e)&&this.refresh()}_getMouseBufferCoords(e){let i=this._mouseService.getCoords(e,this._screenElement,this._bufferService.cols,this._bufferService.rows,!0);if(i)return i[0]--,i[1]--,i[1]+=this._bufferService.buffer.ydisp,i}_getMouseEventScrollAmount(e){let i=Ci(this._coreBrowserService.window,e,this._screenElement)[1],r=this._renderService.dimensions.css.canvas.height;return i>=0&&i<=r?0:(i>r&&(i-=r),i=Math.min(Math.max(i,-Ds),Ds),i/=Ds,i/Math.abs(i)+Math.round(i*(Ya-1)))}shouldForceSelection(e){return Zt?e.altKey&&this._optionsService.rawOptions.macOptionClickForcesSelection:e.shiftKey}handleMouseDown(e){if(this._mouseDownTimeStamp=e.timeStamp,!(e.button===2&&this.hasSelection)&&e.button===0){if(!this._enabled){if(!this.shouldForceSelection(e))return;e.stopPropagation()}e.preventDefault(),this._dragScrollAmount=0,this._enabled&&e.shiftKey?this._handleIncrementalClick(e):e.detail===1?this._handleSingleClick(e):e.detail===2?this._handleDoubleClick(e):e.detail===3&&this._handleTripleClick(e),this._addMouseDownListeners(),this.refresh(!0)}}_addMouseDownListeners(){this._screenElement.ownerDocument&&(this._screenElement.ownerDocument.addEventListener(\"mousemove\",this._mouseMoveListener),this._screenElement.ownerDocument.addEventListener(\"mouseup\",this._mouseUpListener)),this._dragScrollIntervalTimer=this._coreBrowserService.window.setInterval(()=>this._dragScroll(),ja)}_removeMouseDownListeners(){this._screenElement.ownerDocument&&(this._screenElement.ownerDocument.removeEventListener(\"mousemove\",this._mouseMoveListener),this._screenElement.ownerDocument.removeEventListener(\"mouseup\",this._mouseUpListener)),this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer),this._dragScrollIntervalTimer=void 0}_handleIncrementalClick(e){this._model.selectionStart&&(this._model.selectionEnd=this._getMouseBufferCoords(e))}_handleSingleClick(e){if(this._model.selectionStartLength=0,this._model.isSelectAllActive=!1,this._activeSelectionMode=this.shouldColumnSelect(e)?3:0,this._model.selectionStart=this._getMouseBufferCoords(e),!this._model.selectionStart)return;this._model.selectionEnd=void 0;let i=this._bufferService.buffer.lines.get(this._model.selectionStart[1]);i&&i.length!==this._model.selectionStart[0]&&i.hasWidth(this._model.selectionStart[0])===0&&this._model.selectionStart[0]++}_handleDoubleClick(e){this._selectWordAtCursor(e,!0)&&(this._activeSelectionMode=1)}_handleTripleClick(e){let i=this._getMouseBufferCoords(e);i&&(this._activeSelectionMode=2,this._selectLineAt(i[1]))}shouldColumnSelect(e){return e.altKey&&!(Zt&&this._optionsService.rawOptions.macOptionClickForcesSelection)}_handleMouseMove(e){if(e.stopImmediatePropagation(),!this._model.selectionStart)return;let i=this._model.selectionEnd?[this._model.selectionEnd[0],this._model.selectionEnd[1]]:null;if(this._model.selectionEnd=this._getMouseBufferCoords(e),!this._model.selectionEnd){this.refresh(!0);return}this._activeSelectionMode===2?this._model.selectionEnd[1]<this._model.selectionStart[1]?this._model.selectionEnd[0]=0:this._model.selectionEnd[0]=this._bufferService.cols:this._activeSelectionMode===1&&this._selectToWordAt(this._model.selectionEnd),this._dragScrollAmount=this._getMouseEventScrollAmount(e),this._activeSelectionMode!==3&&(this._dragScrollAmount>0?this._model.selectionEnd[0]=this._bufferService.cols:this._dragScrollAmount<0&&(this._model.selectionEnd[0]=0));let r=this._bufferService.buffer;if(this._model.selectionEnd[1]<r.lines.length){let n=r.lines.get(this._model.selectionEnd[1]);n&&n.hasWidth(this._model.selectionEnd[0])===0&&this._model.selectionEnd[0]<this._bufferService.cols&&this._model.selectionEnd[0]++}(!i||i[0]!==this._model.selectionEnd[0]||i[1]!==this._model.selectionEnd[1])&&this.refresh(!0)}_dragScroll(){if(!(!this._model.selectionEnd||!this._model.selectionStart)&&this._dragScrollAmount){this._onRequestScrollLines.fire({amount:this._dragScrollAmount,suppressScrollEvent:!1});let e=this._bufferService.buffer;this._dragScrollAmount>0?(this._activeSelectionMode!==3&&(this._model.selectionEnd[0]=this._bufferService.cols),this._model.selectionEnd[1]=Math.min(e.ydisp+this._bufferService.rows,e.lines.length-1)):(this._activeSelectionMode!==3&&(this._model.selectionEnd[0]=0),this._model.selectionEnd[1]=e.ydisp),this.refresh()}}_handleMouseUp(e){let i=e.timeStamp-this._mouseDownTimeStamp;if(this._removeMouseDownListeners(),this.selectionText.length<=1&&i<Xa&&e.altKey&&this._optionsService.rawOptions.altClickMovesCursor){if(this._bufferService.buffer.ybase===this._bufferService.buffer.ydisp){let r=this._mouseService.getCoords(e,this._element,this._bufferService.cols,this._bufferService.rows,!1);if(r&&r[0]!==void 0&&r[1]!==void 0){let n=Jo(r[0]-1,r[1]-1,this._bufferService,this._coreService.decPrivateModes.applicationCursorKeys);this._coreService.triggerDataEvent(n,!0)}}}else this._fireEventIfSelectionChanged()}_fireEventIfSelectionChanged(){let e=this._model.finalSelectionStart,i=this._model.finalSelectionEnd,r=!!e&&!!i&&(e[0]!==i[0]||e[1]!==i[1]);if(!r){this._oldHasSelection&&this._fireOnSelectionChange(e,i,r);return}!e||!i||(!this._oldSelectionStart||!this._oldSelectionEnd||e[0]!==this._oldSelectionStart[0]||e[1]!==this._oldSelectionStart[1]||i[0]!==this._oldSelectionEnd[0]||i[1]!==this._oldSelectionEnd[1])&&this._fireOnSelectionChange(e,i,r)}_fireOnSelectionChange(e,i,r){this._oldSelectionStart=e,this._oldSelectionEnd=i,this._oldHasSelection=r,this._onSelectionChange.fire()}_handleBufferActivate(e){this.clearSelection(),this._trimListener.dispose(),this._trimListener=e.activeBuffer.lines.onTrim(i=>this._handleTrim(i))}_convertViewportColToCharacterIndex(e,i){let r=i;for(let n=0;i>=n;n++){let o=e.loadCell(n,this._workCell).getChars().length;this._workCell.getWidth()===0?r--:o>1&&i!==n&&(r+=o-1)}return r}setSelection(e,i,r){this._model.clearSelection(),this._removeMouseDownListeners(),this._model.selectionStart=[e,i],this._model.selectionStartLength=r,this.refresh(),this._fireEventIfSelectionChanged()}rightClickSelect(e){this._isClickInSelection(e)||(this._selectWordAtCursor(e,!1)&&this.refresh(!0),this._fireEventIfSelectionChanged())}_getWordAt(e,i,r=!0,n=!0){if(e[0]>=this._bufferService.cols)return;let o=this._bufferService.buffer,l=o.lines.get(e[1]);if(!l)return;let a=o.translateBufferLineToString(e[1],!1),u=this._convertViewportColToCharacterIndex(l,e[0]),h=u,c=e[0]-u,d=0,_=0,p=0,m=0;if(a.charAt(u)===\" \"){for(;u>0&&a.charAt(u-1)===\" \";)u--;for(;h<a.length&&a.charAt(h+1)===\" \";)h++}else{let R=e[0],O=e[0];l.getWidth(R)===0&&(d++,R--),l.getWidth(O)===2&&(_++,O++);let I=l.getString(O).length;for(I>1&&(m+=I-1,h+=I-1);R>0&&u>0&&!this._isCharWordSeparator(l.loadCell(R-1,this._workCell));){l.loadCell(R-1,this._workCell);let k=this._workCell.getChars().length;this._workCell.getWidth()===0?(d++,R--):k>1&&(p+=k-1,u-=k-1),u--,R--}for(;O<l.length&&h+1<a.length&&!this._isCharWordSeparator(l.loadCell(O+1,this._workCell));){l.loadCell(O+1,this._workCell);let k=this._workCell.getChars().length;this._workCell.getWidth()===2?(_++,O++):k>1&&(m+=k-1,h+=k-1),h++,O++}}h++;let f=u+c-d+p,A=Math.min(this._bufferService.cols,h-u+d+_-p-m);if(!(!i&&a.slice(u,h).trim()===\"\")){if(r&&f===0&&l.getCodePoint(0)!==32){let R=o.lines.get(e[1]-1);if(R&&l.isWrapped&&R.getCodePoint(this._bufferService.cols-1)!==32){let O=this._getWordAt([this._bufferService.cols-1,e[1]-1],!1,!0,!1);if(O){let I=this._bufferService.cols-O.start;f-=I,A+=I}}}if(n&&f+A===this._bufferService.cols&&l.getCodePoint(this._bufferService.cols-1)!==32){let R=o.lines.get(e[1]+1);if(R?.isWrapped&&R.getCodePoint(0)!==32){let O=this._getWordAt([0,e[1]+1],!1,!1,!0);O&&(A+=O.length)}}return{start:f,length:A}}}_selectWordAt(e,i){let r=this._getWordAt(e,i);if(r){for(;r.start<0;)r.start+=this._bufferService.cols,e[1]--;this._model.selectionStart=[r.start,e[1]],this._model.selectionStartLength=r.length}}_selectToWordAt(e){let i=this._getWordAt(e,!0);if(i){let r=e[1];for(;i.start<0;)i.start+=this._bufferService.cols,r--;if(!this._model.areSelectionValuesReversed())for(;i.start+i.length>this._bufferService.cols;)i.length-=this._bufferService.cols,r++;this._model.selectionEnd=[this._model.areSelectionValuesReversed()?i.start:i.start+i.length,r]}}_isCharWordSeparator(e){return e.getWidth()===0?!1:this._optionsService.rawOptions.wordSeparator.indexOf(e.getChars())>=0}_selectLineAt(e){let i=this._bufferService.buffer.getWrappedRangeForLine(e),r={start:{x:0,y:i.first},end:{x:this._bufferService.cols-1,y:i.last}};this._model.selectionStart=[0,i.first],this._model.selectionEnd=void 0,this._model.selectionStartLength=ws(r,this._bufferService.cols)}};ei=M([S(3,F),S(4,ge),S(5,Dt),S(6,H),S(7,ce),S(8,ae)],ei);var Hi=class{constructor(){this._data={}}set(t,e,i){this._data[t]||(this._data[t]={}),this._data[t][e]=i}get(t,e){return this._data[t]?this._data[t][e]:void 0}clear(){this._data={}}};var Wi=class{constructor(){this._color=new Hi;this._css=new Hi}setCss(t,e,i){this._css.set(t,e,i)}getCss(t,e){return this._css.get(t,e)}setColor(t,e,i){this._color.set(t,e,i)}getColor(t,e){return this._color.get(t,e)}clear(){this._color.clear(),this._css.clear()}};var re=Object.freeze((()=>{let s=[z.toColor(\"#2e3436\"),z.toColor(\"#cc0000\"),z.toColor(\"#4e9a06\"),z.toColor(\"#c4a000\"),z.toColor(\"#3465a4\"),z.toColor(\"#75507b\"),z.toColor(\"#06989a\"),z.toColor(\"#d3d7cf\"),z.toColor(\"#555753\"),z.toColor(\"#ef2929\"),z.toColor(\"#8ae234\"),z.toColor(\"#fce94f\"),z.toColor(\"#729fcf\"),z.toColor(\"#ad7fa8\"),z.toColor(\"#34e2e2\"),z.toColor(\"#eeeeec\")],t=[0,95,135,175,215,255];for(let e=0;e<216;e++){let i=t[e/36%6|0],r=t[e/6%6|0],n=t[e%6];s.push({css:j.toCss(i,r,n),rgba:j.toRgba(i,r,n)})}for(let e=0;e<24;e++){let i=8+e*10;s.push({css:j.toCss(i,i,i),rgba:j.toRgba(i,i,i)})}return s})());var St=z.toColor(\"#ffffff\"),Ki=z.toColor(\"#000000\"),tl=z.toColor(\"#ffffff\"),il=Ki,Ui={css:\"rgba(255, 255, 255, 0.3)\",rgba:4294967117},Qa=St,ti=class extends D{constructor(e){super();this._optionsService=e;this._contrastCache=new Wi;this._halfContrastCache=new Wi;this._onChangeColors=this._register(new v);this.onChangeColors=this._onChangeColors.event;this._colors={foreground:St,background:Ki,cursor:tl,cursorAccent:il,selectionForeground:void 0,selectionBackgroundTransparent:Ui,selectionBackgroundOpaque:U.blend(Ki,Ui),selectionInactiveBackgroundTransparent:Ui,selectionInactiveBackgroundOpaque:U.blend(Ki,Ui),scrollbarSliderBackground:U.opacity(St,.2),scrollbarSliderHoverBackground:U.opacity(St,.4),scrollbarSliderActiveBackground:U.opacity(St,.5),overviewRulerBorder:St,ansi:re.slice(),contrastCache:this._contrastCache,halfContrastCache:this._halfContrastCache},this._updateRestoreColors(),this._setTheme(this._optionsService.rawOptions.theme),this._register(this._optionsService.onSpecificOptionChange(\"minimumContrastRatio\",()=>this._contrastCache.clear())),this._register(this._optionsService.onSpecificOptionChange(\"theme\",()=>this._setTheme(this._optionsService.rawOptions.theme)))}get colors(){return this._colors}_setTheme(e={}){let i=this._colors;if(i.foreground=K(e.foreground,St),i.background=K(e.background,Ki),i.cursor=U.blend(i.background,K(e.cursor,tl)),i.cursorAccent=U.blend(i.background,K(e.cursorAccent,il)),i.selectionBackgroundTransparent=K(e.selectionBackground,Ui),i.selectionBackgroundOpaque=U.blend(i.background,i.selectionBackgroundTransparent),i.selectionInactiveBackgroundTransparent=K(e.selectionInactiveBackground,i.selectionBackgroundTransparent),i.selectionInactiveBackgroundOpaque=U.blend(i.background,i.selectionInactiveBackgroundTransparent),i.selectionForeground=e.selectionForeground?K(e.selectionForeground,ps):void 0,i.selectionForeground===ps&&(i.selectionForeground=void 0),U.isOpaque(i.selectionBackgroundTransparent)&&(i.selectionBackgroundTransparent=U.opacity(i.selectionBackgroundTransparent,.3)),U.isOpaque(i.selectionInactiveBackgroundTransparent)&&(i.selectionInactiveBackgroundTransparent=U.opacity(i.selectionInactiveBackgroundTransparent,.3)),i.scrollbarSliderBackground=K(e.scrollbarSliderBackground,U.opacity(i.foreground,.2)),i.scrollbarSliderHoverBackground=K(e.scrollbarSliderHoverBackground,U.opacity(i.foreground,.4)),i.scrollbarSliderActiveBackground=K(e.scrollbarSliderActiveBackground,U.opacity(i.foreground,.5)),i.overviewRulerBorder=K(e.overviewRulerBorder,Qa),i.ansi=re.slice(),i.ansi[0]=K(e.black,re[0]),i.ansi[1]=K(e.red,re[1]),i.ansi[2]=K(e.green,re[2]),i.ansi[3]=K(e.yellow,re[3]),i.ansi[4]=K(e.blue,re[4]),i.ansi[5]=K(e.magenta,re[5]),i.ansi[6]=K(e.cyan,re[6]),i.ansi[7]=K(e.white,re[7]),i.ansi[8]=K(e.brightBlack,re[8]),i.ansi[9]=K(e.brightRed,re[9]),i.ansi[10]=K(e.brightGreen,re[10]),i.ansi[11]=K(e.brightYellow,re[11]),i.ansi[12]=K(e.brightBlue,re[12]),i.ansi[13]=K(e.brightMagenta,re[13]),i.ansi[14]=K(e.brightCyan,re[14]),i.ansi[15]=K(e.brightWhite,re[15]),e.extendedAnsi){let r=Math.min(i.ansi.length-16,e.extendedAnsi.length);for(let n=0;n<r;n++)i.ansi[n+16]=K(e.extendedAnsi[n],re[n+16])}this._contrastCache.clear(),this._halfContrastCache.clear(),this._updateRestoreColors(),this._onChangeColors.fire(this.colors)}restoreColor(e){this._restoreColor(e),this._onChangeColors.fire(this.colors)}_restoreColor(e){if(e===void 0){for(let i=0;i<this._restoreColors.ansi.length;++i)this._colors.ansi[i]=this._restoreColors.ansi[i];return}switch(e){case 256:this._colors.foreground=this._restoreColors.foreground;break;case 257:this._colors.background=this._restoreColors.background;break;case 258:this._colors.cursor=this._restoreColors.cursor;break;default:this._colors.ansi[e]=this._restoreColors.ansi[e]}}modifyColors(e){e(this._colors),this._onChangeColors.fire(this.colors)}_updateRestoreColors(){this._restoreColors={foreground:this._colors.foreground,background:this._colors.background,cursor:this._colors.cursor,ansi:this._colors.ansi.slice()}}};ti=M([S(0,H)],ti);function K(s,t){if(s!==void 0)try{return z.toColor(s)}catch{}return t}var Rs=class{constructor(...t){this._entries=new Map;for(let[e,i]of t)this.set(e,i)}set(t,e){let i=this._entries.get(t);return this._entries.set(t,e),i}forEach(t){for(let[e,i]of this._entries.entries())t(e,i)}has(t){return this._entries.has(t)}get(t){return this._entries.get(t)}},ln=class{constructor(){this._services=new Rs;this._services.set(xt,this)}setService(t,e){this._services.set(t,e)}getService(t){return this._services.get(t)}createInstance(t,...e){let i=Xs(t).sort((o,l)=>o.index-l.index),r=[];for(let o of i){let l=this._services.get(o.id);if(!l)throw new Error(`[createInstance] ${t.name} depends on UNKNOWN service ${o.id._id}.`);r.push(l)}let n=i.length>0?i[0].index:e.length;if(e.length!==n)throw new Error(`[createInstance] First service dependency of ${t.name} at position ${n+1} conflicts with ${e.length} static arguments`);return new t(...e,...r)}};var ec={trace:0,debug:1,info:2,warn:3,error:4,off:5},tc=\"xterm.js: \",ii=class extends D{constructor(e){super();this._optionsService=e;this._logLevel=5;this._updateLogLevel(),this._register(this._optionsService.onSpecificOptionChange(\"logLevel\",()=>this._updateLogLevel())),ic=this}get logLevel(){return this._logLevel}_updateLogLevel(){this._logLevel=ec[this._optionsService.rawOptions.logLevel]}_evalLazyOptionalParams(e){for(let i=0;i<e.length;i++)typeof e[i]==\"function\"&&(e[i]=e[i]())}_log(e,i,r){this._evalLazyOptionalParams(r),e.call(console,(this._optionsService.options.logger?\"\":tc)+i,...r)}trace(e,...i){this._logLevel<=0&&this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger)??console.log,e,i)}debug(e,...i){this._logLevel<=1&&this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger)??console.log,e,i)}info(e,...i){this._logLevel<=2&&this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger)??console.info,e,i)}warn(e,...i){this._logLevel<=3&&this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger)??console.warn,e,i)}error(e,...i){this._logLevel<=4&&this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger)??console.error,e,i)}};ii=M([S(0,H)],ii);var ic;var zi=class extends D{constructor(e){super();this._maxLength=e;this.onDeleteEmitter=this._register(new v);this.onDelete=this.onDeleteEmitter.event;this.onInsertEmitter=this._register(new v);this.onInsert=this.onInsertEmitter.event;this.onTrimEmitter=this._register(new v);this.onTrim=this.onTrimEmitter.event;this._array=new Array(this._maxLength),this._startIndex=0,this._length=0}get maxLength(){return this._maxLength}set maxLength(e){if(this._maxLength===e)return;let i=new Array(e);for(let r=0;r<Math.min(e,this.length);r++)i[r]=this._array[this._getCyclicIndex(r)];this._array=i,this._maxLength=e,this._startIndex=0}get length(){return this._length}set length(e){if(e>this._length)for(let i=this._length;i<e;i++)this._array[i]=void 0;this._length=e}get(e){return this._array[this._getCyclicIndex(e)]}set(e,i){this._array[this._getCyclicIndex(e)]=i}push(e){this._array[this._getCyclicIndex(this._length)]=e,this._length===this._maxLength?(this._startIndex=++this._startIndex%this._maxLength,this.onTrimEmitter.fire(1)):this._length++}recycle(){if(this._length!==this._maxLength)throw new Error(\"Can only recycle when the buffer is full\");return this._startIndex=++this._startIndex%this._maxLength,this.onTrimEmitter.fire(1),this._array[this._getCyclicIndex(this._length-1)]}get isFull(){return this._length===this._maxLength}pop(){return this._array[this._getCyclicIndex(this._length---1)]}splice(e,i,...r){if(i){for(let n=e;n<this._length-i;n++)this._array[this._getCyclicIndex(n)]=this._array[this._getCyclicIndex(n+i)];this._length-=i,this.onDeleteEmitter.fire({index:e,amount:i})}for(let n=this._length-1;n>=e;n--)this._array[this._getCyclicIndex(n+r.length)]=this._array[this._getCyclicIndex(n)];for(let n=0;n<r.length;n++)this._array[this._getCyclicIndex(e+n)]=r[n];if(r.length&&this.onInsertEmitter.fire({index:e,amount:r.length}),this._length+r.length>this._maxLength){let n=this._length+r.length-this._maxLength;this._startIndex+=n,this._length=this._maxLength,this.onTrimEmitter.fire(n)}else this._length+=r.length}trimStart(e){e>this._length&&(e=this._length),this._startIndex+=e,this._length-=e,this.onTrimEmitter.fire(e)}shiftElements(e,i,r){if(!(i<=0)){if(e<0||e>=this._length)throw new Error(\"start argument out of range\");if(e+r<0)throw new Error(\"Cannot shift elements in list beyond index 0\");if(r>0){for(let o=i-1;o>=0;o--)this.set(e+o+r,this.get(e+o));let n=e+i+r-this._length;if(n>0)for(this._length+=n;this._length>this._maxLength;)this._length--,this._startIndex++,this.onTrimEmitter.fire(1)}else for(let n=0;n<i;n++)this.set(e+n+r,this.get(e+n))}}_getCyclicIndex(e){return(this._startIndex+e)%this._maxLength}};var B=3;var X=Object.freeze(new De),an=0,Ls=2,Ze=class s{constructor(t,e,i=!1){this.isWrapped=i;this._combined={};this._extendedAttrs={};this._data=new Uint32Array(t*B);let r=e||q.fromCharData([0,ir,1,0]);for(let n=0;n<t;++n)this.setCell(n,r);this.length=t}get(t){let e=this._data[t*B+0],i=e&2097151;return[this._data[t*B+1],e&2097152?this._combined[t]:i?Ce(i):\"\",e>>22,e&2097152?this._combined[t].charCodeAt(this._combined[t].length-1):i]}set(t,e){this._data[t*B+1]=e[0],e[1].length>1?(this._combined[t]=e[1],this._data[t*B+0]=t|2097152|e[2]<<22):this._data[t*B+0]=e[1].charCodeAt(0)|e[2]<<22}getWidth(t){return this._data[t*B+0]>>22}hasWidth(t){return this._data[t*B+0]&12582912}getFg(t){return this._data[t*B+1]}getBg(t){return this._data[t*B+2]}hasContent(t){return this._data[t*B+0]&4194303}getCodePoint(t){let e=this._data[t*B+0];return e&2097152?this._combined[t].charCodeAt(this._combined[t].length-1):e&2097151}isCombined(t){return this._data[t*B+0]&2097152}getString(t){let e=this._data[t*B+0];return e&2097152?this._combined[t]:e&2097151?Ce(e&2097151):\"\"}isProtected(t){return this._data[t*B+2]&536870912}loadCell(t,e){return an=t*B,e.content=this._data[an+0],e.fg=this._data[an+1],e.bg=this._data[an+2],e.content&2097152&&(e.combinedData=this._combined[t]),e.bg&268435456&&(e.extended=this._extendedAttrs[t]),e}setCell(t,e){e.content&2097152&&(this._combined[t]=e.combinedData),e.bg&268435456&&(this._extendedAttrs[t]=e.extended),this._data[t*B+0]=e.content,this._data[t*B+1]=e.fg,this._data[t*B+2]=e.bg}setCellFromCodepoint(t,e,i,r){r.bg&268435456&&(this._extendedAttrs[t]=r.extended),this._data[t*B+0]=e|i<<22,this._data[t*B+1]=r.fg,this._data[t*B+2]=r.bg}addCodepointToCell(t,e,i){let r=this._data[t*B+0];r&2097152?this._combined[t]+=Ce(e):r&2097151?(this._combined[t]=Ce(r&2097151)+Ce(e),r&=-2097152,r|=2097152):r=e|1<<22,i&&(r&=-12582913,r|=i<<22),this._data[t*B+0]=r}insertCells(t,e,i){if(t%=this.length,t&&this.getWidth(t-1)===2&&this.setCellFromCodepoint(t-1,0,1,i),e<this.length-t){let r=new q;for(let n=this.length-t-e-1;n>=0;--n)this.setCell(t+e+n,this.loadCell(t+n,r));for(let n=0;n<e;++n)this.setCell(t+n,i)}else for(let r=t;r<this.length;++r)this.setCell(r,i);this.getWidth(this.length-1)===2&&this.setCellFromCodepoint(this.length-1,0,1,i)}deleteCells(t,e,i){if(t%=this.length,e<this.length-t){let r=new q;for(let n=0;n<this.length-t-e;++n)this.setCell(t+n,this.loadCell(t+e+n,r));for(let n=this.length-e;n<this.length;++n)this.setCell(n,i)}else for(let r=t;r<this.length;++r)this.setCell(r,i);t&&this.getWidth(t-1)===2&&this.setCellFromCodepoint(t-1,0,1,i),this.getWidth(t)===0&&!this.hasContent(t)&&this.setCellFromCodepoint(t,0,1,i)}replaceCells(t,e,i,r=!1){if(r){for(t&&this.getWidth(t-1)===2&&!this.isProtected(t-1)&&this.setCellFromCodepoint(t-1,0,1,i),e<this.length&&this.getWidth(e-1)===2&&!this.isProtected(e)&&this.setCellFromCodepoint(e,0,1,i);t<e&&t<this.length;)this.isProtected(t)||this.setCell(t,i),t++;return}for(t&&this.getWidth(t-1)===2&&this.setCellFromCodepoint(t-1,0,1,i),e<this.length&&this.getWidth(e-1)===2&&this.setCellFromCodepoint(e,0,1,i);t<e&&t<this.length;)this.setCell(t++,i)}resize(t,e){if(t===this.length)return this._data.length*4*Ls<this._data.buffer.byteLength;let i=t*B;if(t>this.length){if(this._data.buffer.byteLength>=i*4)this._data=new Uint32Array(this._data.buffer,0,i);else{let r=new Uint32Array(i);r.set(this._data),this._data=r}for(let r=this.length;r<t;++r)this.setCell(r,e)}else{this._data=this._data.subarray(0,i);let r=Object.keys(this._combined);for(let o=0;o<r.length;o++){let l=parseInt(r[o],10);l>=t&&delete this._combined[l]}let n=Object.keys(this._extendedAttrs);for(let o=0;o<n.length;o++){let l=parseInt(n[o],10);l>=t&&delete this._extendedAttrs[l]}}return this.length=t,i*4*Ls<this._data.buffer.byteLength}cleanupMemory(){if(this._data.length*4*Ls<this._data.buffer.byteLength){let t=new Uint32Array(this._data.length);return t.set(this._data),this._data=t,1}return 0}fill(t,e=!1){if(e){for(let i=0;i<this.length;++i)this.isProtected(i)||this.setCell(i,t);return}this._combined={},this._extendedAttrs={};for(let i=0;i<this.length;++i)this.setCell(i,t)}copyFrom(t){this.length!==t.length?this._data=new Uint32Array(t._data):this._data.set(t._data),this.length=t.length,this._combined={};for(let e in t._combined)this._combined[e]=t._combined[e];this._extendedAttrs={};for(let e in t._extendedAttrs)this._extendedAttrs[e]=t._extendedAttrs[e];this.isWrapped=t.isWrapped}clone(){let t=new s(0);t._data=new Uint32Array(this._data),t.length=this.length;for(let e in this._combined)t._combined[e]=this._combined[e];for(let e in this._extendedAttrs)t._extendedAttrs[e]=this._extendedAttrs[e];return t.isWrapped=this.isWrapped,t}getTrimmedLength(){for(let t=this.length-1;t>=0;--t)if(this._data[t*B+0]&4194303)return t+(this._data[t*B+0]>>22);return 0}getNoBgTrimmedLength(){for(let t=this.length-1;t>=0;--t)if(this._data[t*B+0]&4194303||this._data[t*B+2]&50331648)return t+(this._data[t*B+0]>>22);return 0}copyCellsFrom(t,e,i,r,n){let o=t._data;if(n)for(let a=r-1;a>=0;a--){for(let u=0;u<B;u++)this._data[(i+a)*B+u]=o[(e+a)*B+u];o[(e+a)*B+2]&268435456&&(this._extendedAttrs[i+a]=t._extendedAttrs[e+a])}else for(let a=0;a<r;a++){for(let u=0;u<B;u++)this._data[(i+a)*B+u]=o[(e+a)*B+u];o[(e+a)*B+2]&268435456&&(this._extendedAttrs[i+a]=t._extendedAttrs[e+a])}let l=Object.keys(t._combined);for(let a=0;a<l.length;a++){let u=parseInt(l[a],10);u>=e&&(this._combined[u-e+i]=t._combined[u])}}translateToString(t,e,i,r){e=e??0,i=i??this.length,t&&(i=Math.min(i,this.getTrimmedLength())),r&&(r.length=0);let n=\"\";for(;e<i;){let o=this._data[e*B+0],l=o&2097151,a=o&2097152?this._combined[e]:l?Ce(l):we;if(n+=a,r)for(let u=0;u<a.length;++u)r.push(e);e+=o>>22||1}return r&&r.push(e),n}};function sl(s,t,e,i,r,n){let o=[];for(let l=0;l<s.length-1;l++){let a=l,u=s.get(++a);if(!u.isWrapped)continue;let h=[s.get(l)];for(;a<s.length&&u.isWrapped;)h.push(u),u=s.get(++a);if(!n&&i>=l&&i<a){l+=h.length-1;continue}let c=0,d=ri(h,c,t),_=1,p=0;for(;_<h.length;){let f=ri(h,_,t),A=f-p,R=e-d,O=Math.min(A,R);h[c].copyCellsFrom(h[_],p,d,O,!1),d+=O,d===e&&(c++,d=0),p+=O,p===f&&(_++,p=0),d===0&&c!==0&&h[c-1].getWidth(e-1)===2&&(h[c].copyCellsFrom(h[c-1],e-1,d++,1,!1),h[c-1].setCell(e-1,r))}h[c].replaceCells(d,e,r);let m=0;for(let f=h.length-1;f>0&&(f>c||h[f].getTrimmedLength()===0);f--)m++;m>0&&(o.push(l+h.length-m),o.push(m)),l+=h.length-1}return o}function ol(s,t){let e=[],i=0,r=t[i],n=0;for(let o=0;o<s.length;o++)if(r===o){let l=t[++i];s.onDeleteEmitter.fire({index:o-n,amount:l}),o+=l-1,n+=l,r=t[++i]}else e.push(o);return{layout:e,countRemoved:n}}function ll(s,t){let e=[];for(let i=0;i<t.length;i++)e.push(s.get(t[i]));for(let i=0;i<e.length;i++)s.set(i,e[i]);s.length=t.length}function al(s,t,e){let i=[],r=s.map((a,u)=>ri(s,u,t)).reduce((a,u)=>a+u),n=0,o=0,l=0;for(;l<r;){if(r-l<e){i.push(r-l);break}n+=e;let a=ri(s,o,t);n>a&&(n-=a,o++);let u=s[o].getWidth(n-1)===2;u&&n--;let h=u?e-1:e;i.push(h),l+=h}return i}function ri(s,t,e){if(t===s.length-1)return s[t].getTrimmedLength();let i=!s[t].hasContent(e-1)&&s[t].getWidth(e-1)===1,r=s[t+1].getWidth(0)===2;return i&&r?e-1:e}var un=class un{constructor(t){this.line=t;this.isDisposed=!1;this._disposables=[];this._id=un._nextId++;this._onDispose=this.register(new v);this.onDispose=this._onDispose.event}get id(){return this._id}dispose(){this.isDisposed||(this.isDisposed=!0,this.line=-1,this._onDispose.fire(),Ne(this._disposables),this._disposables.length=0)}register(t){return this._disposables.push(t),t}};un._nextId=1;var cn=un;var ne={},Je=ne.B;ne[0]={\"`\":\"\\u25C6\",a:\"\\u2592\",b:\"\\u2409\",c:\"\\u240C\",d:\"\\u240D\",e:\"\\u240A\",f:\"\\xB0\",g:\"\\xB1\",h:\"\\u2424\",i:\"\\u240B\",j:\"\\u2518\",k:\"\\u2510\",l:\"\\u250C\",m:\"\\u2514\",n:\"\\u253C\",o:\"\\u23BA\",p:\"\\u23BB\",q:\"\\u2500\",r:\"\\u23BC\",s:\"\\u23BD\",t:\"\\u251C\",u:\"\\u2524\",v:\"\\u2534\",w:\"\\u252C\",x:\"\\u2502\",y:\"\\u2264\",z:\"\\u2265\",\"{\":\"\\u03C0\",\"|\":\"\\u2260\",\"}\":\"\\xA3\",\"~\":\"\\xB7\"};ne.A={\"#\":\"\\xA3\"};ne.B=void 0;ne[4]={\"#\":\"\\xA3\",\"@\":\"\\xBE\",\"[\":\"ij\",\"\\\\\":\"\\xBD\",\"]\":\"|\",\"{\":\"\\xA8\",\"|\":\"f\",\"}\":\"\\xBC\",\"~\":\"\\xB4\"};ne.C=ne[5]={\"[\":\"\\xC4\",\"\\\\\":\"\\xD6\",\"]\":\"\\xC5\",\"^\":\"\\xDC\",\"`\":\"\\xE9\",\"{\":\"\\xE4\",\"|\":\"\\xF6\",\"}\":\"\\xE5\",\"~\":\"\\xFC\"};ne.R={\"#\":\"\\xA3\",\"@\":\"\\xE0\",\"[\":\"\\xB0\",\"\\\\\":\"\\xE7\",\"]\":\"\\xA7\",\"{\":\"\\xE9\",\"|\":\"\\xF9\",\"}\":\"\\xE8\",\"~\":\"\\xA8\"};ne.Q={\"@\":\"\\xE0\",\"[\":\"\\xE2\",\"\\\\\":\"\\xE7\",\"]\":\"\\xEA\",\"^\":\"\\xEE\",\"`\":\"\\xF4\",\"{\":\"\\xE9\",\"|\":\"\\xF9\",\"}\":\"\\xE8\",\"~\":\"\\xFB\"};ne.K={\"@\":\"\\xA7\",\"[\":\"\\xC4\",\"\\\\\":\"\\xD6\",\"]\":\"\\xDC\",\"{\":\"\\xE4\",\"|\":\"\\xF6\",\"}\":\"\\xFC\",\"~\":\"\\xDF\"};ne.Y={\"#\":\"\\xA3\",\"@\":\"\\xA7\",\"[\":\"\\xB0\",\"\\\\\":\"\\xE7\",\"]\":\"\\xE9\",\"`\":\"\\xF9\",\"{\":\"\\xE0\",\"|\":\"\\xF2\",\"}\":\"\\xE8\",\"~\":\"\\xEC\"};ne.E=ne[6]={\"@\":\"\\xC4\",\"[\":\"\\xC6\",\"\\\\\":\"\\xD8\",\"]\":\"\\xC5\",\"^\":\"\\xDC\",\"`\":\"\\xE4\",\"{\":\"\\xE6\",\"|\":\"\\xF8\",\"}\":\"\\xE5\",\"~\":\"\\xFC\"};ne.Z={\"#\":\"\\xA3\",\"@\":\"\\xA7\",\"[\":\"\\xA1\",\"\\\\\":\"\\xD1\",\"]\":\"\\xBF\",\"{\":\"\\xB0\",\"|\":\"\\xF1\",\"}\":\"\\xE7\"};ne.H=ne[7]={\"@\":\"\\xC9\",\"[\":\"\\xC4\",\"\\\\\":\"\\xD6\",\"]\":\"\\xC5\",\"^\":\"\\xDC\",\"`\":\"\\xE9\",\"{\":\"\\xE4\",\"|\":\"\\xF6\",\"}\":\"\\xE5\",\"~\":\"\\xFC\"};ne[\"=\"]={\"#\":\"\\xF9\",\"@\":\"\\xE0\",\"[\":\"\\xE9\",\"\\\\\":\"\\xE7\",\"]\":\"\\xEA\",\"^\":\"\\xEE\",_:\"\\xE8\",\"`\":\"\\xF4\",\"{\":\"\\xE4\",\"|\":\"\\xF6\",\"}\":\"\\xFC\",\"~\":\"\\xFB\"};var cl=4294967295,$i=class{constructor(t,e,i){this._hasScrollback=t;this._optionsService=e;this._bufferService=i;this.ydisp=0;this.ybase=0;this.y=0;this.x=0;this.tabs={};this.savedY=0;this.savedX=0;this.savedCurAttrData=X.clone();this.savedCharset=Je;this.markers=[];this._nullCell=q.fromCharData([0,ir,1,0]);this._whitespaceCell=q.fromCharData([0,we,1,32]);this._isClearing=!1;this._memoryCleanupQueue=new Jt;this._memoryCleanupPosition=0;this._cols=this._bufferService.cols,this._rows=this._bufferService.rows,this.lines=new zi(this._getCorrectBufferLength(this._rows)),this.scrollTop=0,this.scrollBottom=this._rows-1,this.setupTabStops()}getNullCell(t){return t?(this._nullCell.fg=t.fg,this._nullCell.bg=t.bg,this._nullCell.extended=t.extended):(this._nullCell.fg=0,this._nullCell.bg=0,this._nullCell.extended=new rt),this._nullCell}getWhitespaceCell(t){return t?(this._whitespaceCell.fg=t.fg,this._whitespaceCell.bg=t.bg,this._whitespaceCell.extended=t.extended):(this._whitespaceCell.fg=0,this._whitespaceCell.bg=0,this._whitespaceCell.extended=new rt),this._whitespaceCell}getBlankLine(t,e){return new Ze(this._bufferService.cols,this.getNullCell(t),e)}get hasScrollback(){return this._hasScrollback&&this.lines.maxLength>this._rows}get isCursorInViewport(){let e=this.ybase+this.y-this.ydisp;return e>=0&&e<this._rows}_getCorrectBufferLength(t){if(!this._hasScrollback)return t;let e=t+this._optionsService.rawOptions.scrollback;return e>cl?cl:e}fillViewportRows(t){if(this.lines.length===0){t===void 0&&(t=X);let e=this._rows;for(;e--;)this.lines.push(this.getBlankLine(t))}}clear(){this.ydisp=0,this.ybase=0,this.y=0,this.x=0,this.lines=new zi(this._getCorrectBufferLength(this._rows)),this.scrollTop=0,this.scrollBottom=this._rows-1,this.setupTabStops()}resize(t,e){let i=this.getNullCell(X),r=0,n=this._getCorrectBufferLength(e);if(n>this.lines.maxLength&&(this.lines.maxLength=n),this.lines.length>0){if(this._cols<t)for(let l=0;l<this.lines.length;l++)r+=+this.lines.get(l).resize(t,i);let o=0;if(this._rows<e)for(let l=this._rows;l<e;l++)this.lines.length<e+this.ybase&&(this._optionsService.rawOptions.windowsMode||this._optionsService.rawOptions.windowsPty.backend!==void 0||this._optionsService.rawOptions.windowsPty.buildNumber!==void 0?this.lines.push(new Ze(t,i)):this.ybase>0&&this.lines.length<=this.ybase+this.y+o+1?(this.ybase--,o++,this.ydisp>0&&this.ydisp--):this.lines.push(new Ze(t,i)));else for(let l=this._rows;l>e;l--)this.lines.length>e+this.ybase&&(this.lines.length>this.ybase+this.y+1?this.lines.pop():(this.ybase++,this.ydisp++));if(n<this.lines.maxLength){let l=this.lines.length-n;l>0&&(this.lines.trimStart(l),this.ybase=Math.max(this.ybase-l,0),this.ydisp=Math.max(this.ydisp-l,0),this.savedY=Math.max(this.savedY-l,0)),this.lines.maxLength=n}this.x=Math.min(this.x,t-1),this.y=Math.min(this.y,e-1),o&&(this.y+=o),this.savedX=Math.min(this.savedX,t-1),this.scrollTop=0}if(this.scrollBottom=e-1,this._isReflowEnabled&&(this._reflow(t,e),this._cols>t))for(let o=0;o<this.lines.length;o++)r+=+this.lines.get(o).resize(t,i);this._cols=t,this._rows=e,this._memoryCleanupQueue.clear(),r>.1*this.lines.length&&(this._memoryCleanupPosition=0,this._memoryCleanupQueue.enqueue(()=>this._batchedMemoryCleanup()))}_batchedMemoryCleanup(){let t=!0;this._memoryCleanupPosition>=this.lines.length&&(this._memoryCleanupPosition=0,t=!1);let e=0;for(;this._memoryCleanupPosition<this.lines.length;)if(e+=this.lines.get(this._memoryCleanupPosition++).cleanupMemory(),e>100)return!0;return t}get _isReflowEnabled(){let t=this._optionsService.rawOptions.windowsPty;return t&&t.buildNumber?this._hasScrollback&&t.backend===\"conpty\"&&t.buildNumber>=21376:this._hasScrollback&&!this._optionsService.rawOptions.windowsMode}_reflow(t,e){this._cols!==t&&(t>this._cols?this._reflowLarger(t,e):this._reflowSmaller(t,e))}_reflowLarger(t,e){let i=this._optionsService.rawOptions.reflowCursorLine,r=sl(this.lines,this._cols,t,this.ybase+this.y,this.getNullCell(X),i);if(r.length>0){let n=ol(this.lines,r);ll(this.lines,n.layout),this._reflowLargerAdjustViewport(t,e,n.countRemoved)}}_reflowLargerAdjustViewport(t,e,i){let r=this.getNullCell(X),n=i;for(;n-- >0;)this.ybase===0?(this.y>0&&this.y--,this.lines.length<e&&this.lines.push(new Ze(t,r))):(this.ydisp===this.ybase&&this.ydisp--,this.ybase--);this.savedY=Math.max(this.savedY-i,0)}_reflowSmaller(t,e){let i=this._optionsService.rawOptions.reflowCursorLine,r=this.getNullCell(X),n=[],o=0;for(let l=this.lines.length-1;l>=0;l--){let a=this.lines.get(l);if(!a||!a.isWrapped&&a.getTrimmedLength()<=t)continue;let u=[a];for(;a.isWrapped&&l>0;)a=this.lines.get(--l),u.unshift(a);if(!i){let I=this.ybase+this.y;if(I>=l&&I<l+u.length)continue}let h=u[u.length-1].getTrimmedLength(),c=al(u,this._cols,t),d=c.length-u.length,_;this.ybase===0&&this.y!==this.lines.length-1?_=Math.max(0,this.y-this.lines.maxLength+d):_=Math.max(0,this.lines.length-this.lines.maxLength+d);let p=[];for(let I=0;I<d;I++){let k=this.getBlankLine(X,!0);p.push(k)}p.length>0&&(n.push({start:l+u.length+o,newLines:p}),o+=p.length),u.push(...p);let m=c.length-1,f=c[m];f===0&&(m--,f=c[m]);let A=u.length-d-1,R=h;for(;A>=0;){let I=Math.min(R,f);if(u[m]===void 0)break;if(u[m].copyCellsFrom(u[A],R-I,f-I,I,!0),f-=I,f===0&&(m--,f=c[m]),R-=I,R===0){A--;let k=Math.max(A,0);R=ri(u,k,this._cols)}}for(let I=0;I<u.length;I++)c[I]<t&&u[I].setCell(c[I],r);let O=d-_;for(;O-- >0;)this.ybase===0?this.y<e-1?(this.y++,this.lines.pop()):(this.ybase++,this.ydisp++):this.ybase<Math.min(this.lines.maxLength,this.lines.length+o)-e&&(this.ybase===this.ydisp&&this.ydisp++,this.ybase++);this.savedY=Math.min(this.savedY+d,this.ybase+e-1)}if(n.length>0){let l=[],a=[];for(let f=0;f<this.lines.length;f++)a.push(this.lines.get(f));let u=this.lines.length,h=u-1,c=0,d=n[c];this.lines.length=Math.min(this.lines.maxLength,this.lines.length+o);let _=0;for(let f=Math.min(this.lines.maxLength-1,u+o-1);f>=0;f--)if(d&&d.start>h+_){for(let A=d.newLines.length-1;A>=0;A--)this.lines.set(f--,d.newLines[A]);f++,l.push({index:h+1,amount:d.newLines.length}),_+=d.newLines.length,d=n[++c]}else this.lines.set(f,a[h--]);let p=0;for(let f=l.length-1;f>=0;f--)l[f].index+=p,this.lines.onInsertEmitter.fire(l[f]),p+=l[f].amount;let m=Math.max(0,u+o-this.lines.maxLength);m>0&&this.lines.onTrimEmitter.fire(m)}}translateBufferLineToString(t,e,i=0,r){let n=this.lines.get(t);return n?n.translateToString(e,i,r):\"\"}getWrappedRangeForLine(t){let e=t,i=t;for(;e>0&&this.lines.get(e).isWrapped;)e--;for(;i+1<this.lines.length&&this.lines.get(i+1).isWrapped;)i++;return{first:e,last:i}}setupTabStops(t){for(t!=null?this.tabs[t]||(t=this.prevStop(t)):(this.tabs={},t=0);t<this._cols;t+=this._optionsService.rawOptions.tabStopWidth)this.tabs[t]=!0}prevStop(t){for(t==null&&(t=this.x);!this.tabs[--t]&&t>0;);return t>=this._cols?this._cols-1:t<0?0:t}nextStop(t){for(t==null&&(t=this.x);!this.tabs[++t]&&t<this._cols;);return t>=this._cols?this._cols-1:t<0?0:t}clearMarkers(t){this._isClearing=!0;for(let e=0;e<this.markers.length;e++)this.markers[e].line===t&&(this.markers[e].dispose(),this.markers.splice(e--,1));this._isClearing=!1}clearAllMarkers(){this._isClearing=!0;for(let t=0;t<this.markers.length;t++)this.markers[t].dispose();this.markers.length=0,this._isClearing=!1}addMarker(t){let e=new cn(t);return this.markers.push(e),e.register(this.lines.onTrim(i=>{e.line-=i,e.line<0&&e.dispose()})),e.register(this.lines.onInsert(i=>{e.line>=i.index&&(e.line+=i.amount)})),e.register(this.lines.onDelete(i=>{e.line>=i.index&&e.line<i.index+i.amount&&e.dispose(),e.line>i.index&&(e.line-=i.amount)})),e.register(e.onDispose(()=>this._removeMarker(e))),e}_removeMarker(t){this._isClearing||this.markers.splice(this.markers.indexOf(t),1)}};var hn=class extends D{constructor(e,i){super();this._optionsService=e;this._bufferService=i;this._onBufferActivate=this._register(new v);this.onBufferActivate=this._onBufferActivate.event;this.reset(),this._register(this._optionsService.onSpecificOptionChange(\"scrollback\",()=>this.resize(this._bufferService.cols,this._bufferService.rows))),this._register(this._optionsService.onSpecificOptionChange(\"tabStopWidth\",()=>this.setupTabStops()))}reset(){this._normal=new $i(!0,this._optionsService,this._bufferService),this._normal.fillViewportRows(),this._alt=new $i(!1,this._optionsService,this._bufferService),this._activeBuffer=this._normal,this._onBufferActivate.fire({activeBuffer:this._normal,inactiveBuffer:this._alt}),this.setupTabStops()}get alt(){return this._alt}get active(){return this._activeBuffer}get normal(){return this._normal}activateNormalBuffer(){this._activeBuffer!==this._normal&&(this._normal.x=this._alt.x,this._normal.y=this._alt.y,this._alt.clearAllMarkers(),this._alt.clear(),this._activeBuffer=this._normal,this._onBufferActivate.fire({activeBuffer:this._normal,inactiveBuffer:this._alt}))}activateAltBuffer(e){this._activeBuffer!==this._alt&&(this._alt.fillViewportRows(e),this._alt.x=this._normal.x,this._alt.y=this._normal.y,this._activeBuffer=this._alt,this._onBufferActivate.fire({activeBuffer:this._alt,inactiveBuffer:this._normal}))}resize(e,i){this._normal.resize(e,i),this._alt.resize(e,i),this.setupTabStops(e)}setupTabStops(e){this._normal.setupTabStops(e),this._alt.setupTabStops(e)}};var ks=2,Cs=1,ni=class extends D{constructor(e){super();this.isUserScrolling=!1;this._onResize=this._register(new v);this.onResize=this._onResize.event;this._onScroll=this._register(new v);this.onScroll=this._onScroll.event;this.cols=Math.max(e.rawOptions.cols||0,ks),this.rows=Math.max(e.rawOptions.rows||0,Cs),this.buffers=this._register(new hn(e,this)),this._register(this.buffers.onBufferActivate(i=>{this._onScroll.fire(i.activeBuffer.ydisp)}))}get buffer(){return this.buffers.active}resize(e,i){let r=this.cols!==e,n=this.rows!==i;this.cols=e,this.rows=i,this.buffers.resize(e,i),this._onResize.fire({cols:e,rows:i,colsChanged:r,rowsChanged:n})}reset(){this.buffers.reset(),this.isUserScrolling=!1}scroll(e,i=!1){let r=this.buffer,n;n=this._cachedBlankLine,(!n||n.length!==this.cols||n.getFg(0)!==e.fg||n.getBg(0)!==e.bg)&&(n=r.getBlankLine(e,i),this._cachedBlankLine=n),n.isWrapped=i;let o=r.ybase+r.scrollTop,l=r.ybase+r.scrollBottom;if(r.scrollTop===0){let a=r.lines.isFull;l===r.lines.length-1?a?r.lines.recycle().copyFrom(n):r.lines.push(n.clone()):r.lines.splice(l+1,0,n.clone()),a?this.isUserScrolling&&(r.ydisp=Math.max(r.ydisp-1,0)):(r.ybase++,this.isUserScrolling||r.ydisp++)}else{let a=l-o+1;r.lines.shiftElements(o+1,a-1,-1),r.lines.set(l,n.clone())}this.isUserScrolling||(r.ydisp=r.ybase),this._onScroll.fire(r.ydisp)}scrollLines(e,i){let r=this.buffer;if(e<0){if(r.ydisp===0)return;this.isUserScrolling=!0}else e+r.ydisp>=r.ybase&&(this.isUserScrolling=!1);let n=r.ydisp;r.ydisp=Math.max(Math.min(r.ydisp+e,r.ybase),0),n!==r.ydisp&&(i||this._onScroll.fire(r.ydisp))}};ni=M([S(0,H)],ni);var si={cols:80,rows:24,cursorBlink:!1,cursorStyle:\"block\",cursorWidth:1,cursorInactiveStyle:\"outline\",customGlyphs:!0,drawBoldTextInBrightColors:!0,documentOverride:null,fastScrollModifier:\"alt\",fastScrollSensitivity:5,fontFamily:\"monospace\",fontSize:15,fontWeight:\"normal\",fontWeightBold:\"bold\",ignoreBracketedPasteMode:!1,lineHeight:1,letterSpacing:0,linkHandler:null,logLevel:\"info\",logger:null,scrollback:1e3,scrollOnEraseInDisplay:!1,scrollOnUserInput:!0,scrollSensitivity:1,screenReaderMode:!1,smoothScrollDuration:0,macOptionIsMeta:!1,macOptionClickForcesSelection:!1,minimumContrastRatio:1,disableStdin:!1,allowProposedApi:!1,allowTransparency:!1,tabStopWidth:8,theme:{},reflowCursorLine:!1,rescaleOverlappingGlyphs:!1,rightClickSelectsWord:Zt,windowOptions:{},windowsMode:!1,windowsPty:{},wordSeparator:\" ()[]{}',\\\"`\",altClickMovesCursor:!0,convertEol:!1,termName:\"xterm\",cancelEvents:!1,overviewRuler:{}},nc=[\"normal\",\"bold\",\"100\",\"200\",\"300\",\"400\",\"500\",\"600\",\"700\",\"800\",\"900\"],dn=class extends D{constructor(e){super();this._onOptionChange=this._register(new v);this.onOptionChange=this._onOptionChange.event;let i={...si};for(let r in e)if(r in i)try{let n=e[r];i[r]=this._sanitizeAndValidateOption(r,n)}catch(n){console.error(n)}this.rawOptions=i,this.options={...i},this._setupOptions(),this._register(C(()=>{this.rawOptions.linkHandler=null,this.rawOptions.documentOverride=null}))}onSpecificOptionChange(e,i){return this.onOptionChange(r=>{r===e&&i(this.rawOptions[e])})}onMultipleOptionChange(e,i){return this.onOptionChange(r=>{e.indexOf(r)!==-1&&i()})}_setupOptions(){let e=r=>{if(!(r in si))throw new Error(`No option with key \"${r}\"`);return this.rawOptions[r]},i=(r,n)=>{if(!(r in si))throw new Error(`No option with key \"${r}\"`);n=this._sanitizeAndValidateOption(r,n),this.rawOptions[r]!==n&&(this.rawOptions[r]=n,this._onOptionChange.fire(r))};for(let r in this.rawOptions){let n={get:e.bind(this,r),set:i.bind(this,r)};Object.defineProperty(this.options,r,n)}}_sanitizeAndValidateOption(e,i){switch(e){case\"cursorStyle\":if(i||(i=si[e]),!sc(i))throw new Error(`\"${i}\" is not a valid value for ${e}`);break;case\"wordSeparator\":i||(i=si[e]);break;case\"fontWeight\":case\"fontWeightBold\":if(typeof i==\"number\"&&1<=i&&i<=1e3)break;i=nc.includes(i)?i:si[e];break;case\"cursorWidth\":i=Math.floor(i);case\"lineHeight\":case\"tabStopWidth\":if(i<1)throw new Error(`${e} cannot be less than 1, value: ${i}`);break;case\"minimumContrastRatio\":i=Math.max(1,Math.min(21,Math.round(i*10)/10));break;case\"scrollback\":if(i=Math.min(i,4294967295),i<0)throw new Error(`${e} cannot be less than 0, value: ${i}`);break;case\"fastScrollSensitivity\":case\"scrollSensitivity\":if(i<=0)throw new Error(`${e} cannot be less than or equal to 0, value: ${i}`);break;case\"rows\":case\"cols\":if(!i&&i!==0)throw new Error(`${e} must be numeric, value: ${i}`);break;case\"windowsPty\":i=i??{};break}return i}};function sc(s){return s===\"block\"||s===\"underline\"||s===\"bar\"}function oi(s,t=5){if(typeof s!=\"object\")return s;let e=Array.isArray(s)?[]:{};for(let i in s)e[i]=t<=1?s[i]:s[i]&&oi(s[i],t-1);return e}var ul=Object.freeze({insertMode:!1}),hl=Object.freeze({applicationCursorKeys:!1,applicationKeypad:!1,bracketedPasteMode:!1,cursorBlink:void 0,cursorStyle:void 0,origin:!1,reverseWraparound:!1,sendFocus:!1,synchronizedOutput:!1,wraparound:!0}),li=class extends D{constructor(e,i,r){super();this._bufferService=e;this._logService=i;this._optionsService=r;this.isCursorInitialized=!1;this.isCursorHidden=!1;this._onData=this._register(new v);this.onData=this._onData.event;this._onUserInput=this._register(new v);this.onUserInput=this._onUserInput.event;this._onBinary=this._register(new v);this.onBinary=this._onBinary.event;this._onRequestScrollToBottom=this._register(new v);this.onRequestScrollToBottom=this._onRequestScrollToBottom.event;this.modes=oi(ul),this.decPrivateModes=oi(hl)}reset(){this.modes=oi(ul),this.decPrivateModes=oi(hl)}triggerDataEvent(e,i=!1){if(this._optionsService.rawOptions.disableStdin)return;let r=this._bufferService.buffer;i&&this._optionsService.rawOptions.scrollOnUserInput&&r.ybase!==r.ydisp&&this._onRequestScrollToBottom.fire(),i&&this._onUserInput.fire(),this._logService.debug(`sending data \"${e}\"`),this._logService.trace(\"sending data (codes)\",()=>e.split(\"\").map(n=>n.charCodeAt(0))),this._onData.fire(e)}triggerBinaryEvent(e){this._optionsService.rawOptions.disableStdin||(this._logService.debug(`sending binary \"${e}\"`),this._logService.trace(\"sending binary (codes)\",()=>e.split(\"\").map(i=>i.charCodeAt(0))),this._onBinary.fire(e))}};li=M([S(0,F),S(1,nr),S(2,H)],li);var dl={NONE:{events:0,restrict:()=>!1},X10:{events:1,restrict:s=>s.button===4||s.action!==1?!1:(s.ctrl=!1,s.alt=!1,s.shift=!1,!0)},VT200:{events:19,restrict:s=>s.action!==32},DRAG:{events:23,restrict:s=>!(s.action===32&&s.button===3)},ANY:{events:31,restrict:s=>!0}};function Ms(s,t){let e=(s.ctrl?16:0)|(s.shift?4:0)|(s.alt?8:0);return s.button===4?(e|=64,e|=s.action):(e|=s.button&3,s.button&4&&(e|=64),s.button&8&&(e|=128),s.action===32?e|=32:s.action===0&&!t&&(e|=3)),e}var Ps=String.fromCharCode,fl={DEFAULT:s=>{let t=[Ms(s,!1)+32,s.col+32,s.row+32];return t[0]>255||t[1]>255||t[2]>255?\"\":`\\x1B[M${Ps(t[0])}${Ps(t[1])}${Ps(t[2])}`},SGR:s=>{let t=s.action===0&&s.button!==4?\"m\":\"M\";return`\\x1B[<${Ms(s,!0)};${s.col};${s.row}${t}`},SGR_PIXELS:s=>{let t=s.action===0&&s.button!==4?\"m\":\"M\";return`\\x1B[<${Ms(s,!0)};${s.x};${s.y}${t}`}},ai=class extends D{constructor(e,i,r){super();this._bufferService=e;this._coreService=i;this._optionsService=r;this._protocols={};this._encodings={};this._activeProtocol=\"\";this._activeEncoding=\"\";this._lastEvent=null;this._wheelPartialScroll=0;this._onProtocolChange=this._register(new v);this.onProtocolChange=this._onProtocolChange.event;for(let n of Object.keys(dl))this.addProtocol(n,dl[n]);for(let n of Object.keys(fl))this.addEncoding(n,fl[n]);this.reset()}addProtocol(e,i){this._protocols[e]=i}addEncoding(e,i){this._encodings[e]=i}get activeProtocol(){return this._activeProtocol}get areMouseEventsActive(){return this._protocols[this._activeProtocol].events!==0}set activeProtocol(e){if(!this._protocols[e])throw new Error(`unknown protocol \"${e}\"`);this._activeProtocol=e,this._onProtocolChange.fire(this._protocols[e].events)}get activeEncoding(){return this._activeEncoding}set activeEncoding(e){if(!this._encodings[e])throw new Error(`unknown encoding \"${e}\"`);this._activeEncoding=e}reset(){this.activeProtocol=\"NONE\",this.activeEncoding=\"DEFAULT\",this._lastEvent=null,this._wheelPartialScroll=0}consumeWheelEvent(e,i,r){if(e.deltaY===0||e.shiftKey||i===void 0||r===void 0)return 0;let n=i/r,o=this._applyScrollModifier(e.deltaY,e);return e.deltaMode===WheelEvent.DOM_DELTA_PIXEL?(o/=n+0,Math.abs(e.deltaY)<50&&(o*=.3),this._wheelPartialScroll+=o,o=Math.floor(Math.abs(this._wheelPartialScroll))*(this._wheelPartialScroll>0?1:-1),this._wheelPartialScroll%=1):e.deltaMode===WheelEvent.DOM_DELTA_PAGE&&(o*=this._bufferService.rows),o}_applyScrollModifier(e,i){return i.altKey||i.ctrlKey||i.shiftKey?e*this._optionsService.rawOptions.fastScrollSensitivity*this._optionsService.rawOptions.scrollSensitivity:e*this._optionsService.rawOptions.scrollSensitivity}triggerMouseEvent(e){if(e.col<0||e.col>=this._bufferService.cols||e.row<0||e.row>=this._bufferService.rows||e.button===4&&e.action===32||e.button===3&&e.action!==32||e.button!==4&&(e.action===2||e.action===3)||(e.col++,e.row++,e.action===32&&this._lastEvent&&this._equalEvents(this._lastEvent,e,this._activeEncoding===\"SGR_PIXELS\"))||!this._protocols[this._activeProtocol].restrict(e))return!1;let i=this._encodings[this._activeEncoding](e);return i&&(this._activeEncoding===\"DEFAULT\"?this._coreService.triggerBinaryEvent(i):this._coreService.triggerDataEvent(i,!0)),this._lastEvent=e,!0}explainEvents(e){return{down:!!(e&1),up:!!(e&2),drag:!!(e&4),move:!!(e&8),wheel:!!(e&16)}}_equalEvents(e,i,r){if(r){if(e.x!==i.x||e.y!==i.y)return!1}else if(e.col!==i.col||e.row!==i.row)return!1;return!(e.button!==i.button||e.action!==i.action||e.ctrl!==i.ctrl||e.alt!==i.alt||e.shift!==i.shift)}};ai=M([S(0,F),S(1,ge),S(2,H)],ai);var Os=[[768,879],[1155,1158],[1160,1161],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1536,1539],[1552,1557],[1611,1630],[1648,1648],[1750,1764],[1767,1768],[1770,1773],[1807,1807],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2305,2306],[2364,2364],[2369,2376],[2381,2381],[2385,2388],[2402,2403],[2433,2433],[2492,2492],[2497,2500],[2509,2509],[2530,2531],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2672,2673],[2689,2690],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2817,2817],[2876,2876],[2879,2879],[2881,2883],[2893,2893],[2902,2902],[2946,2946],[3008,3008],[3021,3021],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3260,3260],[3263,3263],[3270,3270],[3276,3277],[3298,3299],[3393,3395],[3405,3405],[3530,3530],[3538,3540],[3542,3542],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3769],[3771,3772],[3784,3789],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3984,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4146],[4150,4151],[4153,4153],[4184,4185],[4448,4607],[4959,4959],[5906,5908],[5938,5940],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6109,6109],[6155,6157],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6912,6915],[6964,6964],[6966,6970],[6972,6972],[6978,6978],[7019,7027],[7616,7626],[7678,7679],[8203,8207],[8234,8238],[8288,8291],[8298,8303],[8400,8431],[12330,12335],[12441,12442],[43014,43014],[43019,43019],[43045,43046],[64286,64286],[65024,65039],[65056,65059],[65279,65279],[65529,65531]],ac=[[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[119143,119145],[119155,119170],[119173,119179],[119210,119213],[119362,119364],[917505,917505],[917536,917631],[917760,917999]],se;function cc(s,t){let e=0,i=t.length-1,r;if(s<t[0][0]||s>t[i][1])return!1;for(;i>=e;)if(r=e+i>>1,s>t[r][1])e=r+1;else if(s<t[r][0])i=r-1;else return!0;return!1}var fn=class{constructor(){this.version=\"6\";if(!se){se=new Uint8Array(65536),se.fill(1),se[0]=0,se.fill(0,1,32),se.fill(0,127,160),se.fill(2,4352,4448),se[9001]=2,se[9002]=2,se.fill(2,11904,42192),se[12351]=1,se.fill(2,44032,55204),se.fill(2,63744,64256),se.fill(2,65040,65050),se.fill(2,65072,65136),se.fill(2,65280,65377),se.fill(2,65504,65511);for(let t=0;t<Os.length;++t)se.fill(0,Os[t][0],Os[t][1]+1)}}wcwidth(t){return t<32?0:t<127?1:t<65536?se[t]:cc(t,ac)?0:t>=131072&&t<=196605||t>=196608&&t<=262141?2:1}charProperties(t,e){let i=this.wcwidth(t),r=i===0&&e!==0;if(r){let n=Ae.extractWidth(e);n===0?r=!1:n>i&&(i=n)}return Ae.createPropertyValue(0,i,r)}};var Ae=class s{constructor(){this._providers=Object.create(null);this._active=\"\";this._onChange=new v;this.onChange=this._onChange.event;let t=new fn;this.register(t),this._active=t.version,this._activeProvider=t}static extractShouldJoin(t){return(t&1)!==0}static extractWidth(t){return t>>1&3}static extractCharKind(t){return t>>3}static createPropertyValue(t,e,i=!1){return(t&16777215)<<3|(e&3)<<1|(i?1:0)}dispose(){this._onChange.dispose()}get versions(){return Object.keys(this._providers)}get activeVersion(){return this._active}set activeVersion(t){if(!this._providers[t])throw new Error(`unknown Unicode version \"${t}\"`);this._active=t,this._activeProvider=this._providers[t],this._onChange.fire(t)}register(t){this._providers[t.version]=t}wcwidth(t){return this._activeProvider.wcwidth(t)}getStringCellWidth(t){let e=0,i=0,r=t.length;for(let n=0;n<r;++n){let o=t.charCodeAt(n);if(55296<=o&&o<=56319){if(++n>=r)return e+this.wcwidth(o);let u=t.charCodeAt(n);56320<=u&&u<=57343?o=(o-55296)*1024+u-56320+65536:e+=this.wcwidth(u)}let l=this.charProperties(o,i),a=s.extractWidth(l);s.extractShouldJoin(l)&&(a-=s.extractWidth(i)),e+=a,i=l}return e}charProperties(t,e){return this._activeProvider.charProperties(t,e)}};var pn=class{constructor(){this.glevel=0;this._charsets=[]}reset(){this.charset=void 0,this._charsets=[],this.glevel=0}setgLevel(t){this.glevel=t,this.charset=this._charsets[t]}setgCharset(t,e){this._charsets[t]=e,this.glevel===t&&(this.charset=e)}};function Bs(s){let e=s.buffer.lines.get(s.buffer.ybase+s.buffer.y-1)?.get(s.cols-1),i=s.buffer.lines.get(s.buffer.ybase+s.buffer.y);i&&e&&(i.isWrapped=e[3]!==0&&e[3]!==32)}var Vi=2147483647,uc=256,ci=class s{constructor(t=32,e=32){this.maxLength=t;this.maxSubParamsLength=e;if(e>uc)throw new Error(\"maxSubParamsLength must not be greater than 256\");this.params=new Int32Array(t),this.length=0,this._subParams=new Int32Array(e),this._subParamsLength=0,this._subParamsIdx=new Uint16Array(t),this._rejectDigits=!1,this._rejectSubDigits=!1,this._digitIsSub=!1}static fromArray(t){let e=new s;if(!t.length)return e;for(let i=Array.isArray(t[0])?1:0;i<t.length;++i){let r=t[i];if(Array.isArray(r))for(let n=0;n<r.length;++n)e.addSubParam(r[n]);else e.addParam(r)}return e}clone(){let t=new s(this.maxLength,this.maxSubParamsLength);return t.params.set(this.params),t.length=this.length,t._subParams.set(this._subParams),t._subParamsLength=this._subParamsLength,t._subParamsIdx.set(this._subParamsIdx),t._rejectDigits=this._rejectDigits,t._rejectSubDigits=this._rejectSubDigits,t._digitIsSub=this._digitIsSub,t}toArray(){let t=[];for(let e=0;e<this.length;++e){t.push(this.params[e]);let i=this._subParamsIdx[e]>>8,r=this._subParamsIdx[e]&255;r-i>0&&t.push(Array.prototype.slice.call(this._subParams,i,r))}return t}reset(){this.length=0,this._subParamsLength=0,this._rejectDigits=!1,this._rejectSubDigits=!1,this._digitIsSub=!1}addParam(t){if(this._digitIsSub=!1,this.length>=this.maxLength){this._rejectDigits=!0;return}if(t<-1)throw new Error(\"values lesser than -1 are not allowed\");this._subParamsIdx[this.length]=this._subParamsLength<<8|this._subParamsLength,this.params[this.length++]=t>Vi?Vi:t}addSubParam(t){if(this._digitIsSub=!0,!!this.length){if(this._rejectDigits||this._subParamsLength>=this.maxSubParamsLength){this._rejectSubDigits=!0;return}if(t<-1)throw new Error(\"values lesser than -1 are not allowed\");this._subParams[this._subParamsLength++]=t>Vi?Vi:t,this._subParamsIdx[this.length-1]++}}hasSubParams(t){return(this._subParamsIdx[t]&255)-(this._subParamsIdx[t]>>8)>0}getSubParams(t){let e=this._subParamsIdx[t]>>8,i=this._subParamsIdx[t]&255;return i-e>0?this._subParams.subarray(e,i):null}getSubParamsAll(){let t={};for(let e=0;e<this.length;++e){let i=this._subParamsIdx[e]>>8,r=this._subParamsIdx[e]&255;r-i>0&&(t[e]=this._subParams.slice(i,r))}return t}addDigit(t){let e;if(this._rejectDigits||!(e=this._digitIsSub?this._subParamsLength:this.length)||this._digitIsSub&&this._rejectSubDigits)return;let i=this._digitIsSub?this._subParams:this.params,r=i[e-1];i[e-1]=~r?Math.min(r*10+t,Vi):t}};var qi=[],mn=class{constructor(){this._state=0;this._active=qi;this._id=-1;this._handlers=Object.create(null);this._handlerFb=()=>{};this._stack={paused:!1,loopPosition:0,fallThrough:!1}}registerHandler(t,e){this._handlers[t]===void 0&&(this._handlers[t]=[]);let i=this._handlers[t];return i.push(e),{dispose:()=>{let r=i.indexOf(e);r!==-1&&i.splice(r,1)}}}clearHandler(t){this._handlers[t]&&delete this._handlers[t]}setHandlerFallback(t){this._handlerFb=t}dispose(){this._handlers=Object.create(null),this._handlerFb=()=>{},this._active=qi}reset(){if(this._state===2)for(let t=this._stack.paused?this._stack.loopPosition-1:this._active.length-1;t>=0;--t)this._active[t].end(!1);this._stack.paused=!1,this._active=qi,this._id=-1,this._state=0}_start(){if(this._active=this._handlers[this._id]||qi,!this._active.length)this._handlerFb(this._id,\"START\");else for(let t=this._active.length-1;t>=0;t--)this._active[t].start()}_put(t,e,i){if(!this._active.length)this._handlerFb(this._id,\"PUT\",It(t,e,i));else for(let r=this._active.length-1;r>=0;r--)this._active[r].put(t,e,i)}start(){this.reset(),this._state=1}put(t,e,i){if(this._state!==3){if(this._state===1)for(;e<i;){let r=t[e++];if(r===59){this._state=2,this._start();break}if(r<48||57<r){this._state=3;return}this._id===-1&&(this._id=0),this._id=this._id*10+r-48}this._state===2&&i-e>0&&this._put(t,e,i)}}end(t,e=!0){if(this._state!==0){if(this._state!==3)if(this._state===1&&this._start(),!this._active.length)this._handlerFb(this._id,\"END\",t);else{let i=!1,r=this._active.length-1,n=!1;if(this._stack.paused&&(r=this._stack.loopPosition-1,i=e,n=this._stack.fallThrough,this._stack.paused=!1),!n&&i===!1){for(;r>=0&&(i=this._active[r].end(t),i!==!0);r--)if(i instanceof Promise)return this._stack.paused=!0,this._stack.loopPosition=r,this._stack.fallThrough=!1,i;r--}for(;r>=0;r--)if(i=this._active[r].end(!1),i instanceof Promise)return this._stack.paused=!0,this._stack.loopPosition=r,this._stack.fallThrough=!0,i}this._active=qi,this._id=-1,this._state=0}}},pe=class{constructor(t){this._handler=t;this._data=\"\";this._hitLimit=!1}start(){this._data=\"\",this._hitLimit=!1}put(t,e,i){this._hitLimit||(this._data+=It(t,e,i),this._data.length>1e7&&(this._data=\"\",this._hitLimit=!0))}end(t){let e=!1;if(this._hitLimit)e=!1;else if(t&&(e=this._handler(this._data),e instanceof Promise))return e.then(i=>(this._data=\"\",this._hitLimit=!1,i));return this._data=\"\",this._hitLimit=!1,e}};var Yi=[],_n=class{constructor(){this._handlers=Object.create(null);this._active=Yi;this._ident=0;this._handlerFb=()=>{};this._stack={paused:!1,loopPosition:0,fallThrough:!1}}dispose(){this._handlers=Object.create(null),this._handlerFb=()=>{},this._active=Yi}registerHandler(t,e){this._handlers[t]===void 0&&(this._handlers[t]=[]);let i=this._handlers[t];return i.push(e),{dispose:()=>{let r=i.indexOf(e);r!==-1&&i.splice(r,1)}}}clearHandler(t){this._handlers[t]&&delete this._handlers[t]}setHandlerFallback(t){this._handlerFb=t}reset(){if(this._active.length)for(let t=this._stack.paused?this._stack.loopPosition-1:this._active.length-1;t>=0;--t)this._active[t].unhook(!1);this._stack.paused=!1,this._active=Yi,this._ident=0}hook(t,e){if(this.reset(),this._ident=t,this._active=this._handlers[t]||Yi,!this._active.length)this._handlerFb(this._ident,\"HOOK\",e);else for(let i=this._active.length-1;i>=0;i--)this._active[i].hook(e)}put(t,e,i){if(!this._active.length)this._handlerFb(this._ident,\"PUT\",It(t,e,i));else for(let r=this._active.length-1;r>=0;r--)this._active[r].put(t,e,i)}unhook(t,e=!0){if(!this._active.length)this._handlerFb(this._ident,\"UNHOOK\",t);else{let i=!1,r=this._active.length-1,n=!1;if(this._stack.paused&&(r=this._stack.loopPosition-1,i=e,n=this._stack.fallThrough,this._stack.paused=!1),!n&&i===!1){for(;r>=0&&(i=this._active[r].unhook(t),i!==!0);r--)if(i instanceof Promise)return this._stack.paused=!0,this._stack.loopPosition=r,this._stack.fallThrough=!1,i;r--}for(;r>=0;r--)if(i=this._active[r].unhook(!1),i instanceof Promise)return this._stack.paused=!0,this._stack.loopPosition=r,this._stack.fallThrough=!0,i}this._active=Yi,this._ident=0}},ji=new ci;ji.addParam(0);var Xi=class{constructor(t){this._handler=t;this._data=\"\";this._params=ji;this._hitLimit=!1}hook(t){this._params=t.length>1||t.params[0]?t.clone():ji,this._data=\"\",this._hitLimit=!1}put(t,e,i){this._hitLimit||(this._data+=It(t,e,i),this._data.length>1e7&&(this._data=\"\",this._hitLimit=!0))}unhook(t){let e=!1;if(this._hitLimit)e=!1;else if(t&&(e=this._handler(this._data,this._params),e instanceof Promise))return e.then(i=>(this._params=ji,this._data=\"\",this._hitLimit=!1,i));return this._params=ji,this._data=\"\",this._hitLimit=!1,e}};var Fs=class{constructor(t){this.table=new Uint8Array(t)}setDefault(t,e){this.table.fill(t<<4|e)}add(t,e,i,r){this.table[e<<8|t]=i<<4|r}addMany(t,e,i,r){for(let n=0;n<t.length;n++)this.table[e<<8|t[n]]=i<<4|r}},ke=160,hc=function(){let s=new Fs(4095),e=Array.apply(null,Array(256)).map((a,u)=>u),i=(a,u)=>e.slice(a,u),r=i(32,127),n=i(0,24);n.push(25),n.push.apply(n,i(28,32));let o=i(0,14),l;s.setDefault(1,0),s.addMany(r,0,2,0);for(l in o)s.addMany([24,26,153,154],l,3,0),s.addMany(i(128,144),l,3,0),s.addMany(i(144,152),l,3,0),s.add(156,l,0,0),s.add(27,l,11,1),s.add(157,l,4,8),s.addMany([152,158,159],l,0,7),s.add(155,l,11,3),s.add(144,l,11,9);return s.addMany(n,0,3,0),s.addMany(n,1,3,1),s.add(127,1,0,1),s.addMany(n,8,0,8),s.addMany(n,3,3,3),s.add(127,3,0,3),s.addMany(n,4,3,4),s.add(127,4,0,4),s.addMany(n,6,3,6),s.addMany(n,5,3,5),s.add(127,5,0,5),s.addMany(n,2,3,2),s.add(127,2,0,2),s.add(93,1,4,8),s.addMany(r,8,5,8),s.add(127,8,5,8),s.addMany([156,27,24,26,7],8,6,0),s.addMany(i(28,32),8,0,8),s.addMany([88,94,95],1,0,7),s.addMany(r,7,0,7),s.addMany(n,7,0,7),s.add(156,7,0,0),s.add(127,7,0,7),s.add(91,1,11,3),s.addMany(i(64,127),3,7,0),s.addMany(i(48,60),3,8,4),s.addMany([60,61,62,63],3,9,4),s.addMany(i(48,60),4,8,4),s.addMany(i(64,127),4,7,0),s.addMany([60,61,62,63],4,0,6),s.addMany(i(32,64),6,0,6),s.add(127,6,0,6),s.addMany(i(64,127),6,0,0),s.addMany(i(32,48),3,9,5),s.addMany(i(32,48),5,9,5),s.addMany(i(48,64),5,0,6),s.addMany(i(64,127),5,7,0),s.addMany(i(32,48),4,9,5),s.addMany(i(32,48),1,9,2),s.addMany(i(32,48),2,9,2),s.addMany(i(48,127),2,10,0),s.addMany(i(48,80),1,10,0),s.addMany(i(81,88),1,10,0),s.addMany([89,90,92],1,10,0),s.addMany(i(96,127),1,10,0),s.add(80,1,11,9),s.addMany(n,9,0,9),s.add(127,9,0,9),s.addMany(i(28,32),9,0,9),s.addMany(i(32,48),9,9,12),s.addMany(i(48,60),9,8,10),s.addMany([60,61,62,63],9,9,10),s.addMany(n,11,0,11),s.addMany(i(32,128),11,0,11),s.addMany(i(28,32),11,0,11),s.addMany(n,10,0,10),s.add(127,10,0,10),s.addMany(i(28,32),10,0,10),s.addMany(i(48,60),10,8,10),s.addMany([60,61,62,63],10,0,11),s.addMany(i(32,48),10,9,12),s.addMany(n,12,0,12),s.add(127,12,0,12),s.addMany(i(28,32),12,0,12),s.addMany(i(32,48),12,9,12),s.addMany(i(48,64),12,0,11),s.addMany(i(64,127),12,12,13),s.addMany(i(64,127),10,12,13),s.addMany(i(64,127),9,12,13),s.addMany(n,13,13,13),s.addMany(r,13,13,13),s.add(127,13,0,13),s.addMany([27,156,24,26],13,14,0),s.add(ke,0,2,0),s.add(ke,8,5,8),s.add(ke,6,0,6),s.add(ke,11,0,11),s.add(ke,13,13,13),s}(),bn=class extends D{constructor(e=hc){super();this._transitions=e;this._parseStack={state:0,handlers:[],handlerPos:0,transition:0,chunkPos:0};this.initialState=0,this.currentState=this.initialState,this._params=new ci,this._params.addParam(0),this._collect=0,this.precedingJoinState=0,this._printHandlerFb=(i,r,n)=>{},this._executeHandlerFb=i=>{},this._csiHandlerFb=(i,r)=>{},this._escHandlerFb=i=>{},this._errorHandlerFb=i=>i,this._printHandler=this._printHandlerFb,this._executeHandlers=Object.create(null),this._csiHandlers=Object.create(null),this._escHandlers=Object.create(null),this._register(C(()=>{this._csiHandlers=Object.create(null),this._executeHandlers=Object.create(null),this._escHandlers=Object.create(null)})),this._oscParser=this._register(new mn),this._dcsParser=this._register(new _n),this._errorHandler=this._errorHandlerFb,this.registerEscHandler({final:\"\\\\\"},()=>!0)}_identifier(e,i=[64,126]){let r=0;if(e.prefix){if(e.prefix.length>1)throw new Error(\"only one byte as prefix supported\");if(r=e.prefix.charCodeAt(0),r&&60>r||r>63)throw new Error(\"prefix must be in range 0x3c .. 0x3f\")}if(e.intermediates){if(e.intermediates.length>2)throw new Error(\"only two bytes as intermediates are supported\");for(let o=0;o<e.intermediates.length;++o){let l=e.intermediates.charCodeAt(o);if(32>l||l>47)throw new Error(\"intermediate must be in range 0x20 .. 0x2f\");r<<=8,r|=l}}if(e.final.length!==1)throw new Error(\"final must be a single byte\");let n=e.final.charCodeAt(0);if(i[0]>n||n>i[1])throw new Error(`final must be in range ${i[0]} .. ${i[1]}`);return r<<=8,r|=n,r}identToString(e){let i=[];for(;e;)i.push(String.fromCharCode(e&255)),e>>=8;return i.reverse().join(\"\")}setPrintHandler(e){this._printHandler=e}clearPrintHandler(){this._printHandler=this._printHandlerFb}registerEscHandler(e,i){let r=this._identifier(e,[48,126]);this._escHandlers[r]===void 0&&(this._escHandlers[r]=[]);let n=this._escHandlers[r];return n.push(i),{dispose:()=>{let o=n.indexOf(i);o!==-1&&n.splice(o,1)}}}clearEscHandler(e){this._escHandlers[this._identifier(e,[48,126])]&&delete this._escHandlers[this._identifier(e,[48,126])]}setEscHandlerFallback(e){this._escHandlerFb=e}setExecuteHandler(e,i){this._executeHandlers[e.charCodeAt(0)]=i}clearExecuteHandler(e){this._executeHandlers[e.charCodeAt(0)]&&delete this._executeHandlers[e.charCodeAt(0)]}setExecuteHandlerFallback(e){this._executeHandlerFb=e}registerCsiHandler(e,i){let r=this._identifier(e);this._csiHandlers[r]===void 0&&(this._csiHandlers[r]=[]);let n=this._csiHandlers[r];return n.push(i),{dispose:()=>{let o=n.indexOf(i);o!==-1&&n.splice(o,1)}}}clearCsiHandler(e){this._csiHandlers[this._identifier(e)]&&delete this._csiHandlers[this._identifier(e)]}setCsiHandlerFallback(e){this._csiHandlerFb=e}registerDcsHandler(e,i){return this._dcsParser.registerHandler(this._identifier(e),i)}clearDcsHandler(e){this._dcsParser.clearHandler(this._identifier(e))}setDcsHandlerFallback(e){this._dcsParser.setHandlerFallback(e)}registerOscHandler(e,i){return this._oscParser.registerHandler(e,i)}clearOscHandler(e){this._oscParser.clearHandler(e)}setOscHandlerFallback(e){this._oscParser.setHandlerFallback(e)}setErrorHandler(e){this._errorHandler=e}clearErrorHandler(){this._errorHandler=this._errorHandlerFb}reset(){this.currentState=this.initialState,this._oscParser.reset(),this._dcsParser.reset(),this._params.reset(),this._params.addParam(0),this._collect=0,this.precedingJoinState=0,this._parseStack.state!==0&&(this._parseStack.state=2,this._parseStack.handlers=[])}_preserveStack(e,i,r,n,o){this._parseStack.state=e,this._parseStack.handlers=i,this._parseStack.handlerPos=r,this._parseStack.transition=n,this._parseStack.chunkPos=o}parse(e,i,r){let n=0,o=0,l=0,a;if(this._parseStack.state)if(this._parseStack.state===2)this._parseStack.state=0,l=this._parseStack.chunkPos+1;else{if(r===void 0||this._parseStack.state===1)throw this._parseStack.state=1,new Error(\"improper continuation due to previous async handler, giving up parsing\");let u=this._parseStack.handlers,h=this._parseStack.handlerPos-1;switch(this._parseStack.state){case 3:if(r===!1&&h>-1){for(;h>=0&&(a=u[h](this._params),a!==!0);h--)if(a instanceof Promise)return this._parseStack.handlerPos=h,a}this._parseStack.handlers=[];break;case 4:if(r===!1&&h>-1){for(;h>=0&&(a=u[h](),a!==!0);h--)if(a instanceof Promise)return this._parseStack.handlerPos=h,a}this._parseStack.handlers=[];break;case 6:if(n=e[this._parseStack.chunkPos],a=this._dcsParser.unhook(n!==24&&n!==26,r),a)return a;n===27&&(this._parseStack.transition|=1),this._params.reset(),this._params.addParam(0),this._collect=0;break;case 5:if(n=e[this._parseStack.chunkPos],a=this._oscParser.end(n!==24&&n!==26,r),a)return a;n===27&&(this._parseStack.transition|=1),this._params.reset(),this._params.addParam(0),this._collect=0;break}this._parseStack.state=0,l=this._parseStack.chunkPos+1,this.precedingJoinState=0,this.currentState=this._parseStack.transition&15}for(let u=l;u<i;++u){switch(n=e[u],o=this._transitions.table[this.currentState<<8|(n<160?n:ke)],o>>4){case 2:for(let m=u+1;;++m){if(m>=i||(n=e[m])<32||n>126&&n<ke){this._printHandler(e,u,m),u=m-1;break}if(++m>=i||(n=e[m])<32||n>126&&n<ke){this._printHandler(e,u,m),u=m-1;break}if(++m>=i||(n=e[m])<32||n>126&&n<ke){this._printHandler(e,u,m),u=m-1;break}if(++m>=i||(n=e[m])<32||n>126&&n<ke){this._printHandler(e,u,m),u=m-1;break}}break;case 3:this._executeHandlers[n]?this._executeHandlers[n]():this._executeHandlerFb(n),this.precedingJoinState=0;break;case 0:break;case 1:if(this._errorHandler({position:u,code:n,currentState:this.currentState,collect:this._collect,params:this._params,abort:!1}).abort)return;break;case 7:let c=this._csiHandlers[this._collect<<8|n],d=c?c.length-1:-1;for(;d>=0&&(a=c[d](this._params),a!==!0);d--)if(a instanceof Promise)return this._preserveStack(3,c,d,o,u),a;d<0&&this._csiHandlerFb(this._collect<<8|n,this._params),this.precedingJoinState=0;break;case 8:do switch(n){case 59:this._params.addParam(0);break;case 58:this._params.addSubParam(-1);break;default:this._params.addDigit(n-48)}while(++u<i&&(n=e[u])>47&&n<60);u--;break;case 9:this._collect<<=8,this._collect|=n;break;case 10:let _=this._escHandlers[this._collect<<8|n],p=_?_.length-1:-1;for(;p>=0&&(a=_[p](),a!==!0);p--)if(a instanceof Promise)return this._preserveStack(4,_,p,o,u),a;p<0&&this._escHandlerFb(this._collect<<8|n),this.precedingJoinState=0;break;case 11:this._params.reset(),this._params.addParam(0),this._collect=0;break;case 12:this._dcsParser.hook(this._collect<<8|n,this._params);break;case 13:for(let m=u+1;;++m)if(m>=i||(n=e[m])===24||n===26||n===27||n>127&&n<ke){this._dcsParser.put(e,u,m),u=m-1;break}break;case 14:if(a=this._dcsParser.unhook(n!==24&&n!==26),a)return this._preserveStack(6,[],0,o,u),a;n===27&&(o|=1),this._params.reset(),this._params.addParam(0),this._collect=0,this.precedingJoinState=0;break;case 4:this._oscParser.start();break;case 5:for(let m=u+1;;m++)if(m>=i||(n=e[m])<32||n>127&&n<ke){this._oscParser.put(e,u,m),u=m-1;break}break;case 6:if(a=this._oscParser.end(n!==24&&n!==26),a)return this._preserveStack(5,[],0,o,u),a;n===27&&(o|=1),this._params.reset(),this._params.addParam(0),this._collect=0,this.precedingJoinState=0;break}this.currentState=o&15}}};var dc=/^([\\da-f])\\/([\\da-f])\\/([\\da-f])$|^([\\da-f]{2})\\/([\\da-f]{2})\\/([\\da-f]{2})$|^([\\da-f]{3})\\/([\\da-f]{3})\\/([\\da-f]{3})$|^([\\da-f]{4})\\/([\\da-f]{4})\\/([\\da-f]{4})$/,fc=/^[\\da-f]+$/;function Ws(s){if(!s)return;let t=s.toLowerCase();if(t.indexOf(\"rgb:\")===0){t=t.slice(4);let e=dc.exec(t);if(e){let i=e[1]?15:e[4]?255:e[7]?4095:65535;return[Math.round(parseInt(e[1]||e[4]||e[7]||e[10],16)/i*255),Math.round(parseInt(e[2]||e[5]||e[8]||e[11],16)/i*255),Math.round(parseInt(e[3]||e[6]||e[9]||e[12],16)/i*255)]}}else if(t.indexOf(\"#\")===0&&(t=t.slice(1),fc.exec(t)&&[3,6,9,12].includes(t.length))){let e=t.length/3,i=[0,0,0];for(let r=0;r<3;++r){let n=parseInt(t.slice(e*r,e*r+e),16);i[r]=e===1?n<<4:e===2?n:e===3?n>>4:n>>8}return i}}function Hs(s,t){let e=s.toString(16),i=e.length<2?\"0\"+e:e;switch(t){case 4:return e[0];case 8:return i;case 12:return(i+i).slice(0,3);default:return i+i}}function ml(s,t=16){let[e,i,r]=s;return`rgb:${Hs(e,t)}/${Hs(i,t)}/${Hs(r,t)}`}var mc={\"(\":0,\")\":1,\"*\":2,\"+\":3,\"-\":1,\".\":2},ut=131072,_l=10;function bl(s,t){if(s>24)return t.setWinLines||!1;switch(s){case 1:return!!t.restoreWin;case 2:return!!t.minimizeWin;case 3:return!!t.setWinPosition;case 4:return!!t.setWinSizePixels;case 5:return!!t.raiseWin;case 6:return!!t.lowerWin;case 7:return!!t.refreshWin;case 8:return!!t.setWinSizeChars;case 9:return!!t.maximizeWin;case 10:return!!t.fullscreenWin;case 11:return!!t.getWinState;case 13:return!!t.getWinPosition;case 14:return!!t.getWinSizePixels;case 15:return!!t.getScreenSizePixels;case 16:return!!t.getCellSizePixels;case 18:return!!t.getWinSizeChars;case 19:return!!t.getScreenSizeChars;case 20:return!!t.getIconTitle;case 21:return!!t.getWinTitle;case 22:return!!t.pushTitle;case 23:return!!t.popTitle;case 24:return!!t.setWinLines}return!1}var vl=5e3,gl=0,vn=class extends D{constructor(e,i,r,n,o,l,a,u,h=new bn){super();this._bufferService=e;this._charsetService=i;this._coreService=r;this._logService=n;this._optionsService=o;this._oscLinkService=l;this._coreMouseService=a;this._unicodeService=u;this._parser=h;this._parseBuffer=new Uint32Array(4096);this._stringDecoder=new er;this._utf8Decoder=new tr;this._windowTitle=\"\";this._iconName=\"\";this._windowTitleStack=[];this._iconNameStack=[];this._curAttrData=X.clone();this._eraseAttrDataInternal=X.clone();this._onRequestBell=this._register(new v);this.onRequestBell=this._onRequestBell.event;this._onRequestRefreshRows=this._register(new v);this.onRequestRefreshRows=this._onRequestRefreshRows.event;this._onRequestReset=this._register(new v);this.onRequestReset=this._onRequestReset.event;this._onRequestSendFocus=this._register(new v);this.onRequestSendFocus=this._onRequestSendFocus.event;this._onRequestSyncScrollBar=this._register(new v);this.onRequestSyncScrollBar=this._onRequestSyncScrollBar.event;this._onRequestWindowsOptionsReport=this._register(new v);this.onRequestWindowsOptionsReport=this._onRequestWindowsOptionsReport.event;this._onA11yChar=this._register(new v);this.onA11yChar=this._onA11yChar.event;this._onA11yTab=this._register(new v);this.onA11yTab=this._onA11yTab.event;this._onCursorMove=this._register(new v);this.onCursorMove=this._onCursorMove.event;this._onLineFeed=this._register(new v);this.onLineFeed=this._onLineFeed.event;this._onScroll=this._register(new v);this.onScroll=this._onScroll.event;this._onTitleChange=this._register(new v);this.onTitleChange=this._onTitleChange.event;this._onColor=this._register(new v);this.onColor=this._onColor.event;this._parseStack={paused:!1,cursorStartX:0,cursorStartY:0,decodedLength:0,position:0};this._specialColors=[256,257,258];this._register(this._parser),this._dirtyRowTracker=new Zi(this._bufferService),this._activeBuffer=this._bufferService.buffer,this._register(this._bufferService.buffers.onBufferActivate(c=>this._activeBuffer=c.activeBuffer)),this._parser.setCsiHandlerFallback((c,d)=>{this._logService.debug(\"Unknown CSI code: \",{identifier:this._parser.identToString(c),params:d.toArray()})}),this._parser.setEscHandlerFallback(c=>{this._logService.debug(\"Unknown ESC code: \",{identifier:this._parser.identToString(c)})}),this._parser.setExecuteHandlerFallback(c=>{this._logService.debug(\"Unknown EXECUTE code: \",{code:c})}),this._parser.setOscHandlerFallback((c,d,_)=>{this._logService.debug(\"Unknown OSC code: \",{identifier:c,action:d,data:_})}),this._parser.setDcsHandlerFallback((c,d,_)=>{d===\"HOOK\"&&(_=_.toArray()),this._logService.debug(\"Unknown DCS code: \",{identifier:this._parser.identToString(c),action:d,payload:_})}),this._parser.setPrintHandler((c,d,_)=>this.print(c,d,_)),this._parser.registerCsiHandler({final:\"@\"},c=>this.insertChars(c)),this._parser.registerCsiHandler({intermediates:\" \",final:\"@\"},c=>this.scrollLeft(c)),this._parser.registerCsiHandler({final:\"A\"},c=>this.cursorUp(c)),this._parser.registerCsiHandler({intermediates:\" \",final:\"A\"},c=>this.scrollRight(c)),this._parser.registerCsiHandler({final:\"B\"},c=>this.cursorDown(c)),this._parser.registerCsiHandler({final:\"C\"},c=>this.cursorForward(c)),this._parser.registerCsiHandler({final:\"D\"},c=>this.cursorBackward(c)),this._parser.registerCsiHandler({final:\"E\"},c=>this.cursorNextLine(c)),this._parser.registerCsiHandler({final:\"F\"},c=>this.cursorPrecedingLine(c)),this._parser.registerCsiHandler({final:\"G\"},c=>this.cursorCharAbsolute(c)),this._parser.registerCsiHandler({final:\"H\"},c=>this.cursorPosition(c)),this._parser.registerCsiHandler({final:\"I\"},c=>this.cursorForwardTab(c)),this._parser.registerCsiHandler({final:\"J\"},c=>this.eraseInDisplay(c,!1)),this._parser.registerCsiHandler({prefix:\"?\",final:\"J\"},c=>this.eraseInDisplay(c,!0)),this._parser.registerCsiHandler({final:\"K\"},c=>this.eraseInLine(c,!1)),this._parser.registerCsiHandler({prefix:\"?\",final:\"K\"},c=>this.eraseInLine(c,!0)),this._parser.registerCsiHandler({final:\"L\"},c=>this.insertLines(c)),this._parser.registerCsiHandler({final:\"M\"},c=>this.deleteLines(c)),this._parser.registerCsiHandler({final:\"P\"},c=>this.deleteChars(c)),this._parser.registerCsiHandler({final:\"S\"},c=>this.scrollUp(c)),this._parser.registerCsiHandler({final:\"T\"},c=>this.scrollDown(c)),this._parser.registerCsiHandler({final:\"X\"},c=>this.eraseChars(c)),this._parser.registerCsiHandler({final:\"Z\"},c=>this.cursorBackwardTab(c)),this._parser.registerCsiHandler({final:\"`\"},c=>this.charPosAbsolute(c)),this._parser.registerCsiHandler({final:\"a\"},c=>this.hPositionRelative(c)),this._parser.registerCsiHandler({final:\"b\"},c=>this.repeatPrecedingCharacter(c)),this._parser.registerCsiHandler({final:\"c\"},c=>this.sendDeviceAttributesPrimary(c)),this._parser.registerCsiHandler({prefix:\">\",final:\"c\"},c=>this.sendDeviceAttributesSecondary(c)),this._parser.registerCsiHandler({final:\"d\"},c=>this.linePosAbsolute(c)),this._parser.registerCsiHandler({final:\"e\"},c=>this.vPositionRelative(c)),this._parser.registerCsiHandler({final:\"f\"},c=>this.hVPosition(c)),this._parser.registerCsiHandler({final:\"g\"},c=>this.tabClear(c)),this._parser.registerCsiHandler({final:\"h\"},c=>this.setMode(c)),this._parser.registerCsiHandler({prefix:\"?\",final:\"h\"},c=>this.setModePrivate(c)),this._parser.registerCsiHandler({final:\"l\"},c=>this.resetMode(c)),this._parser.registerCsiHandler({prefix:\"?\",final:\"l\"},c=>this.resetModePrivate(c)),this._parser.registerCsiHandler({final:\"m\"},c=>this.charAttributes(c)),this._parser.registerCsiHandler({final:\"n\"},c=>this.deviceStatus(c)),this._parser.registerCsiHandler({prefix:\"?\",final:\"n\"},c=>this.deviceStatusPrivate(c)),this._parser.registerCsiHandler({intermediates:\"!\",final:\"p\"},c=>this.softReset(c)),this._parser.registerCsiHandler({intermediates:\" \",final:\"q\"},c=>this.setCursorStyle(c)),this._parser.registerCsiHandler({final:\"r\"},c=>this.setScrollRegion(c)),this._parser.registerCsiHandler({final:\"s\"},c=>this.saveCursor(c)),this._parser.registerCsiHandler({final:\"t\"},c=>this.windowOptions(c)),this._parser.registerCsiHandler({final:\"u\"},c=>this.restoreCursor(c)),this._parser.registerCsiHandler({intermediates:\"'\",final:\"}\"},c=>this.insertColumns(c)),this._parser.registerCsiHandler({intermediates:\"'\",final:\"~\"},c=>this.deleteColumns(c)),this._parser.registerCsiHandler({intermediates:'\"',final:\"q\"},c=>this.selectProtected(c)),this._parser.registerCsiHandler({intermediates:\"$\",final:\"p\"},c=>this.requestMode(c,!0)),this._parser.registerCsiHandler({prefix:\"?\",intermediates:\"$\",final:\"p\"},c=>this.requestMode(c,!1)),this._parser.setExecuteHandler(b.BEL,()=>this.bell()),this._parser.setExecuteHandler(b.LF,()=>this.lineFeed()),this._parser.setExecuteHandler(b.VT,()=>this.lineFeed()),this._parser.setExecuteHandler(b.FF,()=>this.lineFeed()),this._parser.setExecuteHandler(b.CR,()=>this.carriageReturn()),this._parser.setExecuteHandler(b.BS,()=>this.backspace()),this._parser.setExecuteHandler(b.HT,()=>this.tab()),this._parser.setExecuteHandler(b.SO,()=>this.shiftOut()),this._parser.setExecuteHandler(b.SI,()=>this.shiftIn()),this._parser.setExecuteHandler(Ai.IND,()=>this.index()),this._parser.setExecuteHandler(Ai.NEL,()=>this.nextLine()),this._parser.setExecuteHandler(Ai.HTS,()=>this.tabSet()),this._parser.registerOscHandler(0,new pe(c=>(this.setTitle(c),this.setIconName(c),!0))),this._parser.registerOscHandler(1,new pe(c=>this.setIconName(c))),this._parser.registerOscHandler(2,new pe(c=>this.setTitle(c))),this._parser.registerOscHandler(4,new pe(c=>this.setOrReportIndexedColor(c))),this._parser.registerOscHandler(8,new pe(c=>this.setHyperlink(c))),this._parser.registerOscHandler(10,new pe(c=>this.setOrReportFgColor(c))),this._parser.registerOscHandler(11,new pe(c=>this.setOrReportBgColor(c))),this._parser.registerOscHandler(12,new pe(c=>this.setOrReportCursorColor(c))),this._parser.registerOscHandler(104,new pe(c=>this.restoreIndexedColor(c))),this._parser.registerOscHandler(110,new pe(c=>this.restoreFgColor(c))),this._parser.registerOscHandler(111,new pe(c=>this.restoreBgColor(c))),this._parser.registerOscHandler(112,new pe(c=>this.restoreCursorColor(c))),this._parser.registerEscHandler({final:\"7\"},()=>this.saveCursor()),this._parser.registerEscHandler({final:\"8\"},()=>this.restoreCursor()),this._parser.registerEscHandler({final:\"D\"},()=>this.index()),this._parser.registerEscHandler({final:\"E\"},()=>this.nextLine()),this._parser.registerEscHandler({final:\"H\"},()=>this.tabSet()),this._parser.registerEscHandler({final:\"M\"},()=>this.reverseIndex()),this._parser.registerEscHandler({final:\"=\"},()=>this.keypadApplicationMode()),this._parser.registerEscHandler({final:\">\"},()=>this.keypadNumericMode()),this._parser.registerEscHandler({final:\"c\"},()=>this.fullReset()),this._parser.registerEscHandler({final:\"n\"},()=>this.setgLevel(2)),this._parser.registerEscHandler({final:\"o\"},()=>this.setgLevel(3)),this._parser.registerEscHandler({final:\"|\"},()=>this.setgLevel(3)),this._parser.registerEscHandler({final:\"}\"},()=>this.setgLevel(2)),this._parser.registerEscHandler({final:\"~\"},()=>this.setgLevel(1)),this._parser.registerEscHandler({intermediates:\"%\",final:\"@\"},()=>this.selectDefaultCharset()),this._parser.registerEscHandler({intermediates:\"%\",final:\"G\"},()=>this.selectDefaultCharset());for(let c in ne)this._parser.registerEscHandler({intermediates:\"(\",final:c},()=>this.selectCharset(\"(\"+c)),this._parser.registerEscHandler({intermediates:\")\",final:c},()=>this.selectCharset(\")\"+c)),this._parser.registerEscHandler({intermediates:\"*\",final:c},()=>this.selectCharset(\"*\"+c)),this._parser.registerEscHandler({intermediates:\"+\",final:c},()=>this.selectCharset(\"+\"+c)),this._parser.registerEscHandler({intermediates:\"-\",final:c},()=>this.selectCharset(\"-\"+c)),this._parser.registerEscHandler({intermediates:\".\",final:c},()=>this.selectCharset(\".\"+c)),this._parser.registerEscHandler({intermediates:\"/\",final:c},()=>this.selectCharset(\"/\"+c));this._parser.registerEscHandler({intermediates:\"#\",final:\"8\"},()=>this.screenAlignmentPattern()),this._parser.setErrorHandler(c=>(this._logService.error(\"Parsing error: \",c),c)),this._parser.registerDcsHandler({intermediates:\"$\",final:\"q\"},new Xi((c,d)=>this.requestStatusString(c,d)))}getAttrData(){return this._curAttrData}_preserveStack(e,i,r,n){this._parseStack.paused=!0,this._parseStack.cursorStartX=e,this._parseStack.cursorStartY=i,this._parseStack.decodedLength=r,this._parseStack.position=n}_logSlowResolvingAsync(e){this._logService.logLevel<=3&&Promise.race([e,new Promise((i,r)=>setTimeout(()=>r(\"#SLOW_TIMEOUT\"),vl))]).catch(i=>{if(i!==\"#SLOW_TIMEOUT\")throw i;console.warn(`async parser handler taking longer than ${vl} ms`)})}_getCurrentLinkId(){return this._curAttrData.extended.urlId}parse(e,i){let r,n=this._activeBuffer.x,o=this._activeBuffer.y,l=0,a=this._parseStack.paused;if(a){if(r=this._parser.parse(this._parseBuffer,this._parseStack.decodedLength,i))return this._logSlowResolvingAsync(r),r;n=this._parseStack.cursorStartX,o=this._parseStack.cursorStartY,this._parseStack.paused=!1,e.length>ut&&(l=this._parseStack.position+ut)}if(this._logService.logLevel<=1&&this._logService.debug(`parsing data ${typeof e==\"string\"?` \"${e}\"`:` \"${Array.prototype.map.call(e,c=>String.fromCharCode(c)).join(\"\")}\"`}`),this._logService.logLevel===0&&this._logService.trace(\"parsing data (codes)\",typeof e==\"string\"?e.split(\"\").map(c=>c.charCodeAt(0)):e),this._parseBuffer.length<e.length&&this._parseBuffer.length<ut&&(this._parseBuffer=new Uint32Array(Math.min(e.length,ut))),a||this._dirtyRowTracker.clearRange(),e.length>ut)for(let c=l;c<e.length;c+=ut){let d=c+ut<e.length?c+ut:e.length,_=typeof e==\"string\"?this._stringDecoder.decode(e.substring(c,d),this._parseBuffer):this._utf8Decoder.decode(e.subarray(c,d),this._parseBuffer);if(r=this._parser.parse(this._parseBuffer,_))return this._preserveStack(n,o,_,c),this._logSlowResolvingAsync(r),r}else if(!a){let c=typeof e==\"string\"?this._stringDecoder.decode(e,this._parseBuffer):this._utf8Decoder.decode(e,this._parseBuffer);if(r=this._parser.parse(this._parseBuffer,c))return this._preserveStack(n,o,c,0),this._logSlowResolvingAsync(r),r}(this._activeBuffer.x!==n||this._activeBuffer.y!==o)&&this._onCursorMove.fire();let u=this._dirtyRowTracker.end+(this._bufferService.buffer.ybase-this._bufferService.buffer.ydisp),h=this._dirtyRowTracker.start+(this._bufferService.buffer.ybase-this._bufferService.buffer.ydisp);h<this._bufferService.rows&&this._onRequestRefreshRows.fire({start:Math.min(h,this._bufferService.rows-1),end:Math.min(u,this._bufferService.rows-1)})}print(e,i,r){let n,o,l=this._charsetService.charset,a=this._optionsService.rawOptions.screenReaderMode,u=this._bufferService.cols,h=this._coreService.decPrivateModes.wraparound,c=this._coreService.modes.insertMode,d=this._curAttrData,_=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y);this._dirtyRowTracker.markDirty(this._activeBuffer.y),this._activeBuffer.x&&r-i>0&&_.getWidth(this._activeBuffer.x-1)===2&&_.setCellFromCodepoint(this._activeBuffer.x-1,0,1,d);let p=this._parser.precedingJoinState;for(let m=i;m<r;++m){if(n=e[m],n<127&&l){let O=l[String.fromCharCode(n)];O&&(n=O.charCodeAt(0))}let f=this._unicodeService.charProperties(n,p);o=Ae.extractWidth(f);let A=Ae.extractShouldJoin(f),R=A?Ae.extractWidth(p):0;if(p=f,a&&this._onA11yChar.fire(Ce(n)),this._getCurrentLinkId()&&this._oscLinkService.addLineToLink(this._getCurrentLinkId(),this._activeBuffer.ybase+this._activeBuffer.y),this._activeBuffer.x+o-R>u){if(h){let O=_,I=this._activeBuffer.x-R;for(this._activeBuffer.x=R,this._activeBuffer.y++,this._activeBuffer.y===this._activeBuffer.scrollBottom+1?(this._activeBuffer.y--,this._bufferService.scroll(this._eraseAttrData(),!0)):(this._activeBuffer.y>=this._bufferService.rows&&(this._activeBuffer.y=this._bufferService.rows-1),this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y).isWrapped=!0),_=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y),R>0&&_ instanceof Ze&&_.copyCellsFrom(O,I,0,R,!1);I<u;)O.setCellFromCodepoint(I++,0,1,d)}else if(this._activeBuffer.x=u-1,o===2)continue}if(A&&this._activeBuffer.x){let O=_.getWidth(this._activeBuffer.x-1)?1:2;_.addCodepointToCell(this._activeBuffer.x-O,n,o);for(let I=o-R;--I>=0;)_.setCellFromCodepoint(this._activeBuffer.x++,0,0,d);continue}if(c&&(_.insertCells(this._activeBuffer.x,o-R,this._activeBuffer.getNullCell(d)),_.getWidth(u-1)===2&&_.setCellFromCodepoint(u-1,0,1,d)),_.setCellFromCodepoint(this._activeBuffer.x++,n,o,d),o>0)for(;--o;)_.setCellFromCodepoint(this._activeBuffer.x++,0,0,d)}this._parser.precedingJoinState=p,this._activeBuffer.x<u&&r-i>0&&_.getWidth(this._activeBuffer.x)===0&&!_.hasContent(this._activeBuffer.x)&&_.setCellFromCodepoint(this._activeBuffer.x,0,1,d),this._dirtyRowTracker.markDirty(this._activeBuffer.y)}registerCsiHandler(e,i){return e.final===\"t\"&&!e.prefix&&!e.intermediates?this._parser.registerCsiHandler(e,r=>bl(r.params[0],this._optionsService.rawOptions.windowOptions)?i(r):!0):this._parser.registerCsiHandler(e,i)}registerDcsHandler(e,i){return this._parser.registerDcsHandler(e,new Xi(i))}registerEscHandler(e,i){return this._parser.registerEscHandler(e,i)}registerOscHandler(e,i){return this._parser.registerOscHandler(e,new pe(i))}bell(){return this._onRequestBell.fire(),!0}lineFeed(){return this._dirtyRowTracker.markDirty(this._activeBuffer.y),this._optionsService.rawOptions.convertEol&&(this._activeBuffer.x=0),this._activeBuffer.y++,this._activeBuffer.y===this._activeBuffer.scrollBottom+1?(this._activeBuffer.y--,this._bufferService.scroll(this._eraseAttrData())):this._activeBuffer.y>=this._bufferService.rows?this._activeBuffer.y=this._bufferService.rows-1:this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y).isWrapped=!1,this._activeBuffer.x>=this._bufferService.cols&&this._activeBuffer.x--,this._dirtyRowTracker.markDirty(this._activeBuffer.y),this._onLineFeed.fire(),!0}carriageReturn(){return this._activeBuffer.x=0,!0}backspace(){if(!this._coreService.decPrivateModes.reverseWraparound)return this._restrictCursor(),this._activeBuffer.x>0&&this._activeBuffer.x--,!0;if(this._restrictCursor(this._bufferService.cols),this._activeBuffer.x>0)this._activeBuffer.x--;else if(this._activeBuffer.x===0&&this._activeBuffer.y>this._activeBuffer.scrollTop&&this._activeBuffer.y<=this._activeBuffer.scrollBottom&&this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y)?.isWrapped){this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y).isWrapped=!1,this._activeBuffer.y--,this._activeBuffer.x=this._bufferService.cols-1;let e=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y);e.hasWidth(this._activeBuffer.x)&&!e.hasContent(this._activeBuffer.x)&&this._activeBuffer.x--}return this._restrictCursor(),!0}tab(){if(this._activeBuffer.x>=this._bufferService.cols)return!0;let e=this._activeBuffer.x;return this._activeBuffer.x=this._activeBuffer.nextStop(),this._optionsService.rawOptions.screenReaderMode&&this._onA11yTab.fire(this._activeBuffer.x-e),!0}shiftOut(){return this._charsetService.setgLevel(1),!0}shiftIn(){return this._charsetService.setgLevel(0),!0}_restrictCursor(e=this._bufferService.cols-1){this._activeBuffer.x=Math.min(e,Math.max(0,this._activeBuffer.x)),this._activeBuffer.y=this._coreService.decPrivateModes.origin?Math.min(this._activeBuffer.scrollBottom,Math.max(this._activeBuffer.scrollTop,this._activeBuffer.y)):Math.min(this._bufferService.rows-1,Math.max(0,this._activeBuffer.y)),this._dirtyRowTracker.markDirty(this._activeBuffer.y)}_setCursor(e,i){this._dirtyRowTracker.markDirty(this._activeBuffer.y),this._coreService.decPrivateModes.origin?(this._activeBuffer.x=e,this._activeBuffer.y=this._activeBuffer.scrollTop+i):(this._activeBuffer.x=e,this._activeBuffer.y=i),this._restrictCursor(),this._dirtyRowTracker.markDirty(this._activeBuffer.y)}_moveCursor(e,i){this._restrictCursor(),this._setCursor(this._activeBuffer.x+e,this._activeBuffer.y+i)}cursorUp(e){let i=this._activeBuffer.y-this._activeBuffer.scrollTop;return i>=0?this._moveCursor(0,-Math.min(i,e.params[0]||1)):this._moveCursor(0,-(e.params[0]||1)),!0}cursorDown(e){let i=this._activeBuffer.scrollBottom-this._activeBuffer.y;return i>=0?this._moveCursor(0,Math.min(i,e.params[0]||1)):this._moveCursor(0,e.params[0]||1),!0}cursorForward(e){return this._moveCursor(e.params[0]||1,0),!0}cursorBackward(e){return this._moveCursor(-(e.params[0]||1),0),!0}cursorNextLine(e){return this.cursorDown(e),this._activeBuffer.x=0,!0}cursorPrecedingLine(e){return this.cursorUp(e),this._activeBuffer.x=0,!0}cursorCharAbsolute(e){return this._setCursor((e.params[0]||1)-1,this._activeBuffer.y),!0}cursorPosition(e){return this._setCursor(e.length>=2?(e.params[1]||1)-1:0,(e.params[0]||1)-1),!0}charPosAbsolute(e){return this._setCursor((e.params[0]||1)-1,this._activeBuffer.y),!0}hPositionRelative(e){return this._moveCursor(e.params[0]||1,0),!0}linePosAbsolute(e){return this._setCursor(this._activeBuffer.x,(e.params[0]||1)-1),!0}vPositionRelative(e){return this._moveCursor(0,e.params[0]||1),!0}hVPosition(e){return this.cursorPosition(e),!0}tabClear(e){let i=e.params[0];return i===0?delete this._activeBuffer.tabs[this._activeBuffer.x]:i===3&&(this._activeBuffer.tabs={}),!0}cursorForwardTab(e){if(this._activeBuffer.x>=this._bufferService.cols)return!0;let i=e.params[0]||1;for(;i--;)this._activeBuffer.x=this._activeBuffer.nextStop();return!0}cursorBackwardTab(e){if(this._activeBuffer.x>=this._bufferService.cols)return!0;let i=e.params[0]||1;for(;i--;)this._activeBuffer.x=this._activeBuffer.prevStop();return!0}selectProtected(e){let i=e.params[0];return i===1&&(this._curAttrData.bg|=536870912),(i===2||i===0)&&(this._curAttrData.bg&=-536870913),!0}_eraseInBufferLine(e,i,r,n=!1,o=!1){let l=this._activeBuffer.lines.get(this._activeBuffer.ybase+e);l.replaceCells(i,r,this._activeBuffer.getNullCell(this._eraseAttrData()),o),n&&(l.isWrapped=!1)}_resetBufferLine(e,i=!1){let r=this._activeBuffer.lines.get(this._activeBuffer.ybase+e);r&&(r.fill(this._activeBuffer.getNullCell(this._eraseAttrData()),i),this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase+e),r.isWrapped=!1)}eraseInDisplay(e,i=!1){this._restrictCursor(this._bufferService.cols);let r;switch(e.params[0]){case 0:for(r=this._activeBuffer.y,this._dirtyRowTracker.markDirty(r),this._eraseInBufferLine(r++,this._activeBuffer.x,this._bufferService.cols,this._activeBuffer.x===0,i);r<this._bufferService.rows;r++)this._resetBufferLine(r,i);this._dirtyRowTracker.markDirty(r);break;case 1:for(r=this._activeBuffer.y,this._dirtyRowTracker.markDirty(r),this._eraseInBufferLine(r,0,this._activeBuffer.x+1,!0,i),this._activeBuffer.x+1>=this._bufferService.cols&&(this._activeBuffer.lines.get(r+1).isWrapped=!1);r--;)this._resetBufferLine(r,i);this._dirtyRowTracker.markDirty(0);break;case 2:if(this._optionsService.rawOptions.scrollOnEraseInDisplay){for(r=this._bufferService.rows,this._dirtyRowTracker.markRangeDirty(0,r-1);r--&&!this._activeBuffer.lines.get(this._activeBuffer.ybase+r)?.getTrimmedLength(););for(;r>=0;r--)this._bufferService.scroll(this._eraseAttrData())}else{for(r=this._bufferService.rows,this._dirtyRowTracker.markDirty(r-1);r--;)this._resetBufferLine(r,i);this._dirtyRowTracker.markDirty(0)}break;case 3:let n=this._activeBuffer.lines.length-this._bufferService.rows;n>0&&(this._activeBuffer.lines.trimStart(n),this._activeBuffer.ybase=Math.max(this._activeBuffer.ybase-n,0),this._activeBuffer.ydisp=Math.max(this._activeBuffer.ydisp-n,0),this._onScroll.fire(0));break}return!0}eraseInLine(e,i=!1){switch(this._restrictCursor(this._bufferService.cols),e.params[0]){case 0:this._eraseInBufferLine(this._activeBuffer.y,this._activeBuffer.x,this._bufferService.cols,this._activeBuffer.x===0,i);break;case 1:this._eraseInBufferLine(this._activeBuffer.y,0,this._activeBuffer.x+1,!1,i);break;case 2:this._eraseInBufferLine(this._activeBuffer.y,0,this._bufferService.cols,!0,i);break}return this._dirtyRowTracker.markDirty(this._activeBuffer.y),!0}insertLines(e){this._restrictCursor();let i=e.params[0]||1;if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let r=this._activeBuffer.ybase+this._activeBuffer.y,n=this._bufferService.rows-1-this._activeBuffer.scrollBottom,o=this._bufferService.rows-1+this._activeBuffer.ybase-n+1;for(;i--;)this._activeBuffer.lines.splice(o-1,1),this._activeBuffer.lines.splice(r,0,this._activeBuffer.getBlankLine(this._eraseAttrData()));return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y,this._activeBuffer.scrollBottom),this._activeBuffer.x=0,!0}deleteLines(e){this._restrictCursor();let i=e.params[0]||1;if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let r=this._activeBuffer.ybase+this._activeBuffer.y,n;for(n=this._bufferService.rows-1-this._activeBuffer.scrollBottom,n=this._bufferService.rows-1+this._activeBuffer.ybase-n;i--;)this._activeBuffer.lines.splice(r,1),this._activeBuffer.lines.splice(n,0,this._activeBuffer.getBlankLine(this._eraseAttrData()));return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y,this._activeBuffer.scrollBottom),this._activeBuffer.x=0,!0}insertChars(e){this._restrictCursor();let i=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y);return i&&(i.insertCells(this._activeBuffer.x,e.params[0]||1,this._activeBuffer.getNullCell(this._eraseAttrData())),this._dirtyRowTracker.markDirty(this._activeBuffer.y)),!0}deleteChars(e){this._restrictCursor();let i=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y);return i&&(i.deleteCells(this._activeBuffer.x,e.params[0]||1,this._activeBuffer.getNullCell(this._eraseAttrData())),this._dirtyRowTracker.markDirty(this._activeBuffer.y)),!0}scrollUp(e){let i=e.params[0]||1;for(;i--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase+this._activeBuffer.scrollTop,1),this._activeBuffer.lines.splice(this._activeBuffer.ybase+this._activeBuffer.scrollBottom,0,this._activeBuffer.getBlankLine(this._eraseAttrData()));return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}scrollDown(e){let i=e.params[0]||1;for(;i--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase+this._activeBuffer.scrollBottom,1),this._activeBuffer.lines.splice(this._activeBuffer.ybase+this._activeBuffer.scrollTop,0,this._activeBuffer.getBlankLine(X));return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}scrollLeft(e){if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let i=e.params[0]||1;for(let r=this._activeBuffer.scrollTop;r<=this._activeBuffer.scrollBottom;++r){let n=this._activeBuffer.lines.get(this._activeBuffer.ybase+r);n.deleteCells(0,i,this._activeBuffer.getNullCell(this._eraseAttrData())),n.isWrapped=!1}return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}scrollRight(e){if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let i=e.params[0]||1;for(let r=this._activeBuffer.scrollTop;r<=this._activeBuffer.scrollBottom;++r){let n=this._activeBuffer.lines.get(this._activeBuffer.ybase+r);n.insertCells(0,i,this._activeBuffer.getNullCell(this._eraseAttrData())),n.isWrapped=!1}return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}insertColumns(e){if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let i=e.params[0]||1;for(let r=this._activeBuffer.scrollTop;r<=this._activeBuffer.scrollBottom;++r){let n=this._activeBuffer.lines.get(this._activeBuffer.ybase+r);n.insertCells(this._activeBuffer.x,i,this._activeBuffer.getNullCell(this._eraseAttrData())),n.isWrapped=!1}return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}deleteColumns(e){if(this._activeBuffer.y>this._activeBuffer.scrollBottom||this._activeBuffer.y<this._activeBuffer.scrollTop)return!0;let i=e.params[0]||1;for(let r=this._activeBuffer.scrollTop;r<=this._activeBuffer.scrollBottom;++r){let n=this._activeBuffer.lines.get(this._activeBuffer.ybase+r);n.deleteCells(this._activeBuffer.x,i,this._activeBuffer.getNullCell(this._eraseAttrData())),n.isWrapped=!1}return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom),!0}eraseChars(e){this._restrictCursor();let i=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y);return i&&(i.replaceCells(this._activeBuffer.x,this._activeBuffer.x+(e.params[0]||1),this._activeBuffer.getNullCell(this._eraseAttrData())),this._dirtyRowTracker.markDirty(this._activeBuffer.y)),!0}repeatPrecedingCharacter(e){let i=this._parser.precedingJoinState;if(!i)return!0;let r=e.params[0]||1,n=Ae.extractWidth(i),o=this._activeBuffer.x-n,a=this._activeBuffer.lines.get(this._activeBuffer.ybase+this._activeBuffer.y).getString(o),u=new Uint32Array(a.length*r),h=0;for(let d=0;d<a.length;){let _=a.codePointAt(d)||0;u[h++]=_,d+=_>65535?2:1}let c=h;for(let d=1;d<r;++d)u.copyWithin(c,0,h),c+=h;return this.print(u,0,c),!0}sendDeviceAttributesPrimary(e){return e.params[0]>0||(this._is(\"xterm\")||this._is(\"rxvt-unicode\")||this._is(\"screen\")?this._coreService.triggerDataEvent(b.ESC+\"[?1;2c\"):this._is(\"linux\")&&this._coreService.triggerDataEvent(b.ESC+\"[?6c\")),!0}sendDeviceAttributesSecondary(e){return e.params[0]>0||(this._is(\"xterm\")?this._coreService.triggerDataEvent(b.ESC+\"[>0;276;0c\"):this._is(\"rxvt-unicode\")?this._coreService.triggerDataEvent(b.ESC+\"[>85;95;0c\"):this._is(\"linux\")?this._coreService.triggerDataEvent(e.params[0]+\"c\"):this._is(\"screen\")&&this._coreService.triggerDataEvent(b.ESC+\"[>83;40003;0c\")),!0}_is(e){return(this._optionsService.rawOptions.termName+\"\").indexOf(e)===0}setMode(e){for(let i=0;i<e.length;i++)switch(e.params[i]){case 4:this._coreService.modes.insertMode=!0;break;case 20:this._optionsService.options.convertEol=!0;break}return!0}setModePrivate(e){for(let i=0;i<e.length;i++)switch(e.params[i]){case 1:this._coreService.decPrivateModes.applicationCursorKeys=!0;break;case 2:this._charsetService.setgCharset(0,Je),this._charsetService.setgCharset(1,Je),this._charsetService.setgCharset(2,Je),this._charsetService.setgCharset(3,Je);break;case 3:this._optionsService.rawOptions.windowOptions.setWinLines&&(this._bufferService.resize(132,this._bufferService.rows),this._onRequestReset.fire());break;case 6:this._coreService.decPrivateModes.origin=!0,this._setCursor(0,0);break;case 7:this._coreService.decPrivateModes.wraparound=!0;break;case 12:this._optionsService.options.cursorBlink=!0;break;case 45:this._coreService.decPrivateModes.reverseWraparound=!0;break;case 66:this._logService.debug(\"Serial port requested application keypad.\"),this._coreService.decPrivateModes.applicationKeypad=!0,this._onRequestSyncScrollBar.fire();break;case 9:this._coreMouseService.activeProtocol=\"X10\";break;case 1e3:this._coreMouseService.activeProtocol=\"VT200\";break;case 1002:this._coreMouseService.activeProtocol=\"DRAG\";break;case 1003:this._coreMouseService.activeProtocol=\"ANY\";break;case 1004:this._coreService.decPrivateModes.sendFocus=!0,this._onRequestSendFocus.fire();break;case 1005:this._logService.debug(\"DECSET 1005 not supported (see #2507)\");break;case 1006:this._coreMouseService.activeEncoding=\"SGR\";break;case 1015:this._logService.debug(\"DECSET 1015 not supported (see #2507)\");break;case 1016:this._coreMouseService.activeEncoding=\"SGR_PIXELS\";break;case 25:this._coreService.isCursorHidden=!1;break;case 1048:this.saveCursor();break;case 1049:this.saveCursor();case 47:case 1047:this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()),this._coreService.isCursorInitialized=!0,this._onRequestRefreshRows.fire(void 0),this._onRequestSyncScrollBar.fire();break;case 2004:this._coreService.decPrivateModes.bracketedPasteMode=!0;break;case 2026:this._coreService.decPrivateModes.synchronizedOutput=!0;break}return!0}resetMode(e){for(let i=0;i<e.length;i++)switch(e.params[i]){case 4:this._coreService.modes.insertMode=!1;break;case 20:this._optionsService.options.convertEol=!1;break}return!0}resetModePrivate(e){for(let i=0;i<e.length;i++)switch(e.params[i]){case 1:this._coreService.decPrivateModes.applicationCursorKeys=!1;break;case 3:this._optionsService.rawOptions.windowOptions.setWinLines&&(this._bufferService.resize(80,this._bufferService.rows),this._onRequestReset.fire());break;case 6:this._coreService.decPrivateModes.origin=!1,this._setCursor(0,0);break;case 7:this._coreService.decPrivateModes.wraparound=!1;break;case 12:this._optionsService.options.cursorBlink=!1;break;case 45:this._coreService.decPrivateModes.reverseWraparound=!1;break;case 66:this._logService.debug(\"Switching back to normal keypad.\"),this._coreService.decPrivateModes.applicationKeypad=!1,this._onRequestSyncScrollBar.fire();break;case 9:case 1e3:case 1002:case 1003:this._coreMouseService.activeProtocol=\"NONE\";break;case 1004:this._coreService.decPrivateModes.sendFocus=!1;break;case 1005:this._logService.debug(\"DECRST 1005 not supported (see #2507)\");break;case 1006:this._coreMouseService.activeEncoding=\"DEFAULT\";break;case 1015:this._logService.debug(\"DECRST 1015 not supported (see #2507)\");break;case 1016:this._coreMouseService.activeEncoding=\"DEFAULT\";break;case 25:this._coreService.isCursorHidden=!0;break;case 1048:this.restoreCursor();break;case 1049:case 47:case 1047:this._bufferService.buffers.activateNormalBuffer(),e.params[i]===1049&&this.restoreCursor(),this._coreService.isCursorInitialized=!0,this._onRequestRefreshRows.fire(void 0),this._onRequestSyncScrollBar.fire();break;case 2004:this._coreService.decPrivateModes.bracketedPasteMode=!1;break;case 2026:this._coreService.decPrivateModes.synchronizedOutput=!1,this._onRequestRefreshRows.fire(void 0);break}return!0}requestMode(e,i){let r;(P=>(P[P.NOT_RECOGNIZED=0]=\"NOT_RECOGNIZED\",P[P.SET=1]=\"SET\",P[P.RESET=2]=\"RESET\",P[P.PERMANENTLY_SET=3]=\"PERMANENTLY_SET\",P[P.PERMANENTLY_RESET=4]=\"PERMANENTLY_RESET\"))(r||={});let n=this._coreService.decPrivateModes,{activeProtocol:o,activeEncoding:l}=this._coreMouseService,a=this._coreService,{buffers:u,cols:h}=this._bufferService,{active:c,alt:d}=u,_=this._optionsService.rawOptions,p=(A,R)=>(a.triggerDataEvent(`${b.ESC}[${i?\"\":\"?\"}${A};${R}$y`),!0),m=A=>A?1:2,f=e.params[0];return i?f===2?p(f,4):f===4?p(f,m(a.modes.insertMode)):f===12?p(f,3):f===20?p(f,m(_.convertEol)):p(f,0):f===1?p(f,m(n.applicationCursorKeys)):f===3?p(f,_.windowOptions.setWinLines?h===80?2:h===132?1:0:0):f===6?p(f,m(n.origin)):f===7?p(f,m(n.wraparound)):f===8?p(f,3):f===9?p(f,m(o===\"X10\")):f===12?p(f,m(_.cursorBlink)):f===25?p(f,m(!a.isCursorHidden)):f===45?p(f,m(n.reverseWraparound)):f===66?p(f,m(n.applicationKeypad)):f===67?p(f,4):f===1e3?p(f,m(o===\"VT200\")):f===1002?p(f,m(o===\"DRAG\")):f===1003?p(f,m(o===\"ANY\")):f===1004?p(f,m(n.sendFocus)):f===1005?p(f,4):f===1006?p(f,m(l===\"SGR\")):f===1015?p(f,4):f===1016?p(f,m(l===\"SGR_PIXELS\")):f===1048?p(f,1):f===47||f===1047||f===1049?p(f,m(c===d)):f===2004?p(f,m(n.bracketedPasteMode)):f===2026?p(f,m(n.synchronizedOutput)):p(f,0)}_updateAttrColor(e,i,r,n,o){return i===2?(e|=50331648,e&=-16777216,e|=De.fromColorRGB([r,n,o])):i===5&&(e&=-50331904,e|=33554432|r&255),e}_extractColor(e,i,r){let n=[0,0,-1,0,0,0],o=0,l=0;do{if(n[l+o]=e.params[i+l],e.hasSubParams(i+l)){let a=e.getSubParams(i+l),u=0;do n[1]===5&&(o=1),n[l+u+1+o]=a[u];while(++u<a.length&&u+l+1+o<n.length);break}if(n[1]===5&&l+o>=2||n[1]===2&&l+o>=5)break;n[1]&&(o=1)}while(++l+i<e.length&&l+o<n.length);for(let a=2;a<n.length;++a)n[a]===-1&&(n[a]=0);switch(n[0]){case 38:r.fg=this._updateAttrColor(r.fg,n[1],n[3],n[4],n[5]);break;case 48:r.bg=this._updateAttrColor(r.bg,n[1],n[3],n[4],n[5]);break;case 58:r.extended=r.extended.clone(),r.extended.underlineColor=this._updateAttrColor(r.extended.underlineColor,n[1],n[3],n[4],n[5])}return l}_processUnderline(e,i){i.extended=i.extended.clone(),(!~e||e>5)&&(e=1),i.extended.underlineStyle=e,i.fg|=268435456,e===0&&(i.fg&=-268435457),i.updateExtended()}_processSGR0(e){e.fg=X.fg,e.bg=X.bg,e.extended=e.extended.clone(),e.extended.underlineStyle=0,e.extended.underlineColor&=-67108864,e.updateExtended()}charAttributes(e){if(e.length===1&&e.params[0]===0)return this._processSGR0(this._curAttrData),!0;let i=e.length,r,n=this._curAttrData;for(let o=0;o<i;o++)r=e.params[o],r>=30&&r<=37?(n.fg&=-50331904,n.fg|=16777216|r-30):r>=40&&r<=47?(n.bg&=-50331904,n.bg|=16777216|r-40):r>=90&&r<=97?(n.fg&=-50331904,n.fg|=16777216|r-90|8):r>=100&&r<=107?(n.bg&=-50331904,n.bg|=16777216|r-100|8):r===0?this._processSGR0(n):r===1?n.fg|=134217728:r===3?n.bg|=67108864:r===4?(n.fg|=268435456,this._processUnderline(e.hasSubParams(o)?e.getSubParams(o)[0]:1,n)):r===5?n.fg|=536870912:r===7?n.fg|=67108864:r===8?n.fg|=1073741824:r===9?n.fg|=2147483648:r===2?n.bg|=134217728:r===21?this._processUnderline(2,n):r===22?(n.fg&=-134217729,n.bg&=-134217729):r===23?n.bg&=-67108865:r===24?(n.fg&=-268435457,this._processUnderline(0,n)):r===25?n.fg&=-536870913:r===27?n.fg&=-67108865:r===28?n.fg&=-1073741825:r===29?n.fg&=2147483647:r===39?(n.fg&=-67108864,n.fg|=X.fg&16777215):r===49?(n.bg&=-67108864,n.bg|=X.bg&16777215):r===38||r===48||r===58?o+=this._extractColor(e,o,n):r===53?n.bg|=1073741824:r===55?n.bg&=-1073741825:r===59?(n.extended=n.extended.clone(),n.extended.underlineColor=-1,n.updateExtended()):r===100?(n.fg&=-67108864,n.fg|=X.fg&16777215,n.bg&=-67108864,n.bg|=X.bg&16777215):this._logService.debug(\"Unknown SGR attribute: %d.\",r);return!0}deviceStatus(e){switch(e.params[0]){case 5:this._coreService.triggerDataEvent(`${b.ESC}[0n`);break;case 6:let i=this._activeBuffer.y+1,r=this._activeBuffer.x+1;this._coreService.triggerDataEvent(`${b.ESC}[${i};${r}R`);break}return!0}deviceStatusPrivate(e){switch(e.params[0]){case 6:let i=this._activeBuffer.y+1,r=this._activeBuffer.x+1;this._coreService.triggerDataEvent(`${b.ESC}[?${i};${r}R`);break;case 15:break;case 25:break;case 26:break;case 53:break}return!0}softReset(e){return this._coreService.isCursorHidden=!1,this._onRequestSyncScrollBar.fire(),this._activeBuffer.scrollTop=0,this._activeBuffer.scrollBottom=this._bufferService.rows-1,this._curAttrData=X.clone(),this._coreService.reset(),this._charsetService.reset(),this._activeBuffer.savedX=0,this._activeBuffer.savedY=this._activeBuffer.ybase,this._activeBuffer.savedCurAttrData.fg=this._curAttrData.fg,this._activeBuffer.savedCurAttrData.bg=this._curAttrData.bg,this._activeBuffer.savedCharset=this._charsetService.charset,this._coreService.decPrivateModes.origin=!1,!0}setCursorStyle(e){let i=e.length===0?1:e.params[0];if(i===0)this._coreService.decPrivateModes.cursorStyle=void 0,this._coreService.decPrivateModes.cursorBlink=void 0;else{switch(i){case 1:case 2:this._coreService.decPrivateModes.cursorStyle=\"block\";break;case 3:case 4:this._coreService.decPrivateModes.cursorStyle=\"underline\";break;case 5:case 6:this._coreService.decPrivateModes.cursorStyle=\"bar\";break}let r=i%2===1;this._coreService.decPrivateModes.cursorBlink=r}return!0}setScrollRegion(e){let i=e.params[0]||1,r;return(e.length<2||(r=e.params[1])>this._bufferService.rows||r===0)&&(r=this._bufferService.rows),r>i&&(this._activeBuffer.scrollTop=i-1,this._activeBuffer.scrollBottom=r-1,this._setCursor(0,0)),!0}windowOptions(e){if(!bl(e.params[0],this._optionsService.rawOptions.windowOptions))return!0;let i=e.length>1?e.params[1]:0;switch(e.params[0]){case 14:i!==2&&this._onRequestWindowsOptionsReport.fire(0);break;case 16:this._onRequestWindowsOptionsReport.fire(1);break;case 18:this._bufferService&&this._coreService.triggerDataEvent(`${b.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);break;case 22:(i===0||i===2)&&(this._windowTitleStack.push(this._windowTitle),this._windowTitleStack.length>_l&&this._windowTitleStack.shift()),(i===0||i===1)&&(this._iconNameStack.push(this._iconName),this._iconNameStack.length>_l&&this._iconNameStack.shift());break;case 23:(i===0||i===2)&&this._windowTitleStack.length&&this.setTitle(this._windowTitleStack.pop()),(i===0||i===1)&&this._iconNameStack.length&&this.setIconName(this._iconNameStack.pop());break}return!0}saveCursor(e){return this._activeBuffer.savedX=this._activeBuffer.x,this._activeBuffer.savedY=this._activeBuffer.ybase+this._activeBuffer.y,this._activeBuffer.savedCurAttrData.fg=this._curAttrData.fg,this._activeBuffer.savedCurAttrData.bg=this._curAttrData.bg,this._activeBuffer.savedCharset=this._charsetService.charset,!0}restoreCursor(e){return this._activeBuffer.x=this._activeBuffer.savedX||0,this._activeBuffer.y=Math.max(this._activeBuffer.savedY-this._activeBuffer.ybase,0),this._curAttrData.fg=this._activeBuffer.savedCurAttrData.fg,this._curAttrData.bg=this._activeBuffer.savedCurAttrData.bg,this._charsetService.charset=this._savedCharset,this._activeBuffer.savedCharset&&(this._charsetService.charset=this._activeBuffer.savedCharset),this._restrictCursor(),!0}setTitle(e){return this._windowTitle=e,this._onTitleChange.fire(e),!0}setIconName(e){return this._iconName=e,!0}setOrReportIndexedColor(e){let i=[],r=e.split(\";\");for(;r.length>1;){let n=r.shift(),o=r.shift();if(/^\\d+$/.exec(n)){let l=parseInt(n);if(Sl(l))if(o===\"?\")i.push({type:0,index:l});else{let a=Ws(o);a&&i.push({type:1,index:l,color:a})}}}return i.length&&this._onColor.fire(i),!0}setHyperlink(e){let i=e.indexOf(\";\");if(i===-1)return!0;let r=e.slice(0,i).trim(),n=e.slice(i+1);return n?this._createHyperlink(r,n):r.trim()?!1:this._finishHyperlink()}_createHyperlink(e,i){this._getCurrentLinkId()&&this._finishHyperlink();let r=e.split(\":\"),n,o=r.findIndex(l=>l.startsWith(\"id=\"));return o!==-1&&(n=r[o].slice(3)||void 0),this._curAttrData.extended=this._curAttrData.extended.clone(),this._curAttrData.extended.urlId=this._oscLinkService.registerLink({id:n,uri:i}),this._curAttrData.updateExtended(),!0}_finishHyperlink(){return this._curAttrData.extended=this._curAttrData.extended.clone(),this._curAttrData.extended.urlId=0,this._curAttrData.updateExtended(),!0}_setOrReportSpecialColor(e,i){let r=e.split(\";\");for(let n=0;n<r.length&&!(i>=this._specialColors.length);++n,++i)if(r[n]===\"?\")this._onColor.fire([{type:0,index:this._specialColors[i]}]);else{let o=Ws(r[n]);o&&this._onColor.fire([{type:1,index:this._specialColors[i],color:o}])}return!0}setOrReportFgColor(e){return this._setOrReportSpecialColor(e,0)}setOrReportBgColor(e){return this._setOrReportSpecialColor(e,1)}setOrReportCursorColor(e){return this._setOrReportSpecialColor(e,2)}restoreIndexedColor(e){if(!e)return this._onColor.fire([{type:2}]),!0;let i=[],r=e.split(\";\");for(let n=0;n<r.length;++n)if(/^\\d+$/.exec(r[n])){let o=parseInt(r[n]);Sl(o)&&i.push({type:2,index:o})}return i.length&&this._onColor.fire(i),!0}restoreFgColor(e){return this._onColor.fire([{type:2,index:256}]),!0}restoreBgColor(e){return this._onColor.fire([{type:2,index:257}]),!0}restoreCursorColor(e){return this._onColor.fire([{type:2,index:258}]),!0}nextLine(){return this._activeBuffer.x=0,this.index(),!0}keypadApplicationMode(){return this._logService.debug(\"Serial port requested application keypad.\"),this._coreService.decPrivateModes.applicationKeypad=!0,this._onRequestSyncScrollBar.fire(),!0}keypadNumericMode(){return this._logService.debug(\"Switching back to normal keypad.\"),this._coreService.decPrivateModes.applicationKeypad=!1,this._onRequestSyncScrollBar.fire(),!0}selectDefaultCharset(){return this._charsetService.setgLevel(0),this._charsetService.setgCharset(0,Je),!0}selectCharset(e){return e.length!==2?(this.selectDefaultCharset(),!0):(e[0]===\"/\"||this._charsetService.setgCharset(mc[e[0]],ne[e[1]]||Je),!0)}index(){return this._restrictCursor(),this._activeBuffer.y++,this._activeBuffer.y===this._activeBuffer.scrollBottom+1?(this._activeBuffer.y--,this._bufferService.scroll(this._eraseAttrData())):this._activeBuffer.y>=this._bufferService.rows&&(this._activeBuffer.y=this._bufferService.rows-1),this._restrictCursor(),!0}tabSet(){return this._activeBuffer.tabs[this._activeBuffer.x]=!0,!0}reverseIndex(){if(this._restrictCursor(),this._activeBuffer.y===this._activeBuffer.scrollTop){let e=this._activeBuffer.scrollBottom-this._activeBuffer.scrollTop;this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase+this._activeBuffer.y,e,1),this._activeBuffer.lines.set(this._activeBuffer.ybase+this._activeBuffer.y,this._activeBuffer.getBlankLine(this._eraseAttrData())),this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop,this._activeBuffer.scrollBottom)}else this._activeBuffer.y--,this._restrictCursor();return!0}fullReset(){return this._parser.reset(),this._onRequestReset.fire(),!0}reset(){this._curAttrData=X.clone(),this._eraseAttrDataInternal=X.clone()}_eraseAttrData(){return this._eraseAttrDataInternal.bg&=-67108864,this._eraseAttrDataInternal.bg|=this._curAttrData.bg&67108863,this._eraseAttrDataInternal}setgLevel(e){return this._charsetService.setgLevel(e),!0}screenAlignmentPattern(){let e=new q;e.content=1<<22|69,e.fg=this._curAttrData.fg,e.bg=this._curAttrData.bg,this._setCursor(0,0);for(let i=0;i<this._bufferService.rows;++i){let r=this._activeBuffer.ybase+this._activeBuffer.y+i,n=this._activeBuffer.lines.get(r);n&&(n.fill(e),n.isWrapped=!1)}return this._dirtyRowTracker.markAllDirty(),this._setCursor(0,0),!0}requestStatusString(e,i){let r=a=>(this._coreService.triggerDataEvent(`${b.ESC}${a}${b.ESC}\\\\`),!0),n=this._bufferService.buffer,o=this._optionsService.rawOptions,l={block:2,underline:4,bar:6};return r(e==='\"q'?`P1$r${this._curAttrData.isProtected()?1:0}\"q`:e==='\"p'?'P1$r61;1\"p':e===\"r\"?`P1$r${n.scrollTop+1};${n.scrollBottom+1}r`:e===\"m\"?\"P1$r0m\":e===\" q\"?`P1$r${l[o.cursorStyle]-(o.cursorBlink?1:0)} q`:\"P0$r\")}markRangeDirty(e,i){this._dirtyRowTracker.markRangeDirty(e,i)}},Zi=class{constructor(t){this._bufferService=t;this.clearRange()}clearRange(){this.start=this._bufferService.buffer.y,this.end=this._bufferService.buffer.y}markDirty(t){t<this.start?this.start=t:t>this.end&&(this.end=t)}markRangeDirty(t,e){t>e&&(gl=t,t=e,e=gl),t<this.start&&(this.start=t),e>this.end&&(this.end=e)}markAllDirty(){this.markRangeDirty(0,this._bufferService.rows-1)}};Zi=M([S(0,F)],Zi);function Sl(s){return 0<=s&&s<256}var _c=5e7,El=12,bc=50,gn=class extends D{constructor(e){super();this._action=e;this._writeBuffer=[];this._callbacks=[];this._pendingData=0;this._bufferOffset=0;this._isSyncWriting=!1;this._syncCalls=0;this._didUserInput=!1;this._onWriteParsed=this._register(new v);this.onWriteParsed=this._onWriteParsed.event}handleUserInput(){this._didUserInput=!0}writeSync(e,i){if(i!==void 0&&this._syncCalls>i){this._syncCalls=0;return}if(this._pendingData+=e.length,this._writeBuffer.push(e),this._callbacks.push(void 0),this._syncCalls++,this._isSyncWriting)return;this._isSyncWriting=!0;let r;for(;r=this._writeBuffer.shift();){this._action(r);let n=this._callbacks.shift();n&&n()}this._pendingData=0,this._bufferOffset=2147483647,this._isSyncWriting=!1,this._syncCalls=0}write(e,i){if(this._pendingData>_c)throw new Error(\"write data discarded, use flow control to avoid losing data\");if(!this._writeBuffer.length){if(this._bufferOffset=0,this._didUserInput){this._didUserInput=!1,this._pendingData+=e.length,this._writeBuffer.push(e),this._callbacks.push(i),this._innerWrite();return}setTimeout(()=>this._innerWrite())}this._pendingData+=e.length,this._writeBuffer.push(e),this._callbacks.push(i)}_innerWrite(e=0,i=!0){let r=e||performance.now();for(;this._writeBuffer.length>this._bufferOffset;){let n=this._writeBuffer[this._bufferOffset],o=this._action(n,i);if(o){let a=u=>performance.now()-r>=El?setTimeout(()=>this._innerWrite(0,u)):this._innerWrite(r,u);o.catch(u=>(queueMicrotask(()=>{throw u}),Promise.resolve(!1))).then(a);return}let l=this._callbacks[this._bufferOffset];if(l&&l(),this._bufferOffset++,this._pendingData-=n.length,performance.now()-r>=El)break}this._writeBuffer.length>this._bufferOffset?(this._bufferOffset>bc&&(this._writeBuffer=this._writeBuffer.slice(this._bufferOffset),this._callbacks=this._callbacks.slice(this._bufferOffset),this._bufferOffset=0),setTimeout(()=>this._innerWrite())):(this._writeBuffer.length=0,this._callbacks.length=0,this._pendingData=0,this._bufferOffset=0),this._onWriteParsed.fire()}};var ui=class{constructor(t){this._bufferService=t;this._nextId=1;this._entriesWithId=new Map;this._dataByLinkId=new Map}registerLink(t){let e=this._bufferService.buffer;if(t.id===void 0){let a=e.addMarker(e.ybase+e.y),u={data:t,id:this._nextId++,lines:[a]};return a.onDispose(()=>this._removeMarkerFromLink(u,a)),this._dataByLinkId.set(u.id,u),u.id}let i=t,r=this._getEntryIdKey(i),n=this._entriesWithId.get(r);if(n)return this.addLineToLink(n.id,e.ybase+e.y),n.id;let o=e.addMarker(e.ybase+e.y),l={id:this._nextId++,key:this._getEntryIdKey(i),data:i,lines:[o]};return o.onDispose(()=>this._removeMarkerFromLink(l,o)),this._entriesWithId.set(l.key,l),this._dataByLinkId.set(l.id,l),l.id}addLineToLink(t,e){let i=this._dataByLinkId.get(t);if(i&&i.lines.every(r=>r.line!==e)){let r=this._bufferService.buffer.addMarker(e);i.lines.push(r),r.onDispose(()=>this._removeMarkerFromLink(i,r))}}getLinkData(t){return this._dataByLinkId.get(t)?.data}_getEntryIdKey(t){return`${t.id};;${t.uri}`}_removeMarkerFromLink(t,e){let i=t.lines.indexOf(e);i!==-1&&(t.lines.splice(i,1),t.lines.length===0&&(t.data.id!==void 0&&this._entriesWithId.delete(t.key),this._dataByLinkId.delete(t.id)))}};ui=M([S(0,F)],ui);var Tl=!1,Sn=class extends D{constructor(e){super();this._windowsWrappingHeuristics=this._register(new ye);this._onBinary=this._register(new v);this.onBinary=this._onBinary.event;this._onData=this._register(new v);this.onData=this._onData.event;this._onLineFeed=this._register(new v);this.onLineFeed=this._onLineFeed.event;this._onResize=this._register(new v);this.onResize=this._onResize.event;this._onWriteParsed=this._register(new v);this.onWriteParsed=this._onWriteParsed.event;this._onScroll=this._register(new v);this._instantiationService=new ln,this.optionsService=this._register(new dn(e)),this._instantiationService.setService(H,this.optionsService),this._bufferService=this._register(this._instantiationService.createInstance(ni)),this._instantiationService.setService(F,this._bufferService),this._logService=this._register(this._instantiationService.createInstance(ii)),this._instantiationService.setService(nr,this._logService),this.coreService=this._register(this._instantiationService.createInstance(li)),this._instantiationService.setService(ge,this.coreService),this.coreMouseService=this._register(this._instantiationService.createInstance(ai)),this._instantiationService.setService(rr,this.coreMouseService),this.unicodeService=this._register(this._instantiationService.createInstance(Ae)),this._instantiationService.setService(Js,this.unicodeService),this._charsetService=this._instantiationService.createInstance(pn),this._instantiationService.setService(Zs,this._charsetService),this._oscLinkService=this._instantiationService.createInstance(ui),this._instantiationService.setService(sr,this._oscLinkService),this._inputHandler=this._register(new vn(this._bufferService,this._charsetService,this.coreService,this._logService,this.optionsService,this._oscLinkService,this.coreMouseService,this.unicodeService)),this._register($.forward(this._inputHandler.onLineFeed,this._onLineFeed)),this._register(this._inputHandler),this._register($.forward(this._bufferService.onResize,this._onResize)),this._register($.forward(this.coreService.onData,this._onData)),this._register($.forward(this.coreService.onBinary,this._onBinary)),this._register(this.coreService.onRequestScrollToBottom(()=>this.scrollToBottom(!0))),this._register(this.coreService.onUserInput(()=>this._writeBuffer.handleUserInput())),this._register(this.optionsService.onMultipleOptionChange([\"windowsMode\",\"windowsPty\"],()=>this._handleWindowsPtyOptionChange())),this._register(this._bufferService.onScroll(()=>{this._onScroll.fire({position:this._bufferService.buffer.ydisp}),this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop,this._bufferService.buffer.scrollBottom)})),this._writeBuffer=this._register(new gn((i,r)=>this._inputHandler.parse(i,r))),this._register($.forward(this._writeBuffer.onWriteParsed,this._onWriteParsed))}get onScroll(){return this._onScrollApi||(this._onScrollApi=this._register(new v),this._onScroll.event(e=>{this._onScrollApi?.fire(e.position)})),this._onScrollApi.event}get cols(){return this._bufferService.cols}get rows(){return this._bufferService.rows}get buffers(){return this._bufferService.buffers}get options(){return this.optionsService.options}set options(e){for(let i in e)this.optionsService.options[i]=e[i]}write(e,i){this._writeBuffer.write(e,i)}writeSync(e,i){this._logService.logLevel<=3&&!Tl&&(this._logService.warn(\"writeSync is unreliable and will be removed soon.\"),Tl=!0),this._writeBuffer.writeSync(e,i)}input(e,i=!0){this.coreService.triggerDataEvent(e,i)}resize(e,i){isNaN(e)||isNaN(i)||(e=Math.max(e,ks),i=Math.max(i,Cs),this._bufferService.resize(e,i))}scroll(e,i=!1){this._bufferService.scroll(e,i)}scrollLines(e,i){this._bufferService.scrollLines(e,i)}scrollPages(e){this.scrollLines(e*(this.rows-1))}scrollToTop(){this.scrollLines(-this._bufferService.buffer.ydisp)}scrollToBottom(e){this.scrollLines(this._bufferService.buffer.ybase-this._bufferService.buffer.ydisp)}scrollToLine(e){let i=e-this._bufferService.buffer.ydisp;i!==0&&this.scrollLines(i)}registerEscHandler(e,i){return this._inputHandler.registerEscHandler(e,i)}registerDcsHandler(e,i){return this._inputHandler.registerDcsHandler(e,i)}registerCsiHandler(e,i){return this._inputHandler.registerCsiHandler(e,i)}registerOscHandler(e,i){return this._inputHandler.registerOscHandler(e,i)}_setup(){this._handleWindowsPtyOptionChange()}reset(){this._inputHandler.reset(),this._bufferService.reset(),this._charsetService.reset(),this.coreService.reset(),this.coreMouseService.reset()}_handleWindowsPtyOptionChange(){let e=!1,i=this.optionsService.rawOptions.windowsPty;i&&i.buildNumber!==void 0&&i.buildNumber!==void 0?e=i.backend===\"conpty\"&&i.buildNumber<21376:this.optionsService.rawOptions.windowsMode&&(e=!0),e?this._enableWindowsWrappingHeuristics():this._windowsWrappingHeuristics.clear()}_enableWindowsWrappingHeuristics(){if(!this._windowsWrappingHeuristics.value){let e=[];e.push(this.onLineFeed(Bs.bind(null,this._bufferService))),e.push(this.registerCsiHandler({final:\"H\"},()=>(Bs(this._bufferService),!1))),this._windowsWrappingHeuristics.value=C(()=>{for(let i of e)i.dispose()})}}};var gc={48:[\"0\",\")\"],49:[\"1\",\"!\"],50:[\"2\",\"@\"],51:[\"3\",\"#\"],52:[\"4\",\"$\"],53:[\"5\",\"%\"],54:[\"6\",\"^\"],55:[\"7\",\"&\"],56:[\"8\",\"*\"],57:[\"9\",\"(\"],186:[\";\",\":\"],187:[\"=\",\"+\"],188:[\",\",\"<\"],189:[\"-\",\"_\"],190:[\".\",\">\"],191:[\"/\",\"?\"],192:[\"`\",\"~\"],219:[\"[\",\"{\"],220:[\"\\\\\",\"|\"],221:[\"]\",\"}\"],222:[\"'\",'\"']};function Il(s,t,e,i){let r={type:0,cancel:!1,key:void 0},n=(s.shiftKey?1:0)|(s.altKey?2:0)|(s.ctrlKey?4:0)|(s.metaKey?8:0);switch(s.keyCode){case 0:s.key===\"UIKeyInputUpArrow\"?t?r.key=b.ESC+\"OA\":r.key=b.ESC+\"[A\":s.key===\"UIKeyInputLeftArrow\"?t?r.key=b.ESC+\"OD\":r.key=b.ESC+\"[D\":s.key===\"UIKeyInputRightArrow\"?t?r.key=b.ESC+\"OC\":r.key=b.ESC+\"[C\":s.key===\"UIKeyInputDownArrow\"&&(t?r.key=b.ESC+\"OB\":r.key=b.ESC+\"[B\");break;case 8:r.key=s.ctrlKey?\"\\b\":b.DEL,s.altKey&&(r.key=b.ESC+r.key);break;case 9:if(s.shiftKey){r.key=b.ESC+\"[Z\";break}r.key=b.HT,r.cancel=!0;break;case 13:r.key=s.altKey?b.ESC+b.CR:b.CR,r.cancel=!0;break;case 27:r.key=b.ESC,s.altKey&&(r.key=b.ESC+b.ESC),r.cancel=!0;break;case 37:if(s.metaKey)break;n?r.key=b.ESC+\"[1;\"+(n+1)+\"D\":t?r.key=b.ESC+\"OD\":r.key=b.ESC+\"[D\";break;case 39:if(s.metaKey)break;n?r.key=b.ESC+\"[1;\"+(n+1)+\"C\":t?r.key=b.ESC+\"OC\":r.key=b.ESC+\"[C\";break;case 38:if(s.metaKey)break;n?r.key=b.ESC+\"[1;\"+(n+1)+\"A\":t?r.key=b.ESC+\"OA\":r.key=b.ESC+\"[A\";break;case 40:if(s.metaKey)break;n?r.key=b.ESC+\"[1;\"+(n+1)+\"B\":t?r.key=b.ESC+\"OB\":r.key=b.ESC+\"[B\";break;case 45:!s.shiftKey&&!s.ctrlKey&&(r.key=b.ESC+\"[2~\");break;case 46:n?r.key=b.ESC+\"[3;\"+(n+1)+\"~\":r.key=b.ESC+\"[3~\";break;case 36:n?r.key=b.ESC+\"[1;\"+(n+1)+\"H\":t?r.key=b.ESC+\"OH\":r.key=b.ESC+\"[H\";break;case 35:n?r.key=b.ESC+\"[1;\"+(n+1)+\"F\":t?r.key=b.ESC+\"OF\":r.key=b.ESC+\"[F\";break;case 33:s.shiftKey?r.type=2:s.ctrlKey?r.key=b.ESC+\"[5;\"+(n+1)+\"~\":r.key=b.ESC+\"[5~\";break;case 34:s.shiftKey?r.type=3:s.ctrlKey?r.key=b.ESC+\"[6;\"+(n+1)+\"~\":r.key=b.ESC+\"[6~\";break;case 112:n?r.key=b.ESC+\"[1;\"+(n+1)+\"P\":r.key=b.ESC+\"OP\";break;case 113:n?r.key=b.ESC+\"[1;\"+(n+1)+\"Q\":r.key=b.ESC+\"OQ\";break;case 114:n?r.key=b.ESC+\"[1;\"+(n+1)+\"R\":r.key=b.ESC+\"OR\";break;case 115:n?r.key=b.ESC+\"[1;\"+(n+1)+\"S\":r.key=b.ESC+\"OS\";break;case 116:n?r.key=b.ESC+\"[15;\"+(n+1)+\"~\":r.key=b.ESC+\"[15~\";break;case 117:n?r.key=b.ESC+\"[17;\"+(n+1)+\"~\":r.key=b.ESC+\"[17~\";break;case 118:n?r.key=b.ESC+\"[18;\"+(n+1)+\"~\":r.key=b.ESC+\"[18~\";break;case 119:n?r.key=b.ESC+\"[19;\"+(n+1)+\"~\":r.key=b.ESC+\"[19~\";break;case 120:n?r.key=b.ESC+\"[20;\"+(n+1)+\"~\":r.key=b.ESC+\"[20~\";break;case 121:n?r.key=b.ESC+\"[21;\"+(n+1)+\"~\":r.key=b.ESC+\"[21~\";break;case 122:n?r.key=b.ESC+\"[23;\"+(n+1)+\"~\":r.key=b.ESC+\"[23~\";break;case 123:n?r.key=b.ESC+\"[24;\"+(n+1)+\"~\":r.key=b.ESC+\"[24~\";break;default:if(s.ctrlKey&&!s.shiftKey&&!s.altKey&&!s.metaKey)s.keyCode>=65&&s.keyCode<=90?r.key=String.fromCharCode(s.keyCode-64):s.keyCode===32?r.key=b.NUL:s.keyCode>=51&&s.keyCode<=55?r.key=String.fromCharCode(s.keyCode-51+27):s.keyCode===56?r.key=b.DEL:s.keyCode===219?r.key=b.ESC:s.keyCode===220?r.key=b.FS:s.keyCode===221&&(r.key=b.GS);else if((!e||i)&&s.altKey&&!s.metaKey){let l=gc[s.keyCode]?.[s.shiftKey?1:0];if(l)r.key=b.ESC+l;else if(s.keyCode>=65&&s.keyCode<=90){let a=s.ctrlKey?s.keyCode-64:s.keyCode+32,u=String.fromCharCode(a);s.shiftKey&&(u=u.toUpperCase()),r.key=b.ESC+u}else if(s.keyCode===32)r.key=b.ESC+(s.ctrlKey?b.NUL:\" \");else if(s.key===\"Dead\"&&s.code.startsWith(\"Key\")){let a=s.code.slice(3,4);s.shiftKey||(a=a.toLowerCase()),r.key=b.ESC+a,r.cancel=!0}}else e&&!s.altKey&&!s.ctrlKey&&!s.shiftKey&&s.metaKey?s.keyCode===65&&(r.type=1):s.key&&!s.ctrlKey&&!s.altKey&&!s.metaKey&&s.keyCode>=48&&s.key.length===1?r.key=s.key:s.key&&s.ctrlKey&&(s.key===\"_\"&&(r.key=b.US),s.key===\"@\"&&(r.key=b.NUL));break}return r}var ee=0,En=class{constructor(t){this._getKey=t;this._array=[];this._insertedValues=[];this._flushInsertedTask=new Jt;this._isFlushingInserted=!1;this._deletedIndices=[];this._flushDeletedTask=new Jt;this._isFlushingDeleted=!1}clear(){this._array.length=0,this._insertedValues.length=0,this._flushInsertedTask.clear(),this._isFlushingInserted=!1,this._deletedIndices.length=0,this._flushDeletedTask.clear(),this._isFlushingDeleted=!1}insert(t){this._flushCleanupDeleted(),this._insertedValues.length===0&&this._flushInsertedTask.enqueue(()=>this._flushInserted()),this._insertedValues.push(t)}_flushInserted(){let t=this._insertedValues.sort((n,o)=>this._getKey(n)-this._getKey(o)),e=0,i=0,r=new Array(this._array.length+this._insertedValues.length);for(let n=0;n<r.length;n++)i>=this._array.length||this._getKey(t[e])<=this._getKey(this._array[i])?(r[n]=t[e],e++):r[n]=this._array[i++];this._array=r,this._insertedValues.length=0}_flushCleanupInserted(){!this._isFlushingInserted&&this._insertedValues.length>0&&this._flushInsertedTask.flush()}delete(t){if(this._flushCleanupInserted(),this._array.length===0)return!1;let e=this._getKey(t);if(e===void 0||(ee=this._search(e),ee===-1)||this._getKey(this._array[ee])!==e)return!1;do if(this._array[ee]===t)return this._deletedIndices.length===0&&this._flushDeletedTask.enqueue(()=>this._flushDeleted()),this._deletedIndices.push(ee),!0;while(++ee<this._array.length&&this._getKey(this._array[ee])===e);return!1}_flushDeleted(){this._isFlushingDeleted=!0;let t=this._deletedIndices.sort((n,o)=>n-o),e=0,i=new Array(this._array.length-t.length),r=0;for(let n=0;n<this._array.length;n++)t[e]===n?e++:i[r++]=this._array[n];this._array=i,this._deletedIndices.length=0,this._isFlushingDeleted=!1}_flushCleanupDeleted(){!this._isFlushingDeleted&&this._deletedIndices.length>0&&this._flushDeletedTask.flush()}*getKeyIterator(t){if(this._flushCleanupInserted(),this._flushCleanupDeleted(),this._array.length!==0&&(ee=this._search(t),!(ee<0||ee>=this._array.length)&&this._getKey(this._array[ee])===t))do yield this._array[ee];while(++ee<this._array.length&&this._getKey(this._array[ee])===t)}forEachByKey(t,e){if(this._flushCleanupInserted(),this._flushCleanupDeleted(),this._array.length!==0&&(ee=this._search(t),!(ee<0||ee>=this._array.length)&&this._getKey(this._array[ee])===t))do e(this._array[ee]);while(++ee<this._array.length&&this._getKey(this._array[ee])===t)}values(){return this._flushCleanupInserted(),this._flushCleanupDeleted(),[...this._array].values()}_search(t){let e=0,i=this._array.length-1;for(;i>=e;){let r=e+i>>1,n=this._getKey(this._array[r]);if(n>t)i=r-1;else if(n<t)e=r+1;else{for(;r>0&&this._getKey(this._array[r-1])===t;)r--;return r}}return e}};var Us=0,yl=0,Tn=class extends D{constructor(){super();this._decorations=new En(e=>e?.marker.line);this._onDecorationRegistered=this._register(new v);this.onDecorationRegistered=this._onDecorationRegistered.event;this._onDecorationRemoved=this._register(new v);this.onDecorationRemoved=this._onDecorationRemoved.event;this._register(C(()=>this.reset()))}get decorations(){return this._decorations.values()}registerDecoration(e){if(e.marker.isDisposed)return;let i=new Ks(e);if(i){let r=i.marker.onDispose(()=>i.dispose()),n=i.onDispose(()=>{n.dispose(),i&&(this._decorations.delete(i)&&this._onDecorationRemoved.fire(i),r.dispose())});this._decorations.insert(i),this._onDecorationRegistered.fire(i)}return i}reset(){for(let e of this._decorations.values())e.dispose();this._decorations.clear()}*getDecorationsAtCell(e,i,r){let n=0,o=0;for(let l of this._decorations.getKeyIterator(i))n=l.options.x??0,o=n+(l.options.width??1),e>=n&&e<o&&(!r||(l.options.layer??\"bottom\")===r)&&(yield l)}forEachDecorationAtCell(e,i,r,n){this._decorations.forEachByKey(i,o=>{Us=o.options.x??0,yl=Us+(o.options.width??1),e>=Us&&e<yl&&(!r||(o.options.layer??\"bottom\")===r)&&n(o)})}},Ks=class extends Ee{constructor(e){super();this.options=e;this.onRenderEmitter=this.add(new v);this.onRender=this.onRenderEmitter.event;this._onDispose=this.add(new v);this.onDispose=this._onDispose.event;this._cachedBg=null;this._cachedFg=null;this.marker=e.marker,this.options.overviewRulerOptions&&!this.options.overviewRulerOptions.position&&(this.options.overviewRulerOptions.position=\"full\")}get backgroundColorRGB(){return this._cachedBg===null&&(this.options.backgroundColor?this._cachedBg=z.toColor(this.options.backgroundColor):this._cachedBg=void 0),this._cachedBg}get foregroundColorRGB(){return this._cachedFg===null&&(this.options.foregroundColor?this._cachedFg=z.toColor(this.options.foregroundColor):this._cachedFg=void 0),this._cachedFg}dispose(){this._onDispose.fire(),super.dispose()}};var Sc=1e3,In=class{constructor(t,e=Sc){this._renderCallback=t;this._debounceThresholdMS=e;this._lastRefreshMs=0;this._additionalRefreshRequested=!1}dispose(){this._refreshTimeoutID&&clearTimeout(this._refreshTimeoutID)}refresh(t,e,i){this._rowCount=i,t=t!==void 0?t:0,e=e!==void 0?e:this._rowCount-1,this._rowStart=this._rowStart!==void 0?Math.min(this._rowStart,t):t,this._rowEnd=this._rowEnd!==void 0?Math.max(this._rowEnd,e):e;let r=performance.now();if(r-this._lastRefreshMs>=this._debounceThresholdMS)this._lastRefreshMs=r,this._innerRefresh();else if(!this._additionalRefreshRequested){let n=r-this._lastRefreshMs,o=this._debounceThresholdMS-n;this._additionalRefreshRequested=!0,this._refreshTimeoutID=window.setTimeout(()=>{this._lastRefreshMs=performance.now(),this._innerRefresh(),this._additionalRefreshRequested=!1,this._refreshTimeoutID=void 0},o)}}_innerRefresh(){if(this._rowStart===void 0||this._rowEnd===void 0||this._rowCount===void 0)return;let t=Math.max(this._rowStart,0),e=Math.min(this._rowEnd,this._rowCount-1);this._rowStart=void 0,this._rowEnd=void 0,this._renderCallback(t,e)}};var xl=20;var wl=!1,Tt=class extends D{constructor(e,i,r,n){super();this._terminal=e;this._coreBrowserService=r;this._renderService=n;this._rowColumns=new WeakMap;this._liveRegionLineCount=0;this._charsToConsume=[];this._charsToAnnounce=\"\";let o=this._coreBrowserService.mainDocument;this._accessibilityContainer=o.createElement(\"div\"),this._accessibilityContainer.classList.add(\"xterm-accessibility\"),this._rowContainer=o.createElement(\"div\"),this._rowContainer.setAttribute(\"role\",\"list\"),this._rowContainer.classList.add(\"xterm-accessibility-tree\"),this._rowElements=[];for(let l=0;l<this._terminal.rows;l++)this._rowElements[l]=this._createAccessibilityTreeNode(),this._rowContainer.appendChild(this._rowElements[l]);if(this._topBoundaryFocusListener=l=>this._handleBoundaryFocus(l,0),this._bottomBoundaryFocusListener=l=>this._handleBoundaryFocus(l,1),this._rowElements[0].addEventListener(\"focus\",this._topBoundaryFocusListener),this._rowElements[this._rowElements.length-1].addEventListener(\"focus\",this._bottomBoundaryFocusListener),this._accessibilityContainer.appendChild(this._rowContainer),this._liveRegion=o.createElement(\"div\"),this._liveRegion.classList.add(\"live-region\"),this._liveRegion.setAttribute(\"aria-live\",\"assertive\"),this._accessibilityContainer.appendChild(this._liveRegion),this._liveRegionDebouncer=this._register(new In(this._renderRows.bind(this))),!this._terminal.element)throw new Error(\"Cannot enable accessibility before Terminal.open\");wl?(this._accessibilityContainer.classList.add(\"debug\"),this._rowContainer.classList.add(\"debug\"),this._debugRootContainer=o.createElement(\"div\"),this._debugRootContainer.classList.add(\"xterm\"),this._debugRootContainer.appendChild(o.createTextNode(\"------start a11y------\")),this._debugRootContainer.appendChild(this._accessibilityContainer),this._debugRootContainer.appendChild(o.createTextNode(\"------end a11y------\")),this._terminal.element.insertAdjacentElement(\"afterend\",this._debugRootContainer)):this._terminal.element.insertAdjacentElement(\"afterbegin\",this._accessibilityContainer),this._register(this._terminal.onResize(l=>this._handleResize(l.rows))),this._register(this._terminal.onRender(l=>this._refreshRows(l.start,l.end))),this._register(this._terminal.onScroll(()=>this._refreshRows())),this._register(this._terminal.onA11yChar(l=>this._handleChar(l))),this._register(this._terminal.onLineFeed(()=>this._handleChar(`\n`))),this._register(this._terminal.onA11yTab(l=>this._handleTab(l))),this._register(this._terminal.onKey(l=>this._handleKey(l.key))),this._register(this._terminal.onBlur(()=>this._clearLiveRegion())),this._register(this._renderService.onDimensionsChange(()=>this._refreshRowsDimensions())),this._register(L(o,\"selectionchange\",()=>this._handleSelectionChange())),this._register(this._coreBrowserService.onDprChange(()=>this._refreshRowsDimensions())),this._refreshRowsDimensions(),this._refreshRows(),this._register(C(()=>{wl?this._debugRootContainer.remove():this._accessibilityContainer.remove(),this._rowElements.length=0}))}_handleTab(e){for(let i=0;i<e;i++)this._handleChar(\" \")}_handleChar(e){this._liveRegionLineCount<xl+1&&(this._charsToConsume.length>0?this._charsToConsume.shift()!==e&&(this._charsToAnnounce+=e):this._charsToAnnounce+=e,e===`\n`&&(this._liveRegionLineCount++,this._liveRegionLineCount===xl+1&&(this._liveRegion.textContent+=_i.get())))}_clearLiveRegion(){this._liveRegion.textContent=\"\",this._liveRegionLineCount=0}_handleKey(e){this._clearLiveRegion(),/\\p{Control}/u.test(e)||this._charsToConsume.push(e)}_refreshRows(e,i){this._liveRegionDebouncer.refresh(e,i,this._terminal.rows)}_renderRows(e,i){let r=this._terminal.buffer,n=r.lines.length.toString();for(let o=e;o<=i;o++){let l=r.lines.get(r.ydisp+o),a=[],u=l?.translateToString(!0,void 0,void 0,a)||\"\",h=(r.ydisp+o+1).toString(),c=this._rowElements[o];c&&(u.length===0?(c.textContent=\"\\xA0\",this._rowColumns.set(c,[0,1])):(c.textContent=u,this._rowColumns.set(c,a)),c.setAttribute(\"aria-posinset\",h),c.setAttribute(\"aria-setsize\",n),this._alignRowWidth(c))}this._announceCharacters()}_announceCharacters(){this._charsToAnnounce.length!==0&&(this._liveRegion.textContent+=this._charsToAnnounce,this._charsToAnnounce=\"\")}_handleBoundaryFocus(e,i){let r=e.target,n=this._rowElements[i===0?1:this._rowElements.length-2],o=r.getAttribute(\"aria-posinset\"),l=i===0?\"1\":`${this._terminal.buffer.lines.length}`;if(o===l||e.relatedTarget!==n)return;let a,u;if(i===0?(a=r,u=this._rowElements.pop(),this._rowContainer.removeChild(u)):(a=this._rowElements.shift(),u=r,this._rowContainer.removeChild(a)),a.removeEventListener(\"focus\",this._topBoundaryFocusListener),u.removeEventListener(\"focus\",this._bottomBoundaryFocusListener),i===0){let h=this._createAccessibilityTreeNode();this._rowElements.unshift(h),this._rowContainer.insertAdjacentElement(\"afterbegin\",h)}else{let h=this._createAccessibilityTreeNode();this._rowElements.push(h),this._rowContainer.appendChild(h)}this._rowElements[0].addEventListener(\"focus\",this._topBoundaryFocusListener),this._rowElements[this._rowElements.length-1].addEventListener(\"focus\",this._bottomBoundaryFocusListener),this._terminal.scrollLines(i===0?-1:1),this._rowElements[i===0?1:this._rowElements.length-2].focus(),e.preventDefault(),e.stopImmediatePropagation()}_handleSelectionChange(){if(this._rowElements.length===0)return;let e=this._coreBrowserService.mainDocument.getSelection();if(!e)return;if(e.isCollapsed){this._rowContainer.contains(e.anchorNode)&&this._terminal.clearSelection();return}if(!e.anchorNode||!e.focusNode){console.error(\"anchorNode and/or focusNode are null\");return}let i={node:e.anchorNode,offset:e.anchorOffset},r={node:e.focusNode,offset:e.focusOffset};if((i.node.compareDocumentPosition(r.node)&Node.DOCUMENT_POSITION_PRECEDING||i.node===r.node&&i.offset>r.offset)&&([i,r]=[r,i]),i.node.compareDocumentPosition(this._rowElements[0])&(Node.DOCUMENT_POSITION_CONTAINED_BY|Node.DOCUMENT_POSITION_FOLLOWING)&&(i={node:this._rowElements[0].childNodes[0],offset:0}),!this._rowContainer.contains(i.node))return;let n=this._rowElements.slice(-1)[0];if(r.node.compareDocumentPosition(n)&(Node.DOCUMENT_POSITION_CONTAINED_BY|Node.DOCUMENT_POSITION_PRECEDING)&&(r={node:n,offset:n.textContent?.length??0}),!this._rowContainer.contains(r.node))return;let o=({node:u,offset:h})=>{let c=u instanceof Text?u.parentNode:u,d=parseInt(c?.getAttribute(\"aria-posinset\"),10)-1;if(isNaN(d))return console.warn(\"row is invalid. Race condition?\"),null;let _=this._rowColumns.get(c);if(!_)return console.warn(\"columns is null. Race condition?\"),null;let p=h<_.length?_[h]:_.slice(-1)[0]+1;return p>=this._terminal.cols&&(++d,p=0),{row:d,column:p}},l=o(i),a=o(r);if(!(!l||!a)){if(l.row>a.row||l.row===a.row&&l.column>=a.column)throw new Error(\"invalid range\");this._terminal.select(l.column,l.row,(a.row-l.row)*this._terminal.cols-l.column+a.column)}}_handleResize(e){this._rowElements[this._rowElements.length-1].removeEventListener(\"focus\",this._bottomBoundaryFocusListener);for(let i=this._rowContainer.children.length;i<this._terminal.rows;i++)this._rowElements[i]=this._createAccessibilityTreeNode(),this._rowContainer.appendChild(this._rowElements[i]);for(;this._rowElements.length>e;)this._rowContainer.removeChild(this._rowElements.pop());this._rowElements[this._rowElements.length-1].addEventListener(\"focus\",this._bottomBoundaryFocusListener),this._refreshRowsDimensions()}_createAccessibilityTreeNode(){let e=this._coreBrowserService.mainDocument.createElement(\"div\");return e.setAttribute(\"role\",\"listitem\"),e.tabIndex=-1,this._refreshRowDimensions(e),e}_refreshRowsDimensions(){if(this._renderService.dimensions.css.cell.height){Object.assign(this._accessibilityContainer.style,{width:`${this._renderService.dimensions.css.canvas.width}px`,fontSize:`${this._terminal.options.fontSize}px`}),this._rowElements.length!==this._terminal.rows&&this._handleResize(this._terminal.rows);for(let e=0;e<this._terminal.rows;e++)this._refreshRowDimensions(this._rowElements[e]),this._alignRowWidth(this._rowElements[e])}}_refreshRowDimensions(e){e.style.height=`${this._renderService.dimensions.css.cell.height}px`}_alignRowWidth(e){e.style.transform=\"\";let i=e.getBoundingClientRect().width,r=this._rowColumns.get(e)?.slice(-1)?.[0];if(!r)return;let n=r*this._renderService.dimensions.css.cell.width;e.style.transform=`scaleX(${n/i})`}};Tt=M([S(1,xt),S(2,ae),S(3,ce)],Tt);var hi=class extends D{constructor(e,i,r,n,o){super();this._element=e;this._mouseService=i;this._renderService=r;this._bufferService=n;this._linkProviderService=o;this._linkCacheDisposables=[];this._isMouseOut=!0;this._wasResized=!1;this._activeLine=-1;this._onShowLinkUnderline=this._register(new v);this.onShowLinkUnderline=this._onShowLinkUnderline.event;this._onHideLinkUnderline=this._register(new v);this.onHideLinkUnderline=this._onHideLinkUnderline.event;this._register(C(()=>{Ne(this._linkCacheDisposables),this._linkCacheDisposables.length=0,this._lastMouseEvent=void 0,this._activeProviderReplies?.clear()})),this._register(this._bufferService.onResize(()=>{this._clearCurrentLink(),this._wasResized=!0})),this._register(L(this._element,\"mouseleave\",()=>{this._isMouseOut=!0,this._clearCurrentLink()})),this._register(L(this._element,\"mousemove\",this._handleMouseMove.bind(this))),this._register(L(this._element,\"mousedown\",this._handleMouseDown.bind(this))),this._register(L(this._element,\"mouseup\",this._handleMouseUp.bind(this)))}get currentLink(){return this._currentLink}_handleMouseMove(e){this._lastMouseEvent=e;let i=this._positionFromMouseEvent(e,this._element,this._mouseService);if(!i)return;this._isMouseOut=!1;let r=e.composedPath();for(let n=0;n<r.length;n++){let o=r[n];if(o.classList.contains(\"xterm\"))break;if(o.classList.contains(\"xterm-hover\"))return}(!this._lastBufferCell||i.x!==this._lastBufferCell.x||i.y!==this._lastBufferCell.y)&&(this._handleHover(i),this._lastBufferCell=i)}_handleHover(e){if(this._activeLine!==e.y||this._wasResized){this._clearCurrentLink(),this._askForLink(e,!1),this._wasResized=!1;return}this._currentLink&&this._linkAtPosition(this._currentLink.link,e)||(this._clearCurrentLink(),this._askForLink(e,!0))}_askForLink(e,i){(!this._activeProviderReplies||!i)&&(this._activeProviderReplies?.forEach(n=>{n?.forEach(o=>{o.link.dispose&&o.link.dispose()})}),this._activeProviderReplies=new Map,this._activeLine=e.y);let r=!1;for(let[n,o]of this._linkProviderService.linkProviders.entries())i?this._activeProviderReplies?.get(n)&&(r=this._checkLinkProviderResult(n,e,r)):o.provideLinks(e.y,l=>{if(this._isMouseOut)return;let a=l?.map(u=>({link:u}));this._activeProviderReplies?.set(n,a),r=this._checkLinkProviderResult(n,e,r),this._activeProviderReplies?.size===this._linkProviderService.linkProviders.length&&this._removeIntersectingLinks(e.y,this._activeProviderReplies)})}_removeIntersectingLinks(e,i){let r=new Set;for(let n=0;n<i.size;n++){let o=i.get(n);if(o)for(let l=0;l<o.length;l++){let a=o[l],u=a.link.range.start.y<e?0:a.link.range.start.x,h=a.link.range.end.y>e?this._bufferService.cols:a.link.range.end.x;for(let c=u;c<=h;c++){if(r.has(c)){o.splice(l--,1);break}r.add(c)}}}}_checkLinkProviderResult(e,i,r){if(!this._activeProviderReplies)return r;let n=this._activeProviderReplies.get(e),o=!1;for(let l=0;l<e;l++)(!this._activeProviderReplies.has(l)||this._activeProviderReplies.get(l))&&(o=!0);if(!o&&n){let l=n.find(a=>this._linkAtPosition(a.link,i));l&&(r=!0,this._handleNewLink(l))}if(this._activeProviderReplies.size===this._linkProviderService.linkProviders.length&&!r)for(let l=0;l<this._activeProviderReplies.size;l++){let a=this._activeProviderReplies.get(l)?.find(u=>this._linkAtPosition(u.link,i));if(a){r=!0,this._handleNewLink(a);break}}return r}_handleMouseDown(){this._mouseDownLink=this._currentLink}_handleMouseUp(e){if(!this._currentLink)return;let i=this._positionFromMouseEvent(e,this._element,this._mouseService);i&&this._mouseDownLink&&Ec(this._mouseDownLink.link,this._currentLink.link)&&this._linkAtPosition(this._currentLink.link,i)&&this._currentLink.link.activate(e,this._currentLink.link.text)}_clearCurrentLink(e,i){!this._currentLink||!this._lastMouseEvent||(!e||!i||this._currentLink.link.range.start.y>=e&&this._currentLink.link.range.end.y<=i)&&(this._linkLeave(this._element,this._currentLink.link,this._lastMouseEvent),this._currentLink=void 0,Ne(this._linkCacheDisposables),this._linkCacheDisposables.length=0)}_handleNewLink(e){if(!this._lastMouseEvent)return;let i=this._positionFromMouseEvent(this._lastMouseEvent,this._element,this._mouseService);i&&this._linkAtPosition(e.link,i)&&(this._currentLink=e,this._currentLink.state={decorations:{underline:e.link.decorations===void 0?!0:e.link.decorations.underline,pointerCursor:e.link.decorations===void 0?!0:e.link.decorations.pointerCursor},isHovered:!0},this._linkHover(this._element,e.link,this._lastMouseEvent),e.link.decorations={},Object.defineProperties(e.link.decorations,{pointerCursor:{get:()=>this._currentLink?.state?.decorations.pointerCursor,set:r=>{this._currentLink?.state&&this._currentLink.state.decorations.pointerCursor!==r&&(this._currentLink.state.decorations.pointerCursor=r,this._currentLink.state.isHovered&&this._element.classList.toggle(\"xterm-cursor-pointer\",r))}},underline:{get:()=>this._currentLink?.state?.decorations.underline,set:r=>{this._currentLink?.state&&this._currentLink?.state?.decorations.underline!==r&&(this._currentLink.state.decorations.underline=r,this._currentLink.state.isHovered&&this._fireUnderlineEvent(e.link,r))}}}),this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(r=>{if(!this._currentLink)return;let n=r.start===0?0:r.start+1+this._bufferService.buffer.ydisp,o=this._bufferService.buffer.ydisp+1+r.end;if(this._currentLink.link.range.start.y>=n&&this._currentLink.link.range.end.y<=o&&(this._clearCurrentLink(n,o),this._lastMouseEvent)){let l=this._positionFromMouseEvent(this._lastMouseEvent,this._element,this._mouseService);l&&this._askForLink(l,!1)}})))}_linkHover(e,i,r){this._currentLink?.state&&(this._currentLink.state.isHovered=!0,this._currentLink.state.decorations.underline&&this._fireUnderlineEvent(i,!0),this._currentLink.state.decorations.pointerCursor&&e.classList.add(\"xterm-cursor-pointer\")),i.hover&&i.hover(r,i.text)}_fireUnderlineEvent(e,i){let r=e.range,n=this._bufferService.buffer.ydisp,o=this._createLinkUnderlineEvent(r.start.x-1,r.start.y-n-1,r.end.x,r.end.y-n-1,void 0);(i?this._onShowLinkUnderline:this._onHideLinkUnderline).fire(o)}_linkLeave(e,i,r){this._currentLink?.state&&(this._currentLink.state.isHovered=!1,this._currentLink.state.decorations.underline&&this._fireUnderlineEvent(i,!1),this._currentLink.state.decorations.pointerCursor&&e.classList.remove(\"xterm-cursor-pointer\")),i.leave&&i.leave(r,i.text)}_linkAtPosition(e,i){let r=e.range.start.y*this._bufferService.cols+e.range.start.x,n=e.range.end.y*this._bufferService.cols+e.range.end.x,o=i.y*this._bufferService.cols+i.x;return r<=o&&o<=n}_positionFromMouseEvent(e,i,r){let n=r.getCoords(e,i,this._bufferService.cols,this._bufferService.rows);if(n)return{x:n[0],y:n[1]+this._bufferService.buffer.ydisp}}_createLinkUnderlineEvent(e,i,r,n,o){return{x1:e,y1:i,x2:r,y2:n,cols:this._bufferService.cols,fg:o}}};hi=M([S(1,Dt),S(2,ce),S(3,F),S(4,lr)],hi);function Ec(s,t){return s.text===t.text&&s.range.start.x===t.range.start.x&&s.range.start.y===t.range.start.y&&s.range.end.x===t.range.end.x&&s.range.end.y===t.range.end.y}var yn=class extends Sn{constructor(e={}){super(e);this._linkifier=this._register(new ye);this.browser=tn;this._keyDownHandled=!1;this._keyDownSeen=!1;this._keyPressHandled=!1;this._unprocessedDeadKey=!1;this._accessibilityManager=this._register(new ye);this._onCursorMove=this._register(new v);this.onCursorMove=this._onCursorMove.event;this._onKey=this._register(new v);this.onKey=this._onKey.event;this._onRender=this._register(new v);this.onRender=this._onRender.event;this._onSelectionChange=this._register(new v);this.onSelectionChange=this._onSelectionChange.event;this._onTitleChange=this._register(new v);this.onTitleChange=this._onTitleChange.event;this._onBell=this._register(new v);this.onBell=this._onBell.event;this._onFocus=this._register(new v);this._onBlur=this._register(new v);this._onA11yCharEmitter=this._register(new v);this._onA11yTabEmitter=this._register(new v);this._onWillOpen=this._register(new v);this._setup(),this._decorationService=this._instantiationService.createInstance(Tn),this._instantiationService.setService(Be,this._decorationService),this._linkProviderService=this._instantiationService.createInstance(Qr),this._instantiationService.setService(lr,this._linkProviderService),this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(wt)),this._register(this._inputHandler.onRequestBell(()=>this._onBell.fire())),this._register(this._inputHandler.onRequestRefreshRows(i=>this.refresh(i?.start??0,i?.end??this.rows-1))),this._register(this._inputHandler.onRequestSendFocus(()=>this._reportFocus())),this._register(this._inputHandler.onRequestReset(()=>this.reset())),this._register(this._inputHandler.onRequestWindowsOptionsReport(i=>this._reportWindowsOptions(i))),this._register(this._inputHandler.onColor(i=>this._handleColorEvent(i))),this._register($.forward(this._inputHandler.onCursorMove,this._onCursorMove)),this._register($.forward(this._inputHandler.onTitleChange,this._onTitleChange)),this._register($.forward(this._inputHandler.onA11yChar,this._onA11yCharEmitter)),this._register($.forward(this._inputHandler.onA11yTab,this._onA11yTabEmitter)),this._register(this._bufferService.onResize(i=>this._afterResize(i.cols,i.rows))),this._register(C(()=>{this._customKeyEventHandler=void 0,this.element?.parentNode?.removeChild(this.element)}))}get linkifier(){return this._linkifier.value}get onFocus(){return this._onFocus.event}get onBlur(){return this._onBlur.event}get onA11yChar(){return this._onA11yCharEmitter.event}get onA11yTab(){return this._onA11yTabEmitter.event}get onWillOpen(){return this._onWillOpen.event}_handleColorEvent(e){if(this._themeService)for(let i of e){let r,n=\"\";switch(i.index){case 256:r=\"foreground\",n=\"10\";break;case 257:r=\"background\",n=\"11\";break;case 258:r=\"cursor\",n=\"12\";break;default:r=\"ansi\",n=\"4;\"+i.index}switch(i.type){case 0:let o=U.toColorRGB(r===\"ansi\"?this._themeService.colors.ansi[i.index]:this._themeService.colors[r]);this.coreService.triggerDataEvent(`${b.ESC}]${n};${ml(o)}${fs.ST}`);break;case 1:if(r===\"ansi\")this._themeService.modifyColors(l=>l.ansi[i.index]=j.toColor(...i.color));else{let l=r;this._themeService.modifyColors(a=>a[l]=j.toColor(...i.color))}break;case 2:this._themeService.restoreColor(i.index);break}}}_setup(){super._setup(),this._customKeyEventHandler=void 0}get buffer(){return this.buffers.active}focus(){this.textarea&&this.textarea.focus({preventScroll:!0})}_handleScreenReaderModeOptionChange(e){e?!this._accessibilityManager.value&&this._renderService&&(this._accessibilityManager.value=this._instantiationService.createInstance(Tt,this)):this._accessibilityManager.clear()}_handleTextAreaFocus(e){this.coreService.decPrivateModes.sendFocus&&this.coreService.triggerDataEvent(b.ESC+\"[I\"),this.element.classList.add(\"focus\"),this._showCursor(),this._onFocus.fire()}blur(){return this.textarea?.blur()}_handleTextAreaBlur(){this.textarea.value=\"\",this.refresh(this.buffer.y,this.buffer.y),this.coreService.decPrivateModes.sendFocus&&this.coreService.triggerDataEvent(b.ESC+\"[O\"),this.element.classList.remove(\"focus\"),this._onBlur.fire()}_syncTextArea(){if(!this.textarea||!this.buffer.isCursorInViewport||this._compositionHelper.isComposing||!this._renderService)return;let e=this.buffer.ybase+this.buffer.y,i=this.buffer.lines.get(e);if(!i)return;let r=Math.min(this.buffer.x,this.cols-1),n=this._renderService.dimensions.css.cell.height,o=i.getWidth(r),l=this._renderService.dimensions.css.cell.width*o,a=this.buffer.y*this._renderService.dimensions.css.cell.height,u=r*this._renderService.dimensions.css.cell.width;this.textarea.style.left=u+\"px\",this.textarea.style.top=a+\"px\",this.textarea.style.width=l+\"px\",this.textarea.style.height=n+\"px\",this.textarea.style.lineHeight=n+\"px\",this.textarea.style.zIndex=\"-5\"}_initGlobal(){this._bindKeys(),this._register(L(this.element,\"copy\",i=>{this.hasSelection()&&Vs(i,this._selectionService)}));let e=i=>qs(i,this.textarea,this.coreService,this.optionsService);this._register(L(this.textarea,\"paste\",e)),this._register(L(this.element,\"paste\",e)),Ss?this._register(L(this.element,\"mousedown\",i=>{i.button===2&&Pn(i,this.textarea,this.screenElement,this._selectionService,this.options.rightClickSelectsWord)})):this._register(L(this.element,\"contextmenu\",i=>{Pn(i,this.textarea,this.screenElement,this._selectionService,this.options.rightClickSelectsWord)})),Bi&&this._register(L(this.element,\"auxclick\",i=>{i.button===1&&Mn(i,this.textarea,this.screenElement)}))}_bindKeys(){this._register(L(this.textarea,\"keyup\",e=>this._keyUp(e),!0)),this._register(L(this.textarea,\"keydown\",e=>this._keyDown(e),!0)),this._register(L(this.textarea,\"keypress\",e=>this._keyPress(e),!0)),this._register(L(this.textarea,\"compositionstart\",()=>this._compositionHelper.compositionstart())),this._register(L(this.textarea,\"compositionupdate\",e=>this._compositionHelper.compositionupdate(e))),this._register(L(this.textarea,\"compositionend\",()=>this._compositionHelper.compositionend())),this._register(L(this.textarea,\"input\",e=>this._inputEvent(e),!0)),this._register(this.onRender(()=>this._compositionHelper.updateCompositionElements()))}open(e){if(!e)throw new Error(\"Terminal requires a parent element.\");if(e.isConnected||this._logService.debug(\"Terminal.open was called on an element that was not attached to the DOM\"),this.element?.ownerDocument.defaultView&&this._coreBrowserService){this.element.ownerDocument.defaultView!==this._coreBrowserService.window&&(this._coreBrowserService.window=this.element.ownerDocument.defaultView);return}this._document=e.ownerDocument,this.options.documentOverride&&this.options.documentOverride instanceof Document&&(this._document=this.optionsService.rawOptions.documentOverride),this.element=this._document.createElement(\"div\"),this.element.dir=\"ltr\",this.element.classList.add(\"terminal\"),this.element.classList.add(\"xterm\"),e.appendChild(this.element);let i=this._document.createDocumentFragment();this._viewportElement=this._document.createElement(\"div\"),this._viewportElement.classList.add(\"xterm-viewport\"),i.appendChild(this._viewportElement),this.screenElement=this._document.createElement(\"div\"),this.screenElement.classList.add(\"xterm-screen\"),this._register(L(this.screenElement,\"mousemove\",o=>this.updateCursorStyle(o))),this._helperContainer=this._document.createElement(\"div\"),this._helperContainer.classList.add(\"xterm-helpers\"),this.screenElement.appendChild(this._helperContainer),i.appendChild(this.screenElement);let r=this.textarea=this._document.createElement(\"textarea\");this.textarea.classList.add(\"xterm-helper-textarea\"),this.textarea.setAttribute(\"aria-label\",mi.get()),Ts||this.textarea.setAttribute(\"aria-multiline\",\"false\"),this.textarea.setAttribute(\"autocorrect\",\"off\"),this.textarea.setAttribute(\"autocapitalize\",\"off\"),this.textarea.setAttribute(\"spellcheck\",\"false\"),this.textarea.tabIndex=0,this._register(this.optionsService.onSpecificOptionChange(\"disableStdin\",()=>r.readOnly=this.optionsService.rawOptions.disableStdin)),this.textarea.readOnly=this.optionsService.rawOptions.disableStdin,this._coreBrowserService=this._register(this._instantiationService.createInstance(Jr,this.textarea,e.ownerDocument.defaultView??window,this._document??typeof window<\"u\"?window.document:null)),this._instantiationService.setService(ae,this._coreBrowserService),this._register(L(this.textarea,\"focus\",o=>this._handleTextAreaFocus(o))),this._register(L(this.textarea,\"blur\",()=>this._handleTextAreaBlur())),this._helperContainer.appendChild(this.textarea),this._charSizeService=this._instantiationService.createInstance(jt,this._document,this._helperContainer),this._instantiationService.setService(nt,this._charSizeService),this._themeService=this._instantiationService.createInstance(ti),this._instantiationService.setService(Re,this._themeService),this._characterJoinerService=this._instantiationService.createInstance(ct),this._instantiationService.setService(or,this._characterJoinerService),this._renderService=this._register(this._instantiationService.createInstance(Qt,this.rows,this.screenElement)),this._instantiationService.setService(ce,this._renderService),this._register(this._renderService.onRenderedViewportChange(o=>this._onRender.fire(o))),this.onResize(o=>this._renderService.resize(o.cols,o.rows)),this._compositionView=this._document.createElement(\"div\"),this._compositionView.classList.add(\"composition-view\"),this._compositionHelper=this._instantiationService.createInstance($t,this.textarea,this._compositionView),this._helperContainer.appendChild(this._compositionView),this._mouseService=this._instantiationService.createInstance(Xt),this._instantiationService.setService(Dt,this._mouseService);let n=this._linkifier.value=this._register(this._instantiationService.createInstance(hi,this.screenElement));this.element.appendChild(i);try{this._onWillOpen.fire(this.element)}catch{}this._renderService.hasRenderer()||this._renderService.setRenderer(this._createRenderer()),this._register(this.onCursorMove(()=>{this._renderService.handleCursorMove(),this._syncTextArea()})),this._register(this.onResize(()=>this._renderService.handleResize(this.cols,this.rows))),this._register(this.onBlur(()=>this._renderService.handleBlur())),this._register(this.onFocus(()=>this._renderService.handleFocus())),this._viewport=this._register(this._instantiationService.createInstance(zt,this.element,this.screenElement)),this._register(this._viewport.onRequestScrollLines(o=>{super.scrollLines(o,!1),this.refresh(0,this.rows-1)})),this._selectionService=this._register(this._instantiationService.createInstance(ei,this.element,this.screenElement,n)),this._instantiationService.setService(Qs,this._selectionService),this._register(this._selectionService.onRequestScrollLines(o=>this.scrollLines(o.amount,o.suppressScrollEvent))),this._register(this._selectionService.onSelectionChange(()=>this._onSelectionChange.fire())),this._register(this._selectionService.onRequestRedraw(o=>this._renderService.handleSelectionChanged(o.start,o.end,o.columnSelectMode))),this._register(this._selectionService.onLinuxMouseSelection(o=>{this.textarea.value=o,this.textarea.focus(),this.textarea.select()})),this._register($.any(this._onScroll.event,this._inputHandler.onScroll)(()=>{this._selectionService.refresh(),this._viewport?.queueSync()})),this._register(this._instantiationService.createInstance(Gt,this.screenElement)),this._register(L(this.element,\"mousedown\",o=>this._selectionService.handleMouseDown(o))),this.coreMouseService.areMouseEventsActive?(this._selectionService.disable(),this.element.classList.add(\"enable-mouse-events\")):this._selectionService.enable(),this.options.screenReaderMode&&(this._accessibilityManager.value=this._instantiationService.createInstance(Tt,this)),this._register(this.optionsService.onSpecificOptionChange(\"screenReaderMode\",o=>this._handleScreenReaderModeOptionChange(o))),this.options.overviewRuler.width&&(this._overviewRulerRenderer=this._register(this._instantiationService.createInstance(bt,this._viewportElement,this.screenElement))),this.optionsService.onSpecificOptionChange(\"overviewRuler\",o=>{!this._overviewRulerRenderer&&o&&this._viewportElement&&this.screenElement&&(this._overviewRulerRenderer=this._register(this._instantiationService.createInstance(bt,this._viewportElement,this.screenElement)))}),this._charSizeService.measure(),this.refresh(0,this.rows-1),this._initGlobal(),this.bindMouse()}_createRenderer(){return this._instantiationService.createInstance(Yt,this,this._document,this.element,this.screenElement,this._viewportElement,this._helperContainer,this.linkifier)}bindMouse(){let e=this,i=this.element;function r(l){let a=e._mouseService.getMouseReportCoords(l,e.screenElement);if(!a)return!1;let u,h;switch(l.overrideType||l.type){case\"mousemove\":h=32,l.buttons===void 0?(u=3,l.button!==void 0&&(u=l.button<3?l.button:3)):u=l.buttons&1?0:l.buttons&4?1:l.buttons&2?2:3;break;case\"mouseup\":h=0,u=l.button<3?l.button:3;break;case\"mousedown\":h=1,u=l.button<3?l.button:3;break;case\"wheel\":if(e._customWheelEventHandler&&e._customWheelEventHandler(l)===!1)return!1;let c=l.deltaY;if(c===0||e.coreMouseService.consumeWheelEvent(l,e._renderService?.dimensions?.device?.cell?.height,e._coreBrowserService?.dpr)===0)return!1;h=c<0?0:1,u=4;break;default:return!1}return h===void 0||u===void 0||u>4?!1:e.coreMouseService.triggerMouseEvent({col:a.col,row:a.row,x:a.x,y:a.y,button:u,action:h,ctrl:l.ctrlKey,alt:l.altKey,shift:l.shiftKey})}let n={mouseup:null,wheel:null,mousedrag:null,mousemove:null},o={mouseup:l=>(r(l),l.buttons||(this._document.removeEventListener(\"mouseup\",n.mouseup),n.mousedrag&&this._document.removeEventListener(\"mousemove\",n.mousedrag)),this.cancel(l)),wheel:l=>(r(l),this.cancel(l,!0)),mousedrag:l=>{l.buttons&&r(l)},mousemove:l=>{l.buttons||r(l)}};this._register(this.coreMouseService.onProtocolChange(l=>{l?(this.optionsService.rawOptions.logLevel===\"debug\"&&this._logService.debug(\"Binding to mouse events:\",this.coreMouseService.explainEvents(l)),this.element.classList.add(\"enable-mouse-events\"),this._selectionService.disable()):(this._logService.debug(\"Unbinding from mouse events.\"),this.element.classList.remove(\"enable-mouse-events\"),this._selectionService.enable()),l&8?n.mousemove||(i.addEventListener(\"mousemove\",o.mousemove),n.mousemove=o.mousemove):(i.removeEventListener(\"mousemove\",n.mousemove),n.mousemove=null),l&16?n.wheel||(i.addEventListener(\"wheel\",o.wheel,{passive:!1}),n.wheel=o.wheel):(i.removeEventListener(\"wheel\",n.wheel),n.wheel=null),l&2?n.mouseup||(n.mouseup=o.mouseup):(this._document.removeEventListener(\"mouseup\",n.mouseup),n.mouseup=null),l&4?n.mousedrag||(n.mousedrag=o.mousedrag):(this._document.removeEventListener(\"mousemove\",n.mousedrag),n.mousedrag=null)})),this.coreMouseService.activeProtocol=this.coreMouseService.activeProtocol,this._register(L(i,\"mousedown\",l=>{if(l.preventDefault(),this.focus(),!(!this.coreMouseService.areMouseEventsActive||this._selectionService.shouldForceSelection(l)))return r(l),n.mouseup&&this._document.addEventListener(\"mouseup\",n.mouseup),n.mousedrag&&this._document.addEventListener(\"mousemove\",n.mousedrag),this.cancel(l)})),this._register(L(i,\"wheel\",l=>{if(!n.wheel){if(this._customWheelEventHandler&&this._customWheelEventHandler(l)===!1)return!1;if(!this.buffer.hasScrollback){if(l.deltaY===0)return!1;if(e.coreMouseService.consumeWheelEvent(l,e._renderService?.dimensions?.device?.cell?.height,e._coreBrowserService?.dpr)===0)return this.cancel(l,!0);let h=b.ESC+(this.coreService.decPrivateModes.applicationCursorKeys?\"O\":\"[\")+(l.deltaY<0?\"A\":\"B\");return this.coreService.triggerDataEvent(h,!0),this.cancel(l,!0)}}},{passive:!1}))}refresh(e,i){this._renderService?.refreshRows(e,i)}updateCursorStyle(e){this._selectionService?.shouldColumnSelect(e)?this.element.classList.add(\"column-select\"):this.element.classList.remove(\"column-select\")}_showCursor(){this.coreService.isCursorInitialized||(this.coreService.isCursorInitialized=!0,this.refresh(this.buffer.y,this.buffer.y))}scrollLines(e,i){this._viewport?this._viewport.scrollLines(e):super.scrollLines(e,i),this.refresh(0,this.rows-1)}scrollPages(e){this.scrollLines(e*(this.rows-1))}scrollToTop(){this.scrollLines(-this._bufferService.buffer.ydisp)}scrollToBottom(e){e&&this._viewport?this._viewport.scrollToLine(this.buffer.ybase,!0):this.scrollLines(this._bufferService.buffer.ybase-this._bufferService.buffer.ydisp)}scrollToLine(e){let i=e-this._bufferService.buffer.ydisp;i!==0&&this.scrollLines(i)}paste(e){Cn(e,this.textarea,this.coreService,this.optionsService)}attachCustomKeyEventHandler(e){this._customKeyEventHandler=e}attachCustomWheelEventHandler(e){this._customWheelEventHandler=e}registerLinkProvider(e){return this._linkProviderService.registerLinkProvider(e)}registerCharacterJoiner(e){if(!this._characterJoinerService)throw new Error(\"Terminal must be opened first\");let i=this._characterJoinerService.register(e);return this.refresh(0,this.rows-1),i}deregisterCharacterJoiner(e){if(!this._characterJoinerService)throw new Error(\"Terminal must be opened first\");this._characterJoinerService.deregister(e)&&this.refresh(0,this.rows-1)}get markers(){return this.buffer.markers}registerMarker(e){return this.buffer.addMarker(this.buffer.ybase+this.buffer.y+e)}registerDecoration(e){return this._decorationService.registerDecoration(e)}hasSelection(){return this._selectionService?this._selectionService.hasSelection:!1}select(e,i,r){this._selectionService.setSelection(e,i,r)}getSelection(){return this._selectionService?this._selectionService.selectionText:\"\"}getSelectionPosition(){if(!(!this._selectionService||!this._selectionService.hasSelection))return{start:{x:this._selectionService.selectionStart[0],y:this._selectionService.selectionStart[1]},end:{x:this._selectionService.selectionEnd[0],y:this._selectionService.selectionEnd[1]}}}clearSelection(){this._selectionService?.clearSelection()}selectAll(){this._selectionService?.selectAll()}selectLines(e,i){this._selectionService?.selectLines(e,i)}_keyDown(e){if(this._keyDownHandled=!1,this._keyDownSeen=!0,this._customKeyEventHandler&&this._customKeyEventHandler(e)===!1)return!1;let i=this.browser.isMac&&this.options.macOptionIsMeta&&e.altKey;if(!i&&!this._compositionHelper.keydown(e))return this.options.scrollOnUserInput&&this.buffer.ybase!==this.buffer.ydisp&&this.scrollToBottom(!0),!1;!i&&(e.key===\"Dead\"||e.key===\"AltGraph\")&&(this._unprocessedDeadKey=!0);let r=Il(e,this.coreService.decPrivateModes.applicationCursorKeys,this.browser.isMac,this.options.macOptionIsMeta);if(this.updateCursorStyle(e),r.type===3||r.type===2){let n=this.rows-1;return this.scrollLines(r.type===2?-n:n),this.cancel(e,!0)}if(r.type===1&&this.selectAll(),this._isThirdLevelShift(this.browser,e)||(r.cancel&&this.cancel(e,!0),!r.key)||e.key&&!e.ctrlKey&&!e.altKey&&!e.metaKey&&e.key.length===1&&e.key.charCodeAt(0)>=65&&e.key.charCodeAt(0)<=90)return!0;if(this._unprocessedDeadKey)return this._unprocessedDeadKey=!1,!0;if((r.key===b.ETX||r.key===b.CR)&&(this.textarea.value=\"\"),this._onKey.fire({key:r.key,domEvent:e}),this._showCursor(),this.coreService.triggerDataEvent(r.key,!0),!this.optionsService.rawOptions.screenReaderMode||e.altKey||e.ctrlKey)return this.cancel(e,!0);this._keyDownHandled=!0}_isThirdLevelShift(e,i){let r=e.isMac&&!this.options.macOptionIsMeta&&i.altKey&&!i.ctrlKey&&!i.metaKey||e.isWindows&&i.altKey&&i.ctrlKey&&!i.metaKey||e.isWindows&&i.getModifierState(\"AltGraph\");return i.type===\"keypress\"?r:r&&(!i.keyCode||i.keyCode>47)}_keyUp(e){this._keyDownSeen=!1,!(this._customKeyEventHandler&&this._customKeyEventHandler(e)===!1)&&(Tc(e)||this.focus(),this.updateCursorStyle(e),this._keyPressHandled=!1)}_keyPress(e){let i;if(this._keyPressHandled=!1,this._keyDownHandled||this._customKeyEventHandler&&this._customKeyEventHandler(e)===!1)return!1;if(this.cancel(e),e.charCode)i=e.charCode;else if(e.which===null||e.which===void 0)i=e.keyCode;else if(e.which!==0&&e.charCode!==0)i=e.which;else return!1;return!i||(e.altKey||e.ctrlKey||e.metaKey)&&!this._isThirdLevelShift(this.browser,e)?!1:(i=String.fromCharCode(i),this._onKey.fire({key:i,domEvent:e}),this._showCursor(),this.coreService.triggerDataEvent(i,!0),this._keyPressHandled=!0,this._unprocessedDeadKey=!1,!0)}_inputEvent(e){if(e.data&&e.inputType===\"insertText\"&&(!e.composed||!this._keyDownSeen)&&!this.optionsService.rawOptions.screenReaderMode){if(this._keyPressHandled)return!1;this._unprocessedDeadKey=!1;let i=e.data;return this.coreService.triggerDataEvent(i,!0),this.cancel(e),!0}return!1}resize(e,i){if(e===this.cols&&i===this.rows){this._charSizeService&&!this._charSizeService.hasValidSize&&this._charSizeService.measure();return}super.resize(e,i)}_afterResize(e,i){this._charSizeService?.measure()}clear(){if(!(this.buffer.ybase===0&&this.buffer.y===0)){this.buffer.clearAllMarkers(),this.buffer.lines.set(0,this.buffer.lines.get(this.buffer.ybase+this.buffer.y)),this.buffer.lines.length=1,this.buffer.ydisp=0,this.buffer.ybase=0,this.buffer.y=0;for(let e=1;e<this.rows;e++)this.buffer.lines.push(this.buffer.getBlankLine(X));this._onScroll.fire({position:this.buffer.ydisp}),this.refresh(0,this.rows-1)}}reset(){this.options.rows=this.rows,this.options.cols=this.cols;let e=this._customKeyEventHandler;this._setup(),super.reset(),this._selectionService?.reset(),this._decorationService.reset(),this._customKeyEventHandler=e,this.refresh(0,this.rows-1)}clearTextureAtlas(){this._renderService?.clearTextureAtlas()}_reportFocus(){this.element?.classList.contains(\"focus\")?this.coreService.triggerDataEvent(b.ESC+\"[I\"):this.coreService.triggerDataEvent(b.ESC+\"[O\")}_reportWindowsOptions(e){if(this._renderService)switch(e){case 0:let i=this._renderService.dimensions.css.canvas.width.toFixed(0),r=this._renderService.dimensions.css.canvas.height.toFixed(0);this.coreService.triggerDataEvent(`${b.ESC}[4;${r};${i}t`);break;case 1:let n=this._renderService.dimensions.css.cell.width.toFixed(0),o=this._renderService.dimensions.css.cell.height.toFixed(0);this.coreService.triggerDataEvent(`${b.ESC}[6;${o};${n}t`);break}}cancel(e,i){if(!(!this.options.cancelEvents&&!i))return e.preventDefault(),e.stopPropagation(),!1}};function Tc(s){return s.keyCode===16||s.keyCode===17||s.keyCode===18}var xn=class{constructor(){this._addons=[]}dispose(){for(let t=this._addons.length-1;t>=0;t--)this._addons[t].instance.dispose()}loadAddon(t,e){let i={instance:e,dispose:e.dispose,isDisposed:!1};this._addons.push(i),e.dispose=()=>this._wrappedAddonDispose(i),e.activate(t)}_wrappedAddonDispose(t){if(t.isDisposed)return;let e=-1;for(let i=0;i<this._addons.length;i++)if(this._addons[i]===t){e=i;break}if(e===-1)throw new Error(\"Could not dispose an addon that has not been loaded\");t.isDisposed=!0,t.dispose.apply(t.instance),this._addons.splice(e,1)}};var wn=class{constructor(t){this._line=t}get isWrapped(){return this._line.isWrapped}get length(){return this._line.length}getCell(t,e){if(!(t<0||t>=this._line.length))return e?(this._line.loadCell(t,e),e):this._line.loadCell(t,new q)}translateToString(t,e,i){return this._line.translateToString(t,e,i)}};var Ji=class{constructor(t,e){this._buffer=t;this.type=e}init(t){return this._buffer=t,this}get cursorY(){return this._buffer.y}get cursorX(){return this._buffer.x}get viewportY(){return this._buffer.ydisp}get baseY(){return this._buffer.ybase}get length(){return this._buffer.lines.length}getLine(t){let e=this._buffer.lines.get(t);if(e)return new wn(e)}getNullCell(){return new q}};var Dn=class extends D{constructor(e){super();this._core=e;this._onBufferChange=this._register(new v);this.onBufferChange=this._onBufferChange.event;this._normal=new Ji(this._core.buffers.normal,\"normal\"),this._alternate=new Ji(this._core.buffers.alt,\"alternate\"),this._core.buffers.onBufferActivate(()=>this._onBufferChange.fire(this.active))}get active(){if(this._core.buffers.active===this._core.buffers.normal)return this.normal;if(this._core.buffers.active===this._core.buffers.alt)return this.alternate;throw new Error(\"Active buffer is neither normal nor alternate\")}get normal(){return this._normal.init(this._core.buffers.normal)}get alternate(){return this._alternate.init(this._core.buffers.alt)}};var Rn=class{constructor(t){this._core=t}registerCsiHandler(t,e){return this._core.registerCsiHandler(t,i=>e(i.toArray()))}addCsiHandler(t,e){return this.registerCsiHandler(t,e)}registerDcsHandler(t,e){return this._core.registerDcsHandler(t,(i,r)=>e(i,r.toArray()))}addDcsHandler(t,e){return this.registerDcsHandler(t,e)}registerEscHandler(t,e){return this._core.registerEscHandler(t,e)}addEscHandler(t,e){return this.registerEscHandler(t,e)}registerOscHandler(t,e){return this._core.registerOscHandler(t,e)}addOscHandler(t,e){return this.registerOscHandler(t,e)}};var Ln=class{constructor(t){this._core=t}register(t){this._core.unicodeService.register(t)}get versions(){return this._core.unicodeService.versions}get activeVersion(){return this._core.unicodeService.activeVersion}set activeVersion(t){this._core.unicodeService.activeVersion=t}};var Ic=[\"cols\",\"rows\"],Ue=0,Dl=class extends D{constructor(t){super(),this._core=this._register(new yn(t)),this._addonManager=this._register(new xn),this._publicOptions={...this._core.options};let e=r=>this._core.options[r],i=(r,n)=>{this._checkReadonlyOptions(r),this._core.options[r]=n};for(let r in this._core.options){let n={get:e.bind(this,r),set:i.bind(this,r)};Object.defineProperty(this._publicOptions,r,n)}}_checkReadonlyOptions(t){if(Ic.includes(t))throw new Error(`Option \"${t}\" can only be set in the constructor`)}_checkProposedApi(){if(!this._core.optionsService.rawOptions.allowProposedApi)throw new Error(\"You must set the allowProposedApi option to true to use proposed API\")}get onBell(){return this._core.onBell}get onBinary(){return this._core.onBinary}get onCursorMove(){return this._core.onCursorMove}get onData(){return this._core.onData}get onKey(){return this._core.onKey}get onLineFeed(){return this._core.onLineFeed}get onRender(){return this._core.onRender}get onResize(){return this._core.onResize}get onScroll(){return this._core.onScroll}get onSelectionChange(){return this._core.onSelectionChange}get onTitleChange(){return this._core.onTitleChange}get onWriteParsed(){return this._core.onWriteParsed}get element(){return this._core.element}get parser(){return this._parser||(this._parser=new Rn(this._core)),this._parser}get unicode(){return this._checkProposedApi(),new Ln(this._core)}get textarea(){return this._core.textarea}get rows(){return this._core.rows}get cols(){return this._core.cols}get buffer(){return this._buffer||(this._buffer=this._register(new Dn(this._core))),this._buffer}get markers(){return this._checkProposedApi(),this._core.markers}get modes(){let t=this._core.coreService.decPrivateModes,e=\"none\";switch(this._core.coreMouseService.activeProtocol){case\"X10\":e=\"x10\";break;case\"VT200\":e=\"vt200\";break;case\"DRAG\":e=\"drag\";break;case\"ANY\":e=\"any\";break}return{applicationCursorKeysMode:t.applicationCursorKeys,applicationKeypadMode:t.applicationKeypad,bracketedPasteMode:t.bracketedPasteMode,insertMode:this._core.coreService.modes.insertMode,mouseTrackingMode:e,originMode:t.origin,reverseWraparoundMode:t.reverseWraparound,sendFocusMode:t.sendFocus,synchronizedOutputMode:t.synchronizedOutput,wraparoundMode:t.wraparound}}get options(){return this._publicOptions}set options(t){for(let e in t)this._publicOptions[e]=t[e]}blur(){this._core.blur()}focus(){this._core.focus()}input(t,e=!0){this._core.input(t,e)}resize(t,e){this._verifyIntegers(t,e),this._core.resize(t,e)}open(t){this._core.open(t)}attachCustomKeyEventHandler(t){this._core.attachCustomKeyEventHandler(t)}attachCustomWheelEventHandler(t){this._core.attachCustomWheelEventHandler(t)}registerLinkProvider(t){return this._core.registerLinkProvider(t)}registerCharacterJoiner(t){return this._checkProposedApi(),this._core.registerCharacterJoiner(t)}deregisterCharacterJoiner(t){this._checkProposedApi(),this._core.deregisterCharacterJoiner(t)}registerMarker(t=0){return this._verifyIntegers(t),this._core.registerMarker(t)}registerDecoration(t){return this._checkProposedApi(),this._verifyPositiveIntegers(t.x??0,t.width??0,t.height??0),this._core.registerDecoration(t)}hasSelection(){return this._core.hasSelection()}select(t,e,i){this._verifyIntegers(t,e,i),this._core.select(t,e,i)}getSelection(){return this._core.getSelection()}getSelectionPosition(){return this._core.getSelectionPosition()}clearSelection(){this._core.clearSelection()}selectAll(){this._core.selectAll()}selectLines(t,e){this._verifyIntegers(t,e),this._core.selectLines(t,e)}dispose(){super.dispose()}scrollLines(t){this._verifyIntegers(t),this._core.scrollLines(t)}scrollPages(t){this._verifyIntegers(t),this._core.scrollPages(t)}scrollToTop(){this._core.scrollToTop()}scrollToBottom(){this._core.scrollToBottom()}scrollToLine(t){this._verifyIntegers(t),this._core.scrollToLine(t)}clear(){this._core.clear()}write(t,e){this._core.write(t,e)}writeln(t,e){this._core.write(t),this._core.write(`\\r\n`,e)}paste(t){this._core.paste(t)}refresh(t,e){this._verifyIntegers(t,e),this._core.refresh(t,e)}reset(){this._core.reset()}clearTextureAtlas(){this._core.clearTextureAtlas()}loadAddon(t){this._addonManager.loadAddon(this,t)}static get strings(){return{get promptLabel(){return mi.get()},set promptLabel(t){mi.set(t)},get tooMuchOutput(){return _i.get()},set tooMuchOutput(t){_i.set(t)}}}_verifyIntegers(...t){for(Ue of t)if(Ue===1/0||isNaN(Ue)||Ue%1!==0)throw new Error(\"This API only accepts integers\")}_verifyPositiveIntegers(...t){for(Ue of t)if(Ue&&(Ue===1/0||isNaN(Ue)||Ue%1!==0||Ue<0))throw new Error(\"This API only accepts positive integers\")}};export{Dl as Terminal};\n//# sourceMappingURL=xterm.mjs.map\n"],"file":"assets/index-BAtcgTxg.js"}